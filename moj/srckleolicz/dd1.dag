/******** konstrukcje  ********************/
new string	A = "!!!";
new real		PI = 3.14159265358979323846;

public varget(string svar)				{	[svar];				}
public varset(string svar, def val)			{	<svar> = val;			}
public varnew(string styp, string svar)	{	new <styp> <svar>;	}
public varnewif(string styp, string svar)	{	if( !.hasvar(svar) )	.varnew(styp,svar);}
public vardel(string svar)				{	delete <svar>;		}
public reader(string sname)	{
	.varnewif("def", sname);
	.addmethod( sname, func { [.methodname]; } );
}
public writer(string sname)	{
	.varnewif("def", sname);
	.addmethod( sname+"=", func { (def val) <.methodname->strsube(1)> = val; } );
}
public var(string sname)	{
	.reader(sname);
	.writer(sname);
}
public var2(string sname, def val)	{
	.var(sname);
	<sname> = val;
}
public withlist(string sfun)	{
	@s = _;
	while( A != s )	{
		.<sfun>(s);
		@s = _;
	}
}
public vars	{	.withlist("var");}
/*****************************************************/
public bool in	{
	bool b = false;
	@x = .get;
	@y = _;
	while( A != y )	{
		if( !b )	b = x==y;
		@y=_;
	}
	b;
}
public with(string sfun)	{
	string sob = _;
	while( sob!=A )	{
		<sob>.<sfun>();
		sob=_;
	}
}
public def case(def dout)	{	dout.in ? dout : null;	}
public copycall(string sfun, string sob)	{
	string s = "__call" + sfun;
	new string <s>;
	<s> = sob;
	.addmethod( sfun, func {
		string sf = .methodname;
		< [ "__call" + sf ] >.<sf>();
		});
}
public copycalls(string sobj)	{
	string s = _;
	while( s!=A )	{
		.copycall( s, sobj ); 
		s=_;
	}
}
/***********************************/
public mresize()	{	< .gettype + "_pack">::resizemethods( this );	}
/******** petle ********************/
public times(string sfun)		{	this.for_plus(0, this.get()-1, sfun );		}
public upto(int ito, string sfun)	{	this.for_plus( this.get(), ito, sfun );	}
public downto(int ito, string sfun)	{	this.for_minus( this.get(), ito, sfun );	}
public for_plus(int ifrom, int ito, string sfun)	{
	if( ito-ifrom<=0 )	return;
	for( ; ifrom<=ito; ifrom++)	this.<sfun>(ifrom);
}
public for_minus(int ifrom, int ito, string sfun)	{
	if( ifrom-ito<=0 )	return;
	for( ; ifrom>=ito; ifrom--)	this.<sfun>(ifrom);
}
public double_for(int w, int h, string sfun)	{
	int j;
	for( int i=0; i<w; i++)	{
		for( j=0; j<h; j++)	{
			this.<sfun>(i,j);
		}
	}
}
/****************************************/

// klasa do np. dynamicznego tworzenia obiektow z prefixem+id
class classobjcounter	{
	init(string sprefix)	{
		new string _sprefix=sprefix;
		new int _iile=0;
	}
	string get()	{
		_iile++;
		return _sprefix + (_iile-1);
	}
	int size()	{_iile;}
}

class classvsigobj	{
	init()	{
		new bool bplaying=false;
	}
	virtual play()	{	bplaying=true;	}
	virtual stop(bool bstop)	{ 
		bplaying=false;
		if( bstop )	{	this.onfinish();	}
	}
	virtual bool isplaying()	{	bplaying;	}
}

/***************************************************************************/

class classsignals	{
	init()	{}
	/********** std obj **********************/
	stdfinish(string sob) { <sob>.addmethod("onfinish",func { this.<this.getname()+"_FINISH">();}); }
	stdstart(string sob) { <sob>.addmethod("onstart",func { this.<this.getname()+"_START">(); }); }
	stdsigs(string sob)	{
		this.stdstart(sob);
		this.stdfinish(sob);
	}
	/********** anima **********************/
	buildanima(string san)	{
		this.stdsigs(san);
		<san>.addmethod("onendframe", func { this.<this.getname()+"_ENDFRAME">(); } );
	}
	/********** snd **********************/
	buildsnd(string ssnd)	{	this.stdsigs(ssnd);		}
	/********** timer **********************/
	buildtimer(string stimer)	{
		this.stdsigs(stimer);
		<stimer>.addmethod("ontick", func { this.<this.getname()+"_TICK">(); });
	}
	/********** button *******************/
	buildbut(string sbut)	{
		<sbut>.addmethod("onclick", func { this.<this.getname()+"_CLICK">(); });
		<sbut>.addmethod("onrel", func { this.<this.getname()+"_REL">(); });
		<sbut>.addmethod("onmoveon", func { this.<this.getname()+"_MOVEON">(); });
		<sbut>.addmethod("onmoveoff", func { this.<this.getname()+"_MOVEOFF">(); });
	}
}

/******************************************************************/

class classlocker	{
	init()	{
		new bool _block = true;
	}
	public lock()	{	_block=true;	}
	public unlock()	{	_block=false;	}
	public setlock(bool b)	{	_block=b;	}
	public bool getlock()	{	return _block;	}
}

/***************************************************************************/

module classdbreader	{
	init()	{
		new db dbl;
	}
	readdb( string sfunc )	{
		int id = 0;
		int ile = dbl.getrowsno();
		while( id < ile )	{
			this.<sfunc>( id );
			id++;
		}
	}
	readrow( string srow, string sfunc )	{
		int ipos = dbl.findbyrow( srow );
		if( ipos >= 0 )	{
			this.<sfunc>( ipos );
		}
	}
}

/***************************************************************************/


/***************************************************************************/
class collection	{
	init(string styp)	{	new string stype=styp;	}
	public string type()	{	return stype;		}
}

class array : collection {
	init(string styp, int idimens, int isiz)	{
		collection::init(styp);
		new int idim = idimens;
		new int isize = isiz;
		new vector vec;
		vec.type(styp);
		if( idimens<=0 || isiz<=0 )	return;
		vec.resize( isiz.pow(isiz,idimens), 0 );
	}
	int getid()	{
		int pos=0;
		int dim=idim-1;
		while(dim>0)	{
			pos+=_;
			pos*=isize;
			dim--;
		}
		return pos+_;
	}
	public def get()	{	return vec.get( this.getid() );	}
	public set(def svar)	{	vec.set( this.getid(), svar);	}
	public int getsize()	{	return isize;			}
	public int getdim()	{	return idim;			}
}

class stack : collection	{
	init(string styp)	{
		collection::init(styp);
		new vector vec;
		vec.type(styp);
		new <styp> var;
	}
	public push(string svar){	vec.add(svar);		}
	public def top()	{	return vec.last();	}
	public def pop()	{
		var = this.top();
		vec.removeat( vec.size()-1 );
		return var;
	}
}

class map : collection	{
	init(string styp)	{
		collection::init(styp);
		new int isize=0;
	}
	set(string svar, def val)	{
		if( !this.hasvar(svar) )	this.add(svar);
		<"v"+svar>.set(val);
	}
	add(string svar)	{	new <stype> <"v"+svar>;		}
	def get(string svar)	{	return ["v"+svar];		}
	remove(string svar)	{	delete <"v"+svar>;		}
	bool contains(string svar){	return this.hasvar("v"+svar);	}
}
class map2 : collection	{
	init(string styp)	{
		collection::init(styp);
		new vector vn;
		vn.type("string");
		new vector vec;
		vec.type(styp);
	}
	add(string svar, def val)	{	vn.add(svar);	vec.add(val);	}
	set(string svar, def val)	{	vec.set( vn.find(svar), val );	}
	bool contains(string svar)	{	return vn.contains(svar);	}
	def get(string svar)		{	return vec.get( vn.find(svar) );}
	remove(string svar)	{
		int id = vn.find(svar);
		if( id>=0 )	{
			vec.removeat( id );
			vn.removeat(id);
		}
	}
	free()	{	vn.free();	vec.free();	}
}


/***************************************************************************/
class classgamemusic : classdbreader	{
	init()	{
		classdbreader::init();
		new string smuspath = "";
		new string sbgrpath = "";
		new snd _sndbgr;
		_sndbgr.addmethod("onfinish", "_stdsndloop");
	}
	reset()	{
		gameapi.stopmusic();
		this.stopbgr();
	}
	_stdsndloop()	{	this.play(); }
	load(string sfile)	{	dbl.loadscript( sfile );	}
	musicpath(string s)	{	smuspath = s;	}
	sndbgrpath(string s)	{	sbgrpath=s;	}
	_play(int ipos)	{
		int i[3], string s[2];
		i0 = 1;
		i1 = dbl.getcolsno( ipos );
		while( i0 < i1 )	{
			s0 = dbl.get( ipos, i0 );	i0++;
			if( s0 == "music" )	{
				s1 = smuspath + dbl.get( ipos, i0 );
				i0++;
				if( i0 < i1 )	{
					if( dbl.get( ipos, i0 )=="vol" )	{
						i0++;
						gameapi.setmusicvol( dbl.get( ipos, i0 ) );
						i0++;
					}
				} else {
					gameapi.setmusicvol( 100 );
				}
				gameapi.playmusic( s1 );
			} else if (s0 == "bgr")	{
				_sndbgr.load( sbgrpath + dbl.get( ipos, i0 ) );
				i0++;
				if( i0 < i1 )	{
					if( dbl.get( ipos, i0 )=="vol" )	{
						i0++;
						_sndbgr.setvol( dbl.get( ipos, i0 ) );
						i0++;
					}
				} else {
					_sndbgr.setvol( 100 );
				}
				this.playbgr();
			} else {	i0++;	}
		}
	}
	play()	{
		this.reset();
		this.readrow( gameapi.getgamename(), "_play" );
	}
	playbgr()		{	_sndbgr.play();	}
	stopbgr()	{	_sndbgr.stop(false);	}
}

/**************************************************************/
	// zmienne globalna - stany gry
new int igmstate;
new int igmdebug;
new int igmeasy;
new int igmdemo;
new int igmbegin;
new string sgmfontfile = "configs/fonts/bold.ttf";

new int iResX = 800;
new int iResY = 600;

/**************************************************************/
	// standardowa klasa do tworzenia zmiennych
class newvars		{
	init()	{
		new string _sclpath = "";
		new string _sclwavpath = "";
	}
	string checkfont(string sfont, int isize)	{
		if( sfont==null )	sfont=sgmfontfile;
		if( sfont.contains(".ttf") )	{
			new font _fnt;
			_fnt.load( sfont, isize );
			sfont = "_fnt";
		}
		sfont;
	}
	bool begingame()	{
		igmbegin = !igmbegin;
		!igmbegin;
	}
	newarray(string styp, string sbase, int size)	{
		if( size<= 0 )	return;
		size--;
		while(size>=0)	{
			new <styp> <sbase+size>;
			size--;
		}
	}
	setgraphpath(string spath)	{	_sclpath = spath;	}
	setwavpath(string spath)	{ _sclwavpath = spath; }
	string getgraphpath()	{	return _sclpath; }
	string getsndpath()	{	return _sclwavpath; }
	newanima(string sname, string sfile, int z)	{
		new anima <sname>;
		<sname>.load(this.getgraphpath() + sfile);
		<sname>.setz(z);
	}
	newstdanima(string sname, string sfile, int z)	{
		this.newanima(sname, sfile, z);
		this.stdanaction(sname);
	}
	copyanimaactz(string ssrc, string sdest, string saction, int z)	{
		this.copyanimaact(ssrc, sdest, saction);
		<sdest>.setz(z);
	}
	copyanimaact(string ssrc, string sdest, string saction)	{
		this.copyanima(ssrc, sdest);
		<sdest>.setframe( saction, 0 );
	}
	copyanima(string ssrc, string sdest)	{
		new anima <sdest>;
		<sdest>.copy( ssrc );
	}
	copyanimas(string san, string sname, int istart, int ilosc)	{
		if (ilosc<0)	return;
		for(int i=0; i<ilosc; i++)	this.copyanima( san, sname + (istart + i)  );
	}
	newanimas(string sname, string sfile, int z, int ilosc)	{
		if(ilosc<0) return; 
		this.newanima(sname+"0", sfile, z);		// pierwsza load z zerem
		this.copyanimas(sname+"0", sname, 1, ilosc-1);		// pozostale kopiowane z niej
	}
	int newanframesgr(string san, string sname, int iaction, string sgr)	{	// tworzy animacje z klatek
		int ile = <san>.nofframes( iaction );
		this.copyanimas( san, sname, 0, ile );
		for(int i=0; i<ile; i++)	{
			<sname+i>.setframe(iaction, i);
			if( sgr!=null )	{	<sgr>.add( sname+i );	}
		}
		return ile;		// zwraca ilosc stworzonych animacji
	}
	int newanframes(string san, string sname, int iaction)	{	// tworzy animacje z klatek
		return this.newanframesgr(san,sname,iaction,null);
	}
	newcanvas(string sname, int w, int h, int r, int g, int b, int a, int z)	{
		new img <sname>;
		<sname>.create(w,h,r,g,b,a);
		<sname>.setz(z);
	}
	newimg(string sname, string sfile, int z)	{
		new img <sname>;
		<sname>.load(this.getgraphpath() + sfile);
		<sname>.setz(z);
	}
	copyimg(string ssrc, string sdest)	{
		new img <sdest>;
		<sdest>.copy(ssrc);
	}
	playmusic(string sfile)	{gameapi.playmusic( this.getsndpath() + sfile );	}
	newsndfree(string sname, string sfile)	{
		new snd <sname>;
		<sname>.setstartstopflag(false, true);
		<sname>.load( this.getsndpath() + sfile);
	}
	snewsnd(string sname, string sfile)	{
		this.newsnd(sname,sfile);
		<sname>.addmethod("onfinish","__std_finish");
	}
	newsnd(string sname, string sfile)	{
		new snd <sname>;
		<sname>.load( this.getsndpath() + sfile);
	}
	newsndloop(string sname, string sfile)	{
		this.newsnd(sname,sfile);
		this.looponfinish1( sname );
	}
	looponfinish1( string sob )	{<sob>.addmethod("onfinish","_stdsndloop");	}
	sndplayloop(string sob)	{
		this.looponfinish1( sob );
		<sob>.play();
	}
	newsnds(string sbase, int inamestart, string sfilebase, int ifilefrom, int ifileto)	{
		string s;
		int ile = ifileto-ifilefrom+1;
		for(int i=0; i<ile; i++)	{
			s = sbase + (inamestart + i);
			new snd <s>;
			<s>.load( this.getsndpath() + sfilebase + (ifilefrom+i) + ".wav" );
		}
	}
	newtimer(string sname, int idelay, int iticks)	{
		new timer <sname>;
		<sname>.settick(iticks);
		<sname>.delay(idelay);
	}
	newtimercycle(string sname, int icycle, int iticks)	{
		new timer <sname>;
		<sname>.settick(iticks);
		<sname>.setcycle(icycle);
	}
	stdanaction(string san)	{
		string s = <san>.actionname();
		if( s.contains("L")  )	this.looponfinish(san);
		else if( s.contains("H")  )	this.hideonfinish(san);
		if( s.contains("P")  )	<san>.play(-1);
	}
	int newanactionsgr(string san, string sname, string sgr)	{
		int ile = <san>.nofactions();
		this.copyanimas( san, sname, 0, ile );
		string s;
		for(int i=0; i<ile; i++)	{
			s = sname+i;
			<s>.setframe(i,0);
			this.stdanaction(s);
			if( sgr!=null )	{<sgr>.add( s );}
		}
		return ile;
	}
	int newanactions(string san, string sname)	{return this.newanactionsgr(san,sname,null);	}
	int newanfrbyactgr(string san, string sname, string sgr)	{
		int ile = <san>.nofactions();
		for( int i=0; i<ile; i++)	_ = this.newanframesgr(san, sname+i+"_", i, sgr);
		return ile;
	}
	int newanfrbyact(string san, string sname)	{return this.newanfrbyactgr(san,sname,null);	}
	int loadanfrbyact(string san, string sfile, int z)	{
		string s = "_"+san;
		this.newanima(s,sfile,z);
		int ile = this.newanfrbyact(s, san);
		<s>.hide();
		return ile;
	}
	int loadanactions(string san, string sfile, int z)	{
		string s = "_"+san;
		this.newanima(s, sfile, z);
		int ile = this.newanactions(s, san);
		<s>.hide();
		return ile;
	}
	int loadanframes(string san, string sfile, int iaction, int z)	{
		string s = "_"+san;
		this.newanima(s, sfile, z);
		int ile = this.newanframes(s, san, iaction);
		<s>.hide();
		return ile;
	}
	newbutimg(string sbut, string sstd, string smov, string sclick, string smouse)	{
		new button <sbut>;
		<sbut>.set(sstd, smov, sclick);
		<sbut>.setmouse(smouse);
	}
	newbutan(string sbut, string sanstd, string sanmov, string sanclick, string smouse)	{
		new button <sbut>;
		<sbut>.setan(sanstd, sanmov, sanclick);
		<sbut>.setmouse(smouse);
	}
	/*****************************************************/
	newdb(string sdb, string sfile)	{
		new db <sdb>;
		<sdb>.load( this.getgraphpath() + sfile );
	}
	newdbscript(string sdb, string sfile)	{
		new db <sdb>;
		<sdb>.loadscript( this.getgraphpath() + sfile );
	}
	vargmset(string svar, def val)	{
		string sg = gameapi.getgamename();
		if( !<sg>.hasvar(svar) )	<sg>.varnew( val.gettype(), svar );
		<svar> = val;
	}
}

/**************************************************************/
new img imglobcurs;		// globalny kursor aktywnosci
bsms.load("configs/kursorstd.png","configs/kursoract.png" );
	// modul obslugi standardowych kursorow myszy
module bsms {
	init()	{
		new img imgstd;
		new img imgact;
		new int msid = 0;		// 0- brak kursora 1-std lapka 2- active lapka 3- wlasny (wczytany w jakiejs grze)
	}
	load(string spath1, string spath2)	{
		imgstd.load(spath1);
		imgact.load(spath2);
		imglobcurs.copy("imgact");
		imglobcurs.hide();
		imgstd.hide();
		imgact.hide();
		this.reset();
		engine.stdbutcursor("imgstd");
	}
	setinitial()	{	mouse.stdcursor();	msid = 0;	}
	setstd()	{
		mouse.setcursor("imgstd");
		engine.stdbutcursor("imgstd");
		msid = 1;
	}
	setact()	{	mouse.setcursor("imgact");	msid = 2;	}
	setown()	{	msid=3;	}
	bool isinitial()	{	msid==0;	}
	bool isstd()	{	msid==1;	}
	bool isact()	{	msid==2;	}
	bool isown()	{	msid==3;	}
}

module clsav	{
	init()	{
		new vector vqsav;		// quick save (prostszy)
		vqsav.type("string");
		new vector vvqsav;		// quick save (prostszy)
		vvqsav.type("string");
	}
	free()	{
		vqsav.free();	
		vvqsav.free();	
	}
	load(string sfile)	{
		this.free();		// jak bedzie potrzebne dopisac dalej
	}
	save(string sfile)	{}
	qadd( string sname, string sval )	{
		vqsav.add( sname );
		vvqsav.add( sval );
	}
	qsave(string sname, string sval)	{
		int pos = vqsav.find(sname);
		if( pos < 0 )	{
			this.qadd( sname, sval );
		} else {
			vvqsav.set( pos, sval );
		}
	}
	string qload(string sname, string sstdval)	{
		int pos = vqsav.find( sname );
		if ( pos < 0 )	{
			this.qadd( sname, sstdval );
			return sstdval;
		} else {
			return vvqsav.get( pos );
		}
	}
}

class classquest	{
	init()	{
		new vector vqst;
		vqst.type("string");
	}
	int isdone(string sqst)	{	return vqst.contains(sqst);	}
	int notdone( string sqst )	{	return !vqst.contains(sqst);	}
	done(string sqst)	{	if( !vqst.contains(sqst) )	vqst.add(sqst);		}
	reset()	{	vqst.free();	}
	save(string sfile)	{	vqst.save( sfile );	}
	load(string sfile)	{	vqst.load( sfile );	}
}

new classquest clqs;
/*module clqs : classquest	{		// globalny odpowiednik classquesta
	init()	{	classquest::init();	}
}*/

/***************************************************************************/

/*  klasa na load dostaje baze danych z wymienionymi grami do zapisu */
class classeasysaver	{
	init()	{
		new int ilevel = -1;
		new db dbl;
		new string slevelfile;
	}
	getlevel()	{	return ilevel;	}
	setlevel(int il)	{	ilevel=il;	}
	getgame(int ig)	{	return dbl.get( ig, 0 );	}
	load( string slevf, string sdbfile)	{
		ilevel.load( slevf, -1 );
		slevelfile = slevf;
		dbl.load( sdbfile );
	}
	save()	{
		int pos = dbl.findbyrow( gameapi.getgamename() );
		if( pos>ilevel )	{
			ilevel = pos;
			ilevel.save( slevelfile );
		}
	}
}

class classfullsave	{
	init()	{
		new db dbsav;
		new string sstdfile = "saves/save.txt";
	}
	public save(string sfile)	{	dbsav.save(sfile);	}
	public load(string sfile)	{	dbsav.load(sfile);	}
	public print()	{	dbsav.print();	}
	public setfile(string sf)	{	sstdfile = sf;	}
	public stdload()	{	this.load(sstdfile);	}
	public stdsave()	{	this.save(sstdfile); }
	public free()	{	dbsav.free();	}
	public _set(string sname, string svar)	{
		int id = dbsav.findbyrow(sname);
		if( id>=0 )	{
			dbsav.set(id,1,svar);
		} else {
			id = dbsav.addrow()-1;
			dbsav.add( id, sname );
			dbsav.add( id, svar );
		}
// 		this.stdsave();
	}
	public _bset(string sname)	{	this._set(sname,true);	}
	public string _get(string sname)	{
		int id = dbsav.findbyrow(sname);
		return id>=0?dbsav.get(id,1):null;
	}
	public bool _is(string sname, string svar)	{
		int i = dbsav.findbyrow(sname);
  		return i>=0?dbsav.get(i,1)==svar:false;
	}
	public bool _isnt(string sname, string svar)	{
		int i = dbsav.findbyrow(sname);
		return i>=0?dbsav.get(i,1)!=svar:false;
	}
	public bool _bis(string sname)	{	return this._is(sname,true);	}
	public gmset(string sgame, string sname, string svar)	{
		this._set( sgame+sname, svar );
	}
	public string gmget(string sgame, string sname)	{
		return this._get(sgame+sname);
	}
	public bool gmis(string sgame, string sname, string svar)	{
		return this._is(sgame+sname,svar);
	}
	public set(string sname, string svar)	{
		this._set( gameapi.getgamename()+sname, svar );
	}
	public string get(string sname)	{
		return this._get( gameapi.getgamename()+sname);
	}
	public bool is(string sname, string svar)	{
		return this._is(gameapi.getgamename()+sname,svar);
	}
	public bset(string sname)	{
		this._set( gameapi.getgamename()+sname, true );
	}
	public string bget(string sname)	{
		return this._is(gameapi.getgamename()+sname,true);
	}
	public bool bis(string sname)	{
		return this._is(gameapi.getgamename()+sname,true);
	}
	/*** dodane przez andrzeja ****/
	public string gbget(string sgame, string sname) {
	 	return this._get( sgame+sname );
	}
	public bool gbis(string sgame, string sname)	{
		return this._is(sgame+sname,true);
	}
}


/***************************************************************************/

module clsurf	{
	init()	{}
	bool isin(int x, int y, int x1, int y1, int x2, int y2)	{
		x >= x1 && x<=x2 && y>=y1 && y<=y2;
	}
	bool inscreen(int x, int y, int dx, int dy)	{
		this.isin( x, y, 0-dx, 0-dy, 800+dx, 600+dy );
	}
	bool insurf(int x, int y, string simg)	{
		this.isin(x,y,<simg>.getpx(), <simg>.getpy(), <simg>.getex()-1, <simg>.getey()-1);
	}
	bool issurfin(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)	{
		this.isin(x1,y1, x3,y3,x4,y4) || this.isin(x2,y1, x3,y3,x4,y4) ||
				this.isin(x1,y2, x3,y3,x4,y4) || this.isin(x2,y2, x3,y3,x4,y4);
	}
	bool commonsurface(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)	{
		this.issurfin(x1,y1,x2,y2, x3,y3,x4,y4) || 
				this.issurfin(x3,y3,x4,y4, x1,y1,x2,y2);
	}
	bool commonimgs(string simg1, string simg2)	{
		this.commonsurface(<simg1>.getpx(), <simg1>.getpy(), <simg1>.getex()-1, <simg1>.getey()-1,
				<simg2>.getpx(), <simg2>.getpy(), <simg2>.getex()-1, <simg2>.getey()-1 );
	}
	bool surfwithinsurf(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)	{
		this.isin(x1,y1, x3,y3,x4,y4) && this.isin(x2,y1, x3,y3,x4,y4) &&
				this.isin(x1,y2, x3,y3,x4,y4) && this.isin(x2,y2, x3,y3,x4,y4);
	}
	bool imgwithinimg(string simg1, string simg2)	{
		this.surfwithinsurf(<simg1>.getpx(), <simg1>.getpy(), <simg1>.getex()-1, <simg1>.getey()-1,
				<simg2>.getpx(), <simg2>.getpy(), <simg2>.getex()-1, <simg2>.getey()-1 );
	}
}

/* modul do obliczen odleglosci */

module cllen	{
	init()	{
		new int il1;
		new int ilx;
		new int ily;
	}
	int ilenx()	{ return ilx; }
	int ileny()	{ return ily; }
	int ilen4(int x1, int x2)	{	return (x1-x2)->abs();	}
	int ilen3(string simg1, string simg2)	{
		return this.ilen( <simg1>.getcx(), <simg1>.getcy(), <simg2>.getcx(), <simg2>.getcy() );
	}
	int ilen5(string simg1, string simg2)	{
		return this.ilen( <simg1>.getpx(), <simg1>.getpy(), <simg2>.getpx(), <simg2>.getpy() );
	}
	int ilen2(string simg1, int x, int y)	{return this.ilen( <simg1>.getcx(), <simg1>.getcy(), x,  y );	}
	int ilen(int x1, int y1, int x2, int y2)	{
		ilx = x1-x2;
		ily = y1-y2;
		return il1.length( ilx, ily );
	}
	int iclenx(string simg1, int x)	{	return <simg1>.getcx() - x;	}
	int iclenx2(string simg1, string simg2)	{	return <simg1>.getcx() - <simg2>.getcx();	}
	int icleny(string simg1, int y)	{	return <simg1>.getcy() - y;	}
	int icleny2(string simg1, string simg2)	{	return <simg1>.getcy() - <simg2>.getcy();	}
	int isbetween2(string simg1, string simg2, int x1, int y1, int x2, int y2)	{
		return this.isbetween(simg1, <simg2>.getcx(), <simg2>.getcy(), x1, y1, x2, y2);
	}
	int isbetween(string simg1, int xx, int yy, int x1, int y1, int x2, int y2)	{
		il1 = this.ilen( simg1, xx, yy );
		return ilx>=x1 && ilx<=x2 && ily>=y1 && ily<=y2;
	}
	int ilodlen(string s1, string s2)	{	.ilen(<s1>.lodx,<s1>.lody, <s2>.lodx, <s2>.lody);	}
	int iposlen(string simg1, string simg2)	{
		.ilen( <simg1>.getpos, <simg2>.getpos );
	}
}

/****************************************************/
class classansearcher	{
	init()	{}
	def _findnotr(string san, int x, int y, int dx, int dy)	{
		int ex = <san>.getex() , int ey = <san>.getey();
		while( x!=ex && y!=ey )	{
			if( <san>.isin(x,y,false,true) ) return x,y;
			x+=dx;	y+=dy;
		}
		return -1,-1;
	}
	def firstnotrx1y(string san)	{	return ._findnotr(san,<san>.getpx(), <san>.getpy(), 1, 0);	}
	def firstnotrexy1(string san)	{	return ._findnotr(san,<san>.getex()-1, <san>.getpy(), 0, 1);	}
	def firstnotrxy1(string san)	{	return ._findnotr(san,<san>.getpx(), <san>.getpy(), 0, 1);	}
	def firstnotrx1ey(string san)	{	return ._findnotr(san,<san>.getpx(), <san>.getey()-1, 1, 0);	}
}

class signal_pack	{
	init()	{}
	addsignals(string san)	{
		<san>.addmethod("operator<", func { (string sfun) this.addmethod("onfinish", sfun ); } );
	}
}
/***************************************************************************/
	// rozszerzenia dla animcaji
class anima_pack : signal_pack	{
	init()	{}
	public resizemethods(string san)	{
		<san>.addmethod("_clanbuildpomvars", func { new int _ixp; new int _iyp; } );
		<san>._clanbuildpomvars();
		<san>.addmethod("setbpos", func {(int x, int y) this.setpos( x-this.lodx, y-this.lody ); });
		<san>.addmethod("saverelpos", func {(int x,int y)_ixp=x-this.getpx;_iyp=y-this.getpy;} );
		<san>.addmethod("setrelpos", func{(int x, int y) this.setbpos( x - _ixp, y - _iyp );});
		<san>.addmethod("mssaverelpos", func {this.saverelpos( mouse.getpos );} );
		<san>.addmethod("mssetrelpos", func {this.setrelpos( mouse.getpos );});
		<san>.addmethod("rplay", func {(string sact)if( !this.isplaying(sact) ) this.play(sact);});
		<san>.addmethod("setcpos", func {(int x, int y)this.setbpos( x-this.getw/2, y-this.geth/2 );});
		<san>.addmethod("operator=", func { (string s) this.copy(s); } );
		<san>.addmethod("operator==", func { (string s)
			.actionnr==<s>.actionnr && .framenr==<s>.framenr; } );
		this.addsignals(san);
	}
}

class timer_pack : signal_pack	{
	init()	{}
	resizemethods(string sob)	{
		this.addsignals(sob);
	}
}
/***************************************************************************/
class vector_pack	{
	init()	{}
	each(string sfun)	{	for( int i=0; i<.size; i++) this.<sfun>(.get(i));	}
	resizemethods(string svec)	{
		<svec>.addmethod("each", "each");
		<svec>.addmethod("operator-", func { (def x) this.remove(x); this; } );
		<svec>.addmethod("operator+", func { (def x) this.add(x); this; } );
	}
}

/***************************************************************************/

class classanfilter	{
	init()	{}
	buildanfilter()	{
		new filter ft;
		ft.link( this.getname() );
		ft.setpivottype(1);
	}
	public build(string san)	{
		<san>.addmethod("buildanfilter","buildanfilter");
		<san>.buildanfilter();
		<san>.addmethod("setopacity",	func {	(int iop) ft.setopacity(iop); }		);
		<san>.addmethod("setzoom",		func {	(real r) ft.setzoom(r); }			);
		<san>.addmethod("setangle",		func {	(real r) ft.setangle(r); }			);
		<san>.addmethod("getangle",		func {	return ft.getangle; }			);
		<san>.addmethod("rotate",		func {	(real r)	ft.rotate(r); }			);
		<san>.addmethod("setpivottype",	func {	(int ityp) ft.setpivottype(ityp); }	);
		<san>.addmethod("unlink",		func {	ft.unlink(); }					);
		<san>.addmethod("link",			func {	ft.link(this); }					);
		<san>.addmethod("blend",		func {	(string s) ft.blend(s); }			);
		<san>.addmethod("mask",		func {	(string s) ft.mask(s); }			);
	}
}

/***************************************************************************/

class classancounter	{
	init()	{
		new int iile;
		new int id;
		new string _san;
		new vector _vs;
		new int _pos;
	}
	set(string sname, int ile)	{
		_san = sname;
		iile = ile;
		id = 0;
		_pos = sname.length();
		_vs.resize( ile, false );
	}
	string get()	{
		string s = _san+id;
		id = (id+1)%iile;
		return s;
	}
	string getf()	{
		for(int i=0; i<iile; i++)	{
			if( !_vs.get(i) )	{
				_vs.set(i, true);
				return _san+i;
			}
		}
		return null;	// brak wolnych
	}
	retf(string s)	{	_vs.set( s.getb( _pos, 10 ), false );	}
	isfree(int pos)	{	return _vs.get(pos);	}
	int getile()	{	return iile;	}
}

/**************************************************************/
	// operacje na obrazach, dzwiekach, timerach i animacjach
class gmobjvec {
	init()	{
		new vector lsim;
		lsim.type("string");
	}
	operator=(string sgr)	{
		if( engine.varexist(sgr) )	{
			match(<sgr>.gettype())	{
				"vector" => this.copy(sgr);
				"gmobjvec" => this.copy(sgr);
				"gmimgvec" => this.copy(sgr);
				? => {	this.free(); this.add(sgr); }
			}
		} else {
			this.free();
			this.add(sgr);
		}
	}
	operator+(string sob)	{	this.add(sob);		return this;	}
	operator-(string sob)	{	this.remove(sob);	return this;	}
	addtogr(string sgr)	{	for( int i=0; i<this.size(); i++)	<sgr>.add(this.get(i));	}
	addgr(string sgr)	{	for( int i=0; i< <sgr>.size(); i++)	this.add( <sgr>.get(i) );	}
	copy(string sgr)	{
		this.free();
		this.addgr(sgr);
	}
	free()	{ lsim.free();	}
	int size()	{ return lsim.size(); }
	bool empty()	{	return this.size()==0;	}
	hash()	{ lsim.hash(); }
	string first()	{ return lsim.get(0); }
	string last()	{ return lsim.get( lsim.size()-1 ); }
	print()	{	lsim.print();	}
	string get(int i)	{ return lsim.get(i); }
	add(string simg)	{	lsim.add(simg);	}
	addbegin(string simg)	{	lsim.addbegin(simg);	}
	swap(int i, int j)	{	lsim.swap(i,j);	}
	addonce(string simg)	{	if( !lsim.contains(simg) )	lsim.add(simg);	}
	sepadd(string separator)	{
		string s = _;
		while( s!=separator )	{
			this.addbegin(s);
			s = _;
		}
	}
	insertat(string sob, int pos)	{
		@ile = .size;
		if( pos<=0 )	.addbegin(sob);
		else if (pos>=ile)	.add(sob);
		else {
			.add(null);
			for( @i=ile; i>pos; i--)	.set( i, .get(i-1) );
			.set(pos, sob );
		}
	}
	remove(string simg)	{	lsim.remove(simg);	}
	removeat(int pos)		{	lsim.removeat(pos);	}
	removealloccurs(string simg)	{	while(this.contains(simg))	this.remove(simg);	}
	removeif(string sfun)	{
		for( int i=0; i<.size; i++)
			if( <.get(i)>.<sfun>() )  .removeat(i);
	}
	int find(string simg)	{ return lsim.find(simg); }
	int contains(string simg)	{ return lsim.contains(simg); }
	addgroup(string sob, int ile)	{	this.addgroup2( sob, 0, ile-1 );	}
	addgroup2(string sob, int ifrom, int ito)	{
		while( ifrom <= ito )	{
			this.add( sob+ifrom );
			ifrom++;
		}
	}
	string rand()	{
		int ile = .size;
		ile>0 ? .get(ile.rand(ile)) : null;
	}
	string randdiff(string s)	{
		int ile = .size;
		if( ile>0 )	{
			int id = ile.rand(ile);
			int i = id;
			while( .get(id)==s )	{
				id = (id+1)%ile;
				if( id==i )	return null;
			}
			return .get(id);
		}
		null;
	}
	/******************* metody na obiektach grupy *****************************/
	movefrom(string simg, int x, int y)	{
		int i = this.find(simg);
		if( i>=0 )	{
			while( i<lsim.size() )	{
				<lsim.get(i)>.move(x,y);
				i++;
			}
		}
	}
	move(int x, int y)	{	this.eval2("move",x,y);	}
	setpos(int x, int y)	{	this.eval2("setpos",x,y);	}
	show()	{	this.eval("show");	}
	hide()	{	this.eval("hide");	}
	stop(int fin)	{	this.eval1("stop",fin);	}
	play()	{	this.eval("play");	}
	nplay(int iact)	{	this.eval1("nplay",iact);	}
	splay(string sact)	{	this.eval1("splay",sact);	}
	setdelay(int d)	{	this.eval1("setdelay",d);	}
	graddmethod(string sdest, string ssrc)	{	this.eval2("addmethod",sdest,ssrc);	}
	string getimg(int x, int y, int bignorehidden, int bignorealpha)	{
		for( int i=lsim.size()-1; i>=0; i--)	{
			if( <lsim.get(i)>.isin( x,y,bignorehidden,bignorealpha ) )	return lsim.get(i);
		}
		return null;
	}
	int isin(int x, int y, bool bignorehidden, bool bignorealpha)	{
		for( int i=lsim.size()-1; i>=0; i--)	{
			if( <lsim.get(i)>.isin( x,y,bignorehidden,bignorealpha ) )	return i+1;
		}
		return false;
	}
	ssetframe(string sac, int ifr)	{for(int i=0; i<lsim.size(); i++)	<lsim.get(i)>.setframe(sac, ifr);	}
	isetframe(int iac, int ifr)	{	this.eval2("setframe",iac,ifr);	}
	setz(int z)	{	this.eval1("setz",z);	}
	/**************/
	eval(string sfunc)	{
		for(int i=0; i<lsim.size(); i++)	{<lsim.get(i)>.<sfunc>();	}
	}
	eval1(string sfunc, def darg)	{
		for(int i=0; i<lsim.size(); i++)	{<lsim.get(i)>.<sfunc>(darg);}
	}
	eval2(string sfunc, def darg1, def darg2)	{
		for(int i=0; i<lsim.size(); i++)	{<lsim.get(i)>.<sfunc>(darg1, darg2);}
	}
	eval3(string sfunc, def darg1, def darg2, def darg3)	{
		for(int i=0; i<lsim.size(); i++)	{<lsim.get(i)>.<sfunc>(darg1, darg2, darg3);}
	}
	int _find(string sfun, def id)	{
		for( int i=0; i<this.size; i++) if ( <this.get(i)>.<sfun>()==id ) return i;
		-1;
	}
	int _find1(string sfun, @id)	{
		for( int i=0; i<.size; i++) if ( <this.get(i)>.<sfun>(id) ) return i;
		-1;
	}
	each(string sfun)	{	for( int i=0; i<.size; i++) <.get(i)>.<sfun>(i);	}
	each1(string sfun, @d1)	{	for( int i=0; i<.size; i++) <.get(i)>.<sfun>(i, d1);	}
	each2(string sfun, @d1, @d2)	{	for( int i=0; i<.size; i++) <.get(i)>.<sfun>(i, d1, d2);	}
	bool ineach(string sfun)	{
		for( int i=0; i<.size; i++) if( !<.get(i)>.<sfun>(i) )	return false;
		true;
	}
	int find_closest(string sob, string sfun)	{
		if( .empty ) return;
		int id = 0, real il;
		real ilen = <.get(0)>.<sfun>(sob);
		for( int i=1; i<.size; i++)	{
			il = <.get(i)>.<sfun>(sob);
			if( il < ilen )	{
				id = i;
				il = ilen;
			}
		}
		id;
	}
	/**************/
	sortimgsfun(string sfun)	{	lsim.vecsort(sfun);	}
	sortimgs()	{	// sortowanie od najmniejszych
		lsim.vecsort("_scmpimg1");
	}
	bool _scmpimg1(string s0, string s1)	{
		return ( <s0>.getz() < <s1>.getz() || ( <s0>.getz()==<s1>.getz() && <s0>.getidobj() < <s1>.getidobj() ) );
	}
}

class gmimgvec : gmobjvec	{
	init()	{
		gmobjvec::init();
		new int _ix = 0;
		new int _iy = 0;
		new int _iz = 0;
		new int _ifound = -1;
	}
	_setpos(int x, int y)	{	|_ix, _iy| = x,y;	}
	int lodx()	{0;}
	int lody()	{0;}
	int getposx()	{	return _ix;	}
	int getposy()	{	return _iy;	}
	int getpos()	{	return _ix, _iy;	}
	int getpx() {	return _ix;	}
	int getpy() {	return _iy;	}
	int getw()	{	return this.getex()-this.getpx();	}
	int geth()	{	return this.getey()-this.getpy();	}
	int getcx() {	return this.getpx()+this.getw()/2;	}
	int getcy() {	return this.getpy()+this.geth()/2;	}
	int getz()	{	return _iz;	}
	int getex()	{
		int ile = this.size();
		if( ile<=0 )	{	return _ix;	}
		int x = <this.get(0)>.getex();
		int x2;
		for( int i=1; i<ile; i++)	{
			x2 = <this.get(i)>.getex();
			if( x2>x )	{	x=x2;	}
		}
		return x;
	}
	int getey()	{
		int ile = this.size();
		if( ile<=0 )	{	return _iy;	}
		int y = <this.get(0)>.getey();
		int y2;
		for( int i=1; i<ile; i++)	{
			y2 = <this.get(i)>.getey();
			if( y2>y )	{	y=y2;	}
		}
		return y;
	}
	/*minx	{	.find_closest(null, func {(@s) .getpx; } );	}
	miny	{	.find_closest(null, func {(@s) .getpy; } );	}
	countborders	{
		_ix = .minx;
		_iy = .miny;
	}*/
	setz(int z)	{
		_iz = z;
		this.eval1("setz",z);
	}
	move(int x, int y)	{
		_ix +=x;
		_iy +=y;
		this.eval2("move",x,y);
	}
	setpos(int x, int y)	{
		_ix = x;
		_iy = y;
		this.eval2("setpos",x,y);
	}
	setpos2(int x, int y)	{
		_ix = x;
		_iy = y;
		if( !.empty )	{
			x -= <.get(0)>.getpx;
			y -= <.get(0)>.getpy;
			.move(-x,-y);
		}
	}
	changeframe(int ifr) {
		string s;
		for( int i=0; i<.size; i++)	{
			s = .get(i);
			<s>.setframe( <s>.actionnr(-1), ifr );
		}
	}
	anputgr()	{	this.eval("anputgr");	}
	anputy(int ypos)	{	this.eval1("anputy", ipos);	}
	int isin(int x, int y, bool bignorehidden, bool bignorealpha)	{
		for( int i=lsim.size()-1; i>=0; i--)	{
			if( <lsim.get(i)>.isin( x,y,bignorehidden,bignorealpha ) )	{
				_ifound=i;
				return i+1;
			}
		}
		_ifound = -1;
		return false;
	}
	int getfound()	{	return _ifound;	}
	string getsfound()	{	return this.get(_ifound);	}
	int findfr(int id)	{	._find("framenr", id);	}
	int findac(int id)	{	._find("actionnr", id);	}
	int findsac(string sac)	{	._find("actionname", sac);	}
	int nearest_to(string sob)	{
		//.find_closest(sob, func {(string s) 0->length( .getpx-<s>.getpx, .getpy-<s>.getpy ); } );
		.find_closest(sob, func {(string s) cllen.ilen5(this,s); } );
	}
	/*def find_min(string s)	{
		if( .empty ) return;
		int x = <s>.getpx;
		int y = <s>.getpy;
		int id = 0, int il;
		int ilen = id.length( <.get(0)>.getpx-x, <.get(0)>.getpy-y );
		for( int i=1; i<.size; i++)	{
			il = id.length( <.get(i)>.getpx-x, <.get(i)>.getpy-y );
			if( il < ilen )	{
				id = i;
				il = ilen;
			}
		}
	}*/
	/****************************/
	loadallan(string sname, string sfile, int z)	{
		string s = gameapi.getgamename();
		<s>.newanima(sname,sfile,z);
		_ = <s>.newanfrbyactgr(sname, sname, this);
		<sname>.hide();
	}
	operator*(string s)	{
		string sg = gameapi.getgamename;
		string san;
		if ( s.contains(".pyz") ) {
			san = "an" + s.strsubes(".pyz");
			<sg>.newanima(san,s,0);
		} else san = s;
		_ = <sg>.newanactionsgr(san, san, this);
		<san>.hide();
	}
	operator<(string s)	{
		string sg = gameapi.getgamename;
		string san;
		if ( s.contains(".pyz") ) {
			san = "an" + s.strsubes(".pyz");
			<sg>.newanima(san,s,0);
		} else san = s;
		_ = <sg>.newanfrbyactgr(san, san, this);
		<san>.hide();
	}
}

class gmmaskvec : gmimgvec	{
	init()	{
		gmimgvec::init();
	}
	int isin(int x, int y, bool bigvis, bool bigalpha)	{
		return gmimgvec::isin(x,y,false,bigalpha);
	}
}


class classsound {
	init()	{
		new string _csplay = null;
	}
	creset()	{ _csplay = null; }
	string cgetactsnd()	{ return _csplay; }
	crselfplay(string ssnd)	{
		if( !this.cisplaying() )	this.cbplay(ssnd);
		else if ( this.cgetactsnd()!=ssnd )	this.cbplay(ssnd);
	}
	cbplay(string ssnd)	{
		if(this.cisplaying())	<_csplay>.stop(true);
		_csplay = ssnd;
		if( ssnd!=null )	<ssnd>.play();
	}
	cbplay2(string ssnd)	{
		if(this.cisplaying())	<_csplay>.stop(false);
		_csplay = ssnd;
		if( ssnd!=null )	<ssnd>.play();
	}
	crplay(string ssnd)	{
		if(_csplay!=null && <_csplay>.isplaying() )	return;
		_csplay = ssnd;
		if( ssnd!=null )	<ssnd>.play();
	}
	crbgplay(string ssnd)	{	if( ssnd != null && !<ssnd>.isplaying() )	<ssnd>.play();	}
	crandplay(string ssnd, int irand, string styp)	{
		if( irand.rand( irand )==0 )	this.<"c"+styp+"play">( ssnd );
	}
	cplayf(string styp, string ssnd, string sfun)	{
		this.<"c"+styp+"play">(ssnd);
		if( <ssnd>.isplaying() && sfun!=null)	<ssnd>.addmethod("onfinish",sfun);
	}
	cactsndstop(bool bfin)	{	if(_csplay!=null)	<_csplay>.stop(bfin);	}
	bool cisplaying()	{	_csplay!=null ? <_csplay>.isplaying() : false;	}
}

/***************************************************************************/
class classsndbank	{
	init()	{
		new int itype;
		new int ilicz = 0;
		new int iile;
		new string splay=null;
		new string ssnd = "snd";
	}
	/********************************/
	loadsingle(string sfile, int ile)	{
		if( ile<=0)	{	iile=0;	return;	}
		iile=ile;
		itype=0;
		for( int i=0; i<ile; i++)	newvars::newsnd( ssnd+i, sfile );
	}
	/********************************/
	load(string sfilebase, int ifilefrom, int ifileto, int ityp, int itypstart)	{
		iile = ifileto-ifilefrom+1;
		if(iile<=0)	{
			iile = 0;
			return;
		}
		newvars::newsnds( ssnd, 0, sfilebase, ifilefrom, ifileto);
		itype = ityp;			// 0 - po kolei, 1 - random
		if(itypstart==1)	{	// 0 - od pierwszego, 1 - randomowy
			ilicz = ilicz.rand( iile );
		}
	}
	addmethod(string ssig, string sfunc)	{
		for( int i=0; i<iile; i++)	<ssnd+i>.addmethod( ssig, sfunc );
	}
	stop(int ifin)	{	if(splay!=null)	<splay>.stop(ifin);	}
	int isplaying()	{	splay!=null ? <splay>.isplaying() : false;	}
	randplay( int irand )	{	if( irand.rand( irand )==0 )	this.play();	}
	playid(int id)	{
		ilicz=id%iile;
		this.play();
	}
	play()	{
		this.stop(false);
		this.bgplay();
	}
	reset()	{	ilicz=0;	}
	/************************************************/
	rbgplay()	{	if( !this.isplaying() )	this.bgplay();	}
	rplay()	{	if( !this.isplaying() )	this.play();	}
	bgplay()	{
		splay = ssnd + ilicz;
		<splay>.play();
		if( itype==0)	ilicz = (ilicz+1)%iile;
		else if (itype==1)	ilicz = ilicz.rand( iile );
	}
	setvol(int vol)	{	for( int i=0; i<iile; i++)	<ssnd+i>.setvol( vol );	}
}

/**************************************************************/
	// standardowe czynnosci przy grach, popakowane w metody
class classgame : newvars , classsound {
	init()	{
		newvars::init();
		classsound::init();
		new int _iconstid;
	}
	/**************************************************************/
	bkg=(@sfile)	{
		if( sfile.contains(".pyz") ) .newanima("anbkg", sfile, 0);
		else .newimg("imgbkg",sfile,0);
	}
	bgr=(@sfile)	{	this.csndplayloop("sndbgr",sfile);}
	path=(@s)	{	.setgraphpath("scripts/"+s+"/");	}
	cycle=(@stimer, @sfun)	{	.cnewtimercyclefin(stimer,1,1,sfun);	}
	timer=(@stimer, @itime, @sfun) { .cnewtimerfin(stimer,itime,1,sfun);	}
	img=(@sfile)	{
		string sname = sfile.strsube(4);
		if( sfile.contains(".pyz") ) .newanima("an"+sname, sfile, 0);
		else .newimg("img"+sname,sfile,0);
	}
	list=(@sname)	{
		@s=_;
		new gmobjvec <sname>;
		while(s!=A)	{
			<sname>.add(s);
			s = _;
		}
	}
	debug=(@b)	{	engine.setdebugstate(b);	}
	sfx=(string s)	{
		@bloop = false;
		if( s.contains("L") )	{
			s.strremove("L");
			bloop=true;
		}
		@bplay = false;
		if( s.contains("P") )	{
			s.strremove("P");
			bplay=true;
		}
		@ivol = 100;
		if( s.contains(" ") )	{
			ivol = s.strgetfrom(" ");
			s = s.strgetto(" ");
		}
		string sf = "fx"+s;
		.newsnd(sf, "sfx/"+s+".wav");
		<sf>.setvol( ivol );
		if( bloop ) <sf>.addmethod("onfinish","_stdsndloop");
		if( bplay ) <sf>.play;
	}
	sfxs=	{	.withlist("sfx=");	}
	tickstart	{
		if( !.hasvar("__timspeed") )	new TicksCounter __timspeed;
		__timspeed.start;
	}
	tickstop	{	__timspeed.print("ticker: ");	}
	/**************************************************************/
	csetbkg(string sfile)	{	this.newimg("imgbkg",sfile, 0);	}
	cstdbkg()	{	this.csetbkg("bkg.png");	}
	bkgpyz()	{	this.newanima("anbkg", "bkg.pyz", 0 );	}
	csndplayloop(string ssnd, string sfile)	{
		this.newsndloop(ssnd,sfile);
		<ssnd>.play();
	}
	csndbgr(string sfile)	{	this.csndplayloop("sndbgr",sfile);}
	cloadcursor(string sfile)	{
		if( sfile.contains(".") )	{
			.newimg("imgkursor", sfile,0);
			sfile = "imgkursor";
		}
		<sfile>.hide();
		mouse.setcursor(sfile);
		engine.stdbutcursor(sfile);
		bsms.setown();
	}
	csavevar(string svar, string sval)	{
		<svar> = sval;
		clsav.varsave( gameapi.getgamename(), svar, sval);
	}
	cloadvar(string svar, string sstdval)	{	clsav.varload( gameapi.getgamename(), svar, sstdval );	}
	/****************************************************************/
	string newconst(string styp)	{
		string s = "const"+styp+_iconstid;
		new <styp> <s>;
		_iconstid++;
		return s;
	}
	string consttext(string stext, int x, int y, int isize, int r, int g, int b)	{
		string s = this.newconst("text");
		string sf = this.newconst("font");
		<sf>.load( sgmfontfile, isize );
		<s>.setfont(sf);
		<s>.set(stext);
		<s>.createtxt(r,g,b);
		<s>.setpos(x,y);
		return s;
	}
	/****************************************************************/
	cfinmethod(string sobj, string sfuncfin)	{	<sobj>.addmethod("onfinish", sfuncfin);	}
	cnewsndfin(string sname, string sfile, string sfunc)	{
		this.newsnd(sname,sfile);
		this.cfinmethod(sname,sfunc);
	}
	cnewsndsfin(string sbase, int inamestart, string sfilebase, int ifilefrom, int ifileto, string sfunc)	{
		this.newsnds(sbase, inamestart, sfilebase, ifilefrom, ifileto);
		this.caddobjsfunfin(sbase, inamestart, inamestart+( ifileto-ifilefrom), sfunc);
	}
	cnewsndfinbplay(string sname, string sfile, string sfunc)	{
		this.cnewsndfin(sname,sfile,sfunc);
		this.cbplay(sname);
	}
	cnewtimerfin(string sname, int idelay, int iticks, string sfunc)	{
		this.newtimer(sname,idelay,iticks);
		this.cfinmethod(sname,sfunc);
	}
	cnewtimercyclefin(string sname, int icycle, int iticks, string sfunc)	{
		this.newtimercycle(sname,icycle,iticks);
		this.cfinmethod(sname,sfunc);
	}
	/****************************************************************/
	caddobjsfun(string ssnd, int ifrom, int ito, string ssig, string sfunc)	{
		while( ifrom <= ito )	{
			<ssnd+ifrom>.addmethod( ssig, sfunc+ifrom );
			ifrom++;
		}
	}
	caddobjsfunfin(string ssnd, int ifrom, int ito, string sfunc)	{
		this.caddobjsfun( ssnd, ifrom, ito, "onfinish", sfunc );
	}
	/****************************************************************/
	newancounter(string scounter, string sname, string sfile, int z, int ile)	{
		this.newanimas( sname, sfile, z, ile);
		new classancounter <scounter>;
		<scounter>.set( sname, ile );
	}
	newancounterh(string scounter, string sname, string sfile, int z, int ile)	{
		this.newancounter( scounter, sname, sfile, z , ile );
		for( int i=0; i<ile; i++)	<sname+i>.hide();
	}
	newancounterf(string scounter, string sname, string sfile, int z, int ile, string sfun)	{
		this.newancounter( scounter, sname, sfile, z , ile );
		for( int i=0; i<ile; i++)	<sname+i>.addmethod("onfinish", sfun);
	}
	newancounterhf(string scounter, string sname, string sfile, int z, int ile, string sfun)	{
		this.newancounter( scounter, sname, sfile, z , ile );
		for( int i=0; i<ile; i++)	{
			<sname+i>.addmethod("onfinish", sfun);
			<sname+i>.hide();
		}
	}
	cnewanimafin(string sname, string sfile, int z, string sfunc)	{
		this.newanima(sname, sfile, z);
		<sname>.addmethod("onfinish", sfunc );
	}
	ccopyanimafin(string sname, string snew, string sfunc)	{
		this.copyanima(sname, snew);
		<snew>.addmethod("onfinish", sfunc );
	}
	/****************************************************************/
	cloadwavs(string sdb, string sfile)	{
		this.newdb( sdb, sfile );
		int id = 0;
		int ile = <sdb>.getrowsno();
		int i[6], string s[5];
		while( id < ile )	{
			i1 = <sdb>.getcolsno(id);
			i2 = 0;
			s1 = <sdb>.get( id, i2 );	i2++;
			if( s1.getb(0,1)!="#" )	{
				s3 = <sdb>.get( id, i2 );	i2++;
				if( s1=="wav" || s1=="sfx" )	{
					s2 = <sdb>.get( id, i2 );	i2++;
					if( s1=="sfx")	{
						this.newsnd( s3, "sfx/"+s2 );
					} else { this.newsnd( s3, s2 ); }
					if( i2 < i1 )	{
						s1 = <sdb>.get( id, i2 );	i2++;
						s2 = <sdb>.get( id, i2 );	i2++;
						if( s1=="method" )	{
							<s3>.addmethod("onfinish", s2 );
						} else if (s1.gete(0,4)=="play")	{
							this.<"c"+s1.gete(4,10)+"playonfin">(s3, s2);
						} else if ( s1=="vol" )	{
							<s3>.setvol( s2 );
						}
					}
				} else if (s1=="group")	{
					s2 = <sdb>.get( id, i2 );	i2++;
					i3 = <sdb>.get( id, i2 );	i2++;
					i4 = <sdb>.get( id, i2 );	i2++;
					if( i2 < i1 )	{		// jest method
						s1 = <sdb>.get( id, i2 );	i2++;
						if( s1=="method" )	{
							s4 = <sdb>.get( id, i2 );	i2++;
							this.cnewsndsfin( s3, i3, s2, i3, i4, s4 );
						}
					} else {
						this.newsnds( s3, i3, s2, i3, i4 );
					}
				} else if (s1=="bank")	{
					s2 = <sdb>.get( id, i2 );	i2++;
					i0 = <sdb>.get( id, i2 );	i2++;
					i3 = <sdb>.get( id, i2 );	i2++;
					i4 = <sdb>.get( id, i2 );	i2++;
					i5 = <sdb>.get( id, i2 );	i2++;
					new classsndbank <s3>;
					<s3>.load( s2, i0, i3, i4, i5);
					if( i2<i1)	{
						s1 = <sdb>.get( id, i2 );	i2++;
						if( s1=="method")	{
							s4 = <sdb>.get( id, i2 );	i2++;
							<s3>.addmethod( "onfinish", s4 );
						} else if (s1=="vol")	{
							<s3>.setvol( <sdb>.get( id, i2 ) );
						}
					}
				} else if ( s1=="method" )	{
					s2 = <sdb>.get( id, i2 );	i2++;
					i3 = <sdb>.get( id, i2 );	i2++;
					i4 = <sdb>.get( id, i2 );	i2++;
					while( i3<=i4)	{
						<s2+i3>.addmethod("onfinish", s3);
						i3++;
					}
				} else if ( s1=="singlebank")	{
					s2 = <sdb>.get( id, i2 );	i2++;
					i3 = <sdb>.get( id, i2 );	i2++;
					new classsndbank <s3>;
					<s3>.loadsingle( s2, i3 );
				} else if ( s1=="bgr" )	{
					this.csndbgr( s3 );
					if( i2 < i1 )	{
						if( <sdb>.get( id, i2 )=="vol" )	{
							i2++;
							sndbgr.setvol( <sdb>.get( id, i2 ) );
							i2++;
						}
					}
				} else if ( s1=="music" )	{
					this.playmusic( s3 );
					if( i2 < i1 )	{
						if( <sdb>.get( id, i2 )=="vol" )	{
							i2++;
							sndbgr.setvol( <sdb>.get( id, i2 ) );
							i2++;
						}
					}
				}
			}
			id++;
		}
	}
	/****************************************************************/
	crestart()	{	gameapi.play( gameapi.getgamename() );	}
	/****************************************************************/
	chideanimas(string san, int ile)	{	classevalfun::_eval0( san, 0, ile-1, "hide" );		}
	cshowanimas(string san, int ile)	{	classevalfun::_eval0( san, 0, ile-1, "show" );		}
}


/***************************************************************************/

class clfindfunc	{
	init()	{}
	int _stdfindfunc(string sobj, int ifirst, int ilast, string sname, string sfunc)	{	
		while(ifirst<=ilast)	{
			if( <sobj + ifirst>.<sfunc>()==sname)	{
				return ifirst;
			} else {
				ifirst++;
			}
		}
		return -1;
	}
	int _stdfindfunc2(string sobj, int iile, string sname, string sfunc)	{	
		return this._stdfindfunc(sobj, 0, iile-1, sname, sfunc);
	}
	/****************************************************************/
	cfindandeval2(string sobj, int iile, string sname, string sfunc, string seval)	{	
		this.cfindandeval(sobj, 0, iile-1, sname, sfunc, seval);
	}
	cfindandeval(string sobj, int ifirst, int ilast, string sname, string sfunc, string seval)	{	
		int pos = this._stdfindfunc(sobj, ifirst, ilast, sname, sfunc);
		if(pos>=0)	{
			<sobj+pos>.<seval>();
		}
	}
	/****************************************************************/
}

class classevalfun	{
	init()	{}
	_eval0(string sob, int ifrom, int ito, string sfun){while( ifrom<=ito ){<sob+ifrom>.<sfun>(); ifrom++;}}
	_eval1(string sob, int ifrom, int ito, string sfun, def sarg1){while( ifrom<=ito ){<sob+ifrom>.<sfun>(sarg1); ifrom++;}}
	_eval2(string sob, int ifrom, int ito, string sfun, def sarg1, def sarg2)	{
		while( ifrom<=ito ) { <sob+ifrom>.<sfun>(sarg1, sarg2); ifrom++; }
	}
	eval0(string sob, string sfun) {if( sfun != null ) ( sob==null ) ? this.<sfun>() : <sob>.<sfun>();}
	eval1(string sob, string sfun, def sarg1) {if( sfun != null ) ( sob==null )?this.<sfun>(sarg1):<sob>.<sfun>(sarg1);}
}


/*****************************************************************/
class classbutton 	{
	init()	{
		new string san = "anbut";
		new string sbut = "but";
		new int iilebut = 0;
		new string sfxmon = null;
	}
	_cbuildbutname(string sname)	{	new string _sbutname=sname; }
	string cgetbutname()	{ return _sbutname; }
	build(string sfile, int z, string smouse)	{this.build2(sfile,z,smouse,null);	}
	build2(string sfile, int z, string smouse, string sgrp)	{	// wczytuje animacje i buduje z niej przyciski
		string smain = "_" + san;
		new anima <smain>;
		<smain>.load( sfile );
		<smain>.setz(z);
		int ile = <smain>.nofactions();
		int j;	int k;
		int iliczans = 0;
		string sn1, string sn2, string sn3;
		string spom;
		for(int i=0; i<ile; i++)	{
			sn1 = null;	sn2 = null;	sn3 = null;
			j = <smain>.nofframes(i);
			for(k=1; k<=j; k++)	{
				spom = san + iliczans;
				if(k==1)	{	sn1=spom; } 
				else if (k==2)	{ sn2 = spom; }
				else if (k==3)	{ sn3 = spom; }
				newvars::copyanima( smain, spom );
				<spom>.setframe( i, k-1 );
				iliczans++;
			}
			if( sgrp!=null && <sgrp>.contains( <smain>.nameofaction(i)) ) {
				<sn1>.setz(z-1);
			} else this.addbut(sn1, sn2, sn3, smouse);
		}
		<smain>.hide();
	}
	/***************************** \/ \/ \/ \/ \/ wewnetrzne \/ \/ \/ \/ \/ *************************************************/
	_buildfuncclick( string sname )	{	new string _sfunclick = sname; }
	_stdbutclick()	{	this.<_sfunclick>( this.getbutname() );		}
	_buildfuncrel( string sname )	{	new string _sfuncrel = sname; }
	_stdbutrel()	{	this.<_sfuncrel>( this.getbutname() );	}
	_buildfuncmovon( string sname )	{	new string _sfunmovon = sname; }
	_stdbutmovon()	{
		if( sfxmon!=null )	<sfxmon>.play();
		this.<_sfunmovon>( this.getbutname() );
	}
	_buildfuncmovoff( string sname )	{	new string _sfunmovoff = sname; }
	_stdbutmovoff()	{	this.<_sfunmovoff>( this.getbutname() );	}
	butsigfun(string sb, string sfunc, string ssig, string sfun1, string sfun2)	{
		if( sfunc==null )	return;
		<sb>.addmethod(sfun1, sfun1);
		<sb>.<sfun1>( sfunc );
		<sb>.addmethod(ssig, sfun2);
	}
	sigfunc(string sfunc, string ssig, string sfun1, string sfun2)	{
		for(int i=0; i<iilebut; i++)	this.butsigfun(sbut + i, sfunc, ssig, sfun1, sfun2);
	}
	print()	{for(int i=0; i<iilebut; i++)	engine.print( <sbut+i>.getbutname() );}
	setrect()	{
		string s;
		for( int i=0; i<iilebut; i++)	{
			s = <sbut+i>.getimg;
			<sbut+i>.setrect( <s>.getpx, <s>.getpy, <s>.getex, <s>.getey );
		}
	}
	setflags(bool bvis, bool balph)	{	for(int i=0; i<iilebut; i++)	<sbut+i>.setflags(bvis,balph);	}
	/***************************** /\ /\ /\ /\ /\ wewnetrzne /\ /\ /\ /\ /\ ************************************************/
	sfxonmovon(string ssnd)	{	sfxmon=ssnd;	}
	clickfunc(string sfunc)	{this.sigfunc(sfunc,"onclick", "_buildfuncclick", "_stdbutclick");	}
	relfunc(string sfunc)	{this.sigfunc(sfunc,"onrel", "_buildfuncrel", "_stdbutrel");	}
	movonfunc(string sfunc)	{this.sigfunc(sfunc,"onmoveon", "_buildfuncmovon", "_stdbutmovon");	}
	movofffunc( string sfunc)	{this.sigfunc( sfunc,"onmoveoff", "_buildfuncmovoff", "_stdbutmovoff");}
	/*****************************************************************/
	int ilebuts()	{	return iilebut;	}
	/*****************************************************************/
	int ifind(string sname)	{return clfindfunc::_stdfindfunc2(sbut, iilebut, sname, "getbutname");	}
	string sfind(string sname)	{
		int pos = clfindfunc::_stdfindfunc2(sbut, iilebut, sname, "getbutname");
		return pos>=0 ? sbut+pos : null;
	}
	/*****************************************************************/
	_cbutfun(string sname, string sfunc)	{
		clfindfunc::cfindandeval2(sbut, this.ilebuts(), sname, "getbutname", sfunc );
	}
	_callbutfunc(string sfunc)	{	for(int i=0; i<iilebut; i++)	<sbut+i>.<sfunc>();	}
	_cibutfunc(string sfunc, int ile)	{
		if( ile > iilebut )	ile = iilebut;
		for(int i=0; i<ile; i++)	<sbut+i>.<sfunc>();
	}
	ienable( int ile )	{	this._cibutfunc("enable", ile);	}
	benableall()	{	this.resumeall();	this.enableall();	}
	pauseall()	{	this._callbutfunc("pause");	}
	resumeall()	{	this._callbutfunc("resume");	}
	enableall()	{	this._callbutfunc("enable");	}
	disableall()	{	this._callbutfunc("disable");	}
	
	benable(string sname)	{	this.resume(sname);	this.enable(sname);	}
	disable(string sname)	{	this._cbutfun( sname, "disable");	}
	enable(string sname)	{	this._cbutfun( sname, "enable");	}
	pause(string sname)	{	this._cbutfun( sname, "pause");	}
	resume(string sname)	{	this._cbutfun( sname, "resume");	}
	/*****************************************************************/
	string getimg(string sname)	{
		string s= this.sfind(sname);
		return s!=null ? <s>.getimg() : null;	
	}
	/*****************************************************************/
	newmouse(string sname, string snewmouse)	{
		string s = this.sfind(sname);
		if(s!=null)	<s>.setmouse( snewmouse );
	}
	addbut(string san1, string san2, string san3, string smouse)	{
		string spom = sbut + iilebut;
		newvars::newbutan( spom, san1, san2, san3, smouse);
		<spom>.addmethod("getbutname","cgetbutname");
		<spom>._cbuildbutname( <san1>.actionname() );	// nazwa buttonu to nazwa akcji
		iilebut++;
	}
	/*****************************************************************/
	_addfunc(string s, string sfclick, string sfrel, string sfmvon, string sfmvoff)	{
		if( s== null)	return;
		this.butsigfun( s, sfclick, "onclick", "_buildfuncclick", "_stdbutclick");
		this.butsigfun( s, sfrel, "onrel", "_buildfuncrel", "_stdbutrel");
		this.butsigfun( s, sfmvon, "onmoveon", "_buildfuncmovon", "_stdbutmovon");
		this.butsigfun( s, sfmvoff, "onmoveoff", "_buildfuncmovoff", "_stdbutmovoff");
	}
	addfuncto(string sname, string sfclick, string sfrel, string sfmvon, string sfmvoff)	{
		this._addfunc( this.sfind(sname), sfclick, sfrel, sfmvon, sfmvoff);
	}
	addfunctolast(string sfclick, string sfrel, string sfmvon, string sfmvoff)	{
		this._addfunc( sbut + (iilebut-1) , sfclick, sfrel, sfmvon, sfmvoff);
	}
	/*****************************************************************/
	_transmet(string sob, string sfunc, string smet, string s)	{
		new string <"_sob" + s> = sob;
		new string <"_sf" + s> = sfunc;
		this.<smet>( "_trf"+s );
	}
	transclickfunc(string sob, string sfunc)	{this._transmet( sob, sfunc, "clickfunc", "cl" );	}
	transrelfunc(string sob, string sfunc)	{this._transmet( sob, sfunc, "relfunc", "rl" );	}
	transmovonfunc(string sob, string sfunc){this._transmet( sob, sfunc, "movonfunc", "mn" );	}
	transmovofffunc(string sob, string sfunc){this._transmet( sob, sfunc, "movofffunc", "mf" );	}
	_trfcl(string s)	{	<_sobcl>.<_sfcl>(s);		}
	_trfrl(string s)	{	<_sobrl>.<_sfrl>(s);		}
	_trfmn(string s)	{
		if( sfxmon!=null )	<sfxmon>.play();
		<_sobmn>.<_sfmn>(s);
	}
	_trfmf(string s)	{	<_sobmf>.<_sfmf>(s);		}
}

class classsimplebutton	{
	init()	{
		new string simgob=null;
		new gmimgvec grbut;
	}
	public stdbuild(string sfile, string smouse, int z)	{this.build(this.getgraphpath()+sfile, smouse, 0, 0, z, 0);	}
	public getimgfunc(string sfunc)	{	simgob==null ? 0 : <simgob>.<sfunc>();	}
	public setbutpos(int x, int y)	{	grbut.setpos(x,y);	}
	public build(string sfile, string smouse, int x, int y, int z, int iact)	{
		new button but1;
		but1 (this.getname()) {(string s) new string sbut = s; };
		but1.addmethod("onclick", func { this.<sbut+"_CLICK">(); });
		but1.addmethod("onrel", func { this.<sbut+"_REL">(); } );
		but1.addmethod("onmoveon", func { this.<sbut+"_MOVEON">(); });
		but1.addmethod("onmoveoff", func { this.<sbut+"_MOVEOFF">(); });
		
		if( sfile.contains(".pyz") )	{
			new anima anbut0;
			anbut0.load( sfile );
			anbut0.setpos(x,y);
			anbut0.setz(z);
			anbut0.setframe(iact,0);
			simgob="anbut0";
			grbut.add(simgob);
			string s0="anbut0";
			string s1=null;
			string s2=null;
			int ile = anbut0.nofframes(iact);
			if( ile>1 )	{
				new anima anbut1;
				anbut1.copy("anbut0");
				anbut1.setframe(iact,1);
				s1 = "anbut1";
				grbut.add(s1);
			}
			if (ile>2)	{
				new anima anbut2;
				anbut2.copy("anbut0");
				anbut2.setframe(iact,2);
				s1 = "anbut2";
				grbut.add(s1);
			}
			but1.setan(s0,s1,s2);
		} else {
			new img imgbut;
			simgob="imgbut";
			grbut.add(simgob);
			imgbut.load(sfile);
			imgbut.setpos(x,y);
			imgbut.setz(z);
			but1.set("imgbut",null,null);
		}
		but1.setmouse(smouse);
	}
}

/*****************************************************************/

class classmask : classbutton	{
	init()	{
		classbutton::init();
	}
	buildmask(string sfile, string smouse)	{
		this.build(sfile, 0, smouse);
		int ile = this.ilebuts();
		for(int i=0; i<ile; i++)	{
			<sbut+i>.setflags(false, false);
			<sbut+i>.hide();
		}
	}
	buildmaskfunc(string sfile, string smouse, string sfunc)	{
		this.buildmask(sfile, smouse);
		this.clickfunc(sfunc);
	}
	addmask(string sanim, string sname, string smouse, int bhide)	{		// dodanie np. ludka jako maski
		string spom = sbut + iilebut;
		newvars::newbutan( spom, sanim, null, null, smouse);
		<spom>.addmethod("getbutname","cgetbutname");
		sname==null ? <spom>._cbuildbutname(<sanim>.actionname()) : <spom>._cbuildbutname(sname);
		if(bhide)	{
			<spom>.setflags(false, false);
			<spom>.hide();
		}
		iilebut++;
	}
	addadvmask(string sanim, string sname, string smouse, string sfuncclick)	{
		this.addmask( sanim, sname, smouse, false );
		this.addfunctolast( sfuncclick, null, null, null);	
	}
}

/*****************************************************/
public callfun(string sob, string sfun)	{if( sfun!=null ) sob==null ? this.<sfun>() : <sob>.<sfun>();}
public _stdanloop()	{	this.play(-1); }
public _stdanhide()	{	this.hide();	}
public _stdsndloop()	{	this.play(); }
public __std_finish()	{	this.<this+"_FINISH">();	}
public looponfinish(string san)	{	<san>.addmethod("onfinish", "_stdanloop");	}
public hideonfinish(string san)	{	<san>.addmethod("onfinish", "_stdanhide");	}
/*****************************************************/
public string strsube(int ile)	{	return this.getb( 0, this.length()-ile );	}
public string strsubb(int ile)	{	return this.getb( ile, this.length() - ile );	}
public string strsubbs(string s)	{	return this.strsubb( s.length() );	}
public string strsubes(string s)	{	return this.strsube( s.length() );	 }
public string strgetto(string schar)	{	return this.getb(0, this.find(schar));	}
public string strgetfromto(int ipos, string schar)	{	return this.getb(ipos, this.find(schar));	}
public string strgetfrom(string schar)	{	return .getb(.find(schar)+schar.length, .length );	}
public strremove(string s)	{	.set( .strgetto(s) + .strgetfrom(s) ); }
/*****************************************************/
public swap(string s1, string s2)	{
	string s = [s1];
	<s1> = [s2];
	<s2> = s;
}
public bool stats(int ile)	{	(ile <= 0) ? false : ( ile.rand(100)<=ile );}
public int between(int i1, int i, int i2)	{	( i < i1 ) ? i1 : (i>i2) ? i2 : i;}
public def max(def val1, def val2)	{	val1>val2 ? val1 : val2;	}
public def min(def val1, def val2)		{	val1<val2 ? val1 : val2;	}
/*************** do wykorzystania na obiektach!! ***********************************/
public anresizemets()	{	anima_pack::resizemethods(this.getname());	}
public def anfirstnontr	{	classansearcher::firstnotrx1y(this);	}
public anloopfin()	{	this.addmethod("onfinish", "_stdanloop");	}
public anloopplay(int iact)	{	this.anloopfin();	this.play(iact);	}
public anloopsplay(string sact)	{	this.anloopfin();	this.play(sact);	}
public anhidefin()	{	this.addmethod("onfinish","_stdanhide");	}
public anputgr()	{	this.setz( this.getey() );	}
public anputy(int ypos)	{	this.move(0, ypos - this.geth() - this.getpy());	}
public anputx(int xpos)	{	this.move(0, xpos - this.geth() - this.getpy());	}
public ansetposgr(int x, int y)	{	this.setpos(x,y);	this.anputgr();	}
public anplayz(int id, int z)	{	this.setz(z);	this.play(id);	}
public anplaygr(int id)	{	this.play(id);	this.anputgr();	}
public anplayzpos(int id, int z, int x, int y)	{	this.setpos(x,y);	this.anplayz(id,z);	}
public anplaypos(int x, int y)	{	this.setpos(x,y);	this.play(-1);	}
public anplayposgr(int x, int y)	{	this.ansetposgr(x,y);	this.play(-1);	}
public anplaypos2(int x, int y, string sact)	{	this.setpos(x,y);	this.play(sact);	}
public anplaypos3(int x, int y, int iact)	{	this.setpos(x,y);	this.play(iact);	}
public anhide()	{	this.stop(false);	this.hide();	}
public andownpos(int x, int y)	{	this.setpos( x, y-this.geth() );	}
public ansetbpos(int x, int y)	{	this.setpos( x-this.lodx(), y-this.lody() );	}
public ansetcpos(int x, int y)	{	.ansetbpos( x - .getw/2, y - .geth/2 );	}
public ansetframe(int id)	{	this.setframe( this.actionnr(-1), id );	}
public int anonscreen()	{	return clsurf.inscreen(this.getcx(), this.getcy(), this.getw()/2, this.geth()/2);	}
public objplayfin(string sfun)	{	this.addmethod("onfinish", sfun);	this.play();	}
public objplayloop()	{	this.addmethod("onfinish","_stdsndloop");		this.play();	}
public anplayfin(int iact, string sfun)	{	this.addmethod("onfinish", sfun);	this.play(iact);	}
public anytoz()	{	this.setz(this.getposy());	}
public string annextaction(string sact)	{return this.nameofaction( (this.actionnr(sact)+1)%this.nofactions() );}
public anaddfilter()	{	classanfilter::build(this.getname());	}
public anputc(int x1, int y1, int x2, int y2)	{
	.ansetbpos(x1,y1);
	.move( (x2-x1-.getw)/2, (y2-y1-.geth)/2 );
}
public aninlod(int itoler)	{	itoler.length( .getpx - .lodx, .getpy - .lody ) <= itoler; }
/***************** vector ****************/
public vecinc(int pos)	{	this.set( pos, this.get(pos)+1 );	}
public vecdec(int pos)	{	this.set( pos, this.get(pos)-1 );		}
public vecnewint(int ile)	{
	this.free();
	if( ile>0 )	for( int i=0; i<ile; i++)	{	this.add(i);	}
}
public veccopy(string svec)	{
	this.free();
	for( int i=0; i< <svec>.size(); i++ )	this.add( <svec>.get(i) );
}
public int vecnextid(def val)	{
	int id = .find(val);
	if( id>=0 )	id = (id+1)%.size;
	id;
}
public int vecprevid(def val)	{
	int id = .find(val);
	if( id>0 )	id--;
	else if (id==0)	id = .size-1;
	id;
}
public def vecget(int id)	{
	( id>=0 && id<.size) ? .get(id) : null;
}
public def vecnext(def val)	{	.vecget( .vecnextid(val) );	}
public def vecprev(def val)	{	.vecget( .vecprevid(val) );	}
public def veclast()	{
	int ile = this.size();
	ile>0 ? this.get(ile-1) : null;
}
public def vecpop()	{
	@x = .last;
	.removeat( .size - 1 );
	x;
}
public veclimes(int ile)	{	while( .size > ile )	_ = .vecpop;	}
public def vecpopfront()	{
	def x = this.get(0);
	this.removeat( 0 );
	return x;
}
public insertsort(int ile, string sgetfun, string scomparefun, string sswapfun)	{
	if( ile<=1 )	{	return;	}
	def s[2], int id, int i, int j;
	for( i=0; i<ile; i++)	{
		s0 = this.<sgetfun>(i);
		id = i;
		for( j=i+1; j<ile; j++)	{
			s1 = this.<sgetfun>(j);
			if( this.<scomparefun>(s1,s0) )	{
				s0 = s1;
				id = j;
			}
		}
		this.<sswapfun>(i,id);
	}
}
public obbuildfromstring(string s, string separator, string sfunadd)	{
	int pos = s.find(separator);
	while( pos>-1 )	{
		this.<sfunadd>( s.getb(0,pos) );
		s = s.strsubb(pos+1);
		pos = s.find(separator);
	}
	if( s.length()>0 )	{	this.<sfunadd>(s);	}
}
public vecsort(string scomparefun)	{ .insertsort( .size, "get", scomparefun,"swap" ); }
public string vecbuildfromstring(string s, string separator)	{
	this.free();
	this.obbuildfromstring(s,separator,"add");
}
public vecremoveto(int ito)		{	for( int i=0; i<ito; i++ ) this.removeat(0);		}
public vecremovefrom(int ifrom)	{	while( ifrom<this.size() ) this.removeat(ifrom);	}
public vecposfromto(int i1, int i2)	{
	if( i1==i2 || .size==0 )	return;
	def x = .get(i1);
	if( i1>i2 )	for( int i=i1; i>i2; i--)	{	.set(i, .get(i-1));		}
	else if (i1<i2)	for( int i=i1; i<i2; i++)	{	.set(i, .get(i+1));	}
	.set(i2,x);
}
public vecposfirst( def x )	{
	int id = .find(x);
	if( id>=0 )	.vecposfromto(id, 0);
	else	.addbegin(x);
}
public vecposlast( def x )	{
	int id = .find(x);
	if( id>=0 )	.vecposfromto(id, .size-1);
	else	.addbegin(x);
}
public vecset(def x, def d2)	{
	int id = .find(x);
	if( id>=0 )	.set(id,d2);
}
/************** db ************************/
public dbbuild(int icol)	{
	if( icol<=0 )	return;
	icol--;
	string s = _, int id;
	for( int i = 0; s!=A; )	{
		if( i==0 )	id = this.addbeginrow() - 1;
		this.addbegin(0,s);
		s = _;
		i = (i<icol)? i+1 : 0;
	}
}
public dbremovelast()	{
	.removerow( .getrowsno-1 );
}
public dbcuttosize(int isize)	{
	if( isize>0 ) while( .getrowsno > isize )	.dbremovelast;
	else	.free;
}
public dbaddlast(string svar)	{	this.add( this.getrowsno()-1, svar );	}
public dbaddstringrow(string s, string separator)	{
	_ = this.addrow();
	this.obbuildfromstring(s,separator,"dbaddlast");
}
public dbaddrowfrom(string sdb, int irow, int icol)	{
	if( <sdb>.rowinrange(irow) && icol>=0)	{
		int id = this.addrow()-1;
		int ile = <sdb>.getcolsno(irow);
		while( icol < ile )	{
			this.add( id, <sdb>.get( irow, icol ) );
			icol++;
		}
	}
}
public string dbchecknext(int irow, int icol)	{
	icol++;
	icol < this.getcolsno(irow) ? this.get(irow,icol) : null;
}
public string dbgets(string s, int icol)	{return this.get( this.findbyrow(s), icol );}
public int dbinsertless(int i1)	{
	int id = this.addrow()-1;
	this.add(id,i1);
	this.dbsort("cmpless");
	while( id>=0 )	{
		if( i1==this.get(id,0) )	return id;
		id--;
	}
	return -1;
}
public bool dbdelvar(int irow, string svar)	{return this.dbdelvarn(irow,svar,1);}
public bool dbdelvarn(int irow, string svar, int n)	{
	int id = this.dbfindinrow(irow,svar);
	if( id>=0 )	{
		this.removen(irow,id,n);
		return true;
	}
	return false;
}
public int dbfindinrow(int irow, string svar)	{
	if( this.rowinrange(irow) )	{
		for( int i=0; i<this.getcolsno(irow); i++)	if( this.get(irow,i)==svar )	return i;
	}
	return -1;
}
public int dbfindbycol(int icol, string svar)	{
	for( int i=0; i<this.getrowsno(); i++)	{if( this.get(i,icol)==svar ) return i;}
	return -1;
}
public bool dbrowcontains(int irow, string svar)	{	return this.dbfindinrow(irow,svar)!=-1;	}
public string dbfirst(int id)		{	return this.get(id,0);	}	
public bool cmpless(int i1, int i2)	{	return i1<i2;	}
public bool cmpabove(int i1, int i2)	{	i1>i2;	}
public bool dbfirstless(int i1, int i2)	{	.get(i1,0) < .get(i2,0);	}
public dbsort(string scomparefun)	{	.insertsort( .getrowsno, "dbfirst",scomparefun, "swap" ); }
/************** int ************************/
public int randdiff(int zakres, int odjakiej)	{
	if( zakres<=1 )	{	return -1;	}
	for( int i1 = odjakiej.rand(zakres); i1==odjakiej; i1=odjakiej.rand(zakres) )	{}
	return i1;
}

/***************************************************************************/
class classgamepause	{
	init()	{
		new button butpause;
		butpause.setrect( 0, 0, 800, 600 );
		butpause.addmethod("onclick", "resume");
		butpause.disable();
	}
	resume()	{
		butpause.disable();
		gameapi.resume();
	}
	pause()	{
		gameapi.pause();
		butpause.enable();
		butpause.resume();
	}
}

class TicksCounter	{
	init()	{
		new int istart;
	}
	start()	{	istart = engine.getticks();	}
	stop()	{	istart = engine.getticks() - istart;	}
	get()		{	return istart;	}
	int stopget()	{	this.stop();	return this.get();	}
	print(string s)	{	engine.print(s+" delay: "+this.stopget()+" ms");	}
	put()	{	.print("");	}
}

/***************************************************************************/
/* klasa do list dialogow */
class classquickdialog	{
	init()	{
		new db dbl;
		new int irow;
		new int icol;
		new string _sdialog = this.getname();
		new bool _bloading = false;
		new classsound clsnd;
		new string _sgame = gameapi.getgamename();
		new string _spref = this.getname();
		new string _sprevdialog;
	}
	public load(string sdbfile)	{
		dbl.loadscript(this.getgraphpath()+sdbfile);
		_bloading=true;
		for( irow=0; irow<dbl.getrowsno();irow++)	{
			icol=0;
			while(this._nextdial())	{}
		}
		_bloading=false;
		irow = 0;
		icol = 0;
	}
	public playlast()	{
		_ = this._play(irow,icol);
	}
	public play(string sdialname)	{
		irow = dbl.findbyrow(sdialname);
		if( irow>= 0 )	{
			this._callstartdial();
		}
		_sprevdialog = this.getdialog();
		_ = this._play(irow,1);
	}
	public string getprevdialog()	{	return _sprevdialog;	}
	public string getdialog()	{	return dbl.get(irow, 0);	}
	bool _play(int ir, int ic)	{
		irow = ir;	icol=ic;
		if(irow<0 || irow>=dbl.getrowsno() )	return false;
		if( icol>=dbl.getcolsno(irow) )	{
			if( !_bloading )	this._callstopdial();
			return false;
		}
		string s = dbl.get(irow,icol);
		if( s=="an:" )	{
			
		} else {
			if( _bloading )	{
				if( !engine.varexist(_spref+s ) )	{
					<_sgame>.newsndfree( _spref+s , s+".wav" );
					s = _spref+s;
					<s>.addmethod("onstart", func { this.<this.getname()+"_START">(); } );
					<s>.addmethod("onfinish", func { this.<this.getname()+"_FINISH">();
						_ = <_sdialog>._nextdial(); } );
					<s>.addmethod("_buildvars", func { (string s) new string _sdialog=s; } );
					<s>._buildvars(this.getname());
				}
			} else {
				clsnd.cbplay(_spref+s);
			}
		}
		return true;
	}
	public bool _nextdial()	{	return this._play(irow,icol+1);	}
	_cqsndfinish()	{
		this.<this.getname()+"_FINISH">();
		_ = <_sdialog>._nextdial();
	}
	_callstopdial()	{	this.<_spref+dbl.get(irow,0)+"_FINISH">();	}	// finish dialog
	_callstartdial()	{	this.<_spref+dbl.get(irow,0)+"_START">();	}	// start dialog
	public stop(bool b)	{	clsnd.cactsndstop(b);	}
	public bool isplaying()	{	return clsnd.cisplaying();	}
	public stopdial(bool b)	{
		this.stop(false);
		if( b )	this._callstopdial();
	}
}

/***************************************************************************/
/* klasa do szybkiego czytania animacji i plikow graficznych */
class classquickanloader	{
	init()	{
		new db dbl;
		new string _sgame = gameapi.getgamename();
	}
	public load(string sfile)	{
		dbl.loadscript(this.getgraphpath()+sfile);
		int j, string s[3], int i[2];
		for( int i=0; i<dbl.getrowsno(); i++ )	{
			j=0;
			s0 = dbl.get(i,j); j++;
			if( s0=="bkg:" )	{
				s0 = dbl.get(i,j); j++;
				<_sgame>.newimg("imgbkg",s0,0);
				this.analizeimgopts("imgbkg",i,j);
			} else if (s0=="img:")	{
				s0 = dbl.get(i,j); j++;
				s1 = dbl.get(i,j); j++;
				<_sgame>.newimg(s0,s1,0);
				this.analizeimgopts(s0,i,j);
			} else if (s0=="an:" )	{
				s0 = dbl.get(i,j); j++;
				s1 = dbl.get(i,j); j++;
				if( s1.contains(".pyz") )	{
					<_sgame>.newanima(s0,s1,0);
				} else {
					<_sgame>.copyanima(s1,s0);
				}
				this.analizeimgopts(s0,i,j);
			} else if(s0=="anaac:" || s0=="anfac:")	{
				s2=s0;
				s0 = dbl.get(i,j); j++;
				s1 = dbl.get(i,j); j++;
				if( s1.contains(".pyz") )	{
					<_sgame>.newanima("_"+s0,s1,0);
					s1 = "_"+s0;
					<s1>.hide();
				}
				<_sgame>.addmethod("_buildgroup","_buildgroup");
				<_sgame>._buildgroup(s0);
				if( s2=="anfac:")	{
					i1 = dbl.get(i,j); j++;
					i0 = <_sgame>.newanframesgr(s1, s0, i1, s0);
				} else {
					i0 = <_sgame>.newanactionsgr(s1, s0, s0);
				}
				this.analizeimgopts(s0,i,j);
			} else if (s0=="path:")	{
				s0 = dbl.get(i,j); j++;
				<_sgame>.setgraphpath(s0);
			} else if (s0=="snd:")	{
				s0 = dbl.get(i,j); j++;
				<_sgame>.newsnd("snd"+s0,s0+".wav");
				<"snd"+s0>.addmethod("onfinish","__std_finish");
			}
		}
	}
	_buildgroup(string sname)	{	new gmimgvec <sname>;	}
	_cqloadstdframe()	{	this.<this.getname()+"_ENDFRAME">();	}
	analizeimgopts(string san, int i, int j)	{
		string s[2], int i[2];
		while( j<dbl.getcolsno(i) )	{
			s0 = dbl.get(i,j); j++;
			match(s0)	{
				"-z"=>	{<san>.setz( dbl.get(i,j) ); j++;}
				"-pos"=>	{	i0 = dbl.get(i,j); j++;
					i1 = dbl.get(i,j); j++;
					<san>.setpos(i0,i1);	}
				"-hide" =>		<san>.hide();
				"-show"=>	<san>.show();
				"-play"=>	{	s0 = dbl.get(i,j); j++;
					<san>.play(s0);}
				"-nplay"=>{	i0 = dbl.get(i,j); j++;
					<san>.play(i0);}
				"-lplay"=>	{	s0 = dbl.get(i,j); j++;
					<san>.anloopsplay(s0);}
				"-frame"=>	{s0 = dbl.get(i,j); j++;
					i0 = dbl.get(i,j); j++;
					<san>.setframe(s0,i0);}
				"-putgr"=>	<san>.anputgr();
				"-mfin"=>		<san>.addmethod("onfinish","__std_finish");
				"-mfr"=>		<san>.addmethod("onendframe","_cqloadstdframe");
				? => ;
			}
		}
	}
}


class StringChecker	{
	init()	{}
	bool isdigit(string s)	{	return s.to_i()!=0||s.getb(0,1)=="0";	}
	int getint(string s)	{	return s.to_i();	}
	real getreal(string s)	{	return s.to_r();	}	
	bool isreal(string s)	{	return this.isdigit(s)&&s.contains(".");	}
	bool isstring(string s) {	return s.getb(0,1)=="\"";	}
	string getstring(string s)	{	return s.strsubb(1);	}
}

class Script	{
	init(string sfile)	{
		new db __dbcode;
		new string __sdb;
		new int __irow;
		new int __icol;
		new string __sreads;
		
		new vector __vec;
		__vec.type("string");
		
		new string __sarg;
		new int __iarg;
		new real __rarg;
		
		new StringChecker __csc;
		new map2 __mp("int");		// odnosniki do funkcji
		
		this.load(sfile);
	}
	public load(string sfile)	{
		if( sfile==null )	return;
		if( sfile.contains(".") )	{		// znaczy sie plik jest
			__sdb = "__dbcode";
			__dbcode.loadbeh(sfile);
		} else {
			__sdb = sfile;		// odwolanie przez inna baze
		}
		__mp.free();
		for( int i=0; i < <__sdb>.getrowsno(); i++)	{
			if( <__sdb>.get(i,0)=="func" )
				__mp.add( <__sdb>.get(i,1), i );
		}
		this.call("init");
	}
	public def get(string svar)	{	return [svar];	}
	bool isvar(string s)	{	return s.contains("$");	}
	string getvar(string s)	{
		s = s.strsubb(1);
		if( !engine.varexist(s) )
			new def <s>;
		return s;
	}
	bool isfunc(string s)	{	return s.contains(".")&&!__csc.isreal(s);	}
	getfunc(string sfun)	{
		__vec.free();
		__vec.add( sfun.strgetto(".") );
		__vec.add( sfun.strgetfrom(".") );
	}
	string _get()	{
		__icol++;
		return <__sdb>.get(__irow,__icol-1);
	}
	bool isnext()	{
		if( __icol < <__sdb>.getcolsno(__irow) )	{
			__sreads=<__sdb>.get(__irow,__icol);
			return true;
		}
		return false;
	}
	perror(bool expr, string sout)	{
		if( expr )
			engine.print("error: " + sout);
	}
	interpcall(string scal)	{
		this.getfunc(scal);
		string sob = __vec.get(0);
		if( sob.getb(0,1)=="*" ) sob=[sob.strsubb(1)];
		string sfun = __vec.get(1);
		if( sfun.getb(0,1)=="*" ) sob=[sfun.strsubb(1)];
		__vec.free();
		__icol++;	// omin '('
		string s = this._get();
		while( s!=")" )	{
			this.getexpr(s);	// odloz na stos argumenty
			s = this._get();
		}
		if( sob=="this" ) sob=null;
		this.callfun(sob,sfun);
	}
	string getvname(string s)	{
		if( this.isvar(s) )	{
			s=this.getvar(s);
		} else if( __csc.isdigit(s) ) {
			__iarg = s;
			s = "__iarg";
		} else if( __csc.isstring(s) ) {
			__sarg = __csc.getstring(s);
			s = "__sarg";
		} else if(__csc.isreal(s))	{
			__rarg = s.to_r();
			s = "__rarg";
		}
		return s;
	}
	bool isscriptfun(string s)	{	return s.contains("->");	}
	string getscriptfun(string s)	{	return s.strsubb(2);	}
	getexpr(string sexpr)	{
		if( __csc.isstring(sexpr) )	{
			<this.getvname(sexpr)>.get();
		} else if( this.isfunc(sexpr) )	{
			this.interpcall(sexpr);
		} else if(this.isscriptfun(sexpr))	{
			int r = __irow;
			int c = __icol;
			this.call( this.getscriptfun(sexpr) );
			__irow = r;
			__icol = c;
		} else {
			<this.getvname(sexpr)>.get();
		}
	}
	bool cmp()	{
		bool bodp=false;
		def d0 = this.getexpr(this._get());
		string s2 = this._get();		// typ porownania
		def d1 = this.getexpr( this._get() );
		match(s2)	{
			"==" =>	{	bodp = d0 == d1;	}
			"!=" =>	{	bodp = d0 != d1;	}
			"<" =>	{	bodp = d0 < d1;	}
			">" =>	{	bodp = d0 > d1;	}
			"<=" =>	{	bodp = d0 <= d1;	}
			">=" =>	{	bodp = d0 >= d1;	}
			? => ;
		}
		s2 = this._get();
		if( s2=="||" )	return bodp || this.cmp();
		else if (s2=="&&")	return bodp && this.cmp();
		else return bodp;
	}
	public call(string sfun)	{
		if( !__mp.contains(sfun) )	return;
		
		__irow = __mp.get( sfun );
		__irow++;
		__icol=0;
		
		bool bgo = true;
		bool bif = false, bool bifexp, bool bwhile=false;
		bool belif=false;
		int iwhilerow;
		string s[3], int i[3];
		while( bgo )	{
			__icol=0;
			s0 = this._get();
			match(s0)	{
				"new"=>{	s0 = this._get();
					s1 = this._get();
					s1 = s1.strsubb(1);	// pozbadz sie $
					if( this.isnext() )	{
						if( __sreads=="[" )	{
							__icol++;
							i0 = this._get();
							for(i1=0; i1<i0; i1++)	{
								new <s0> <s1+i1>;
							}
						} else {		// powinien byc "(" dla konstruktora
							__icol++;
							while( this.isnext() && __sreads!=")" )	this.getexpr( this._get() );
							new <s0> <s1>;
						}
					} else {
						new <s0> <s1>;
					}
					__irow++;
				}"delete" =>	delete <this.getvar(this.get())>;
				(s0=="if" || belif || bwhile)?s0:"" => {
	// 				belif ? this.perror(!bif,"else without if") : this.perror(bif,"if within if");
					__icol++;		// '('
					bifexp = this.cmp();
					if(s0=="if") bif=true;
					belif=false;
					bwhile = false;
					__irow++;
					if( !bifexp )	{
						i1=1;
						while(i1)	{
							s0 = <__sdb>.get(__irow,0);
							if( s0=="else"||s0=="elif"||s0=="fi"||s0=="done") i1=0;
							else	__irow++;
						}
					}
				}"else" => { 	this.perror(!bif,"else without if");
					__irow++;
					if( bifexp )	{
						while(<__sdb>.get(__irow,0)!="fi")
							__irow++;
					}
				} "fi" =>	{	this.perror(!bif,"fi without if");
					bif=false;
					bifexp = false;
					belif=false;
					__irow++;
				} "elif"=>	{
					if( bifexp )	{
						__irow++;
						while(<__sdb>.get(__irow,0)!="fi")
							__irow++;
					} else {
						belif = true;
					}
				} "end" =>	bgo=false;
				"while" =>	{
					iwhilerow = __irow;
					bwhile = true;
				}"done" =>	{
					if( bifexp )	{
						__irow = iwhilerow;
					} else {
						__irow++;
					}
				}"print" =>	{
					s0 = "";
					while( this.isnext() )
						s0 += this.getexpr( this._get() ); 
					engine.print( s0 );
					__irow++;
				}"return" => 	{
					if( this.isnext() )	{
						this.getexpr( __sreads );
					}
					return;
				} ? => { 
					if (s0.contains("$"))	{
						s0 = this.getvar( s0 );
						__icol++;		// olej <<
						<s0> = this.getexpr(this._get());
						while( this.isnext() )	{
							__icol++;		// omin znak dzialania
							def d2 = this.getexpr( this._get() );
							match(__sreads)	{
								"+"	=>	<s0> += d2;
								"-"	=> 	<s0> -= d2;
								"*"	=>	<s0> *= d2;
								"/"	=>	<s0> /= d2;
								"%"	=>	<s0> %= d2;
								?	=>	;
							}
						}
					} else
						this.getexpr( s0 );
					__irow++; 
				}
			}
			if( __irow >= <__sdb>.getrowsno() )	{
				this.perror(1,"function "+sfun+" not finished!");
				bgo=false;
			}
		}
	}
}


module advmouse	{
	init()	{
		new anima anmsc;
	}
	public load(string sname)	{
		anmsc.load(sname);
		anmsc.hide();
	}
	set(string saction)	{
		anmsc.show();
		anmsc.setframe( saction, 0 );
		mouse.setcursor("anmsc");
		anmsc.hide();
	}
	setstd()	{	this.set("normal");	}
	setactive()	{	this.set("active");	}
	setexit()	{	this.set("exit");	}
	setwait()	{	this.set("wait");	}
	get()		{	return anmsc.actionname();	}
}

class classadvobject	{
	init()	{
		this.addasadvobject();
	}
	addasadvobject()	{
		string s = this.getname();
		grmsmove.add(s);
		grmslrel.add(s);
		grmslclick.add(s);
	}
	removefromadvobjs()	{
		string s = this.getname();
		grmsmove.remove(s);
		grmslrel.remove(s);
		grmslclick.remove(s);
	}
	virtual onmousemove(int x, int y)	{}
	virtual onmouselclick(int x, int y)		{}
	virtual onmouselrel(int x, int y)		{}
}

/*
	klasa bazowa, zawiera podstawowe metody i zmienne bohatera przygodowki
	Dominik Dagiel 3 III 2006
*/

class classadvanhero	{
	init()	{}
	public setashero(string sanima, string sfunonfinish)	{
		<sanima>.addmethod("buildhero", "buildhero");
		<sanima>.addmethod("onendframe", "heroendframe1");
		<sanima>.buildhero();
		<sanima>.addmethod("buildheroframe", "buildheroframe");
		<sanima>.addmethod("onfinish", "herofinish");
		<sanima>.addmethod("getdir", "getdir");
		<sanima>.addmethod("thisfinish", "thisfinish");
		<sanima>.addmethod("playspec", "playspec");
		<sanima>.addmethod("playspec2", "playspec2");
		<sanima>.addmethod("herostop", "herostop");
		<sanima>.addmethod("herostart", "herostart");
		<sanima>.addmethod("herostand", "herostand");
		<sanima>.addmethod("setstdfin", "setstdfin");
		<sanima>.addmethod("getpocket", "getpocket");
		<sanima>.addmethod("haspocket", "haspocket");
		<sanima>.addmethod("setstandbase", "setstandbase");
		<sanima>.setstdfin( sfunonfinish );
	}
	buildheroframe(string san)	{	<san>.addmethod("onendframe", "heroendframe");	}
	setstdfin(string s)	{	this.addmethod("onstdfinish", s);	}
	setstandbase(string s)	{	_sstandbase = s;	}
	buildhero()	{
		new string _sbase;	// baza akcji
		new int _istate = 0;	// 0 - neutral, 1 - start, 2 - body, 3 - stop
		new string _sfinfun;	// metoda do wywolania na finish akcji bohatera
		new string _sobfin;	// obiekt na ktorym wywolac metode na finish (jak null to this)
		new bool _bplaystop;	// czy odegrac stop
		new int _iiloscsek;	// ilosc sekwencji
		new int _itypsort;		// 0 - po kolei, 1 - random
		new int idsort;		// kolejny nr kawalka
		new string _sobstart;	// obiekt na finish start
		new string _sfunfinstart;	// metoda na finish start
		new bool bthisfin = false;	// czy finish jest w animacji a nie z zewnatrz
		new string _sstandbase = "stand";
	}
	getpocket()	{	return _spocketpref + this.getname(); }
	bool haspocket()	{	return engine.varexist(_spocketpref+this.getname());	}
	thisfinish(bool bfin)	{	bthisfin=bfin;	}
	string getdir()	{	return this.actionname()->gete(0,2);	}
	playspec(string sbase, int iloscsek, int itypsort, bool bstart, string sobstart, string sfunfinstart,
		bool bstop, string sobfin, string sfinfun, string sdir)	{
		_sbase = sbase;
		_iiloscsek = iloscsek;
		_itypsort = itypsort;
		_bplaystop = bstop;
		_sobfin = sobfin;
		_sfinfun = sfinfun;
		_sobstart = sobstart;
		_sfunfinstart = sfunfinstart;
		if( iloscsek > 0 )	{
			if( itypsort==0 )	{	idsort = 1;	}
			else if (itypsort==1)	{	idsort = idsort.rand( _iiloscsek ) + 1; }
		}
		if( bstart )	{
			_istate = 1;
			this.play( sbase + "start" + sdir );
		} else {
			this.setframe( sbase + (iloscsek>0?"1"+sdir:sdir), 0 );
			this.herostart();
		}
	}
	playspec2(string sact, string sobfin, string sfinfun)	{
		string s = ( sact.length()<2 ) ? "" : sact.strsube(2);
		this.playspec( s, 0, 0, false, null, null, false, sobfin, sfinfun, sact.gete(0,2));
	}
	herostop()	{
		_istate = 3;
		if( _bplaystop )	{
			_bplaystop = false;
			this.thisfinish(true);
			this.play( _sbase + "stop" + this.getdir() );
		} else {
			this.stop(true);
		}
	}
	herostart()	{
		_istate = 2;
		this.play( _sbase + (_iiloscsek>0 ? idsort : "") + this.getdir() );
	}
	herofinish()	{
		if( _istate==2 && bthisfin )	_istate=3;
		if (_istate==0 )	{		// standardowy finish
			this.herostand();	// 28.V.2006
			this.onstdfinish();
// 			this.< this.getname() + "_FINISH">();
			string sanimo = this.getname();
			string sevent = <sanimo>.actionname();
			this.<sanimo+"_FINISH">();
			this.<sanimo+"_ACTION_"+sevent+"_FINISH">();
		} else if( _istate==1)	{
			this.herostart();
			this.callfun(_sobstart,_sfunfinstart);
		} else if( _istate==2 )	{
			string s;
			if( _iiloscsek > 0 )	{
				if( _itypsort==0)	{	idsort = (idsort%_iiloscsek)+1;	}
				else if (_itypsort==1)	{	idsort = idsort.rand( _iiloscsek ) + 1; }
				s = _sbase + idsort + this.getdir();
			} else s = this.actionname();
			this.play( s );
		} else if ( _istate==3 )	{		// koniec stop
			_istate = 0;
			this.herostand();	// 28.V.2006
			this.thisfinish(true);
			this.callfun(_sobfin,_sfinfun);
		}
	}
	herostand()	{
		string s = _sstndpref + this.getname();
		if( engine.varexist(s) )	{
			this.play( _sstandbase + this.actionname()->gete(0,2) );
			<s>.play();
		}
	}
	heroendframe1()	{	this.< this.getname() + "_ENDFRAME" >();	}
	heroendframe()	{
		this.setz( this.getposy() );
		if( this.haspocket() )	{
			<this.getpocket()>.pocketpos( this.getposx(), this.getposy() - this.geth()/2);
		}
		this.< this.getname() + "_ENDFRAME" >();
	}
}

/******************************************************/

class classadvhero 	{
	init()	{
		new string _sanim;		// podlinkowana animacja
		new bool _bisvecile = false;	// czy operacja sklada sie z kawalkow
		
		new string _sbase = null;		// bazowa nazwa akcji
		new string _sbase2 = null;
		new int izakres = 0;		// length of string _sbase
		
		new string _sbs2;
		new string _sbutoper;
		new string _smetpart;
		
		new string _simgbut;	// button z ktorego czyta dane
		new string _sptfname = this.getname();
	}
	string getptfname()	{	return _sptfname;	}
	public link(string sanim)	{	_sanim = sanim;	}
	public link2(string sanima, string sbase)	{
		this.link(sanima);
		this.checkamounts( sbase );
	}
	public anstand()	{	<_sanim>.play("stand"+this.getdir());	}
	public ansay()		{	<_sanim>.play("talk"+this.getdir());	}
	public string getdir()	{	<_sanim>.actionname()->gete(0, 2);	}
	public int nofpieces()	{	return this.nofpiecesdir( this.getdir() ); }
	public int nofpiecesdir(string sdir)	{return _bisvecile ? vecile.get( vecdirs.find(sdir) ) : 0;	}
	public setbase2(string sbase, string sbase2)	{
		this.setbase(sbase);
		_sbase2 = sbase2;
	}
	public setbase(string sbase)	{
		_sbase = sbase;
		izakres = sbase.length();
	}
	public getpropdir(string sdir)	{	return sdir=="auto" ? this.getdir() : sdir;	}
	/*****************************/
	_buildamounts()	{
		if( !_bisvecile )	{
			_bisvecile = true;
			new vector vecdirs;
			vecdirs.type("string");
			vecdirs.beginadd("begin", "uu", "ru", "rr", "rd", "dd", "ld", "ll", "lu" );
			new vector vecile;
		}
	}
	_clearvecile()	{
		vecile.free();
		vecile.resize( 8, 0 );
	}
	public checkamounts(string sbase)	{
		this.setbase(sbase);
		this._buildamounts();
		this._clearvecile();
		if( _sanim == null )	return;
		int ile = <_sanim>.nofactions();
		string s1, int i1;
		
		for(int  i=0; i < ile; i++)	{
			s1 = <_sanim>.nameofaction(i);
			if( s1.getb(0,izakres) == sbase )	{
				i1 = s1.getb( izakres, 10 );
				if( i1>0 )	{	// jest kolejna animacja gadania
					vecile.vecinc( vecdirs.find( s1.gete(0,2) ) );
				}
			}
		}
	}
	/********************************/
	virtual calllastfun()	{	this.< this.getcallfin() >();	}
	_calllastfunfin()	{
		this.calllastfunfin();
		this.advmsunlock();
	}
	virtual calllastfunfin()	{	this.< this.getcallfin() + "_FINISH" >();	}
	virtual string getcallfin()	{	return _sanim+_smetpart+_sbutoper;	}
	_cplay(string sbase, string sfun, string sdir)	{
		this.advmslock();		// blokuj mysz
		<_sanim>.thisfinish(true);
		if( sbase==null )	{
			if( sfun!=null )	this.<sfun>();
		} else {
			<_sanim>.playspec( sbase, 0, 0, false, null, null, false, 
				this.getname(), sfun, this.getpropdir(sdir) );
		}
	}
	_cplay1(string sbase, string sdir)	{	this._cplay(sbase,"_cplay1_2", sdir);	}
	_cplay1_2()	{
		this.calllastfun();
		this._callbehs();
	}
	_callbehs()	{
		this.advmsunlock();
		this.callbehs();
	}
	virtual callbehs()	{
		string s = this.getcallfin();
		this.behexist("beh_"+s) ? this.playbehobfin( "beh_" + s, this.getname(), "_calllastfunfin" ) : this._calllastfunfin();
	}
	_cplay2_2()	{
		this.calllastfun();
		this._cplay(_sbs2, "_callbehs", this.getdir() );
	}
	_cplay2(string sbase1, string sbase2, string sdir)	{
		_sbs2 = sbase2;
		this._cplay(sbase1, "_cplay2_2", sdir);
	}
	public heroplay1(string simg)	{
		_simgbut=simg;
		_sbutoper = <simg>.getbutname();
		this._cplay1( <simg>.getbase1(), this.getpropdir( <simg>.getbutdir() ) );
	}
	public heroplay2(string simg)	{
		_simgbut=simg;
		_sbutoper = <simg>.getbutname();
		this._cplay2( <simg>.getbase1(), <simg>.getbase2(), this.getpropdir( <simg>.getbutdir() ) );
	}
	_setbase2(string styp)	{	this.setbase2( modadv.get(styp,1), modadv.get(styp,2) );	}
	_setbase(string styp)	{	this.setbase( modadv.get( styp, 1 ) );	}
	public heroplay3(string simg, string sb)	{
		<simg>.setbutbase1(modadv.get(sb,1));
		<simg>.setbutbase2(modadv.get(sb,2));
		this.heroplay2(simg);
	}
	/********************************/
}

/******************************************************/

class classherotaker : classadvhero	{
	init() {
		classadvhero::init();
		_smetpart = "_PICKUP_";
	}
	public herotake(string simg)	{	this.heroplay2(simg);	}
	virtual calllastfun()	{
		if( <_sanim>.haspocket() )	{
			<_simgbut>.hide();		// zabranie przedmiotu
			< <_sanim>.getpocket() >.additem( _sbutoper );
		}
		classadvhero::calllastfun();
	}
}

/******************************************************/

class classherolooker : classadvhero	{
	init()	{
		classadvhero::init();
		_smetpart = "_OPERATE_";
	}
	public herolook(string simg)	{	this.heroplay2(simg);	}
	public herooperate(string simg)	{	this.heroplay2(simg);	}
	public heroopendoor(string simg)	{	this.heroplay3(simg,"open:");	}
	public heroclosedoor(string simg)	{	this.heroplay3(simg,"close:");	}
}

/******************************************************/

class classherouser : classadvhero	{
	init()	{
		classadvhero::init();
		new string _stool;
	}
	public herouse(string stool, string simg)	{
		//_stool = this.getusetool();
		_stool = stool;
		_smetpart = "_USE_"+_stool+"_ON_";
		< <_sanim>.getpocket() >.itemhide();
		this.heroplay2(simg);
	}
	virtual calllastfun()	{
		this.< _sanim + "_USE_" + _stool>();
		this.< _sanim + "_USE_ON_" + _sbutoper>();
		this.< this.getcallfin() >();
	}
	virtual calllastfunfin()	{
		this.< _sanim + "_USE_" + _stool + "_FINISH">();
		this.< _sanim + "_USE_ON_" + _sbutoper + "_FINISH">();
		this.< this.getcallfin() + "_FINISH" >();
	}
	virtual callbehs()	{
		string s = this.getname();
		if( this.behexist( "beh_" + this.getcallfin() ) )	{
			this.playbehobfin( "beh_" + this.getcallfin(), s, "_calllastfunfin" );
		} else  if( this.behexist( "beh_" + _sanim + "_USE_ON_" + _sbutoper ) )	{
			this.playbehobfin( "beh_" + _sanim + "_USE_ON_" + _sbutoper, s, "_calllastfunfin" );
		} else  if( this.behexist( "beh_" + _sanim + "_USE_" + _stool ) )	{
			this.playbehobfin( "beh_" + _sanim + "_USE_" + _stool, s, "_calllastfunfin" );
		} else if ( this.behexist( "beh_"+_sanim+"_USE" ) )	{
			this.playbehobfin( "beh_" + _sanim + "_USE", s,"_calllastfunfin" );
		} else {
			this._calllastfunfin();
		}
	}
}

/******************************************************/
/**	metody rozpoczynajace sie na "c" sa metodami klasy, natomiast na "ob" dotycza obiektu "pathf" **/

class classpathf : classadvhero	{
	init()	{ 
		classadvhero::init();
		new path ptf;
		new string swalkto = null;
		new string _sfunnopath = null;
		new string _sfunvisit = null;
		new int destx;	// dla startgo
		new int desty;	// jezeli jest startgo
		new bool bzmien = false;
		new bool bzatrzym = false;
		new string _sitem=null;
		new int _istep;
		ptf.addmethod("onfinish", "_cptffin");
		ptf.addmethod("onvisit","_cptvisit");
		this.addsigs("_cptfstdreach", "_cptfstdarrive");
		this._setbase( "go:" );
	}
	_buildan(string san)	{
		ptf.linkanima(san);
		this.link(san);
	}
	public build(string san, string sfile, int x, int y, int istep, int ityp)	{
		_istep = istep;
		ptf.build(sfile, x, y, istep, ityp);
		this._buildan(san);
	}
	public buildfrom(string san, string spathf, int istep)	{
		_istep = istep;
		ptf.copy(spathf, istep );
		this._buildan(san);
	}
	public addsigs(string sreach, string sarrive)	{
		if(sreach!=null)	{
			ptf.addmethod("onreach", sreach);
		}
		if(sarrive!=null)	{
			ptf.addmethod("onarrive", sarrive);
		}
	}
	public sigonnopath(string snopath)	{	_sfunnopath = snopath;	}
	public sigonvisit(string svisit)	{	_sfunvisit = svisit;	}
	_cptfstdreach(string s)	{}
	_cptfstdarrive()	{}
	/************************** funkcje dla pathf ***************************************/
	public move(int x, int y)	{	ptf.move( x, y );	}
	public setpos(int x, int y)	{	ptf.setpos(x,y);	}
	public show()	{	ptf.show();	}
	public hide()	{	ptf.hide();	}
	public enable(int id)	{	ptf.enable(id);	}
	public disable(int id)	{	ptf.disable(id);	}
	public setanstep(int step)	{	_istep=istep; ptf.setanstep(step);	}
	public int getanstep()	{	return _istep;	}
	public int getposx()	{	return ptf.getposx(); }
	public int getposy()	{	return ptf.getposy(); }
	public int getpx()	{	return ptf.getpx(); }
	public int getpy()	{	return ptf.getpy(); }
	public int getidan()	{	return ptf.getidan(); }
	public int getidan2()	{	return ptf.getidan2(); }
	public int getidgo()	{	return ptf.getidgo(); }
	public int getidanpath()	{	return ptf.getidanpath(); }
	public int getidan2path()	{	return ptf.getidan2path(); }
	public int getidgopath()	{	return ptf.getidgopath(); }
	public excludev(int id)	{	ptf.excludev(id);	}
	public linkfilter()	{	ptf.linkfilter();	}
	public unlinkfilter()	{	ptf.unlinkfilter();	}
	public unlinkanima()	{	ptf.unlinkanima();	}
	public setscalepower(real rs)	{	ptf.setscalepower(rs);	}
	public setzsize(real rs)	{	ptf.setzsize(rs);	}
	public bool iswayto(int x, int y)	{	return ptf.iswayto(x,y);	}
	public scalean()	{	ptf.scalean();	}
	public int getfromver(int ifrom, int ile, int ito)	{	return ptf.getfromver(ifrom,ile,ito);	}
	public int getgover(int ile)	{	return ptf.getgover(ile);	}
	public int getanver(int ile)	{	return ptf.getanver(ile);	}
	public int getxver(int id)	{	return ptf.getxver(id);	}
	public int getyver(int id)	{	return ptf.getyver(id);	}
	public int getbyname(int idpath)	{	return ptf.getbyname(idpath);	}
	public walkbase(string sb)	{	ptf.setbase(sb);	}
	/*****************************************************************/
	public walkto2(string simg, int x, int y)	{
		swalkto = simg;
		if( this.cangoto(x,y) )	{
			x = ptf.goto( x, y );
		} else if ( _sfunnopath!=null )	{
			this.<_sfunnopath>();
		}
	}
	public int walkto(string simg, int x, int y)	{
		swalkto = simg;
		if( this.iswalking() )	{
			if( ptf.iswayto(x,y) )	{
				bzmien = true;
				destx = x;
				desty = y;
				return 0;
			} else {
				bzatrzym = true;
				return -1;
			}
		} else {
			return ptf.goto( x, y );
		}
	}
	public int goto(int x, int y)	{
		return this.walkto( null, x, y );
	}
	public int gotorel(int x, int y)	{
		return this.goto( <_sanim>.getpx() + x, <_sanim>.getey() + y );
	}
	public int iswalking()	{	return ptf.iswalking();	}
	public stand()	{	ptf.stand(); 	}
	public stop(bool bstop)	{	ptf.stop(bstop);	}
	public int getidpath(int x, int y)	{	return ptf.getidpath( x, y);	}
	public bool cangoto(int x, int y)	{
		int id = ptf.getidpath(x,y);
		return id == -1 ? false : ptf.isenabled(id);
	}
	/************** wyjscia do zaawansowanego chodzenia ***********************/
	_cptfreachbut()	{
		<this.getptfname()+"look">.herolook(swalkto);
	}
	_cptfreachdoors()	{
		<this.getptfname()+"look">.herooperate(swalkto);
	}
	_cptfreachitem()	{
		<this.getptfname()+"take">.herotake(swalkto);
	}
	_cptfherofin()	{
		this.herostand();
		if( swalkto!=null )	{
			this.<_sanim + "_REACH_" + <swalkto>.getbutname() >();	
			if( this.ismainhero( _sanim ) )	{
				string s = null;
				if( <_sanim>.haspocket() )
					s = < <_sanim>.getpocket()>.getitem();
				if( s!=null )	{
					<this.getptfname()+"use">.herouse(s,swalkto);
				} else {
					this.< "_cptfreach" + <swalkto>.gettyp() >();
				}
			}
			swalkto=null;
		} else {
			this.<_sanim+"_ARRIVE">();
			this._cptheroendpath();
		}
	}
	_cptheroendpath()	{
		this.callfun(_sfinob, _sfinfun );
		if( _bylfin )	_bylfin=false;
		else {
			_sfinfun = null;
			_sfinob = null;
		}
	}
	_cptfnopath()	{	this.< _sanim+"_NOPATH">();	}
	_cptfvisit()	{	this.<_sanim+"_VISIT">();	}
	public prepareforhero()	{
		ptf.addmethod("onfinish", "_cptfherofin");
		new string _sfinob;
		new string _sfinfun;
		new bool _bylfin;
		this.sigonnopath("_cptfnopath");
		this.sigonvisit("_cptfvisit");
	}
	public herowalkto2(int x, int y, string sob, string sfinfun)	{
		this.herowalkto(null,x,y,sob,sfinfun);
	}
	public herowalkto(string simg, int x, int y, string sob, string sfinfun)	{
		<_sstndpref + _sanim>.stop();		// wylaczenie standera
		_sfinob = sob;
		_sfinfun = sfinfun;
		if( sfinfun!=null )	_bylfin = true;
		if( this.walkto(simg, x,y)==-1 )	{
			//this.callfun(sob,sfinfun);
			//engine.print(this.getname() + " nie ma przejscia do " + simg + " call:"+sob+"."+sfinfun);
		}
	}
	public advgoto(int x, int y)	{
		this.herowalkto2(x,y,null,null);
	}
	public advwalkto(string simg, int x, int y)	{
		this.herowalkto(simg,x,y,null,null);
	}
	public advvisit(string simg)	{
		if( <simg>.reachable() )
			this.advwalkto( simg, <simg>.getgox(), <simg>.getgoy() );
	}
	public herostand()	{
		this.stand();
		<_sanim>.herostand();
	}
	/*****************************************************************/
	_cptvisit()	{
		if( bzmien )	{
			bzmien = false;
			int id = this.goto(destx, desty);
			if( id==-1 )	{
				this.<_sfunnopath>();
			}
		} else if (bzatrzym)	{
			bzatrzym=false;
			this.stop(true);
		} else {
			this.<_sfunvisit>();
		}
	}
	_cptffin()	{
		if( swalkto!=null )	{
			ptf.onreach(swalkto);		// dotarcie do zadanego obiektu
			swalkto=null;
		} else {
			ptf.onarrive();		// dotarcie do punktu
		}
	}
}

class classwalkerqueue	{
	init()	{
		new timer timwq;
		timwq.settick(1);
		timwq.setcycle(1);
		timwq.addmethod("onfinish","_timwqfin");
		new vector vecpt;
		vecpt.type("string");
		new int iverlen = 1;
	}
	_timwqfin()	{
		this.checkqueue();
		this.play();
	}
	public start()	{
		//timwq.play();
	}
	public stop()	{	timwq.stop(false);	}
	public add(string spt)	{	vecpt.add(spt);	}
	public goto(int x, int y)	{
		this.walkto(null,x,y);
	}
	public visit(string simg)	{
		if( <simg>.reachable() )
			this.walkto(simg, <simg>.getgox(), <simg>.getgoy() );
	}
	public setverlen(int ilen)	{	iverlen = ilen;	}
	public walkto(string simg, int x, int y)	{
		int ile = vecpt.size();
		if( ile<=0 )	{	return;	}
		string sfirst = vecpt.get(0);
		<sfirst>.advwalkto( simg, x, y );
		int i[2], string s;
		for( int i=1; i<ile; i++ )	{
			s = vecpt.get(i);
			<s>.advwalkto( simg, x, y );
			i0 = <s>.getgover(i*iverlen);
			if( i0 >= 0 )	{
				<s>.advwalkto( null, <s>.getxver(i0), <s>.getyver(i0) );
			} else {
				<s>.stop(false);
				<s>.herostand();
			}
		}
		/*int j, string s;
		for( int i=0; i<ile; i++)	{
			s = vecpt.get(i);
			<s>.advwalkto(simg,x,y);
			for( j=i+1; j<ile; j++)	{
				<vecpt.get(j)>.excludev( <s>.getidgo() );
			}
		}*/
	}
	public checkqueue()	{
		int ile = vecpt.size();
		if( ile<=1 )	{	return;	}
		int j, string s[2], int ian, int ian2;
		for( int i=0; i<ile; i++)	{
			s0 = vecpt.get(i);
			if( <s0>.iswalking() )	{
				ian = <s0>.getidan();
				ian2 = <s0>.getidan2();
				for( j=i+1; j<ile; j++)	{
					s1 = vecpt.get(j);
					if( <s1>.iswalking() )	{
						<s1>.excludev( ian );
						<s1>.excludev( ian2 );
					}
				}
			}
		}
	}
}



class classstndgroup	{
	init()	{
		new gmobjvec grstnd;
	}
	public pause()	{
		grstnd.eval("lock");
		this.stop();
	}
	public resume()	{
		grstnd.eval("unlock");
		this.play();
	}
	public add(string sstander)	{	grstnd.add(sstander);	}
	public remove(string sst)	{	grstnd.remove(sst);	}
	public stop()	{	grstnd.eval("stop");	}
	public play()	{	grstnd.eval("play");	}
	public reset()	{	grstnd.eval("reset");}
}

class classadvstander : classlocker 	{
	init()	{
		classlocker::init();
		new timer timstand;
		timstand.settick(1);
		timstand.delay(20000);
		timstand.addmethod("onfinish", "_timstandfin");
		
		new string sanim = this.getname();
		sanim = sanim.strsubbs( _sstndpref );
		
		new string _sbeh = "beh_" + sanim + "_IDLE";
		
		modstnd.add( this.getname() );
	}
	_timstandfin()	{
		string s = gameapi.getgamename();
		if( <s>.behexist( _sbeh )  && !this.getlock() )	<s>.playbeh( _sbeh );
	}
	public play()	{	if( !this.getlock() && !timstand.isplaying() )	timstand.play();	}
	public stop()	{	timstand.stop(false);	}
	public setdelay(int idelay)	{	timstand.setdelay(idelay);	}
	public reset()	{	this.stop();	this.play();	}
}


/* classadv : klasa do przygodowek	*/

class classadv : classgame {
	init()	{
		classgame::init();
	}
	/**************************************************************************/
	newclpathf(string spt, string san, string sfile, int x, int y, real rstep, int ityp)	{
		new classpathf <spt>;
		<spt>.build(san, this.getgraphpath() + sfile, x, y, rstep, ityp);
	}
	newclpathfcopy(string spt, string san, string sptf, real rstep)	{
		new classpathf <spt>;
		<spt>.buildfrom( san, sptf, rstep );
	}
	newpathf(string spathf, string sfile, int x, int y)	{
		new path <spathf>;
		<spathf>.build( this.getgraphpath() +sfile, x, y, 2.0, 1 );
	}
	/**************************************************************************/
	newclbut(string sbut, string sfile, int z, string smouse)	{
		new classbutton <sbut>;
		<sbut>.build( this.getgraphpath() + sfile, z, smouse );
	}
	newclmask(string sm, string sfile, string smouse)	{
		new classmask <sm>;
		<sm>.buildmask( this.getgraphpath() + sfile, smouse );
	}
	newclmaskfunc(string sm, string sfile, string smouse, string sfunc)	{
		new classmask <sm>;
		<sm>.buildmaskfunc( this.getgraphpath() + sfile, smouse, sfunc );
	}
}

/*
	klasa obslugujaca "rozmawianie" postaci
	Dominik Dagiel	3 III 2006
*/

class classtalker : classadvhero	{
	init()	{
		classadvhero::init();
		this._setbase( "talk:" );
		
		new snd sndtalk;
		sndtalk.setstartstopflag(false, true);
		sndtalk.addmethod("onfinish", "_ctalkfin");
		
		new timer timtalk;
		timtalk.settick(1);
		new real rdelay = 1.0;
		timtalk.addmethod("onfinish","_ctalkfin");
		
		new gmimgvec txttalk;
		new int _iletxt=10;
		string s;
		for( int i=0; i<_iletxt; i++ )	{
			s = "txttalk"+i;
			new text <s>;
			txttalk.add(s);
		}
		new font fonttalk;
		txttalk.hide();
		new vector vecpom;
		vecpom.type("string");
		new int iTxtLim = 30;
		new int irtxt;
		new int igtxt;
		new int ibtxt;
		new string stextdb;		// baza z tekstem do mowienia
		new string _swav;
		
		this.buildfullname();
		
		new string stalktype;
		this.settalktype("snd");	// typ: (snd, txt, film) -> kombinacje
	}
	public set(string san)	{
		this.link(san);
	}
	public settextdb(string s)	{	stextdb=s;	}
	public setfont(string sfile, int size)	{
		fonttalk.load(sfile,size);
		txttalk.eval1("setfont","fonttalk");
	}
	public setsnd(string sfile)	{
		if( !sfile.contains(".wav") )	{
			_swav = sfile;
			sfile+=".wav";
		} else {
			_swav = sfile.strsubes(".wav");
		}
		sndtalk.load( this.getsndpath() + sfile );
	}
	public herosay1(string sfinfun)	{
		this.herosay(1, true, true, null, sfinfun );
	}
	public herosay(int itypsort, bool bstart, bool bstop, string sobfin, string sfinfun)	{
		this.herosaydir( itypsort, bstart, bstop, sobfin, sfinfun, this.getdir() );
	}
	public herosaydir(int itypsort, bool bstart, bool bstop, string sobfin, string sfinfun, string sdir)	{
		<_sanim>.thisfinish(false);
		if( !bstart )	{
			<_sanim>.playspec(_sbase, this.nofpiecesdir(sdir), itypsort, bstart, null, null,
					bstop, sobfin, sfinfun, sdir);
			this.<stalktype>();
		} else {
			<_sanim>.playspec(_sbase, this.nofpiecesdir(sdir), itypsort, bstart, this.getfullname(), "_ctalkstart",
					bstop, sobfin, sfinfun, sdir);
		}
	}
	public thisfinish(bool bthisfin)	{	<_sanim>.thisfinish(bthisfin);	}
	public stop(bool b)	{
		if( stalktype.contains("snd") )	{
			sndtalk.stop(b);
			timtalk.stop(false);
		} else {
			timtalk.stop(b);
		}
	}
	public settalktype(string stype)	{
		stalktype = "_cplay";
		if( stype.contains("snd") )	stalktype += "snd";
		if( stype.contains("txt") )		stalktype += "txt";
		if( stype.contains("film") )	stalktype += "film";
	}
	_csay()	{
		if( stextdb!=null )	{
			int id = <stextdb>.findbyrow(_swav);
			if( id<0 )	{	return;	}
			
			vecpom.vecbuildfromstring( <stextdb>.get(id,2), " " );
			string s="", int itlk=0, int x, int y;
			if( stalktype.contains("txt") )	{
				x = <_sanim>.getcx();
				y = <_sanim>.getpy();
			} else {
				x = 400;
				y = 590;
			}
			int x1=0, int x2=800, int y1=0, int y2=600;
			string s1;
			for( int i=0; i<vecpom.size(); i++)	{
				s+=vecpom.get(i)+" ";
				if( s.length()>iTxtLim )	{
					s1 = "txttalk"+itlk;
					<s1>._cprinttxt(s,x,y,itlk);
					if( <s1>.getpx() < x1 )	{	x1=<s1>.getpx();	}
					if( <s1>.getex() > x2 )	{	x2=<s1>.getex();	}
					if( <s1>.getpy() < y1 )	{	y1=<s1>.getpy();	}
					if( <s1>.getey() > y2 )	{	y2=<s1>.getey();	}
					s="";
					itlk++;
				}
			}
			if( s.length()>0 )	{
				s1 = "txttalk"+itlk;
				<s1>._cprinttxt(s,x,y,itlk);
				if( <s1>.getpx() < x1 )	{	x1=<s1>.getpx();	}
				if( <s1>.getex() > x2 )	{	x2=<s1>.getex();	}
				if( <s1>.getpy() < y1 )	{	y1=<s1>.getpy();	}
				if( <s1>.getey() > y2 )	{	y2=<s1>.getey();	}
				itlk++;
			}
			x2-=800;
			y2-=600;
			if( x1>0 )	{	x1=0;	}
			if( y1>0 )	{	x1=0;	}
			txttalk.move(0-x1+x2, -itlk*txttalk0.geth()-y1+y2 );
			if( txttalk0.getpy()<0 )	{
				txttalk.move(0,-txttalk0.getpy());
			}
			timtalk.delay( rdelay*500*vecpom.size() );
		}
	}
	_cprinttxt(string s, int x, int y,int id)	{
		this.set(s);
		this.createtxt(irtxt,igtxt,ibtxt);
		this.setpos( x-this.getw()/2, y+id*this.geth() );
		this.setz(2000);
		this.show();
	}
	public _cplaysnd()	{
		sndtalk.play();
	}
	public _cplaysndtxt()	{
		sndtalk.play();
		this._csay();
	}
	public _cplaysndtxtfilm()	{
		sndtalk.play();
		this._csay();
	}
	public _cplaysndfilm()	{
		this._csay();
	}
	public _cplaytxt()	{
		this._csay();
		timtalk.play();
	}
	public _cplaytxtfilm()	{
		this._csay();
		timtalk.play();
	}
	public _cplayfilm()	{
		this._csay();
		timtalk.play();
	}
	/******  do tekstu pisanego ****************************/
	public setdelay(real r)	{	rdelay=r;	}
	public settxtcolor(int r, int g, int b)	{
		irtxt=r;	igtxt=g;	ibtxt=b;
	}
	/**********************************/
	_ctalkstart()	{
		this.<stalktype>();
	}
	_ctalkfin()	{
		txttalk.hide();
		<_sanim>.herostop();
	}
	/**********************************/
}

class classtxttalker : classadvhero	{
	init()	{
		classadvhero::init();
		this._setbase( "talk:" );
		
		new int iR;
		new int iG;
		new int iB;
		new int ibR;
		new int ibG;
		new int ibB;
		new int ibA;
		new int ibrr;
		new int ibrg;
		new int ibrb;
		new int ibra;
		new int ibw;
		new db dbtxt;
		new int iSize;
		new gmimgvec grtxt;
		new gmimgvec grtxt2;
		string s;
		for( int i=0; i<25; i++ )	{
			s = "txt"+i;
			new text <s>;
			grtxt.add(s);
			<s>.hide();
		}
		new text imgtxt;
		imgtxt.hide();
		
		new bool bplaying = false;
		
		new string slang;
		this.setlang("pol");
	}
	public setlang(string s)	{	slang = s;	}
	public bool isplaying()	{	return bplaying;	}
	public setfont(string sfont)	{
		grtxt.eval1("setfont",sfont);
		iSize = <sfont>.getsize();
	}
	public setfontcolor(int ir, int ig, int ib)	{
		iR=ir; iG=ig; iB=ib;
	}
	public setfontbg(int ibr, int ibg, int ibb, int iba)	{
		ibR=ibr; ibG=ibg; ibB=ibb; ibA=iba;
	}
	public setbgframe(int iw, int ir2, int ig2, int ib2)	{
		ibrr = ir2; ibrg = ig2; ibrb = ib2; ibra=255; ibw=iw;
	}
	public set(string san, int iz)	{
		this.link(san);
		grtxt.setz(iz);
		imgtxt.setz(iz-1);
	}
	public herosay(string sfile, int x, int y)	{
		this.herosaydir(sfile,x,y,this.getdir());
	}
	public herosaydir(string sfile, int x, int y, string sdir)	{
		if( sdir=="auto")	{	sdir=this.getdir();	}
		bplaying = true;
		dbtxt.load( this.getgraphpath() + sfile + "." + slang);
		string s;
		grtxt2.free();
		int iw=0;
		int ile = dbtxt.getrowsno();
		for( int i=0; i<ile; i++)	{
			s = "txt"+i;
			<s>.set( dbtxt.get(i,0) );
			<s>.createtxt(iR, iG, iB);
			<s>.setpos(x,y);
			y+=iSize;
			<s>.show();
			if( <s>.getw()>iw)	{	iw=<s>.getw();	}
			grtxt2.add(s);
		}
		imgtxt.setbkg(txt0.getpx()-iSize/2, txt0.getpy()-iSize/2, iw+iSize, iSize*(ile+1), ibR, ibG, ibB, ibA );
		imgtxt.setborders(ibw,ibrr,ibrg,ibrb,ibra);
		imgtxt.show();
		if( _sanim!=null )	{
			<_sanim>.thisfinish(false);
			<_sanim>.playspec(_sbase, 0, 0, false, null, null,
					false, null, null, sdir);
		}
	}
	public stop()	{
// 		if( bplaying==false )	{	return;	}
		bplaying = false;
		grtxt2.hide();
		imgtxt.hide();
		if( _sanim!=null )	{
			<_sanim>.thisfinish(true);
			<_sanim>.play("stand" + this.getdir());
		}
	}
}



/*
	klasy obslugujace plany tla oraz kamere 
*/

class classbgplan : gmobjvec {
	init() {
		gmobjvec::init;
		new real rpx;
		new real rpy;
		new real scalex;
		new real scaley;
	}
	public setscale(real rsx, real rsy)	{	|scalex, scaley| = rsx, rsy;	}
	public move(real x, real y)	{
		rpx+=x;	rpy+=y;
		int ix = rpx, int iy = rpy;
		rpx-=ix;	rpy-=iy;
		if( ix || iy )	gmobjvec::move(ix,iy);
	}
	public movebgr(real x, real y)	{	.move( scalex*x, scaley*y );	}
}

class classgrplans : gmobjvec	{
	init()	{
		gmobjvec::init();
		new real _rxp;
		new real _ryp;
	}
	public move(real x, real y)	{
		_rxp += x;	_ryp += y;
		this.eval2("movebgr",x,y);
	}
	public real getposx()	{	return _rxp;	}
	public real getposy()	{	return _ryp;	}
	public shift(int x, int y)	{
		_rxp+=x;	_ryp+=y;
		this.eval2("move",x,y);
	}
}

class classadvcamera	{
	init()	{
		new classgrplans grbgrs;
		new string sancamera=null;
		new string smsmvfun = null;
		|new real _rxmod, new real _rymod| = 0.05, 0.05;
		|new real rleft, new real rtop, new real rright, new real rbottom| = 0.0, 0.0, 799.0, 599.0;
		|new int icamx, new int icamy| = 400, 300;
		|new real rborx, new real rbory| = 799, 599;
		new timer timcamera;
		timcamera.settick(1);
		timcamera.setcycle(1);
		timcamera.addmethod("onfinish","_camerafin");
	}
	_camerafin()	{
		this.checkcamera();
		this.play();
	}
	public setcenter(int x, int y)	{	| icamx, icamy | = x, y;	}
	public setborders(int x, int y){	|rright, rbottom| = x-1, y-1;	}
	public real getposx()	{	return grbgrs.getposx();	}
	public real getposy()	{	return grbgrs.getposy();	}
	public setmetonmsmove(string s)	{	smsmvfun=s;	}
	public start()	{	timcamera.play();	}
	public stop()	{	timcamera.stop(false);	}
	public setactor(string sactor)	{	sancamera=sactor;	}
	public bool isactor(string sob)	{	return sob==sancamera;	}
	public string getactor()	{	return sancamera;	}
	public scalemodifiers(real rx, real ry)	{	| _rxmod, _rymod | = rx, ry;	}
	public newbgr(string sbgr, real rscalex, real rscaley)	{
		new classbgplan <sbgr>;
		this.addbgr(sbgr,rscalex,rscaley);
	}
	public addbgr(string sbgr, real rscalex, real rscaley)	{
		<sbgr>.setscale(rscalex,rscaley);
		grbgrs.add(sbgr);
	}
	public addtobgr(string sbgr, string sob)	{	<sbgr>.add(sob);	}
	public setscene()	{	this._setscene(1.0,1.0);	}
	_setscene(real _rx, real _ry)	{
		real x = icamx - <sancamera>.getposx();
		x*=_rx;
		real y = icamy - <sancamera>.getposy();
		y*=_ry;
		real ix = this.getposx()+x;
		real iy = this.getposy()+y;
		if( ix >= rleft )	x = -this.getposx();
		else if (ix+rright<rborx)	x = rborx - (this.getposx()+rright);
		
		if( iy >= rtop )	y = -this.getposy();
		else if (iy+rbottom<rbory)	y = rbory - (this.getposy()+rbottom);
		
		if( x||y )	{
			grbgrs.move(x,y);
			if( smsmvfun!=null )	this.<smsmvfun>();
		}
	}
	public checkcamera()	{
		if( sancamera==null )	return;
		this._setscene( _rxmod, _rymod );
	}
	public moveplans(int x, int y)	{
		rleft+=x;	rright+=x;
		rtop+=y;	rbottom+=y;
		rborx+=x;
		rbory+=y;
		icamx+=x;	icamy+=y;
		grbgrs.shift(x,y);
	}
}

/*
	tworzy z button z obiektu graficznego
*/

class classadvbut	{
	init(string sname)	{
		this.setadvbutmets(sname, "but");
	}
	setasbutton(string san, string sname)	{
		classadvbut::setasbutton2(san,sname,"but");
	}
	setasbutton2(string san, string sname, string styp)	{	// rozszerzanie obiektu o button
		<san>.addmethod("setadvbutmets","setadvbutmets");
		<san>.addmethod("setbuttyp","setbuttyp");
		<san>.addmethod("setadvbutpos","setadvbutpos");
		<san>.addmethod("setbutdir","setbutdir");
		<san>.addmethod("setbutbase1","setbutbase1");
		<san>.addmethod("setbutbase2","setbutbase2");
		<san>.addmethod("setbutbase","setbutbase");
		<san>.addmethod("getbase1","getbase1");
		<san>.addmethod("getbase2","getbase2");
		<san>.addmethod("getbutdir","getbutdir");
		<san>.addmethod("getbutname","getbutname");
		<san>.addmethod("gettyp","gettyp");
		<san>.addmethod("reachable", "reachable");
		<san>.addmethod("setreach", "setreach");
		<san>.addmethod("getgox","getgox");
		<san>.addmethod("getgoy","getgoy");
		
		<san>.addmethod("enable","enable");
		<san>.addmethod("disable","disable");
		<san>.addmethod("enabled","enabled");
		
		<san>.addmethod("moveon","moveon");
		<san>.addmethod("moveoff","moveoff");
		<san>.addmethod("clickon","clickon");
		<san>.addmethod("lrel","lrel");
		<san>.setadvbutmets(sname, styp);
		<san>.setreach(true);
	}
	setadvbutmets(string sname, string styp)	{
		new string _styp = styp;
		new string _sname = sname;
		new int igox = this.getposx();		// jak dojsc do tego..
		new int igoy = this.getposy();
		new string sgox = null;
		new string sgoy = null;
		new string _sbutdir = "auto";
		new string _sbase1 = modadv.get("look:",1);
		new string _sbase2 = modadv.get("look:",2);
		new bool breachable = false;
		this.enable();
	}
	enable()	{	grbuts.addonce( this.getname() );		}
	disable()	{	grbuts.remove(this.getname());	}
	enabled()	{	return grbuts.contains(this.getname());	}
	setbutbase(string s1, string s2)	{
		_sbase1 = s1;
		_sbase2 = s2;
	}
	setreach(bool b)	{	breachable=b;	}
	reachable()	{	return breachable;	}
	setbuttyp(string s)	{	_styp = s;	}
	/*************************/
	lrel()	{}		// mouselrel
	clickon()	{	if( this.reachable() )	{	clwalkq.visit( this.getname() );	}	}
	moveon()	{	advmouse.setactive();	}
	moveoff()	{	advmouse.setstd();	}
	/*************************/
	setadvbutpos(string x, string y)	{	sgox=x; sgoy=y; igox = x; igoy=y;		}
	setbutdir(string sdir)	{	_sbutdir=sdir;	}
	setbutbase1(string sb1)	{	_sbase1=sb1;	}
	setbutbase2(string sb2)	{	_sbase2=sb2;	}
	string getbase1()	{	return _sbase1;	}
	string getbase2()	{	return _sbase2;	}
	string getbutdir()	{	return _sbutdir;	}
	string getbutname()	{	return _sname;	}
	string gettyp()	{	return _styp;	}
	int getgox()	{
		if( sgox=="-hero" )	{
			return sgoy=="main" ? <smainhero>.getposx() : <sgoy>.getposx();
		} else return igox + clcamera.getposx();
	}
	int getgoy()	{
		if( sgox=="-hero" )	{
			return sgoy=="main" ? <smainhero>.getposy() : <sgoy>.getposy();
		} else return igoy + clcamera.getposy();
	}
	/*******  virtuale  ****/
	virtual int getposx()	{	return 0;	}
	virtual int getposy()	{	return 0;	}
	virtual int getz()		{	return 0;	}
	virtual int isin(int x, int y, bool bigv, bool biga)	{	return 0;	}
}

class classadvitem : classadvbut	{
	init(string sname)	{
		classadvbut::init(sname, "item");
		this.setbutbase( modadv.get("take:",1), modadv.get("take:",2) );
	}
	setasbutton(string san, string sname)	{
		classadvbut::setasbutton2(san, sname, "item");
		<san>.setbutbase( modadv.get("take:",1), modadv.get("take:",2) );
	}
}

class classadvdoors : classadvbut	{
	init(string sname)	{
		classadvbut::init(sname, "doors");
		this.setbutbase( modadv.get("doors:",1), modadv.get("doors:",2) );
	}
	setasbutton(string san, string sname)	{
		classadvbut::setasbutton2(san, sname, "doors");
		<san>.addmethod("moveon","moveon");
		<san>.setbutbase( modadv.get("doors:",1), modadv.get("doors:",2) );
	}
	moveon()	{	advmouse.setexit();		}
}

/* 
	behavioury : skladowe cut-scen w przygodzie
*/

class classbehhero 	{
	init()	{
		new string _snextbeh = null;
		new string _stdfinfun = null;	// std funkcja przekazana do odegrania na finish
		new string _stdfinobj = null;
		new string _stype = null;	// typ behavioura
		new string _scaller;	// kto go wywoluje (tego behavioura)
		new bool bblock = true;	// blokuj przed dzialaniami gracza
		new bool bonce = false;	// jednorazowego uzytku
		new bool bparal = false;
	}
	public gonext(string scaller)	{
		bool bfin = false;
		if( bparal )	{
			bfin = <_sstarter>.behret( this.getname() );
		} else if ( <_sstarter>.isenumer() && _sstarter!=this.getname())	{
			bfin = true;
		} else {
			if( _snextbeh!=null )	{
				<_snextbeh>.eval( scaller );
			} else {
				bfin = true;
			}
		}
		if( bfin )	{
			this.finishbeh(scaller);
		}
	}
	public finishbeh(string scaller)	{
		if( scaller!=null )	{
			<scaller>.reteval();
		} else {
			modstnd.resume();
			string s = this.getactbeh();
			<_sstarter>.callbehfin();
			if( this.getactbeh()==s )	{
				this.setactbeh(null);
			}
		}
	}
	public playfin(string sob, string sfun)	{
		this.setfinfun(sob,sfun);
		_bmslock = this.advgetlock();
		this.advmssetlock( bblock );	// zapamietuje mysz
		modstnd.pause();	// stop standery
		this.eval(null);
	}
	public eval(string scaller)	{
		this.setactbeh( this.getname() );		// zapamietanie kto teraz "gra"
		_scaller = scaller;
		this._eval();	
	}
	public rewind()	{
		if( bblock==false || igmdebug)	{
			this._rew();
		}
	}
	public reteval()	{
		this.gonext(_scaller);
	}
	callbehfin()	{
		this.advmssetlock( _bmslock );	// przywrocenie blocka myszy
		
		this.callfun(_stdfinobj,_stdfinfun);
		_stdfinobj = null;
		_stdfinfun = null;
		
		this.< this.getname()->strsubbs( _sbeh )+"_FINISH">();
	}
	_evalscript()	{
		<_sscr>.call( _sfun2 );
		this.reteval();
	}
	_rewscript()	{}
	_evalmet()	{
		this.callfun(_sob2,_sfun2);
		this.reteval();
	}
	_rewmet()	{}
	_evalsave()	{
		clsave._set( ssavvar, ssavval );
		this.reteval();
	}
	_rewsave()	{}
	_evalgame()	{
		this.playnewgamepath(_sgame, sgmglobpath);
		this.reteval();
	}
	_rewgame()	{}
	_evalread()	{	clhilarytxt.herosaydir( _sread, _ix, _iy, _sdir );	}
	_rewread()	{
		clhilarytxt.stop();
		this.reteval();
	}
	_evalwait()	{	timwait.play();	}
	_rewwait()	{	timwait.stop(true);	}
	_evaltalk()	{
		this.advanstand(_san);
		string s = _stalkpref + _san;
		<s>.settalktype( modadv.gettalktype() );
		<s>.setsnd( __swav );
		<s>.checkamounts( __sbase );
		<s>.herosaydir(isort, bstt, bstp, this.getname(), "reteval", <s>.getpropdir(_sdir) );
	}
	_rewtalk()	{	<_stalkpref+_san>.stop(true);	}
	_evalsetpos()	{
		int x, int y;
		string _sptf = _spathpref + _san;
		if( _idestx=="-id" )	{
			y=<_sptf>.getbyname(_idesty);
			x = <_sptf>.getxver(y);
			y = <_sptf>.getyver(y);
			<_san>.setpos(x ,y  );
		} else {
			x=_idestx;
			y=_idesty;
			<_san>.setpos(x + clcamera.getposx() ,y + clcamera.getposy() );
		}
		if( engine.varexist(_sptf) ) <_sptf>.scalean();
		this.reteval();
	}
	_rewsetpos()	{}
	_evalwalk()	{
		int x, int y;
		if( _idestx=="-id" )	{
			y=<_sptf>.getbyname(_idesty);
			x = <_sptf>.getxver(y) - <_sptf>.getposx;
			y = <_sptf>.getyver(y) - <_sptf>.getposy;
		} else {
			x=_idestx;
			y=_idesty;
		}
		<_sptf>.herowalkto2( x + clcamera.getposx(), 
			y + clcamera.getposy(), this.getname(), "reteval" );
	}
	_rewwalk()	{}
	_evalanorder()	{
		this.advanstand(_san);
		_ = this.analizeaninstr(_sdb, _irow, _icol, _san);
		this.reteval();
	}
	_rewanorder()	{}
	_evalanplay()	{
		this.advanstand(_san);
		<_san>.thisfinish(true);
		<_san>.playspec2( _sact, this.getname(), "reteval");
	}
	_rewanplay()	{	<_san>.stop(true);	}
	_evalsndbg()	{
		_sndbg.play();
		this.reteval();
	}
	_rewsndbg()	{}
	_evalsndplay()	{
		sndp.play();
	}
	_rewsndplay()	{	sndp.stop(true);	}
	_evalcall()	{
		string s = scallobj;
		if( s.contains("$") )	{
			s = s.strsubb(1);
			s = engine.varexist(s) ? [s] : <sscript>.get(s);
			if( s==null )	{
				this.reteval();
				return;
			}
		}
		s = this.getbeh(s);
		<s>.eval( this.getname() );
	}
	_rewcall()		{}
	_evalnull()	{	this.reteval();	}		// obiekt niezdefiniowany
	_rewnull()	{}
	_evalstart()	{
		int i, string s;
		if( bonce )	{
			s = this.getname()->strsubbs( _sbeh );
			if( !clsave.bis(s) )	{
				clsave.bset(s); 
			} else {
				this.finishbeh(_scaller);
				return;
			}
		}
		if( (iisifsave==0&&clsave._is(sisifsave,sisifvar)) || (iisifsave==1&&!clsave._is(sisifsave,sisifvar)) )	{
			this.finishbeh(_scaller);
			return;
		}
		if( brand)	{
			i = vecbehs.size();
			i>0 ? < vecbehs.get( i.rand(i) ) >.eval( _scaller ) : this.reteval();
		} else if( bparal)	{
			vecbehs2.veccopy("vecbehs");
			for( i=0; i<vecbehs.size(); i++)	{
				<vecbehs.get(i)>.eval( _scaller );
			}
		} else if (ienumer>0)	{
			<vecbehs.get( this.nextenum()-1 )>.eval( _scaller );
		} else	{
			this.reteval();
		}
	}
	_rewstart()	{}
	/***********************/
	settype(string stype)	{
		_stype = stype;
		this.addmethod("_eval", "_eval" + stype );
		this.addmethod("_rew", "_rew" + stype );
	}
	setflags(string snextob)	{
		 _snextbeh = snextob;	
	}
	setfinfun(string stdfinobj, string stdfinfun)	{
		_stdfinobj = stdfinobj;
		_stdfinfun = stdfinfun;
	}
	setasstarter(bool bone, bool brandom, bool bpar, bool block, int ienum, int iifsave, string sifsave, string sifvar)	{
		this.settype("start");
		new string _sstarter=this.getname();
		new bool brand = brandom;
		new bool _bmslock;		// tmp do przechowania locka myszy
		new vector vecbehs;
		bblock = block;
		vecbehs.type("string");
		bonce = bone;
		bparal = bpar;
		new int ienumer = ienum;
		if( ienum>0 )	{
			new int _iencnt = 1;
		} else if( bpar )	{
			new vector vecbehs2;
			vecbehs2.type("string");
		}
		new int iisifsave=iifsave;
		if( iifsave>=0 )	{
			new string sisifsave = sifsave;
			if( sifvar!=null )
				new string sisifvar = sifvar;
		}
	}
	int isenumer()	{
		return ienumer;	
	}
	int nextenum()	{
		if( _iencnt > vecbehs.size() )	{
			_iencnt = ienumer+1;
		} else {
			_iencnt++;
		}
		return _iencnt-1;
	}
	addtostarter(string sob)	{	vecbehs.add( sob );	}
	bool getblock()	{	return bblock;	}
	addflags(string sst,  bool block, bool bpar)	{
		new string _sstarter=sst;
		bblock = _stype=="read" ? false : block;
		bparal = bpar;	// czy nalezy wykonac rownolegle
	}
	bool behret(string sob)	{
		vecbehs2.remove(sob);
		return vecbehs2.size()==0;
	}
	setasscript(string sscr, string sfun)	{
		this.settype("script");
		new string _sscr = sscr;
		new string _sfun2 = sfun;
	}
	setasmet(string sob, string sfun)	{
		this.settype("met");
		new string _sob2 = sob;
		new string _sfun2 = sfun;
	}
	setassaver(string svar, string sval)	{
		this.settype("save");
		new string ssavvar = svar;
		new string ssavval = sval;
	}
	setasnewgamer(string sgame)	{
		this.settype("game");
		new string _sgame=sgame;
	}
	setasreader(string sfile, int x, int y, string sdir)	{
		this.settype("read");
		new string _sread = sfile;
		new int _ix = x;
		new int _iy = y;
		new string _sdir = sdir;
	}
	setaswaiter(int delay)	{
		this.settype("wait");
		new timer timwait;
		timwait.settick(1);
		timwait.delay(delay);
		timwait._csplbuild( this.getname(), "reteval" );
		timwait.addmethod("onfinish", "_csplfinish");
	}
	setassndbg(string ssnd)	{
		this.settype("sndbg");
		new snd _sndbg;
		_sndbg.setstartstopflag(false, true);
		_sndbg.load( this.getsndpath() + ssnd + ".wav" );
	}
	setasanorder(string sdb,int irow,  int icol, string san)	{
		this.settype("anorder");
		new string _sdb = sdb;
		new int _irow = irow;
		new int _icol = icol;
		new string _san = san;
	}
	setascaller(string sbeh, string sscr)	{
		this.settype("call");
		new string scallobj = sbeh;
		new string sscript = sscr;
	}
	_csplbuild(string sob, string sfin)	{
		new string _sobj = sob;
		new string _sfinfun = sfin;
	}
	_csplfinish()	{
		this.callfun(_sobj, _sfinfun);
	}
	setassndplayer(string sfile)	{
		this.settype("sndplay");
		new snd sndp;
		sndp.setstartstopflag( false, true );
		sndp.load( this.getsndpath()+sfile+".wav" );
		sndp._csplbuild( this.getname(), "reteval" );
		sndp.addmethod("onfinish", "_csplfinish");
	}
	setasposer(string san, string  idestx, int idesty )	{
		this.settype("setpos");
		new string _san = san;
		new string _idestx = idestx;
		new int _idesty = idesty;
	}
	setaswalker(string sptf, string idestx, int idesty )	{
		this.settype("walk");
		new string _sptf = sptf;
		new string _idestx = idestx;
		new int _idesty = idesty;
	}
	setasanplayer(string san, string sact)	{	
		this.settype("anplay");
		new string _san = san;
		new string _sact = sact;
	}
	setastalker(string san, string swav, string sbase, int itypsort,
			bool bstart, bool bstop, string sdir )	{
		this.settype("talk");
		new string _san = san;
		
		new string __swav = swav;
		new string __sbase = sbase;
		
 		new int isort = itypsort;
 		new bool bstt = bstart;
 		new bool bstp = bstop;
 		new string _sdir = sdir;
	}
}



class classadvpocket : classadvobject, classadvbut, gmimgvec	{
	init(string sname)	{
		classadvobject::init();
		classadvbut::init(sname);
		gmimgvec::init();
		this.setbuttyp("pocket");
		new int iX;
		new int iY;
		new int iNumItems = 0;
		new int iMaxItems = 14;
		new int iScale;
		new string sState = "closed";
		new string _sanim = this.getname();
		_sanim = _sanim.strsubbs( _spocketpref );
		new string sItem = null;
		new string sFocusItem = null;
		
		new string _sbase = "anpocket";
		new int _ibase = _sbase.length();
		
		this.setz(1000);
		
		new string sitempath;
		new vector arPocket;
		arPocket.type("string");
		this.cnewtimercyclefin("tim", 1, 1, "evalpocket");
		
		sitempath = modadv.get("itempath:",1);
		
		int z = this.getz();
		new anima imitem;
		imitem.anloopfin();
		imitem.setz(z+1);
		new img immarker;
		immarker.load( sitempath + "itemmarker.png" );
		immarker.setz(z-1);
		immarker.hide();
		
		this.hide();
		
		new bool bskip=false;
	}
	/*******************************/
	addtoadv()	{		// jezeli jest globalna kieszen
		this.addtogamevars(this.getname());
		this.enable();
		this.addasadvobject();
	}
	removefromadv()	{
		this.disable();
		this.removefromadvobjs();
	}
	hidepocket()	{
		if( sState!="closed")	{
			if( sState!="close" )	{
				this.pockettoggle();
				tim.stop(false);
			}
			while(sState!="closed")	{
				tim.evalpocket();
				tim.stop(false);
			}
		}
	}
	/*******************************/
	skip()	{	bskip=true;	}
	skipitem()	{	if( sItem!=null )	{	bskip=true;	}	}
	additem(string sname)	{
		arPocket.add(sname);
// 		string s = _sbase+iNumItems;
		string s = _sbase + sname;
		new anima <s>;
		this.add(s);
		<s>.load( sitempath + sname + ".pyz" );
		<s>.setframe("in",0);
		<s>.setz( this.getz() );
		<s>.hide();
		iNumItems++;
	}
	removeitem(string sname)	{
		arPocket.remove( sname.strsubbs(_sbase) );
		this.remove( sname );
		iNumItems--;
		if ( sState == "opened" ){	this.hide();	}
	}
	useitem()	{
		if( sItem!=null )	{
			this.removeitem( sItem );
			this.itemhide();
		}
	}
	evalpocket(){
		this.play();
		if ( sState == "open" ){
			iScale+=16;
		} else if ( sState == "close" ){
			iScale-=16;
		}
		if ( iScale > 116 ){
			this.stop(false);
			iScale = 116;
			sState = "opened";
		} else if ( iScale < 0 ){
			this.stop(false);
			iScale = 0;
			sState = "closed";
		}
		real dRadius = (iScale * iScale )/550;
		//real dRadius = iScale.sqrt(iScale)*2;
		real dAngle;
		string s;
		for (int i=0; i< iNumItems; i++){
			dAngle = dRadius*i-(dRadius*iNumItems/2.0) -90.0 + dRadius/2;
			s = this.get(i);
			<s>.setpos( dAngle.cos() * iScale + iX - 76/2, dAngle.sin() * iScale + iY - 75/2 );
			<s>.show();
		}
		if ( sState == "closed" ){
			this.hide();
		}
	}
	pocketpos(int x, int y)	{
		int ix = x-iX;
		int iy = y-iY;
		this.move(ix,iy);
		iX=x;
		iY=y;
	}
	pockettoggle(){
		if ( sState == "opened" ){
			sState = "close";
			immarker.hide();
			tim.play();
		} else if ( sState == "closed" ){
			sState = "open";
			iX = <_sanim>.getposx();
			iY = <_sanim>.getposy()-<_sanim>.geth()/2;
			this.itemhide();
			this.show();
			tim.evalpocket();
			tim.play();
		} else if ( sState == "open" ){
			sState = "close";
		} else if ( sState == "close" ){
			sState = "open";
		}
	}
	string getitem()	{	return sItem!=null ? sItem.strsubbs(_sbase) : null;	}
	itemhide(){
		sFocusItem = null;
		sItem = null;
		imitem.stop(false);
		imitem.hide();
	}
	itemclick()	{
		this.skip();
		if ( sState == "closed" ){
			this.pockettoggle();
		} else if ( sState == "opened" ){
			if ( sFocusItem != null ){
				sItem = sFocusItem;
				imitem.copy(sItem);
				<sFocusItem>.hide();
				imitem.play("out");
				imitem.setz( this.getz() + 1 );
				this.setitempos();
				this.pockettoggle();
			} else {
				this.pockettoggle();
			}
		} else if ( sState == "open" ){
			this.pockettoggle();
		} else if ( sState == "close" ){
			this.pockettoggle();
		}
	}
	int isin(int x, int y, bool bignorehidden, bool bignorealpha)	{
		int id = gmimgvec::isin(x,y,bignorehidden,bignorealpha);
		if( id )	{
			sFocusItem = this.get( id-1 );
		} else {
			sFocusItem = null;
			id = <_sanim>.isin(x,y,bignorehidden,bignorealpha);
		}
		return id;
	}
	setitempos()	{
		imitem.setpos( mouse.getpx()-76/2, mouse.getpy()-75/2 );
	}
	itemmoveoff()	{
		if ( sState == "opened" ){
			immarker.hide();
		}
	}
	itemmoveon()	{
		if ( sState == "opened" ){
			if (sFocusItem != null){
				immarker.show();
				immarker.setpos( <sFocusItem>.getpx(), <sFocusItem>.getpy() );
			} 
		}
	}
	onmouselclick(int x, int y)	{
		if(bskip)	{
			bskip=false;
		} else {
			sState=="opened" || sState=="open"  ? this.pockettoggle() : this.itemhide();
		}
	}
	onmousemove(int x, int y)	{
		if ( sItem != null ){	this.setitempos();	}
		if ( sState == "opened" && this.isin(x,y,true,true) )	{
			this.itemmoveon();
		}
	}
	/**************** button **********/
	moveoff()	{
		advmouse.setstd();
		this.itemmoveoff();	
	}
	clickon()	{	this.itemclick();	}
}

/* 
	klasa oblugujaca postac z gry
	Dominik Dagiel 3 III 2006
*/

new string sgmlastscene;
new string sgmglobpath;	// dla gier, ktore sa w innym katalogu niz ich nazwa
new string sgmgame;		// jezeli .adv inaczej sie nazywa niz game
new db gdbsound;			// baza dialogow
new classfullsave clsave;

module modadv	{
	init()	{
		new db dbload;
		new string stalktype;
		this.settalktype("snd");
		new Script scrl(null);
		new string _stalk;
	}
	/********************************/
	public execute(string sfunc)		{	scrl.call(sfunc);		}
	public loadscript(string sfile)		{	scrl.load(sfile);			}
	/********************************/
	public loadsounds(string sfile)	{	gdbsound.load(sfile);	}
	public string gettalktype()	{	return stalktype;	}
	public settalktype(string s)	{	stalktype=s;	}
	/********************************/
	public load(string sfile)			{
		dbload.loadscript(sfile);
		_stalk = this.get("talk:",1);
	}
	public string get(string styp, int ipos)	{
		int id = dbload.findbyrow(styp);
		if( id<0 )	{
			engine.print("modadv.dbload: can't find "+styp);
			return null;
		} else
			return  dbload.get( id, ipos );
	}
}

module modadvglob	{
	init()	{
		new gmobjvec grhero;
	}
	bool addhero(string sname, string sfile, bool bpocket)	{
		if( grhero.contains(sname) ) {
			<sname>.addtogamevars(sname);
			if( bpocket )
				<_spocketpref+sname>.addtoadv();
			return false;
		} else {
			this.newanima(sname,sfile,0);
			<sname>.addtogamevars(sname);
			grhero.add(sname);
			if( bpocket )	{
				string s = _spocketpref+sname;
				new classadvpocket <s>(s);
				<s>.addtogamevars(s);
			}
			return true;
		}
	}
	delhero(string sname)	{
		if(grhero.contains(sname))	{
			delete <sname>;
			grhero.remove(sname);
			sname = _spocketpref + sname;
			if( this.hasvar(sname) )	{
				delete <sname>;
			}
		}
	}
	onexit()	{
		string s;
		for( int i=0; i<grhero.size(); i++)	{
			s = grhero.get(i);
			<s>.stop(false);
			<s>.hide();
			s = _spathpref + s;
			<s>.unlinkanima();
			<s>.hidepocket();
		}
	}
}

class classloadedhero	{
	init()	{
		new string sanhero;
		new bool bplaystart = false;
		new bool bplaystop = false;
	}
	public setplaystart(bool b)	{	bplaystart = b;	}
	public setplaystop(bool b)	{	bplaystop = b;	}
	public getstartstop()	{	return bplaystart, bplaystop;	}
}

class classadvcontroller : classadv	{
	init()	{
// 		new TicksCounter ctc;
		
		classadv::init();
		
// 		engine.setdebugstate(1);
		
		this.setwavpath( modadv.get("sndpath:", 1) );
		
		new string _slhpref = "cllh";	// prefix do obiektu classloadedhero
		new string _spathpref = "pt";	// prefix do obiektu classpathf
		new string _spocketpref = "pc";	// prefix do pocket
		new string _sstndpref = "stnd";	// prefix do standera
		new string _stalkpref = "ctlk";
		
		new classstndgroup modstnd;
		
		new classobjcounter clcbeh("_dbbh");		// prefix do bazy danych bahaviourow
		
		new string _sbeh = "clbeh";	// prefix obiektu behaviour
		new int iidbeh;		// id behavioura niedeklarowanego poprzez nazwe
		
		new classobjcounter clcadv("dbadv");	// bazy danych z przygoda
		
		new db dbmacros;
		new vector _vecarg;	// argumenty wolania makr
		_vecarg.type("string");
		
		new classadvcamera clcamera;	// kamera
		clcamera.setmetonmsmove("advmsmove");
		
		new classwalkerqueue clwalkq;	// kolejnosc chodzenia
		
		new gmimgvec grbuts;		// obiekty do analizowania (buttons)
		new gmimgvec grmsmove;		// kieszenie bohaterow i inne do move
		new gmimgvec grmslclick;
		new gmimgvec grmslrel;
		
		new string _susetool = null;
		new string _slastms = null;
		new bool bmslock = false;
		
		new string sactbeh = null;		// aktualny beh
		new string slastpathf;		// ostatni pathfinder to podawania pozycji buttonow
		
		new int licznik=0;
		
		new string smainhero = null;
		
		string s, string s2;
		if( sgmgame==null )	{
			sgmgame = this.getname();
		}
		new string sprivgame = sgmgame;
		sgmgame = null;
		
		s2 = sprivgame.strsubbs("game");
		if( sgmglobpath!=null )	{
			s = sgmglobpath;
			sgmglobpath = null;
		} else {
			s = s2;
		}
		this.setgraphpath("scripts/" + s + "/" );
		this.loadadventure( s2 + ".adv");
		grbuts.sortimgs();
		
		if( smainhero==null )	{	smainhero = clcamera.getactor();	}
		
		clcamera.start();
		clcamera.setscene();
		clwalkq.start();
		clwalkq.setverlen(1);
		
		advmouse.setstd();
		
		if ( clsave._bis(sprivgame+"visited") ){
			if ( this.playpostinit( "behinit_FROM_" + sgmlastscene ) )	{
			} else if ( this.playpostinit( "behinit" ) )	{
			}
//			else <gameapi.getgamename()>.postinit();
		} else {
			clsave._bset(sprivgame+"visited");
			if( this.playpostinit( "behinit0_FROM_" + sgmlastscene ) )	{}
			else if ( this.playpostinit( "behinit0" ) )	{}
			else if ( this.playpostinit( "behinit_FROM_" + sgmlastscene ) )	{}
			else if ( this.playpostinit( "behinit" ) )	{}
//			else <gameapi.getgamename()>.postinit();
		}
		grbuts.sortimgs();
	}
	public getmainhero()	{	return smainhero;	}
	public setmainhero(string s)	{	smainhero=s;	}
	public bool ismainhero(string s)	{	return smainhero==s;	}
	public setactbeh(string s)	{	sactbeh = s;	}
	public string getactbeh()	{	return sactbeh;	}
	public bool advgetlock()	{	return bmslock;	}
	public advmslock()	{
		bmslock=true;
		advmouse.setwait();
	}
	public advmsunlock()	{
		bmslock=false;
		advmouse.setstd();
	}
	public advmssetlock(bool block)	{
		block ? this.advmslock() : this.advmsunlock();
	}
	public setusetool(string s)	{	_susetool=s;	}
	public getusetool()	{	return _susetool;	}
	/********************************/
	bool playpostinit( string sbeh ){ 
		return this.playbehobfinif( sbeh, gameapi.getgamename(), "postinit");
	}
	public playbeh(string sname)	{
		this.playbehfin(sname,null);
	}
	public bool playbehif(string sname)	{
		if ( this.behexist( sname ) ){
			this.playbehfin(sname,null);
			return true;
		}
		return false;
	}
	public playbehfin(string sname, string sfunfin)	{
		this.playbehobfin(sname,null,sfunfin);
	}
	public bool playbehfinif(string sname, string sfunfin)	{
		if ( this.behexist( sname ) ){
			this.playbehfin(sname,sfunfin);
			return true;
		}
		return false;
	}
	public playbehobfin(string sname, string sobfin, string sfunfin)	{
		<this.getbeh(sname)>.playfin(sobfin, sfunfin);
	}
	public bool playbehobfinif(string sname, string sobfin, string sfunfin)	{
		if ( this.behexist( sname ) ){
			this.playbehobfin(sname,sobfin,sfunfin);
			return true;
		}
		return false;
	}
	public playnewgamepath(string sgame, string spath)	{
		sgmglobpath = spath;
		sgmlastscene = sprivgame;
		gameapi.play(sgame);
	}
	public playnewgame(string sgame)	{
		this.playnewgamepath(sgame, null);
	}
	public playfromscript(string spath, string sgame)	{
		sgmgame = sgame;
		this.playnewgamepath( modadv.get("defaultadv:",1), spath );
	}
	/********************************/
	string getheroloader(string swavbase)	{
		swavbase = _slhpref + swavbase;
		engine.varexist(swavbase) ? swavbase : null;
	}
	/*********************************/
	public advanstand(string san)	{
		string s =  _spathpref + san;
		if( engine.varexist( s ) && <s>.iswalking() )	{
			<s>.stop(false);
			<s>.stand();
		}
	}
	analizeanopts(string sdb, int irow, int icol, int ilecol, string san, string sgrp, string styp)	{
		real r[2], string s1, string s2;
		bool b0 = false, bool b1 = false, int i[3], bool bfont=false;
		while( icol < ilecol )	{
			icol++;
			match(<sdb>.get(irow,icol-1))	{
				"-stt" => {	b0 = <sdb>.get(irow,icol);	icol++;	}
				"-stp"=> {	b1 = <sdb>.get(irow,icol);	icol++;	}
				"-wav"=> { s1 = _slhpref + <sdb>.get(irow,icol);	icol++;
					new classloadedhero <s1>;
					<s1>.varset( "sanhero", san );
					<sgrp>.add( s1 );
				}
				"-path" => { s1 = <sdb>.get(irow,icol);	icol++;	// pathfinder
					r0 = <sdb>.get(irow,icol);	icol++;	// step
					s2 = _spathpref+san;
					this.newclpathfcopy( s2, san, s1, r0);
					<s2>.prepareforhero();
					s1 = s2 + "look";	new classherolooker <s1>;	<s1>.link( san );
					s1 = s2 + "use";	new classherouser <s1>;		<s1>.link( san );
					s1 = s2 + "take";	new classherotaker <s1>;	<s1>.link( san );
				}
				"-ft"=> {	s2 = _spathpref+san;
					r0 = <sdb>.get(irow,icol);	icol++;	// z depth
					r1 = <sdb>.get(irow,icol);	icol++;	// scale power
					<s2>.linkfilter();
					<s2>.setzsize(r0);
					<s2>.setscalepower(r1);
				}
				"-stnd"=> { <_sstndpref+san>.setdelay(<sdb>.get(irow,icol)); icol++; }
				"-txt" => { i0 = <sdb>.get(irow,icol);	icol++;
					i1 = <sdb>.get(irow,icol);	icol++;
					i2 = <sdb>.get(irow,icol);	icol++;
					<_stalkpref+san>.settxtcolor(i0,i1,i2);
				}
				"-font" => {	bfont=true;
					s1 = <sdb>.get(irow,icol);	icol++;
					s2 = <sdb>.get(irow,icol);	icol++;
					if( styp=="hero:" )	{
						<_stalkpref+san>.setfont( s1, s2 );
					}
				}
				? => icol = this.analizeaninstr( sdb ,irow, icol-1, san);
			}
		}
		if( !bfont && styp=="hero:")	{
			<_stalkpref+san>.setfont( modadv.get("font:",1), modadv.get("font:",2) );
		}
		<sgrp>.eval1("setplaystart", b0 );
		<sgrp>.eval1("setplaystop", b1 );
		<sgrp>.free();
	}
	setasadvanima()	{
		classadvanhero::setashero( this.getname(), "cadvherofinish");
	}
	analizebut(string styp, string sdb, int irow, int icol)	{
		string s[3], int i[2];
		s0 = <sdb>.get(irow,icol);	icol++;	// nazwa
		s1 = <sdb>.get(irow,icol);	icol++;	// nazwa annki
		<"classadv"+styp.strsube(1)>::setasbutton(s1,s0);
		<s1>.setadvbutpos( <s1>.getcx(), <s1>.getcy() );
		while( icol < <sdb>.getcolsno(irow) )	{
			icol++;
			match( <sdb>.get(irow,icol-1) )	{
				"-pos"=> {	s0 = <sdb>.get(irow,icol);	icol++;	// x
					s2 = <sdb>.get(irow,icol);	icol++;	// y
					if(s0=="-id" && slastpathf!=null)	{
						i0 = <slastpathf>.getbyname(s2);
						s0 = <slastpathf>.getxver(i0) - <slastpathf>.getposx();
						s2 = <slastpathf>.getyver(i0) - <slastpathf>.getposy();
					}
					<s1>.setadvbutpos(s0,s2);
				}
				"-bs1"	=> {	<s1>.setbutbase1( <sdb>.get(irow,icol) ); icol++;}
				"-bs2"	=> {	<s1>.setbutbase2( <sdb>.get(irow,icol) ); icol++;}
				"-dir"	=> {	<s1>.setbutdir( <sdb>.get(irow,icol) ); icol++;}
				"-doors"	=>	<s1>.setbuttyp("doors");
				"-item"	=>	<s1>.setbuttyp("item");
				"-noreach"=> 	<s1>.setreach(false);
				? => ;
			}
		}
	}
	public loadadventure(string sfile)	{
		string sdb = clcadv.get();
		string sgrp = "grpers"+clcadv.size();
		new db <sdb>;
		<sdb>.loadbeh(this.getgraphpath()+sfile);
		int ile = <sdb>.getrowsno();
		int i[4], string s[3], bool b[2], bool bhero;
		real r[2];
		
		s0 = sdb + "script";
		new Script <s0>(sdb);
		
		string spath = "";
		new gmobjvec <sgrp>;
		for( int i=0; i<ile; i++)	{
			i0 =0 ;
			i1 = <sdb>.getcolsno(i);
			s0 = <sdb>.get(i,i0);	i0++;
			if( s0 == "setpath:" )	{
				spath = <sdb>.get(i,i0);	i0++;
				this.setgraphpath(spath);
			} else if (s0=="nopath:")	{
				spath = "";
				this.setgraphpath(spath);
			} else if( s0=="func" )	{		// funkcja skryptu
				while( <sdb>.get(i,0)!="end" )	i++;
			} else if (s0=="sndpath:")	{
				s0 = <sdb>.get(i,i0);	i0++;
				this.setwavpath(s0);
			} else if( s0=="hero:" || s0=="an:") {
				i2 = <sdb>.dbdelvar(i,"-global");
				i3 = <sdb>.dbdelvar(i,"-pck");
				spath = this.getgraphpath();
				s2 = <sdb>.get(i,i0);	i0++;	// anima
				s1 = <sdb>.get(i,i0);	i0++;	// file
				if( s0=="hero:" )	{
					if( s1=="-path" )	{
						s1 = <sdb>.get(i,i0);	i0++;	// path
						this.setgraphpath(s1);
						s1 = <sdb>.get(i,i0);	i0++;	// file
					} else {
						this.setgraphpath( modadv.get("heropath:",1) );
					}
				}
				if( s1.contains(".pyz") )	{
					if( i2 )	{
						if(modadvglob.addhero(s2,s1,i3))
							<s2>.setasadvanima();
						i1--;
					} else {
						this.newanima(s2, s1, 0);
						<s2>.setasadvanima();
						if( s0=="hero:" && i3)	new classadvpocket <_spocketpref + s2>(_spocketpref +s2);
					}
				} else {
					this.copyanima(s1, s2);
					<s2>.setasadvanima();
					if( s0=="hero:" && i3)	new classadvpocket <_spocketpref + s2>(_spocketpref+s2);
				}
				if(i3)	i1--;
				this.setgraphpath(spath);
				if( s0=="hero:" )	{
					new classadvstander <_sstndpref+s2>;
					classadvanhero::buildheroframe(s2);
					
					//new classadvpocket <_spocketpref + s2>(s2);
					
					s1 = _stalkpref+s2;
					new classtalker <s1>;
					<s1>.set(s2);
					<s1>.settextdb("gdbsound");
				}
				this.analizeanopts(sdb, i, i0, i1, s2, sgrp, s0);
			} else if (s0=="anaac:")	{
				i2 = <sdb>.dbdelvar(i,"-mask");
				s0 = <sdb>.get(i,i0);	i0++;	// anima
				if( i2 )	{
					i1--;
					new gmmaskvec <s0>;
				} else {
					new gmimgvec <s0>;
				}
				s1 = <sdb>.get(i,i0);	i0++;	// z ktorej..
				i2 = this.newanactionsgr(s1, s0, s0);
				i0 = this.analizeaninstr( sdb ,i, i0, s0);
			} else if (s0=="anaf:")	{
				s0 = <sdb>.get(i,i0);	i0++;	// anima
				s1 = <sdb>.get(i,i0);	i0++;	// z ktorej..
				new gmimgvec <s0>;
				i2 = this.newanfrbyactgr(s1, s0, s0);
				i0 = this.analizeaninstr( sdb ,i, i0, s0);
			} else if (s0=="anfac:")	{
				i2 = <sdb>.dbdelvar(i,"-mask");
				s0 = <sdb>.get(i,i0);	i0++;	// anima
				if( i2 )	{
					i1--;
					new gmmaskvec <s0>;
				} else {
					new gmimgvec <s0>;
				}
				s1 = <sdb>.get(i,i0);	i0++;	// z ktorej..
				s2 = <sdb>.get(i,i0);	i0++;	// akcja
				i2 = this.newanframesgr(s1, s0, <s1>.actionnr(s2), s0);
				i0 = this.analizeaninstr( sdb ,i, i0, s0);
			} else if (s0=="anac:")	{
				i2 = <sdb>.dbdelvar(i,"-adv");
				s0 = <sdb>.get(i,i0);	i0++;	// anima
				s1 = <sdb>.get(i,i0);	i0++;	// z ktorej..
				s2 = <sdb>.get(i,i0);	i0++;	// akcja
				this.copyanimaact(s1, s0, s2);
				if( i2 )	{
					i1--;
					<s0>.setasadvanima();
				}
				i0 = this.analizeaninstr( sdb ,i, i0, s0);
			} else if (s0=="anf:")	{
				i2 = <sdb>.dbdelvar(i,"-mask");
				s0 = <sdb>.get(i,i0);	i0++;	// anima
				s1 = <sdb>.get(i,i0);	i0++;	// z ktorej..
				s2 = <sdb>.get(i,i0);	i0++;	// akcja
				i3 = <sdb>.get(i,i0);	i0++;	// klatka
				this.copyanima( s1, s0 );
				<s0>.setframe(s2,i3);
				if( i2 )	{
					i1--;
					<s0>.setasadvanima();
				}
				i0 = this.analizeaninstr( sdb ,i, i0, s0);
			} else if (s0=="behfile:")	{	// file with adv behaviours
				this.loadbehaviours( <sdb>.get(i,i0) );
				i0++;
			} else if (s0=="include:")	{	// another adv specification
				spath = this.getgraphpath();
				if( <sdb>.get(i,i0)=="-path" )	{
					this.setgraphpath(<sdb>.get(i,i0+1));
					i0+=2;
				}
				this.loadadventure( <sdb>.get(i,i0) );
				this.setgraphpath(spath);
				i0++;
			} else if (s0=="walkqueue:")	{
				while( i0<i1 )	{
					clwalkq.add( _spathpref + <sdb>.get(i,i0) );
					i0++;
				}
			} else if(s0=="font:")	{
				s0 = <sdb>.get(i,i0);	i0++;	// nazwa
				s1 = <sdb>.get(i,i0);	i0++;	// plik
				i2 = <sdb>.get(i,i0);	i0++;	// size
				new font <s0>;
				<s0>.load( s1, i2 );
			} else if (s0=="bkg:")	{
				s0 = <sdb>.get(i,i0);	i0++;	// plik
				this.csetbkg(s0);
				i0 = this.analizeaninstr( sdb ,i, i0, "imgbkg");
			} else if (s0=="img:")	{
				s0 = <sdb>.get(i,i0);	i0++;	// nazwa
				s1 = <sdb>.get(i,i0);	i0++;	// plik
				i2 = <sdb>.get(i,i0);	i0++;	// z
				this.newimg(s0,s1,i2);
				i0 = this.analizeaninstr( sdb ,i, i0, s0);
			} else if (s0=="but:" || s0=="doors:" || s0=="item:")	{
				this.analizebut(s0, sdb, i, i0);
			} else if (s0=="camera:")	{
				r0 = <sdb>.get(i,i0);	i0++;	// xmodfifier
				r1 = <sdb>.get(i,i0);	i0++;	// ymodifier
				clcamera.scalemodifiers(r0,r1);
				while(i0<i1)	{
					s0 = <sdb>.get(i,i0);	i0++;
					if( s0=="-size")	{
						i2 = <sdb>.get(i,i0);	i0++;
						i3 = <sdb>.get(i,i0);	i0++;
						clcamera.setborders( i2, i3 );
					} else if (s0=="-center")	{
						i2 = <sdb>.get(i,i0);	i0++;
						i3 = <sdb>.get(i,i0);	i0++;
						clcamera.setcenter( i2, i3 );
					} else if (s0=="-sizebg")	{
						clcamera.setborders(imgbkg.getw(), imgbkg.geth());
					}
				}
			} else if (s0=="actor:")	{
				clcamera.setactor(<sdb>.get(i,i0)); i0++;
			} else if (s0=="bgr:")	{
				s0 = <sdb>.get(i,i0);	i0++;	// plan
				r0 = <sdb>.get(i,i0);	i0++;	// scalex
				r1 = <sdb>.get(i,i0);	i0++;	// scaley
				new classbgplan <s0>;
				clcamera.addbgr(s0, r0, r1);
			} else if (s0=="pathfinder:")	{
				slastpathf = <sdb>.get(i,i0);	i0++;	// nazwa
				s1 = <sdb>.get(i,i0);	i0++;	// file
				if( s1.contains(".ptf") )	{	
					i2 = 20;
					i3 = 20;
				} else {// znaczy, ze wgrywany z grafiki
					i2 = <sdb>.get(i,i0);	i0++;	// dx
					i3 = <sdb>.get(i,i0);	i0++;	// dy
				}
				this.newpathf(slastpathf, s1, i2, i3);
			} else if(s0=="script:")	{
				s0 = <sdb>.get(i,i0);	i0++;	// nazwa
				s1 = <sdb>.get(i,i0);	i0++;	// file
				new Script <s0>(s1);
			} else if(s0=="func:")	{		// wywolanie wewnetrznej funkcji
				<sdb+"script">.call(<sdb>.get(i,i0));
				i0++;
			}
		}
		<sdb>.readonly();
	}
	behrewind()	{	if( sactbeh!=null )	<sactbeh>.rewind();	}
	bool behplaying()	{	return sactbeh!=null;	}
	bool behexist(string sname)	{	return engine.varexist( this.getbeh(sname) );	}
	string getbeh(string sname)	{	return _sbeh+sname;	}
	string newbehname()	{
		string s = _sbeh + "_" + iidbeh;
		iidbeh++;
		return s;
	}
	string newbeh()	{
		string s = this.newbehname();
		new classbehhero <s>;
		return s;
	}
	loadbeh(string sdb, int irow, int icol, int id, string sstarter, string sprevobj, bool brand, bool bpar)	{
		string s[4], bool bblock = <sstarter>.getblock(), bool bread;
		s0 = <sdb>.get(irow,id);	id++;
		s1 = this.newbeh();
		int i[2];
		match(s0)	{
			"call:" => {	s0 = <sdb>.get(irow,id);	id++;
				<s1>.setascaller( s0, sdb+"script" );
			}
			"walk:" => {	s0 = <sdb>.get(irow,id);	id++;	// kto
				string idestx = <sdb>.get(irow,id);	id++;	// destx lub "id"
				int idesty = <sdb>.get(irow,id);	id++;	// desty lub idpath
				<s1>.setaswalker( _spathpref + s0, idestx, idesty );
			}
			"setpos:" => {	s0 = <sdb>.get(irow,id);	id++;	// kto
				s2 = <sdb>.get(irow,id);	id++;	// id lub x
				i1 = <sdb>.get(irow,id);	id++;
				<s1>.setasposer( s0, s2, i1 );
			}
			"game:" => {	s0 = <sdb>.get(irow,id);	id++;	// nazwa gry
				<s1>.setasnewgamer(s0);
			}
			"ref:" => {		id = this.buildbeh( "_" + iidbeh, sdb, irow, id );
				s0 = this.newbehname();
				<s1>.setascaller( s0.strsubbs(_sbeh), sdb+"script" );
			}
			"anplay:" => {	s0 = <sdb>.get(irow,id);	id++;
				s2 = <sdb>.get(irow,id);	id++;
				<s1>.setasanplayer(s0, s2);
			}
			"anorder:" =>	{	s2 = <sdb>.get(irow,id);	id++;
				<s1>.setasanorder(sdb, irow, id, s2);
				id = this.analizeaninstr(sdb,irow,id,null);
			}
			"sndbg:" =>	{	s2 = <sdb>.get(irow,id);	id++;
				<s1>.setassndbg(s2);
			}
			"sndplay:" =>	{	s0 = <sdb>.get(irow,id);	id++;
				<s1>.setassndplayer(s0);
			}
			"wait:" =>	{	i0 = <sdb>.get(irow,id);	id++;
				<s1>.setaswaiter(i0);
			}
			"read:" =>	{	s0 = <sdb>.get(irow,id);	id++;	// plik
				i0 = <sdb>.get(irow,id);	id++;	// x
				i1 = <sdb>.get(irow,id);	id++;	// y
				s2 = "auto";
				if( <sdb>.getcolsno(irow)>id )	{
					s2 = <sdb>.get(irow,id);
					if( s2=="-dir" )	{
						id++;
						s2 = <sdb>.get(irow,id); id++;
					}
				}
				<s1>.setasreader(s0,i0,i1,s2);
			}
			"met:" =>	{	s0 = <sdb>.get(irow,id);	id++;
				s2 = <sdb>.get(irow,id);	id++;
				<s1>.setasmet(s0, s2);
			}
			"bsave:" =>	{	s0 = <sdb>.get(irow,id);	id++;
				<s1>.setassaver(s0,"1");
			}
			"save:" =>	{	s0 = <sdb>.get(irow,id);	id++;
				s2 = <sdb>.get(irow,id);	id++;
				<s1>.setassaver(s0,s2);
			}
			"script:" =>	{	s0 = <sdb>.get(irow,id);	id++;
				s2 = <sdb>.get(irow,id);	id++;
				<s1>.setasscript(s0,s2);
			}
			"func:" =>	{	s0 = sdb + "script";
				s2 = <sdb>.get(irow,id);	id++;
				<s1>.setasscript(s0,s2);
			}
			? => {		// talker
				s3 = s0.strgetto("_");
				s2 = this.getheroloader( s3 );
				if( s2==null )	{
					engine.print("loadbeh error: no hero linked to "+s3);
					return;
					<s1>.setassndplayer(s0);
				} else {
					|bool bstart, bool bstop| = <s2>.getstartstop();
					string sdir="auto", string sbase=modadv.varget("_stalk"), int itypsort=1;
					bread = id<icol;
					while(bread)	{
						s3 = <sdb>.get(irow,id);	id++;
						match(s3)	{
							"-stt" =>	{	bstart = <sdb>.get(irow,id);	id++;}
							"-stp"=>	{	bstop = <sdb>.get(irow,id);	id++;}
							"-base"=>	{	sbase = <sdb>.get(irow,id);	id++;}
							"-r" =>	itypsort=1; 
							"-nr" =>	itypsort = 0;
							"-dir" =>	{	sdir = <sdb>.get(irow,id);	id++;}
							? => {	bread = false;	id--;	}
						}
						if( bread && id>=icol )	{
							bread = false;
						}
					}
					<s1>.setastalker( <s2>.varget("sanhero"), s0, sbase,
						itypsort, bstart, bstop, sdir );
					
				}
			}
		}
		<sstarter>.addtostarter( s1 );
		
		if( brand==false)	{
			<sprevobj>.setflags(s1);
			<s1>.addflags( sstarter, bblock, bpar );
		} else {
			<sprevobj>.setflags(null);
			<s1>.addflags( sstarter, bblock, false );
		}
		if( id < icol )	{
			this.loadbeh(sdb,irow,icol,id,sstarter,s1,brand, bpar);
		}
	}
	int buildbeh(string sname, string sdb, int irow, int icol)	{
		int id = dbmacros.findbyrow( <sdb>.get(irow, icol) );
		if( id<0 )	{
			engine.print("no such macro: "+ <sdb>.get(irow, icol) );
			return -1;	
		}	// nie ma takiego makra
		while( <sdb>.get(irow, icol) != "(" )	{	icol++;	}
		icol++;
		int id2 = <sdb>.addrow() -1;
		string s = <sdb>.get( irow, icol ); icol++;
		_vecarg.free();
		while( s!=")" )	{		// sczytanie argumentow
			_vecarg.add( s );
			s = <sdb>.get( irow, icol ); icol++;
		}
		int ile = dbmacros.getcolsno( id );
		int i1;
		<sdb>.add( id2, sname );
		for( int i=1; i<ile; i++)	{
			s = dbmacros.get( id, i );
			if( s.getb(0,1)=="$" )	{
				i1 = s.getb(1,10);
				<sdb>.add( id2, _vecarg.get( i1-1 ) );
			} else {
				<sdb>.add( id2, s );
			}
		}
		return icol;
	}
	loadbehaviours(string sfile)	{
		string sdb = clcbeh.get();
		new db <sdb>;
		<sdb>.loadbeh(this.getgraphpath()+sfile);
		string s = sdb + "script";
		new Script <s>(sdb);
		int i[2], string s[4], bool brand, bool bread, bool bonce, bool bpar, bool bblock, int ienumer;
		int iifsave, string sifsave, string sifvar;
		for( int i=0; i< <sdb>.getrowsno(); i++)	{
			i1 = 0;
			s0 = <sdb>.get(i,i1);	i1++;
			if( s0=="macro:")	{
				dbmacros.dbaddrowfrom( sdb, i, 1 );
			} else if (s0=="include:")	{
				s0 = <sdb>.get(i,i1);	i1++;	// path
				s1 = <sdb>.get(i,i1);	i1++;	// file
				s2 = this.getgraphpath();
				this.setgraphpath(s0);
				this.loadbehaviours(s1);
				this.setgraphpath(s2);		// przywroc sciezke
			} else if (s0=="build:")	{
				i1 = this.buildbeh( <sdb>.get(i,i1), sdb, i, i1+1 );
			} else if( s0=="func" )	{		// funkcja skryptu
				while( <sdb>.get(i,0)!="end" )	i++;
			} else {
				i0 = <sdb>.getcolsno(i);
				s0 = this.getbeh(s0);
				new classbehhero <s0>;
				brand = false;
				bread = true;
				bonce = false;
				bpar = false;
				bblock = true;
				sifvar = null;
				iifsave = -1;
				ienumer=0;
				while(bread)	{
					s1 = <sdb>.get(i,i1);	i1++;
					match(s1)	{
						"-nr"	=>	brand = false;
						"-once"	=>	bonce = true;
						"-par"=>	bpar = true;
						"-r"	=>	brand = true;
						"-nb"=>	bblock = false;
						"-en"=>	{	ienumer = <sdb>.get(i,i1);	i1++;}
						"-bif"=>	{	iifsave = 1;
							sifsave = <sdb>.get(i,i1);	i1++;
							sifvar=true;
						}
						"-bnif"=>	{	iifsave = 0;
							sifsave = <sdb>.get(i,i1);	i1++;
							sifvar=true;
						}
						"-if"	=>	{	iifsave = 1;
							sifsave = <sdb>.get(i,i1);	i1++;
							sifvar = <sdb>.get(i,i1);	i1++;
						}
						"-nif" =>	{	iifsave = 0;
							sifsave = <sdb>.get(i,i1);	i1++;
							sifvar = <sdb>.get(i,i1);	i1++;
						}
						?	=>	{	bread = false;
							<s0>.setasstarter(bonce, brand, bpar, bblock, ienumer, iifsave, sifsave, sifvar);
							this.loadbeh(sdb, i, i0, i1-1, s0, s0, brand, bpar);
						}
					}
				}
			}
		}
		<sdb>.readonly();
	}
	int analizeaninstr(string sdb,int irow,  int icol, string san)	{
		bool bread = true;
		if( icol >= <sdb>.getcolsno(irow) )	{	bread=false;	}
		bool banalize = false;
		if( san!=null )	{
			banalize=true;
			this.advanstand(san);
		}
		int i[3];
		string s[2];
		while(bread)	{
			s1 = <sdb>.get(irow,icol);	icol++;
			match(s1)	{
				"-z"		=>	{	i1 = <sdb>.get(irow,icol);	icol++;
					if( banalize)	<san>.setz( i1 );
				}
				"-pos"	=>	{	s0 = <sdb>.get(irow,icol);	icol++;
					i2 = <sdb>.get(irow,icol);	icol++;
					if( banalize)	{
						if(s0=="-id")	{
							s0 = _spathpref+san;
							i0 = <s0>.getbyname(i2);
							i1 = <s0>.getxver(i0) - <s0>.getposx;
							i2 = <s0>.getyver(i0) - <s0>.getposy;
						} else i1=s0;
						//<san>.setpos( i1+ clcamera.getposx(), i2+ clcamera.getposy() );
						<san>.setpos( i1, i2 );
					}
				}
				"-putgr"	=>	if( banalize )	<san>.anputgr();
				"-vis"	=>	{	i0 = <sdb>.get(irow,icol);	icol++;
					if( banalize )	i0==false ? <san>.hide() : <san>.show();
				}
				"-show"	=>	if( banalize )	<san>.show();
				"-hide"	=>	if( banalize )	<san>.hide();
				"-dir"	=>	{s0 = <sdb>.get(irow,icol);	icol++;
					if( banalize)	{
						s1 = <san>.actionname();
						i0 = <san>.framenr();
						<san>.setframe( s1.strsube(2) + s0, 0 );
					}
				}
				"-play"	=>	{s1 = <sdb>.get(irow,icol);	icol++;
					if( banalize)	<san>.splay( s1 );
				}
				"-nplay"	=>	{i0 = <sdb>.get(irow,icol);	icol++;
					if( banalize)	<san>.nplay( i0 );
				}
				"-lplay"	=>	{s1 = <sdb>.get(irow,icol);	icol++;
					if( banalize)	<san>.anloopsplay( s1 );
				}
				"-bgr"	=>	{s1 = <sdb>.get(irow,icol);	icol++;
					if( banalize)	{
						<s1>.add(san);
						if( engine.varexist( _spathpref + san ) )	<s1>.add( _spathpref+san );
					}
				}
				"-sc"		=>
					if( banalize)	{
						s1 = _spathpref+san;
						if( engine.varexist( s1 ) )	<s1>.scalean();
					}
				"-ssc"	=>	if( banalize)	clcamera.setscene();
				"-actor"	=>	if( banalize)	clcamera.setactor(san);
				"-mhero"	=>	if( banalize)	this.setmainhero(san);
				"-puty"	=>	{s0 = <sdb>.get(irow,icol);	icol++;
					if( banalize)	s0=="resy" ? <san>.anputy( iResY-1 ) : <san>.anputy(s0);
				}
				"-stopf"	=>	if( banalize )	<san>.stop(false);
				"-setaction" =>	{s0 = <sdb>.get(irow,icol);	icol++;
					if( banalize)	{
						<san>.setframe(s0, 0);
						<san>.stop(false);
					}
				}
				"-setframe"	=>	{s0 = <sdb>.get(irow,icol);	icol++;
					i0 = <sdb>.get(irow,icol);	icol++;
					if( banalize)	{
						<san>.setframe(s0, i0);
						<san>.stop(false);
					}
				}
				"-stand"	=>	{s0 = <sdb>.get(irow,icol);	icol++;
					if( banalize)	<san>.setstandbase(s0);
				}
				"-delay"	=>	{i0 = <sdb>.get(irow,icol);	icol++;
					if( banalize)	<san>.setdelay(i0);
				}
				?	=>	{	bread = false;		// natrafil na inny string
					icol--;		// przywroc go do analizy
				}
			}
			if( bread && icol>=<sdb>.getcolsno(irow) )	bread = false;
		}
		return icol;
	}
	/*******************************/
	cadvherofinish()	{}
	/*******************************/
	butmoveoff(string sbut)	{
		<sbut>.moveoff();
		this.< <sbut>.getbutname() + "_MOVEOFF">();
	}
	butmoveon(string sbut)	{
		<sbut>.moveon();
		this.< <sbut>.getbutname() + "_MOVEON">();
	}
	advmsmove()	{
		if ( !this.advgetlock() ){
			|int x, int y| = mouse.getpos();
			int id = grbuts.isin(x,y,true,true);
			if( id )	{
				string s = grbuts.get(id-1);
				if( s!=_slastms )	{
					if( _slastms!=null )	this.butmoveoff(_slastms);
					_slastms = s;
					this.butmoveon(s);
				}
			} else {
				if( _slastms!=null )	{
					this.butmoveoff(_slastms);
					_slastms = null;
				}
			}
			grmsmove.eval2("onmousemove", x, y);
			moddbg.msmove();
		}
	}
	butclickon(string sbut)	{
		string s = _spocketpref+this.getmainhero();
		if( engine.varexist(s) )	<s>.skipitem();
		<sbut>.clickon();
		this.< <sbut>.getbutname() + "_CLICKON">();
	}
	butrelease(string sbut)	{
		string s = _spocketpref+this.getmainhero();
		if( engine.varexist(s) )	<s>.skipitem();
		<sbut>.lrel();
		this.< <sbut>.getbutname() + "_RELEASE">();
	}
	advmsclick()	{
		if( !bmslock )	{
			|int x, int y| = mouse.getpos();
			int id = grbuts.isin(x,y,true,true);
			( id ) ? this.butclickon(grbuts.get(id-1)) : clwalkq.goto(x,y);
			grmslclick.eval2("onmouselclick",x,y);
		}
		this.behrewind();
		moddbg.mslclick();
	}
	advmslrel() {
		if( !bmslock )	{
			|int x, int y| = mouse.getpos();
			int id = grbuts.isin(x,y,true,true);
			if( id )	this.butrelease(grbuts.get(id-1));
			grmslrel.eval2("onmouselrel",x,y);
		}
		moddbg.mslrel();
	}
	mousemove()	{
		this.advmsmove();
		this.mouse_MOVE();
	}
	mouselclick()	{
		this.advmsclick();
		this.mouse_LCLICK();
	}
	mouselrel()	{
		this.advmslrel();
		this.mouse_LREL();
	}
	mouserclick()	{
		this.mouse_RCLICK();
	}
	keydown()	{
		moddbg.dbkeydown();
		this.keyboard_KEYDOWN();
	}
	exit()	{
		modadvglob.onexit();
	}
}


module moddbg : classlocker	{
	init()	{
		classlocker::init();
		new string sstate = "init";
		new int ilastx;
		new int ilasty;
		new text txtpos;
		txtpos.setz(5000);
		txtpos.setpos( 0, 0 );
		txtpos.setbkg(0,0,64,16, 0,0,0,192);
		
		new text txtswin;
		txtswin.setz(5000);
		txtswin.setbkg(0,0,64,16, 0,0,0,192);

		new text txtpod;
		txtpod.setz(5000);
		txtpod.setbkg(0,0,128,16, 0,0,0,192);

		this.disable();

	}
	public enable()	{
		this.unlock();
		txtpos.show();
		txtswin.show();
		txtpod.show();
	}
	public disable()	{
		this.lock();
		txtpos.hide();
		txtswin.hide();
		txtpod.hide();
	}
	public updatetxtpos(int x, int y)	{
		txtpos.set("" + ( x-clcamera.getposx() ) + "," + ( y-clcamera.getposy() ));
		txtpos.setpos(x-32,y+46);
		txtpod.setpos(x-64,y+30);
		txtpod.set( engine.getimg(x,y,true,true,-1000,1000));
	}
	public updateswin()	{
		txtswin.set(" " + (swinka.getposx()-clcamera.getposx()) + "," + (swinka.getposy()-clcamera.getposy()) );
		txtswin.setpos( swinka.getposx()-32, swinka.getposy() );
	}
	msminit(int x, int y)	{	this.updatetxtpos(x,y);	}
	msmmove(int x, int y)	{
		clcamera.moveplans(x-ilastx, y-ilasty);
		this.updatetxtpos(x,y);
	}
	public msmove()	{
		if( this.getlock()==true )	{	return;	}
		int x = mouse.getpx();
		int y = mouse.getpy();
		this.<"msm"+sstate>(x,y);
		ilastx=x;
		ilasty=y;
	}
	public mslclick()	{
		if( this.getlock()==true )	{	return;	}
		if( keyboard.iskeydown("space")==true )	{
			sstate="move";
		}
	}
	public mslrel()	{
		if( this.getlock()==true )	{	return;	}
		sstate = "init";
	}
	msrclick()	{
		int x = mouse.getpx();
		int y = mouse.getpy();
		int id = grbuts.isin(x,y,true,true);
		if( id!=false )	{
			string s = grbuts.get(id-1);
			s.print();
		} 
//		txtpod.set( engine.getimg(x,y,true,true,-1000,1000));
	}
	dbkeydown(){
		if( keyboard.iskey("d")==true )	{
			if(this.getlock()==true)	{
				this.enable();
			} else {
				this.disable();
			}
		}
		if( this.getlock()==true )	{	return;	}
		if( keyboard.iskey("s")==true )	{
			this.updateswin();
		}
		if( keyboard.iskey("z")==true )	{
			sgmlastscene = gameapi.getgamename();
			<sgmlastscene>.savescene();
			gameapi.play("gamezajezdnia");
		}

	}
}

/***************************************************************************/
class classplacepointer	{
	init()	{
		new anima anpointer;
		anpointer.addmethod("onfinish", func { this.play(-1); } );
		new int _iz = 1000;
	}
	public load(string sfile)	{
		anpointer.load(sfile);
		this.setz(_iz);
		anpointer.hide();
	}
	public setz(int iz)	{
		_iz = iz;
		anpointer.setz(iz);
	}
	public stop()	{	anpointer.stop(false);	}
	public stoph()	{	anpointer.stop(false);	anpointer.hide();	}
	public show(int x, int y, string sdir)	{
		anpointer.setpos(x,y);
		anpointer.play(sdir);
	}
	move(@x, @y)	{	anpointer.move(x,y);	}
	public showob(string sob, string sdir)	{	this.show(<sob>.getcx(), <sob>.getcy(), sdir);	}
	public showu(int x, int y)	{	this.show(x,y,"uu");	}
	public showd(int x, int y)	{	this.show(x,y,"dd");	}
	public showr(int x, int y)	{	this.show(x,y,"rr");	}
	public showl(int x, int y)	{	this.show(x,y,"ll");	}
	public showru(int x, int y)	{	this.show(x,y,"ru");	}
	public showrd(int x, int y)	{	this.show(x,y,"rd");	}
	public showld(int x, int y)	{	this.show(x,y,"ld");	}
	public showlu(int x, int y)	{	this.show(x,y,"lu");	}
}

/***************************************************************************/

class classfadeinout		{
	init()	{
		new timer timf;
		new string _sob;
		new int _istep;
		new int _ival;
		new int _ib1;
		new int _ib2;
		new string _sfun;
		new string _sfunfin;
		timf.addmethod("onfinish", "_ctimffin");
	}
	/***************\/\/\/\/\/ wewnetrzne \/\/\/\/\/\/************************************/
	_cfinito(int v)	{
		<_sob>.<_sfun>( v );
		if( _sfunfin!=null)	this.<_sfunfin>();
	}
	_ctimffin()	{
		_ival+=_istep;
		if( _ival >= _ib2 )	{
			this._cfinito( _ib2 );
		} else if( _ival<=_ib1 )	{
			this._cfinito( _ib1 );
		} else {
			<_sob>.<_sfun>( _ival );
			this.play();
		}
	}
	_play( int icycle, int istep, string sob, string sfun, int ib1, int ib2, string sfun2 )	{
		_sfunfin = sfun2;
		_ib1 = ib1;
		_ib2 = ib2;
		int i = istep.abs();
		if( icycle <= 0 || i==ib1 || i>ib2 )	return;
		_sfun = sfun;
		timf.setcycle( icycle );
		_sob = sob;
		if( istep>0 )	_ival = _ib1;
		else if( istep<0 )	_ival=_ib2;
		else return;
		<sob>.<sfun>( _ival );
		_istep = istep;
		timf.play();
	}
	/******************* /\/\/\/\/\/\/\ wewnetrzne /\/\/\/\ ****************************/
	imgtransparency(int icycle, int istep, string simg, string sfun)	{
		this._play( icycle, istep, simg, "transparency", 0, 255, sfun );
	}
	setopacity(int icycle, int istep, string simg, string sfun)	{
		this._play( icycle, istep, simg, "setopacity", 0, 255, sfun );
	}
	sndvolume(int icycle, int istep, string ssnd, string sfun)	{
		this._play( icycle, istep, ssnd, "setvol", 0, 100, sfun );
	}
	/***************************************************/
}

class classadvkleo : classadv	{
	init()	{
		igmstate = 0;
		classadv::init();
		this.setwavpath("sounds/kleolicz/");
		this.newsnd("sfxgetitem", "sfx/getitem.wav");
		bsms.setstd();		// ustawia standardowo 
		//clmusic.play();
		//clbuts.reset();
	}
	exit()	{
		bsms.setstd();
	}
	/*cloadterrain(string spath, string sbkg, string ster)	{
		this.setgraphpath( spath );
		this.csetbkg( sbkg );	
		this.cloadbgelem( ster );
	}*/
	/***********************************************************/
	mbuildmask(string sstr, string sact, string sname)	{
		this.caddelemtomask("clm", sstr, sact, sname, "mclickmask");
	}
	/***********************************************************/
	advclick()	{
		if(igmstate==0 || igmstate==5)	{
			if(igmdebug==true)	{
				this.cactsndstop(true);
			}
		} else if(igmstate==1)	{
			//ptpiast.goto( mouse.getpx(), mouse.getpy() );
		}
	}
	/***********************************************************/
	keydown()	{
		if( igmdebug==false )	{	return;	}
		if( keyboard.iskey("p")==true )	{
			clpause.pause();
		} else if( keyboard.iskey("escape")==true )	{
			claskexit.askexittomenu();
		} else {
// 			clnextgm.checkkey();
		}
	}
	/***********************************************************/
}



/*
	templaty do bajek 17.II.2006
	
*/

class Tclassopowiesc	{
	init()	{}
	/******************** wewnetrzne ***********************/	
	public tinit(string spath, string sbimg, string sbsnd, int z, int ibazaimg, int iendimg,  int ibazasnd)	{
		int ilescen = iendimg - ibazaimg + 1;
		new int iinstate = 1;		// stan programu
		new img img1;
		new img img2;
		new int iwidok = 1;		// aktualnie odgrywana scena
		new int iilescen = ilescen;		// ilosc scenek do odegrania
		new bool bprzewijana = false;	//  czy sa strzalki przewijania
		new int irodzajp;		//  rodzaj przechodzenia miedzy scenami
		new string simg1 = "img1";
		new string simg2 = "img2";
		new int ibajkaz = z;
		new int iclipw = 800;
		new int icliph = 600;
		new int ibasesnd = ibazasnd-1;
		new int ibaseimg = ibazaimg-1;
		
		new int ileft = 0;
		new int iup = 0;
		
		new string sbaseimg = spath + sbimg;
		new string sbasesnd = sbsnd;
		
		new snd sndpop;
		sndpop.addmethod("onfinish", "mfinpop");
		this.mloadsnd();
		
		this.setgraphpath( spath );
		img1.load( sbaseimg + (iwidok+ibaseimg) + ".png" );
		img1.setz( ibajkaz );
		this.tmodenormal();
	}
	public tmodenormal()	{
		irodzajp=0;
	}
	public tmodeopacity(int ic, int idop)	{
		irodzajp=1;
		new classfadeinout clfio;
		new int iopacityc = ic;
		new int iopacityd = idop;
	}
	public tmoderewind(int step)	{
		irodzajp=2;
		new string sside;
		new gmobjvec grimgs;
		grimgs.add("img1");
		grimgs.add("img2");
		new int istep = step;
		new int imovy = -istep;
		this.cnewtimercyclefin("timrew", 1, 1, "mfintimrew");
		timrew.addmethod("onstart", "mrewstart");
	}
	public tmodezoom(real skala)	{
		irodzajp=3;
		new real rskala = 1;
		new real rstepskala = skala;
		new filter ftimg;
	}
	public tsetpos(int x, int y, int x2, int y2)	{
		ileft=x;
		iup=y;
		iclipw = x2;
		icliph = y2;
		<simg1>.setpos( ileft, iup );
	}
	public tloadbuttons(string sfile, string scurs, string sfuncmove)	{
		bprzewijana = true;
		this.newclbut("clb", sfile, 100, scurs);
		clb.clickfunc("mbutclick");
		clb.movonfunc( sfuncmove );
	}
	public tstart()	{
		this.msndplay();
	}
	public tfinish()		{}
	/******************/
	mrewstart()	{
		//sndrew.play();
	}
	mrewtick()	{
		grimgs.move( imovy, 0 );
		this.play();
	}
	mfintimrew()	{
		if( imovy < 0 )	{
			if( <simg1>.getpx() + imovy > ileft )	{
				this.mrewtick();
			} else {
				<simg1>.setpos( ileft, iup );
				<simg2>.hide();
				this.msndplay();
			}
		} else {
			if( <simg1>.getpx() + imovy < ileft )	{
				this.mrewtick();
			} else {
				<simg1>.setpos( ileft, iup );
				<simg2>.hide();
				this.msndplay();
			}
		}
	}
	mfinclfio()	{
		this.msndplay();
// 		<simg2>.transparency(255);
// 		<simg1>.transparency(255);
		<simg2>.hide();
		<simg2>.setz( ibajkaz );
	}
	msndplay()	{
		iinstate = 0;
		this.cbplay("sndpop");
	}
	mloadsnd()	{
		sndpop.load(this.getsndpath()+sbasesnd + (iwidok+ibasesnd)+".wav");
	}
	//mbutmovon(string s)	{}
	mbutclick(string s)	{
		if( iinstate != 0 )	{	return; 	}
		if(s=="next")	{
			this.mnext(1);
		} else if (s=="prev")	{
			this.mnext(-1);
		} else if (s=="play")	{
			clpause.pause();
		} 
	}
	mnext(int idir)	{
		int id = iwidok + idir;
		if( id > 0 && id <= iilescen )	{
			iwidok = id;
			iinstate=1;
			this.mloadsnd();
			<simg2>.load( sbaseimg+(iwidok+ibaseimg)+".png" );
			<simg2>.clip( ileft, iup, iclipw, icliph );
			<simg2>.setz( ibajkaz );
			if( irodzajp == 0 )	{
				<simg2>.setpos( ileft, iup );
				<simg1>.hide();
				this.msndplay();
			} else if( irodzajp == 1 )	{
				<simg2>.setpos( ileft, iup );
				<simg2>.setz( ibajkaz-1 );
				<simg1>.setz( ibajkaz );
				clfio.imgtransparency( iopacityc, iopacityd, simg1, "mfinclfio");
			} else if( irodzajp == 3 )	{		// na razie brak
				<simg2>.setpos( ileft, iup );
			} else if( irodzajp==2 )	{
				<simg1>.show();
				<simg2>.show();
				if( idir<0 )	{
					<simg2>.setpos( <simg1>.getpx() - <simg2>.getw(), iup );
					imovy = istep;
				} else if (idir>0) {
					<simg2>.setpos( <simg1>.getex(), iup );
					imovy = -istep;
				}
				timrew.play();
			}
			string s = simg1;
			simg1 = simg2;
			simg2 = s;
		}
	}
	mfinpop()	{
		if( iwidok<iilescen )	{
			this.mnext(1);
		} else if (iwidok==iilescen)	{
			this.tfinish();
		}
	}
}


new classgamepause clpause;
new snd sndaskermovon;

game main : newvars {
	init()	{
		newvars::init();
		
		igmstate = 0;
		
		| igmdebug, igmeasy, igmdemo | = true, false, false;
		
		advmouse.load("scripts/common/cursors.pyz");
		modadv.load("scripts/common/defaults.adv");
		modadv.loadsounds("scripts/common/sounds2.db");
		sgmlastscene = this.getname();
		
		modadv.settalktype("snd");
		modadv.loadscript("scripts/common/initscript.dsc");
		
// 		sndaskermovon.load("sounds/kleolicz/sfx/butmovon.wav");
		sndaskermovon.load("sounds/kleolicz/sfx/globbutmovon.wav");
		
		clsave.load("saves/global.txt");
		
		gameapi.play(modadv.get("startgame:",1) );
		
// 		gameapi.play("gametmp2");
		
		/*new A a1;
		new A a2;
		a2.set(-100, -200);
		new A a4 .= "a1";
		a1 .= "a2";
		
		new A a3 .= "a1" .+ "a2" .- "a4";

		a1.print();
		a2.print();
		a3.print();
		a4.print();
		_ = "a1" .+ "a2";
		a1.print();*/
	}
}

class A	{
	init()	{
		new int i1 = 5;
		new int i2 = 10;
	}
	set(int i, int j)	{i1=i;i2=j;	}
	get()	{	return i1,i2;	}
	operator=(string sob)	{
		this.set(<sob>.get());
	}
	operator+(string sob)	{
		i1 += <sob>.varget("i1");
		i2 += <sob>.varget("i2");
		return this.getname();
	}
	operator-(string sob)	{
		i1 -= <sob>.varget("i1");
		i2 -= <sob>.varget("i2");
		return this.getname();
	}
	print()	{
		engine.print(this.getname()+": "+i1+" "+i2);
	}
}

game gametmp1 : classadv	{
	init()	{
		classadv::init();
		this.setgraphpath("scripts/tmp/");
		new Script script("scripts/tmp/tmp.dsc");
	}
	mouselclick()	{
		gameapi.exit();
	}
}

game gametmp2 : classadvcontroller {
	init()	{
		//public playfromscript(string spath, string sgame)	{
		sgmglobpath = "przeddomek";
		sgmgame = "gameprzeddomek0";
		classadvcontroller::init();
		this.setgraphpath("scripts/tmp/");
		new classdzoj dzoj("joy.pyz");
		ankleo.stop(false);
		ankleo.hide();
		this.advmsunlock();
	}
// 	onmousemove(int x, int y)	{
// 		engine.print("msmove error");
// 	}
}

gameapi.play("main");
game gamemenu : classadvkleo	{
	init()	{
		classadvkleo::init();

		this.setgraphpath("scripts/menu/");
		this.cstdbkg();

		this.newsnd("sndwyjscie", "nar04.wav");
		this.newsnd("sndgra", "nar02.wav");
		this.newsnd("sndload", "nar03.wav");
		
		this.newclbut("clb", "buts.pyz", 10, "imglobcurs");
		clb.clickfunc("gmbutclick");
		clb.movonfunc("gmbutmove");
	}
	gmbutmove(string s)	{
		sndaskermovon.play();
		if(s=="exit")	{
			this.crselfplay("sndwyjscie");
		} else if (s=="gra")	{
			this.crselfplay("sndgra");
		} else if (s=="load")	{
			this.crselfplay("sndload");
		} else {
			engine.print("cos innego: " + s);
		}
	}
	gmbutclick(string s)	{
		if(s=="exit")	{
			gameapi.exit();
		} else if (s=="gra")	{
			clsave.setfile("saves/last.txt");
			clsave.stdload();
			sgmglobpath = "mapa";
			sgmgame = "gamemapa1";
			gameapi.play( modadv.get("defaultadv:",1) );
		} else if (s=="load")	{
			gameapi.play("gameload");
		} else {
			engine.print("cos innego: " + s);
		}
	}
}

game gameintro : classadvkleo	{
	init()	{
		classadvkleo::init();
		this.setgraphpath("scripts/intro/");
		this.csetbkg("bkg2.png");
		new int iileanimas = this.loadanframes("annap", "napisy.pyz", 0, 10);
		this.chideanimas("annap", iileanimas );
		this.cnewsndsfin("sndin", 1, "intro", 1, 3, "mfinsnd");
		annap0.show();
		sndin1.play();
	}
	mfinsnd1()	{	sndin2.play();	annap1.show();	}
	mfinsnd2()	{	sndin3.play();	annap2.show();	}
	mfinsnd3()	{
		clsave._bset("introfirsttime");
		clsave.save("saves/global.txt");
		clsave.stdload();
		gameapi.play("gamemenu");
	}
	mouselclick()	{
		if( clsave._bis("introfirsttime") )	{
			gameapi.play("gamemenu");
		}
	}
}




/****************************************************/
game gamedefadv : classadvcontroller	{
	init()	{
		classadvcontroller::init();
	}
}

/****************************************************/
new int iOpowiescFrom;
new int iOpowiescTo;
new string sGameFromOpowiesc;
game gameopowiesc : classadvkleo, Tclassopowiesc	{
	init()	{
		classadvkleo::init();
		Tclassopowiesc::init();
		
		sgmlastscene = this.getname();
		
		this.tinit("scripts/intro/", "intro", "nar_", 3, iOpowiescFrom, iOpowiescTo, iOpowiescFrom+1);
		this.tsetpos(169, 117, 169+462, 117+354);
  		this.tmodeopacity(1, -10);
		this.cstdbkg();
		imgbkg.setz( 20 );
		this.tstart();
	}
	tfinish()			{	gameapi.play( sGameFromOpowiesc );		}
	mouselclick()	{	if( igmdebug )	this.cactsndstop(true);	}
	mouserclick()	{	if( igmdebug )	this.tfinish();			}
}


class classplacepointer2 : classplacepointer	{
	init()	{
		classplacepointer::init();
		this.load("scripts/common/strzalka.pyz");
	}
}

game gamerece1 : classadvkleo	{
	init()	{
		classadvkleo::init();
		this.setgraphpath("scripts/rece/");
		new classquickdialog clqd;
		new classquickanloader clqa;
		new vector vecrece;
		vecrece.type("int");
		new vector vecrece2;
		vecrece2.type("int");
		
		new classplacepointer2 clpt;
		new string slastdial;
		new int ilevel = 1;
		new int iporownaj = 1;
		new string smoved=null;
		new int icyfx;
		new int icyfy;
		
		clqd.load("dialogi.dlg");
		clqa.load("scena.ans");
		this.cloadwavs("dbwav", "wavs.db");
		
		ancyfra.eval("anresizemets");
		igmstate = 1;
		new int ilaststate = igmstate;
		
		clqd.play("start");
	}
	viewhand(int x, int ic)	{
		string s = "anreka"+ic;
		<s>.setpos(x, 400);
		<s>.show();
	}
	viewcyfra(int x, int ic)	{
		string s = "ancyfra"+ic;
		<s>.setcpos(x,500);
		<s>.show();
	}
	viewoba(int x, int ic)	{
		this.viewcyfra(x,ic);
		this.viewhand(x,ic);
	}
	prepareview(int ile, int ileview, int id)	{
		vecrece.free();
		vecrece2.free();
		for( int i=0; i<ile; i++)	{
			if( i!=id)	{	vecrece2.add(i);	}
		}
		vecrece2.hash();
		vecrece.add(id);
		
		for( i=0; i<ileview-1; i++ )	{
			vecrece.add( vecrece2.get(i) );
		}
		vecrece.hash();
		
		this.hideall();
	}
	hideall()	{
		anreka.hide();
		ancyfra.hide();
	}
	showview(int ile)	{
		int dx = 800/(ile+1);
		for( int i=0; i<ile; i++)	{
			this.viewoba(dx,i);
			dx += <"anreka"+i>.getw();
		}
	}
	stdparaview(int id)	{
		<"ancyfra"+id>.setframe(0,id);
		<"anreka"+id>.setframe(0,id);
	}
	startview(int ileprepare, int ileview, int ijaka, int isort)	{
		if( isort==1 )	{		// szukamy prawidlowej pary
			ijaka = ijaka.rand(ijaka+1);	// losuj z dotychczas poznanych
		}
		if( isort==2 )	{
			vecrece.free();
			vecrece.beginadd("begin", 0, 1, 2, 1);
		} else {		// losowana kolejnosc i sklad
			this.prepareview(ileprepare, ileview, ijaka);
		}
		string s[2], int id;
		for( int i=0; i<ileview; i++)	{
			s0 = "anreka"+i;
			s1 = "ancyfra"+i;
			id = vecrece.get(i);
			if( isort==0 )	{		// reka=cyfra
				<s0>.setframe(0,id);
				<s1>.setframe(0,id);
			} else if (isort==1)	{	// jedna para prawidlowa
				if( id==ijaka )	{
					<s0>.setframe(0,id);
					<s1>.setframe(0,id);
				} else {
					id = id.randdiff(ileprepare,ijaka);
					<s0>.setframe(0,id);
					<s1>.setframe(0,id.randdiff(ileprepare,id));
				}
			} else if (isort==2)	{
				<s0>.setframe(0,id);
				if( id==2 )	{	<s1>.setframe(0,1);	}
				else {	<s1>.setframe(0,id);	}
			}
		}
		this.showview(ileview);
	}
	pointobj(string sob, string sdir)	{	clpt.show(<sob>.getcx(), <sob>.getcy(), sdir);	}
	pointpos(int x, int y, string sdir)	{	clpt.show(x,y,sdir);	}
	pointreka(int id, int dx, string sdir)	{
		string s = "anreka"+id;
		clpt.show(<s>.getposx(), <s>.getpy()+dx, sdir);
	}
	resetstate()	{
		ilaststate = igmstate;
		igmstate = 1;
	}
	retstate()	{	igmstate=ilaststate;	}
	startview2()	{
		if( iporownaj>7 )	{
			cpok.stop(false);
			this.hideall();
			this.udalo();
		} else {
			this.hideall();
			vecrece.free();
			if( iporownaj==1 )	{vecrece.beginadd("begin", 0,1);}
			else if( iporownaj==2 )	{vecrece.beginadd("begin", 1,3);}
			else if( iporownaj==3 )	{vecrece.beginadd("begin", 0,1,2);}
			else if( iporownaj==4 )	{vecrece.beginadd("begin", 0,1,3);}
			else if( iporownaj==5 )	{vecrece.beginadd("begin", 1,2,3);}
			else if( iporownaj==6 )	{vecrece.beginadd("begin", 0,1,2,3);}
			else if( iporownaj==7 )	{vecrece.beginadd("begin", 2,1,2,3);}
			iporownaj++;
			vecrece.hash();
			for( int i=0; i<vecrece.size(); i++)	{
				<"anreka"+i>.setframe(0,vecrece.get(i));
				<"ancyfra"+i>.setframe(0,vecrece.get(i));
			}
			this.showview(vecrece.size());
		}
	}
	bool goodchoice()	{
		int id = anreka.isin(mouse.getpx(),mouse.getpy(),true,true) - 1;
		if( id>=0 )	{
			vecrece.sort(true);
			if( vecrece.veclast() == <anreka.get(id)>.framenr() )	{return true;	}
		}
		return false;
	}
	/************************************/
	clqdwkret_12_START()	{
		anreka0.setframe(0,5);
		this.viewhand(400,0);
		this.pointreka(0, 50, "lu");
	}
	clqdwkret_12_2_START()	{
		anreka0.setframe(0,0);
		this.viewhand(400,0);
		this.pointreka(0, 50, "lu");
	}
	clqdwkret_12_FINISH()	{	clpt.stoph();	}
	clqdwkret_12_2_FINISH()	{	clpt.stoph();	}
	clqdwkret_14_START()	{	this.viewcyfra(400,0);	}
	clqdwkret_15_START()	{	this.pointobj("ancyfra0","ld");	}
	clqdwkret_15_FINISH()	{	clpt.stoph();	}
	clqdstart_FINISH()	{	clqd.play("level1");	}
	
	clqdlevel1_START()	{	this.startview(5,3,0,0);	}
	clqdlevel1_FINISH()	{	igmstate=2;	}
	clqdlevel2_START()	{	this.startview(5,3,0,0);	}
	clqdlevel2_FINISH()	{	igmstate=3;	}
	clqdlevel3_START()	{	this.startview(5,3,0,1);	}
	clqdlevel3_FINISH()	{	igmstate=4;	}
	
	clqdlevel4_START()	{	this.hideall();	}
	clqdwkret_23_START()	{
		this.stdparaview(1);
		this.viewhand(400,1);
		this.pointreka(1, 60, "ru");
	}
	clqdwkret_23_2_START()	{
		this.viewcyfra(400,1);
		this.pointobj("ancyfra1","dd");
	}
	clqdlevel4_FINISH()	{
		clpt.stoph();
		this.clqdoki_FINISH();
	}
	
	clqdlevel5_START()	{	this.startview(5,3,1,0);	}
	clqdlevel5_FINISH()	{	igmstate=5;	}
	clqdlevel6_START()	{	this.startview(5,3,1,0);	}
	clqdlevel6_FINISH()	{	igmstate=6;	}	
	clqdlevel7_START()	{	this.startview(5,3,1,1);	}
	clqdlevel7_FINISH()	{	igmstate=7;	}
	clqdlevel8_START()	{
		this.hideall();
	}
	clqdwkret_27_START()	{
		this.stdparaview(1);
		this.viewhand(290,1);
		this.stdparaview(2);
		this.viewhand(510,2);
	}
	clqdwkret_28_START()	{
		this.hideall();
		this.viewhand(400,2);
		this.pointreka(2, 100, "rr");
	}
	clqdwkret_28_2_START()	{
		this.viewcyfra(400,2);
		this.pointobj("ancyfra2","rd");
	}
	clqdlevel8_FINISH()	{
		clpt.stoph();
		this.clqdoki_FINISH();
	}
	clqdlevel9_START()	{	this.startview(6,4,2,0);	}
	clqdlevel9_FINISH()	{	igmstate=9;	}
	clqdlevel10_START()	{	this.startview(6,4,2,0);	}
	clqdlevel10_FINISH()	{	igmstate=10;	}
	clqdlevel11_START()	{	this.startview(6,4,2,2);	}
	clqdlevel11_FINISH()	{	igmstate=11;	}
	clqdwkret_33_START()	{
		this.hideall();
		this.stdparaview(3);
		this.viewhand(400,3);
		this.pointreka(3, 300, "uu");
	}
	clqdwkret_34_START()	{
		clpt.stoph();
		this.hideall();
		this.stdparaview(2);
		this.viewhand(290,2);
		this.stdparaview(3);
		this.viewhand(510,3);
	}
	clqdwkret_35_START()	{
		this.hideall();
		this.viewhand(400,3);
		this.viewcyfra(400,3);
		this.pointobj("ancyfra3","ld");
	}
	clqdkomentdo11_FINISH()	{
		clpt.stoph();
		this.clqdoki_FINISH();
	}
	clqdlevel12_START()	{	this.startview2();	}
	clqdlevel12_FINISH()	{	igmstate=12;	}
	clqdlevel13_START()	{
		this.hideall();
		vecrece.vecnewint(4);
		vecrece.hash();
		vecrece2.vecnewint(4);
		vecrece2.hash();
		string s, int dx = 100;
		for( int i=0; i<4; i++)	{
			s = "anreka"+i;
			<s>.setframe(0,vecrece.get(i));
			<s>.show();
			<s>.setpos(dx,400);
			dx+=<s>.getw();
			s = "ancyfra"+i;
			<s>.setframe( 0, vecrece2.get(i) );
			<s>.show();
			<s>.setpos((i+1)*150, 520);
		}
	}
	clqdlevel13_FINISH()	{
		cpok.reset();
		igmstate = 13;	
	}
	clqdwkret_39_START()	{	this.hideall();	}
	clqdkomentdo13_FINISH()	{
		cpok.reset();
		igmstate=14;
		vecrece.vecnewint(4);
		vecrece.hash();
		iporownaj=0;
		string s;
		for( int i=0; i<4; i++)	{
			s = "ancyfra"+i;
			<s>.setframe( 0, i );
			<s>.show();
			<s>.setpos(700, 150+i*110);
		}
		this.pokalapkie();
	}
	clqdlevel14_START()	{	}
	clqdlevel14_FINISH()	{
		cplicz.playid( vecrece.get(iporownaj) );
	}
	_cpliczfin()	{	igmstate=15;	}
	
	clqdlevel15_START()	{	}
	clqdlevel15_FINISH()	{
		igmstate=16;
		this.pokacyfke();
	}
	pokacyfke()	{
		ancyfra0.setframe(0,vecrece.get(iporownaj));
		this.viewcyfra(400,0);
	}
	
	clqdfinito_START()	{	this.hideall();	}
	clqdfinito_FINISH()	{
		this.finishgame();
	}
	
	clqdoops_START()	{
		slastdial = clqd.getprevdialog();
		this.resetstate();
	}
	clqdoops_FINISH()	{
		this.retstate();
		clqd.play(slastdial);
	}
	clqdoki_START()	{
		this.resetstate();
	}
	clqdoki_FINISH()	{
		ilevel++;
		clqd.play("level"+ilevel);
	}
	nieudalo()	{	clqd.play("oops");	}
	udalo()	{	clqd.play("oki");	}
	/************************************/
	int _getid(string sob)	{
		int id = <sob>.isin(mouse.getpx(),mouse.getpy(),true,true) - 1;
		if( id>=0 )	{
			return <<sob>.get(id)>.framenr();
		}
		return -1;
	}
	int _getidob(string sob)	{
		int id = <sob>.isin(mouse.getpx(),mouse.getpy(),true,true) - 1;
		if( id>=0 )	{
			string s = <sob>.get(id);
			return s.strsubbs(sob);
		}
		return -1;
	}
	int getcyfra()	{	return this._getid("ancyfra");	}
	int getreka()	{	return this._getid("anreka");	}
	msprawdz(string san, int iv)	{
		if( this._getid("an"+san)==iv )	{	this.udalo();	}
		else {	this.nieudalo();	}
	}
	msprawdzpare()	{
		int id = this._getidob("anreka");
		if( id==-1 )	{	id=this._getidob("ancyfra");	}
		if( id!=-1 )	{
			if( <"anreka"+id>.framenr()==<"ancyfra"+id>.framenr() )	{
				this.udalo();
			} else {	this.nieudalo();	}
		}else {
			this.nieudalo();
		}
	}
	mouselclick()	{
		if( igmdebug==true )	{
			clqd.stop(true);
		}
		int id;
		if( igmstate==2 )	{	this.msprawdz("reka",0);	}
		else if( igmstate==3 )	{	this.msprawdz("cyfra",0);	}
		else if( igmstate==4 )	{	this.msprawdzpare();	}
		else if( igmstate==5 )	{	this.msprawdz("reka",1);	}
		else if( igmstate==6 )	{	this.msprawdz("cyfra",1);	}
		else if( igmstate==7 )	{	this.msprawdzpare();	}
		else if( igmstate==9 )	{	this.msprawdz("reka",2);	}
		else if( igmstate==10 )	{	this.msprawdz("cyfra",2);	}
		else if( igmstate==11 )	{
			if( this._getid("anreka")==2 )	{
				this.resetstate();
				clqd.play("komentdo11");	
			} else {	this.nieudalo();	}
		} else if (igmstate==12)	{
			if( this.goodchoice()==true )	{
				cpnon.stop(false);
				cpok.play();
				this.startview2();	
			}else {	this.crplay("cpnon");	}
		} else if (igmstate==13)	{
			this.preparemover( this._getidob("ancyfra") );
		} else if (igmstate==14)	{
			if( this.getcyfra()==anreka0.framenr() )	{
				iporownaj++;
				if( iporownaj>=vecrece.size() )	{
					this.cactsndstop(false);
					cpok.reset();
					vecrece.vecnewint(4);
					vecrece.hash();
					iporownaj=0;
					this.hideall();
					string s;
					for( id=0;id<4; id++)	{
						s = "ancyfra"+id;
						<s>.setframe( 0, id );
						<s>.show();
						<s>.setpos((id+1)*150, 320);
					}
					this.udalo();
				} else {
					this.cbplay("cpok");
					this.pokalapkie();
				}
			} else {
				this.crplay("cpnon");
			}
		} else if (igmstate==15)	{
			if( this.getcyfra()==vecrece.get(iporownaj) )	{
				iporownaj++;
				if( iporownaj>=vecrece.size() )	{
					this.cactsndstop(false);
					cpok.reset();
					vecrece.vecnewint(4);
					vecrece.hash();
					iporownaj=0;
					this.hideall();
					string s, int dx=100;
					for( id=0;id<4; id++)	{
						s = "anreka"+id;
						<s>.setframe( 0, id );
						<s>.show();
						<s>.setpos(dx, 400);
						dx+=<s>.getw();
					}
					this.udalo();
				} else {
					this.cbplay("cpok");
				}
			} else {
				this.crplay("cpnon");
			}
		} else if (igmstate==16)	{
			if( this.getreka()==vecrece.get(iporownaj) )	{
				iporownaj++;
				if( iporownaj>=vecrece.size())	{
					this.cactsndstop(false);
					this.resetstate();
					clqd.play("finito");
				} else {
					this.cbplay("cpok");
				}
			} else {
				this.crplay("cpnon");
			}
		}
	}
	_cpokfin()	{
		if( igmstate==15 )	{
			ilevel--;
			this.udalo();
		} else if (igmstate==16)	{
			this.pokacyfke();
		}
	}
	pokalapkie()	{
		anreka0.setframe(0,vecrece.get(iporownaj));
		this.viewhand(400,0);
	}
	preparemover(int id)	{
		if( id!=-1)	{
			smoved = "ancyfra"+id;
			icyfx = <smoved>.getposx();
			icyfy = <smoved>.getposy();
			<smoved>.mssaverelpos();
		}
	}
	mouselrel()	{
		if( smoved!=null )	{
			if( igmstate==13)	{
				int id = this._getid("anreka");
				if( id!=-1 )	{
					if( <smoved>.framenr()==id )	{
						this.cbplay("cpok");
						<smoved>.hide();
					} else {
						this.crplay("cpnon");
					}
				}
				<smoved>.setpos(icyfx, icyfy);
				smoved=null;
				for( id=0; id<4; id++)	{
					if( <"ancyfra"+id>.isvisible()==true )	{
						return;
					}
				}
				this.resetstate();
				this.cactsndstop(false);
				clqd.play("komentdo13");	
			}
		}
	}
	mousemove()	{
		if( smoved!=null )	{
			<smoved>.mssetrelpos();
		}
	}
	finishgame()	{
		sgmlastscene = gameapi.getgamename();
		sgmglobpath = "domek";
		sgmgame = "gamedomek2";
		gameapi.play( modadv.get("defaultadv:",1) );
	}
	mouserclick()	{
		if( igmdebug )	{
			this.finishgame();
		}
	}
}
/****************************************************/
class ObjPusher	{
	init()	{
		new real rp;	// droga
		new int icyc=0;
		new real ra;	// przyspieszenie
		new real rdiv=1;
	}
	set(real r, real a, real rd, int cyc)	{
		|rp,ra,rdiv,icyc| = r,a,rd,cyc;
		while(cyc<0)	{	a/=rd;cyc++;	}
	}
	bool next()	{
		rp+=ra;
		if(icyc<0)	{
			ra*=rdiv;
			icyc++;
		} else if(icyc>0){
			ra/=rdiv;
			icyc--;
		}
		return ( icyc==0 );
	}
	real get()		{	return rp;	}
	real geta()	{	return ra;	}
}

class classgamestaw : classadvcontroller	{
	init()	{
		classadvcontroller::init();
		new int ileticks = 3;
		
		ptankleo.disable(6);		ptankleo.disable(8);		ptankleo.disable(9);
		ptankleo.disable(11);	ptankleo.disable(13);
		
		anlilia.setframe(1,0);
		anlilie.eval("buildlil");
		anlilie.eval("lilpos");
		anlilia.buildlil();
		anlilia.liliapos();
		this.cnewtimercyclefin("timlil", 1, 1, "fintim");
		timlil.play();
	}
	buildlil()	{
		new int iside = 2;
		new int itick = itick.rand(ileticks);
		new ObjPusher ops;
		
		int it = it.rand(12);
		for(int i=0; i<it; i++)	this.setlil();
	}
	setlil()	{
		if( ops.next() )	{
			real ra = 1.2;
			real rd = 1.14;
			int it = 5;
			match(iside)	{
				0 => {ops.set(0,ra,rd,it); iside=1;}
				1 => {ops.set(0,-ra,rd,-it);iside=2;}
				2 => {ops.set(0,-ra,rd,it);
					this.setpos(0,0);
					iside=3;}
				3 => {ops.set(0,ra,rd,-it);iside=0;}
				?=>;
			}
		}
		this.move( ops.geta(), 0 );
	}
	lilpos()	{
		if( itick==0 )	{
			itick=ileticks-1;
			this.setlil();
		} else
			itick--;
	}
	liliapos()	{
		this.lilpos();
		anpanzab.setpos( this.getcx()+8, this.getcy()-7 );
	}
	fintim()	{
		anlilie.eval("lilpos");
		anlilia.liliapos();
		this.play();
	}
}

game gamestaw0 : classgamestaw	{
	init()	{	classgamestaw::init();	}
}
game gamestaw1 : classgamestaw	{
	init()	{
		classgamestaw::init();
		
	}
}
