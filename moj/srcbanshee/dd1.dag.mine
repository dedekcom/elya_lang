
new db dbconf;
dbconf.loadscript("configs/config.beh");

engine.setdebugstate( dbconf.dbgetint("enginedebug:") );

new int igmdebug = dbconf.dbgetint("igmdebug:");
new int igmpcdebug = dbconf.dbgetint("igmpcdebug:");
new int igmexportan = dbconf.dbgetint("igmexportan:");
new int igmimportan = dbconf.dbgetint("igmimportan:");
new int igmdelay = engine.getloopdelay;

/**************************************************************/
new int igmwinlocal = dbconf.dbgetint("igmwinlocal:");		// special folder windows
new int igmmac = dbconf.dbgetint("igmmac:");
new int igmipad = dbconf.dbgetint("igmipad:");
new int igmiphone = dbconf.dbgetint("igmiphone:");
new int igmandroid = dbconf.dbgetint("igmandroid:");

new string sgmdeveloper = dbconf.dbget("sgmdeveloper:");
new string sgmproject = dbconf.dbget("sgmproject:");

if( igmdebug && (igmipad||igmmac||igmiphone||igmandroid) )	{
	engine.addmethod("getsavepath", func { "saves/"; } );
}

public bool checktouchpad	{
	(igmipad || igmiphone || igmandroid) && igmpcdebug==0;
}

//---------------------- ekran ------------------------------

|new int igmappw, new int igmapph| = engine.getappsize;	// rozmiar
|new int igmoffsetx, new int igmoffsety| = engine.getscreenoffset;	// przesuniecie na wezszych od apki monitorach
|new int iResX, new int iResY| = engine.getscreensize;	// rozmiar gry po przeskalowaniu
|new real rgmscalex, new real rgmscaley| = engine.getscreenscale;

public def getappcenter	{
	return igmappw/2, igmapph/2;
}
public int edgeex	{	iResX+igmoffsetx;	}
public int edgeey	{	iResY+igmoffsety;	}
//------------------ sciezki --------------------

public string getwinpath(string spath)	{
	//("searching: " + spath)->print;
	string s = engine.getspecialpath("appdata");
	if( s!=null )	{
		s + "/" + sgmdeveloper + "/" + sgmproject + "/" + spath;
	} else spath;
}

public getsavepath	{
	if( igmipad || igmmac )	{
		engine.getsavepath;
	} else {
		(igmwinlocal ?  .getwinpath("saves/") :  "saves/");	
	}
}

public buildsavedir	{
	if( igmwinlocal && !igmipad && !igmmac )	{
		string s = engine.getspecialpath("appdata");
		if( s!=null )	{
			s += "/" + sgmdeveloper;
			int odp = engine.mkdir(s);
			odp = 0;
			if( odp==0 || odp==1 )	{
				s +=  "/" + sgmproject;
				odp = engine.mkdir(s);
				odp = 0;
				if( odp==0 || odp==1 )	{
					s+= "/saves";
					_ = engine.mkdir(s);
				}
			}
		}
	}
}
.buildsavedir;

/******** konstrukcje  ********************/
new string	A = "!!!";
new real		PI = 3.14159265358979323846;
new int		BYTE0 = "0"->getbyte(0);
new int		BYTE9 = "9"->getbyte(0);
new int		BYTEa = "a"->getbyte(0);
new int		BYTEz = "z"->getbyte(0);
new int		BYTEA = "A"->getbyte(0);
new int		BYTEZ = "Z"->getbyte(0);
new int		BYTE_ = "_"->getbyte(0);
new int		BYTESPACE = " "->getbyte(0);

public empty_func	{}

public varget(string svar)				{	[svar];				}
public varset(string svar, def val)			{	<svar> = val;			}
public varnew(string styp, string svar)			{	new <styp> <svar>;	}
public varnewif(string styp, string svar)		{	if( !.hasvar(svar) )	.varnew(styp,svar);}
public vardelif(string svar)				{	if( .hasvar(svar) )	.vardel(svar);		}
public vardel(string svar)				{	delete <svar>;		}
public reader(string sname)	{
	.varnewif("def", sname);
	.addmethod( sname, func { [.methodname]; } );
}
public writer(string sname)	{
	.varnewif("def", sname);
	.addmethod( sname+"=", func { (def val) <.methodname->strsube(1)> = val; } );
}
public var(string sname)	{
	.reader(sname);
	.writer(sname);
}
public var2(string sname, def val)	{
	.var(sname);
	<sname> = val;
}
public withlist(string sfun)	{
	@s = _;
	while( A != s )	{
		.<sfun>(s);
		@s = _;
	}
}
public withlist2(string sfun)	{
	@s = _;
	while( A != s )	{
		@s1 = _;
		.<sfun>(s1,s);
		@s = _;
	}
}
public vars	{	.withlist("var");}
public vars2	{	.withlist2("var2");}

/*****************************************************/
public builder_func(string sfun)	{
	<.getbuildername>.<.getbuildername+sfun>;
}
public callfun(string sob, string sfun)	{
	if( sfun!=null ) sob==null ? .<sfun> : <sob>.<sfun>;
}
public string add_callfun(string spref, string sob, string sfun)	{ <gameapi.getgamename> (spref, sob, sfun) { (@spref, @sob, @sfun)
	@s = spref + "_callfun_";
	.vars2(A, s+"sob",sob, s+"sfun",sfun);
	.addmethod(s, func {
		@s = .methodname;
		.callfun( [s + "sob"], [s + "sfun"] );
		} );
	s;
}; }
public string fullname_callfun(string sob, string sfun)	{
	.add_callfun(.getfullname, sob, sfun);
}
public dprint(string smsg)	{
	int d = engine.getstack;
	("stack=" + d + " : " +smsg)->print;
}
/*****************************************************/
public bool in	{
	bool b = false;
	@x = .get;
	@y = _;
	while( A != y )	{
		if( !b )	b = x==y;
		@y=_;
	}
	b;
}
public with(string sfun)	{
	string sob = _;
	while( sob!=A )	{
		<sob>.<sfun>();
		sob=_;
	}
}
public copycall(string sfun, string sob)	{
	string s = "__call" + sfun;
	new string <s>;
	<s> = sob;
	.addmethod( sfun, func {
		string sf = .methodname;
		< [ "__call" + sf ] >.<sf>();
		});
}
public copycalls(string sobj)	{
	string s = _;
	while( s!=A )	{
		.copycall( s, sobj ); 
		s=_;
	}
}
/***********************************/
public mresize()	{	< .gettype + "_pack">::resizemethods( this );	}
/******** petle ********************/
public times(string sfun)		{	this.for_plus(0, this.get()-1, sfun );		}
public upto(int ito, string sfun)	{	this.for_plus( this.get(), ito, sfun );	}
public downto(int ito, string sfun)	{	this.for_minus( this.get(), ito, sfun );	}
public for_plus(int ifrom, int ito, string sfun)	{
	if( ito-ifrom<=0 )	return;
	for( ; ifrom<=ito; ifrom++)	this.<sfun>(ifrom);
}
public for_minus(int ifrom, int ito, string sfun)	{
	if( ifrom-ito<=0 )	return;
	for( ; ifrom>=ito; ifrom--)	this.<sfun>(ifrom);
}
public double_for(int w, int h, string sfun)	{
	int j;
	for( int i=0; i<w; i++)	{
		for( j=0; j<h; j++)	{
			this.<sfun>(i,j);
		}
	}
}
/****************************************/

// klasa do np. dynamicznego tworzenia obiektow z prefixem+id
class classobjcounter	{
	init(string sprefix)	{
		new string _sprefix=sprefix;
		new int _iile=0;
		.var2("limit",0);
	}
	string get()	{
		if( limit>0 ) _iile=_iile%limit+1;
		else _iile++;
		return _sprefix + (_iile-1);
	}
	int size()	{_iile;}
	int getid(int id)	{	_sprefix + (_iile-1-id);	}
}

/*class classvsigobj	{
	init()	{
		new bool bplaying=false;
	}
	virtual play()	{	bplaying=true;	}
	virtual stop(bool bstop)	{ 
		bplaying=false;
		if( bstop )	{	this.onfinish();	}
	}
	virtual bool isplaying()	{	bplaying;	}
}*/

/***************************************************************************/

class classsignals	{
	init()	{}
	/********** std obj **********************/
	stdfinish(string sob) { <sob>.addmethod("onfinish",func { this.<this.getname()+"_FINISH">();}); }
	stdstart(string sob) { <sob>.addmethod("onstart",func { this.<this.getname()+"_START">(); }); }
	stdsigs(string sob)	{
		this.stdstart(sob);
		this.stdfinish(sob);
	}
	/********** anima **********************/
	buildanima(string san)	{
		this.stdsigs(san);
		<san>.addmethod("onendframe", func { this.<this.getname()+"_ENDFRAME">(); } );
	}
	/********** snd **********************/
	buildsnd(string ssnd)	{	this.stdsigs(ssnd);		}
	/********** timer **********************/
	buildtimer(string stimer)	{
		this.stdsigs(stimer);
		<stimer>.addmethod("ontick", func { this.<this.getname()+"_TICK">(); });
	}
	/********** button *******************/
	buildbut(string sbut)	{
		<sbut>.addmethod("onclick", func { this.<this.getname()+"_CLICK">(); });
		<sbut>.addmethod("onrel", func { this.<this.getname()+"_REL">(); });
		<sbut>.addmethod("onmoveon", func { this.<this.getname()+"_MOVEON">(); });
		<sbut>.addmethod("onmoveoff", func { this.<this.getname()+"_MOVEOFF">(); });
	}
}

/******************************************************************/

class classlocker	{
	init()	{
		new bool _block = true;
	}
	public lock()	{	_block=true;	}
	public unlock()	{	_block=false;	}
	public setlock(bool b)	{	_block=b;	}
	public bool getlock()	{	return _block;	}
	public bool unlocked	{	_block==false;	}
	public setaslocker(string sob)	{
		<sob>.addmethod("buildlocker", func { new bool _block=true; });
		<sob>.buildlocker;
		<sob>.addmethod("lock", "lock");
		<sob>.addmethod("unlock", "unlock");
		<sob>.addmethod("setlock", "setlock");
		<sob>.addmethod("getlock", "getlock");
		<sob>.addmethod("unlocked", "unlocked");
	}
}

/***************************************************************************/

module classdbreader	{
	init()	{
		new db dbl;
	}
	readdb( string sfunc )	{
		int id = 0;
		int ile = dbl.getrowsno();
		while( id < ile )	{
			this.<sfunc>( id );
			id++;
		}
	}
	readrow( string srow, string sfunc )	{
		int ipos = dbl.findbyrow( srow );
		if( ipos >= 0 )	{
			this.<sfunc>( ipos );
		}
	}
}

/***************************************************************************/


/***************************************************************************/
class collection	{
	init(string styp)	{	new string stype=styp;	}
	public string type()	{	return stype;		}
}

class array : collection {
	init(string styp, int idimens, int isiz)	{
		collection::init(styp);
		new int idim = idimens;
		new int isize = isiz;
		new vector vec;
		vec.type(styp);
		if( idimens<=0 || isiz<=0 )	return;
		//vec.resize( isiz.pow(isiz,idimens), 0 );
		vec.resize( isiz.pow(idimens), 0 );
	}
	int getid()	{
		int pos=0;
		int dim=idim-1;
		while(dim>0)	{
			pos+=_;
			pos*=isize;
			dim--;
		}
		return pos+_;
	}
	public def get()	{	return vec.get( this.getid() );	}
	public set(def svar)	{	vec.set( this.getid(), svar);	}
	public int getsize()	{	return isize;			}
	public int getdim()	{	return idim;			}
}

class stack : collection	{
	init(string styp)	{
		collection::init(styp);
		new vector vec;
		vec.type(styp);
		new <styp> var;
	}
	public push(string svar){	vec.add(svar);		}
	public def top()	{	return vec.last();	}
	public def pop()	{
		var = this.top();
		vec.removeat( vec.size()-1 );
		return var;
	}
	public free	{	vec.free;	}
}

class map : collection	{
	init(string styp)	{
		collection::init(styp);
		new int isize=0;
	}
	set(string svar, def val)	{
		if( !this.hasvar("v"+svar) )	this.add(svar);
		<"v"+svar>.set(val);
	}
	add(string svar)	{	new <stype> <"v"+svar>;		}
	def get(string svar)	{	return ["v"+svar];		}
	remove(string svar)	{	delete <"v"+svar>;		}
	bool contains(string svar){	return this.hasvar("v"+svar);	}
}
class map2 : collection	{
	init(string styp)	{
		collection::init(styp);
		new vector vn;
		vn.type("string");
		new vector vec;
		vec.type(styp);
	}
	add(string svar, def val)	{	vn.add(svar);	vec.add(val);	}
	set(string svar, def val)	{	vec.set( vn.find(svar), val );	}
	bool contains(string svar)	{	return vn.contains(svar);	}
	def get(string svar)		{	return vec.get( vn.find(svar) );}
	remove(string svar)	{
		int id = vn.find(svar);
		if( id>=0 )	{
			vec.removeat( id );
			vn.removeat(id);
		}
	}
	free()	{	vn.free();	vec.free();	}
	print	{	vec.print;	vn.print;	}
}


/***************************************************************************/
class classgamemusic : classdbreader	{
	init()	{
		classdbreader::init();
		new string smuspath = "";
		new string sbgrpath = "";
		new snd _sndbgr;
		_sndbgr.addmethod("onfinish", "_stdsndloop");
	}
	reset()	{
		if( engine.islocalmusic )
			gameapi.stopmusic();
		this.stopbgr();
	}
	_stdsndloop()	{	this.play(); }
	load(string sfile)	{	dbl.loadscript( sfile );	}
	musicpath(string s)	{	smuspath = s;	}
	sndbgrpath(string s)	{	sbgrpath=s;	}
	_play(int ipos)	{
		int i[3], string s[2];
		i0 = 1;
		i1 = dbl.getcolsno( ipos );
		while( i0 < i1 )	{
			s0 = dbl.get( ipos, i0 );	i0++;
			if( s0 == "music" )	{
				s1 = smuspath + dbl.get( ipos, i0 );
				if( !engine.fileexist(s1) )	{
					s1 = sbgrpath + dbl.get( ipos, i0 );
				}
				i0++;
				if( i0 < i1 )	{
					if( dbl.get( ipos, i0 )=="vol" )	{
						i0++;
						gameapi.setmusicvol( dbl.get( ipos, i0 ) );
						i0++;
					}
				} else {
					gameapi.setmusicvol( 100 );
				}
				gameapi.playmusic( s1 );
			} else if (s0 == "bgr")	{
				_sndbgr.load( sbgrpath + dbl.get( ipos, i0 ) );
				i0++;
				if( i0 < i1 )	{
					if( dbl.get( ipos, i0 )=="vol" )	{
						i0++;
						_sndbgr.setvol( dbl.get( ipos, i0 ) );
						i0++;
					}
				} else {
					_sndbgr.setvol( 100 );
				}
				this.playbgr();
			} else {	i0++;	}
		}
	}
	play()	{
		this.reset();
		this.readrow( gameapi.getgamename(), "_play" );
	}
	playbgr()		{	_sndbgr.play();	}
	stopbgr()	{	_sndbgr.stop(false);	}
}

class Music	{
	init	{
		new vector vmus;
		vmus.type("string");
		new int ilastid;
		.vars2(A, "musicvolume", 100, "smixer", "gameapi");
		//onmusicfin      {       mus.play;       }
	}
	playdb(string s, int row, int icol)	{
		vmus.free;
		while (icol < <s>.getcolsno(row) )	{
			vmus.add( <s>.get(row, icol) );
			icol++;
		}
		ilastid = 0;
		.play;
	}
	playvec(string s, int id)	{
		vmus.free;
		while( id< <s>.size )	{
			vmus.add( <s>.get(id) );
			id++;
		}
		ilastid = 0;
		.play;
	}
	playstr(string s)	{
		vmus.vecbuildfromstring(s, " ");
		ilastid = 0;
		.play;
	}
	play	{
		if( ilastid >= vmus.size ) return;
		
		string s = MUSICPATH + vmus.get(ilastid);
		if( !engine.fileexist(s) )	{
			s = SFXPATH + vmus.get(ilastid);
		}
		
		ilastid++;
		
		bool bloop=false;
		int fin=0;
		int fout = 0;
		int vol = musicvolume;
		for( int i=ilastid; i<vmus.size; i++)	{
			@s1 = vmus.get(i);
			match(s1)	{
				"-l" => bloop = true;
				"-v" => { i++;
					vol = vmus.get(i);
					vol = (vol*musicvolume)/100;
					}
				"-fin" => { i++; fin = vmus.get(i); }
				"-fout" => { i++; fout = vmus.get(i); }
				"-p" => ;
				? => { ilastid=i; i = vmus.size; }
			}
		}
		<smixer>.setmusicvol(vol);
		if( bloop ) {
			ilastid = vmus.size;
			if( smixer=="engine" && engine.ismusicplaying && engine.getactmusic==s ) {
			} else 
				<smixer>.playmusic(s);
			return;
		}
		<smixer>.loadmusic(s);
		if (fin) <smixer>.fadeinmusic(fin);
		else <smixer>.startmusic;
		if (fout) <smixer>.fadeoutmusic(fout);
	}
	fadeout(int ms)	{
		if( <smixer>.ismusicplaying ) {
			<smixer>.fadeoutmusic(ms);
			ilastid=vmus.size;
		}
	}
	isplaying	{	<smixer>.ismusicplaying;	}
	getactmusic	{	engine.getactmusic;	}
	stop	{
		<smixer>.endmusic(false);
	}
}

/**************************************************************/
	// zmienne globalna - stany gry

new int igmstate;
new string sgmstate;
public printstate	{	("sgmstate = "+sgmstate + " ,  igmstate = "+igmstate)->print;}
new int igmdemo = dbconf.dbgetint("igmdemo:");
new int igmbegin = true;
new int igmsoundson = dbconf.dbgetint("igmsoundson:");

new string sgmfontfile = dbconf.dbget("sgmfontfile:");
new string sgmfontmono = dbconf.dbget("sgmfontmono:");
new string sgmfontmonobold = dbconf.dbget("sgmfontmonobold:");
new string sgmfontbold = dbconf.dbget("sgmfontbold:");
new string sgmfontitalic = dbconf.dbget("sgmfontitalic:");

new string SFXPATH = dbconf.dbget("sfxpath:");
new string BGRPATH = dbconf.dbget("sndbgrpath:");
new string MUSICPATH = dbconf.dbget("musicpath:");

new string LANG = dbconf.dbget("lang:");
new string LANGDIR = "lang/" + LANG + "/";
new string SNDPATH = "sounds/";
if( LANG=="pl" ) LANG="";
if( LANG.length > 0 ) SNDPATH += LANG + "/";

/**************************************************************/
	// standardowa klasa do tworzenia zmiennych
class newvars		{
	init()	{
		new string _sclpath = "";
		new string _sclwavpath = "";
	}
	string _checkfont(string sfont, int isize, string sfnt)	{
		if( sfont==null )	sfont=sgmfontfile;
		if( sfont.contains(".ttf") )	{
			new font <sfnt>;
			<sfnt>.load( sfont, isize );
			sfont = sfnt;
		}
		sfont;
	}
	string checkfont(string sfont, int isize)	{
		._checkfont(sfont, isize, "_fnt");
	}
	bool begingame()	{
		igmbegin = !igmbegin;
		!igmbegin;
	}
	newarray(string styp, string sbase, int size)	{
		if( size<= 0 )	return;
		size--;
		while(size>=0)	{
			new <styp> <sbase+size>;
			size--;
		}
	}
	setgraphpath(string spath)	{
		_sclpath = spath;
		engine.setpath(spath);
	}
	setwavpath(string spath)	{	_sclwavpath = spath; }
	string getgraphpath()	{	_sclpath; }
	string getsndpath()	{	_sclwavpath; }
	getpath(string sfile)	{
		if( sfile.getb(0,1)=="$" ) sfile.strsubb(1);
		else .getgraphpath + sfile;
	}
	newanima(string sname, string sfile, int z)	{
		new anima <sname>;
		@s = .getpath(sfile);
		<sname>.load( s );
		if( igmdebug )	{
			if( igmexportan )	{
				<sname>.saveimages("debug/" + s.getb(0, s.length-s.strgeteto("/")->length) + 
					s.strgeteto("/")->strsubes(".pyz") + "/" );
			} else if( igmimportan )	{
				s = "debug/" + s.strsubes(".pyz") + "/";
				if( engine.fileexist( s + "0.png") )	{
					<sname>.loadimages( s );
				}
			}
		}
		<sname>.setz(z);
	}
	newstdanima(string sname, string sfile, int z)	{
		this.newanima(sname, sfile, z);
		this.stdanaction(sname);
	}
	copyanimaactz(string ssrc, string sdest, string saction, int z)	{
		this.copyanimaact(ssrc, sdest, saction);
		<sdest>.setz(z);
	}
	copyanimaact(string ssrc, string sdest, string saction)	{
		this.copyanima(ssrc, sdest);
		<sdest>.setframe( saction, 0 );
	}
	copyanima(string ssrc, string sdest)	{
		new anima <sdest>;
		<sdest>.copy( ssrc );
	}
	copyanimas(string san, string sname, int istart, int ilosc)	{
		if (ilosc<0)	return;
		for(int i=0; i<ilosc; i++)	this.copyanima( san, sname + (istart + i)  );
	}
	newanimas(string sname, string sfile, int z, int ilosc)	{
		if(ilosc<0) return; 
		this.newanima(sname+"0", sfile, z);		// pierwsza load z zerem
		this.copyanimas(sname+"0", sname, 1, ilosc-1);		// pozostale kopiowane z niej
	}
	int newanframesgr(string san, string sname, int iaction, string sgr)	{	// tworzy animacje z klatek
		int ile = <san>.nofframes( iaction );
		this.copyanimas( san, sname, 0, ile );
		for(int i=0; i<ile; i++)	{
			<sname+i>.setframe(iaction, i);
			if( sgr!=null )	{	<sgr>.add( sname+i );	}
		}
		return ile;		// zwraca ilosc stworzonych animacji
	}
	int newanframes(string san, string sname, int iaction)	{	// tworzy animacje z klatek
		return this.newanframesgr(san,sname,iaction,null);
	}
	newcanvas(string sname, int w, int h, int r, int g, int b, int a, int z)	{
		new img <sname>;
		<sname>.create(w,h,r,g,b,a);
		<sname>.setz(z);
	}
	newimg(string sname, string sfile, int z)	{
		new img <sname>;
		<sname>.load( .getpath( sfile ) );
		<sname>.setz(z);
	}
	copyimg(string ssrc, string sdest)	{
		new img <sdest>;
		<sdest>.copy(ssrc);
	}
	playmusic(string sfile)	{gameapi.playmusic( MUSICPATH + sfile );	}
	snewsnd(string sname, string sfile)	{
		this.newsnd(sname,sfile);
		<sname>.addmethod("onfinish","__std_finish");
	}
	_newsnd(string sname, string sfile, bool bfree)	{
		new snd <sname>;
		if( !sfile.contains(".") ) {
			sfile += ".wav";
		}
		if( !engine.fileexist(sfile) )	{
			sfile = sfile.strsubes("wav") + "ogg";
		}
		if( bfree )
			<sname>.setstartstopflag(false, true);
		<sname>.load( sfile );
		if( igmsubtitle )	{
			subtitle.register(sname, sfile);
		}
	}
	newsfx(string sname, string sfile)	{	._newsnd(sname, SFXPATH + sfile, false);	}
	newbgr(string sname, string sfile)	{	._newsnd(sname, BGRPATH + sfile, false);	}
	newbgrloop(string s, string s2)		{	.newbgr(s,s2); .sndplayloop(s);	}
	newsnd(string sname, string sfile)	{	._newsnd(sname, .getsndpath+sfile, false);	}
	newsndfree(string sname, string sfile)	{	._newsnd(sname, .getsndpath+sfile, true);	}
	newsndloop(string sname, string sfile)	{
		this.newsnd(sname,sfile);
		this.looponfinish1( sname );
	}
	looponfinish1( string sob )	{<sob>.addmethod("onfinish","_stdsndloop");	}
	sndplayloop(string sob)	{
		this.looponfinish1( sob );
		<sob>.play();
	}
	newsnds(string sbase, int inamestart, string sfilebase, int ifilefrom, int ifileto)	{
		string s;
		int ile = ifileto-ifilefrom+1;
		for(int i=0; i<ile; i++)	{
			s = sbase + (inamestart + i);
			new snd <s>;
			<s>.load( this.getsndpath() + sfilebase + (ifilefrom+i) + ".wav" );
		}
	}
	newtimer(string sname, int idelay, int iticks)	{
		new timer <sname>;
		<sname>.settick(iticks);
		<sname>.delay(idelay);
	}
	newtimercycle(string sname, int icycle, int iticks)	{
		new timer <sname>;
		<sname>.settick(iticks);
		<sname>.setcycle(icycle);
	}
	stdanaction(string san)	{
		string s = <san>.actionname();
		if( s.contains("L")  )	this.looponfinish(san);
		else if( s.contains("H")  )	this.hideonfinish(san);
		if( s.contains("P")  )	<san>.play(-1);
	}
	int newanactionsgr(string san, string sname, string sgr)	{
		int ile = <san>.nofactions();
		this.copyanimas( san, sname, 0, ile );
		string s;
		for(int i=0; i<ile; i++)	{
			s = sname+i;
			<s>.setframe(i,0);
			this.stdanaction(s);
			if( sgr!=null )	{<sgr>.add( s );}
		}
		ile;
	}
	int newanactions(string san, string sname)	{ this.newanactionsgr(san,sname,null);	}
	int newanfrbyactgr(string san, string sname, string sgr)	{
		int ile = <san>.nofactions();
		for( int i=0; i<ile; i++)	_ = this.newanframesgr(san, sname+i+"_", i, sgr);
		ile;
	}
	int newanfrbyact(string san, string sname)	{ this.newanfrbyactgr(san,sname,null);	}
	int loadanfrbyact(string san, string sfile, int z)	{
		string s = "_"+san;
		this.newanima(s,sfile,z);
		int ile = this.newanfrbyact(s, san);
		<s>.hide();
		return ile;
	}
	int loadanactions(string san, string sfile, int z)	{
		string s = "_"+san;
		this.newanima(s, sfile, z);
		int ile = this.newanactions(s, san);
		<s>.hide();
		return ile;
	}
	int loadanframes(string san, string sfile, int iaction, int z)	{
		string s = "_"+san;
		this.newanima(s, sfile, z);
		int ile = this.newanframes(s, san, iaction);
		<s>.hide();
		return ile;
	}
	newbutimg(string sbut, string sstd, string smov, string sclick, string smouse)	{
		new button <sbut>;
		<sbut>.set(sstd, smov, sclick);
		<sbut>.setmouse(smouse);
	}
	newbutan(string sbut, string sanstd, string sanmov, string sanclick, string smouse)	{
		new button <sbut>;
		<sbut>.setan(sanstd, sanmov, sanclick);
		<sbut>.setmouse(smouse);
	}
	/*****************************************************/
	newdb(string sdb, string sfile)	{
		new db <sdb>;
		<sdb>.load( .getpath(sfile) );
	}
	newdbscript(string sdb, string sfile)	{
		new db <sdb>;
		//<sdb>.loadscript( this.getgraphpath() + sfile );
		<sdb>.loadscritp( .getpath(sfile) );
	}
	vargmset(string svar, def val)	{
		string sg = gameapi.getgamename();
		if( !<sg>.hasvar(svar) )	<sg>.varnew( val.gettype(), svar );
		<svar> = val;
	}
}


class classadvmouse	{
	init()	{
		new anima anmsc;
	}
	public load(string sname)	{
		anmsc.load(sname);
		anmsc.addmethod("onendframe", "setnextframe");
		anmsc.addmethod("onsetframe", func { .hide; } );
		anmsc.hide();
	}
	public stdload	{
		if( !igmdebug && .checktouchpad )	.load("scripts/common/kursorypad.pyz");
		else .load("scripts/common/cursors.pyz");
	}
	setnextframe	{
		anmsc.ansetnextfr;
		mouse.setcursor("anmsc");
	}
	set(string saction)	{
		//anmsc.setframe( saction, 0 );
		if( !anmsc.isplaying( saction ) )	{
			anmsc.play( saction );
		}
		mouse.setcursor("anmsc");
	}
	setstd()	{	this.set("normal");	}
	setactive()	{	this.set("active");	}
	setact()	{	this.set("active");	}
	setbut		{	this.set("active");	}
	setexit()	{	this.set("exit");	}
	setwait()	{	this.set("wait");	}
	get()		{	anmsc.actionname();	}
	lodx	{	anmsc.lodx;	}
	lody	{	anmsc.lody;	}
}

new classadvmouse advmouse;
advmouse.stdload;
/***************************************************************************/

module clsurf	{
	init()	{}
	bool isin(int x, int y, int x1, int y1, int x2, int y2)	{	x >= x1 && x<=x2 && y>=y1 && y<=y2;	}
	bool isin2(int x, int y, int x1, int y1, int w, int h)	{	x >= x1 && x < x1+w && y>=y1 && y<y1+h;	}
	bool inscreen(int x, int y, int dx, int dy)	{	this.isin( x, y, 0-dx, 0-dy, 800+dx, 600+dy );	}
	bool insurf(int x, int y, string simg) { .isin(x,y,<simg>.getpx, <simg>.getpy, <simg>.getex-1, <simg>.getey-1);}
	bool issurfin(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)	{
		this.isin(x1,y1, x3,y3,x4,y4) || this.isin(x2,y1, x3,y3,x4,y4) ||
		this.isin(x1,y2, x3,y3,x4,y4) || this.isin(x2,y2, x3,y3,x4,y4) ||
		( x1<x3 && x2>x4 && y1<y3 && y2>y4 );
	}
	bool commonsurface(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)	{
		this.issurfin(x1,y1,x2,y2, x3,y3,x4,y4) || 
				this.issurfin(x3,y3,x4,y4, x1,y1,x2,y2);
	}
	bool commonimgs(string simg1, string simg2)	{
		this.commonsurface(<simg1>.getpx(), <simg1>.getpy(), <simg1>.getex()-1, <simg1>.getey()-1,
				<simg2>.getpx(), <simg2>.getpy(), <simg2>.getex()-1, <simg2>.getey()-1 );
	}
	bool surfwithinsurf(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)	{
		this.isin(x1,y1, x3,y3,x4,y4) && this.isin(x2,y1, x3,y3,x4,y4) &&
				this.isin(x1,y2, x3,y3,x4,y4) && this.isin(x2,y2, x3,y3,x4,y4);
	}
	bool imgwithinimg(string simg1, string simg2)	{
		this.surfwithinsurf(<simg1>.getpx(), <simg1>.getpy(), <simg1>.getex()-1, <simg1>.getey()-1,
				<simg2>.getpx(), <simg2>.getpy(), <simg2>.getex()-1, <simg2>.getey()-1 );
	}
}

/* modul do obliczen odleglosci */

module cllen	{
	init()	{
		new int il1;
		new int ilx;
		new int ily;
	}
	int ilenx()	{ return ilx; }
	int ileny()	{ return ily; }
	int ilen4(int x1, int x2)	{	return (x1-x2)->abs();	}
	int ilen3(string simg1, string simg2)	{
		return this.ilen( <simg1>.getcx(), <simg1>.getcy(), <simg2>.getcx(), <simg2>.getcy() );
	}
	int ilen5(string simg1, string simg2)	{
		return this.ilen( <simg1>.getpx(), <simg1>.getpy(), <simg2>.getpx(), <simg2>.getpy() );
	}
	int ilen2(string simg1, int x, int y)	{return this.ilen( <simg1>.getcx(), <simg1>.getcy(), x,  y );	}
	int ilen(int x1, int y1, int x2, int y2)	{
		ilx = x1-x2;
		ily = y1-y2;
		return il1.length( ilx, ily );
	}
	int iclenx(string simg1, int x)	{	return <simg1>.getcx() - x;	}
	int iclenx2(string simg1, string simg2)	{	return <simg1>.getcx() - <simg2>.getcx();	}
	int icleny(string simg1, int y)	{	return <simg1>.getcy() - y;	}
	int icleny2(string simg1, string simg2)	{	return <simg1>.getcy() - <simg2>.getcy();	}
	int isbetween2(string simg1, string simg2, int x1, int y1, int x2, int y2)	{
		return this.isbetween(simg1, <simg2>.getcx(), <simg2>.getcy(), x1, y1, x2, y2);
	}
	int isbetween(string simg1, int xx, int yy, int x1, int y1, int x2, int y2)	{
		il1 = this.ilen( simg1, xx, yy );
		return ilx>=x1 && ilx<=x2 && ily>=y1 && ily<=y2;
	}
	int ilodlen(string s1, string s2)	{	.ilen(<s1>.lodx,<s1>.lody, <s2>.lodx, <s2>.lody);	}
	int iposlen(string simg1, string simg2)	{
		.ilen( <simg1>.getpos, <simg2>.getpos );
	}
}

/****************************************************/
class classansearcher	{
	init()	{}
	def _findnotr(string san, int x, int y, int dx, int dy)	{
		int ex = <san>.getex() , int ey = <san>.getey();
		while( x!=ex && y!=ey )	{
			if( <san>.isin(x,y,false,true) ) return x,y;
			x+=dx;	y+=dy;
		}
		return -1,-1;
	}
	def firstnotrx1y(string san)	{	return ._findnotr(san,<san>.getpx(), <san>.getpy(), 1, 0);	}
	def firstnotrexy1(string san)	{	return ._findnotr(san,<san>.getex()-1, <san>.getpy(), 0, 1);	}
	def firstnotrxy1(string san)	{	return ._findnotr(san,<san>.getpx(), <san>.getpy(), 0, 1);	}
	def firstnotrx1ey(string san)	{	return ._findnotr(san,<san>.getpx(), <san>.getey()-1, 1, 0);	}
}

class signal_pack	{
	init()	{}
	addsignals(string san)	{
		<san>.addmethod("operator<", func { (string sfun) this.addmethod("onfinish", sfun ); } );
	}
}
/***************************************************************************/
class ImagePos	{
	init	{}
	getex	{	.getpx + .getw;	}
	getey	{	.getpy + .geth;	}
	getcx	{	.getpx + .getw/2;	}
	getcy	{	.getpy + .geth/2;	}
	setpos(int x, int y)	{	.move(x-.getpx, y-.getpy);	}
}
class ImageVisible	{
	init	{
		new bool _isvisible=1;
	}
	isvisible	{	_isvisible;	}
	show		{	_isvisible=1;	}
	hide		{	_isvisible=0;	}
}
class Image	{
	init	{}
	public resizemethods(string sob)	{
		<sob>.vars2(A, "getz",0, "getpx",0, "getpy",0, "getw",0, "geth",0, "isvisible", 0);
		<sob>.addmethod("show", func { isvisible=1; }	);
		<sob>.addmethod("hide", func { isvisible=0; }	);
		<sob>.addmethod("setz", func { (int z) getz=z; } );
		<sob>.addmethod("setpos", func { (int x, int y) getpx=x; getpy=y; } );
		<sob>.addmethod("move", func { (int x, int y) getpx+=x; getpy+=y; } );
		<sob>.addmethod("getex", func { getpx+getw; } );
		<sob>.addmethod("getey", func { getpy+geth; } );
		<sob>.addmethod("getcx", func { getpx+getw/2; } );
		<sob>.addmethod("getcy", func { getpy+geth/2; } );
		<sob>.addmethod("isin", func { (int x, int y, int bv, int ba)
			if( !ba ) {
				if( !bv || (bv&&isvisible) )	{
					x>=getpx && x<.getex && y>=getpy && y<.getey;
				} else 0;
			} else 0;
			} );
	}
}
	// rozszerzenia dla animcaji
class anima_pack : signal_pack	{
	init()	{}
	public resizemethods(string san)	{
		<san>.addmethod("_clanbuildpomvars", func { new int _ixp; new int _iyp; } );
		<san>._clanbuildpomvars();
		<san>.addmethod("setbpos", func {(int x, int y) .setpos( x-.lodx, y-.lody ); });
		<san>.addmethod("saverelpos", func {(int x,int y)_ixp=x-.getpx;_iyp=y-.getpy;} );
		<san>.addmethod("setrelpos", func{(int x, int y) .setbpos( x - _ixp, y - _iyp );});
		<san>.addmethod("mssaverelpos", func {.saverelpos( mouse.getpos );} );
		<san>.addmethod("mssetrelpos", func {.setrelpos( mouse.getpos );});
		<san>.addmethod("rplay", func {(string sact)if( !.isplaying(sact) ) .play(sact);});
		<san>.addmethod("setcpos", func {(int x, int y).setbpos( x-.getw/2, y-.geth/2 );});
		<san>.addmethod("operator=", func { (string s) .copy(s); } );
		<san>.addmethod("operator==", func { (string s)
			.actionnr==<s>.actionnr && .framenr==<s>.framenr; } );
		this.addsignals(san);
	}
}

class timer_pack : signal_pack	{
	init()	{}
	resizemethods(string sob)	{
		this.addsignals(sob);
	}
}
/***************************************************************************/
class vector_pack	{
	init()	{}
	each(string sfun)	{	for( int i=0; i<.size; i++) this.<sfun>(.get(i));	}
	resizemethods(string svec)	{
		<svec>.addmethod("each", "each");
		<svec>.addmethod("operator-", func { (def x) this.remove(x); this; } );
		<svec>.addmethod("operator+", func { (def x) this.add(x); this; } );
	}
}

/***************************************************************************/

public new_object(string styp, string sob)	{
	new <styp> <sob>;
	<styp+"_pack">::resizemethods(sob);
}
public new_anima(string s)	{	.new_object("anima",s);	}
public new_vector(string s)	{	.new_object("vector",s);	}

/***************************************************************************/

class classanfilter	{
	init()	{}
	buildanfilter()	{
		new filter ft;
		ft.link( this.getname() );
		ft.setpivottype(1);
	}
	public build(string san)	{
		<san>.addmethod("buildanfilter","buildanfilter");
		<san>.buildanfilter();
		<san>.addmethod("setopacity",	func {	(int iop) ft.setopacity(iop); }		);
		<san>.addmethod("setzoom",		func {	(real r) ft.setzoom(r); }			);
		<san>.addmethod("setangle",		func {	(real r) ft.setangle(r); }			);
		<san>.addmethod("getangle",		func {	return ft.getangle; }			);
		<san>.addmethod("rotate",		func {	(real r)	ft.rotate(r); }			);
		<san>.addmethod("setpivottype",	func {	(int ityp) ft.setpivottype(ityp); }	);
		<san>.addmethod("unlink",		func {	ft.unlink(); }					);
		<san>.addmethod("link",			func {	ft.link(this); }					);
		<san>.addmethod("blend",		func {	(string s) ft.blend(s); }			);
		<san>.addmethod("mask",		func {	(string s) ft.mask(s); }			);
	}
}

/***************************************************************************/

class classancounter	{
	init()	{
		new int iile;
		new int id;
		new string _san;
		new vector _vs;
		new int _pos;
	}
	set(string sname, int ile)	{
		_san = sname;
		iile = ile;
		id = 0;
		_pos = sname.length();
		_vs.resize( ile, false );
	}
	string get()	{
		string s = _san+id;
		id = (id+1)%iile;
		return s;
	}
	string getf()	{
		for(int i=0; i<iile; i++)	{
			if( !_vs.get(i) )	{
				_vs.set(i, true);
				return _san+i;
			}
		}
		return null;	// brak wolnych
	}
	retf(string s)	{	_vs.set( s.strsubbs( _san ), false );	}
	isfree(int pos)	{	return _vs.get(pos);	}
	int getile()	{	return iile;	}
	bool allfree	{	_vs.vecsum==0; }
}

/**************************************************************/
	// operacje na obrazach, dzwiekach, timerach i animacjach
class gmobjvec {
	init()	{
		new vector lsim;
		lsim.type("string");
	}
	operator=(string sgr)	{
		if( engine.varexist(sgr) )	{
			match(<sgr>.gettype())	{
				"vector" => this.copy(sgr);
				"gmobjvec" => this.copy(sgr);
				"gmimgvec" => this.copy(sgr);
				? => {	this.free(); this.add(sgr); }
			}
		} else {
			this.free();
			this.add(sgr);
		}
	}
	save(string s)	{	lsim.save(s);	}
	load(string s)	{	lsim.load(s);	}
	operator+(string sob)	{	this.add(sob);		this;	}
	operator-(string sob)	{	this.remove(sob);	this;	}
	removegr(string sgr)	{	for( int i=0; i < <sgr>.size; i++)	.remove( <sgr>.get(i) );	}
	addtogr(string sgr)	{	for( int i=0; i<this.size(); i++)	<sgr>.add(this.get(i));	}
	addgr(string sgr)	{	for( int i=0; i< <sgr>.size(); i++)	this.add( <sgr>.get(i) );	}
	addgroups	{	.withlist("addgr");	}
	copy(string sgr)	{
		this.free();
		this.addgr(sgr);
	}
	free()	{ lsim.free();	}
	int size()	{ 	lsim.size;	 }
	bool empty()	{	.size==0;	}
	hash()	{ lsim.hash(); }
	string first()	{ lsim.get(0); }
	string last()	{ lsim.get( lsim.size-1 ); }
	print()	{
		engine.print("");
		engine.print("------ type("+.gettype+") " + this + " ------");
		lsim.print();
		engine.print("------ end ------");
		engine.print("");
	}
	string get(int i)	{	lsim.get(i);	}
	set(int pos, string sval)	{	lsim.set(pos,sval);	}
	add(string simg)	{	lsim.add(simg);	}
	additer(string s, int ifrom, int iile)	{
		while( iile>0 )	{
			.add(s+ifrom);
			ifrom++;
			iile--;
		}
	}
	buildarray(string styp, string sname, int ilosc)	{
		<gameapi.getgamename>.newarray(styp,sname,ilosc);
		.additer(sname,0,ilosc);
	}
	deleteall	{	for( int i=0; i<.size; i++)	delete <.get(i)>;	}
	deleteallgm	{
		@s = gameapi.getgamename;
		for( int i=0; i<.size; i++)	<s>.vardel(.get(i));
	}
	deleteallgmobj	{
		@s = gameapi.getgamename;
		for( int i=0; i<.size; i++)	<s>.deletegmobj(.get(i));
	}
	lockall	{	.eval("lock");	}
	unlockall	{	.eval("unlock");	}
	addbegin(string simg)	{	lsim.addbegin(simg);	}
	swap(int i, int j)	{	lsim.swap(i,j);	}
	addonce(string simg)	{	if( !lsim.contains(simg) )	lsim.add(simg);	}
	sepadd(string separator)	{
		string s = _;
		while( s!=separator )	{
			this.addbegin(s);
			s = _;
		}
	}
	addlist	{	.sepadd(A);	}
	removelist	{ .withlist("remove");	}
	insertat(string sob, int pos)	{
		@ile = .size;
		if( pos<=0 )	.addbegin(sob);
		else if (pos>=ile)	.add(sob);
		else {
			.add(null);
			for( @i=ile; i>pos; i--)	.set( i, .get(i-1) );
			.set(pos, sob );
		}
	}
	remove(string simg)	{	lsim.remove(simg);	}
	removeat(int pos)		{	lsim.removeat(pos);	}
	removefirst			{	lsim.removeat(0);	}
	removelast			{	lsim.removeat(.size-1);	}
	removealloccurs(string simg)	{	while(this.contains(simg))	this.remove(simg);	}
	removeif(string sfun)	{
		for( int i=0; i<.size; i++)
			if( <.get(i)>.<sfun>() )  .removeat(i);
	}
	int find(string simg)		{	lsim.find(simg);	}
	int contains(string simg)	{	lsim.contains(simg);	}
	addgroup(string sob, int ile)	{	.addgroup2( sob, 0, ile-1 );	}
	addgroup2(string sob, int ifrom, int ito)	{
		while( ifrom <= ito )	{
			this.add( sob+ifrom );
			ifrom++;
		}
	}
	string rand()	{
		int ile = .size;
		ile>0 ? .get(ile.rand) : null;
	}
	string randdiff(string s)	{
		int ile = .size;
		if( ile>0 )	{
			int id = ile.rand;
			int i = id;
			while( .get(id)==s )	{
				id = (id+1)%ile;
				if( id==i )	return null;
			}
			return .get(id);
		}
		null;
	}
	buildfullvars	{	.each( func { (@id) .buildfullname; } );	}
	buildvars		{	.each( func { (@id) .addtogamevars(this); } );	}
	/******************* metody na obiektach grupy *****************************/
	movefrom(string simg, int x, int y)	{
		int i = this.find(simg);
		if( i>=0 )	{
			while( i<lsim.size() )	{
				<lsim.get(i)>.move(x,y);
				i++;
			}
		}
	}
	move(int x, int y)	{	this.eval2("move",x,y);	}
	setpos(int x, int y)	{	this.eval2("setpos",x,y);	}
	show()	{	this.eval("show");	}
	hide()	{	this.eval("hide");	}
	stop(int fin)	{	this.eval1("stop",fin);	}
	play()	{	this.eval("play");	}
	setdelay(int d)	{	this.eval1("setdelay",d);	}
	isplaying	{
		for( int i=0; i<.size; i++)	if( <.get(i)>.isplaying(-1) ) return true;
		false;
	}
	graddmethod(string sdest, string ssrc)	{	this.eval2("addmethod",sdest,ssrc);	}
	string getimg(int x, int y, int bignorehidden, int bignorealpha)	{
		for( int i=lsim.size()-1; i>=0; i--)	{
			if( <lsim.get(i)>.isin( x,y,bignorehidden,bignorealpha ) )	return lsim.get(i);
		}
		return null;
	}
	int isin(int x, int y, bool bignorehidden, bool bignorealpha)	{
		for( int i=lsim.size()-1; i>=0; i--)	{
			if( <lsim.get(i)>.isin( x,y,bignorehidden,bignorealpha ) )	return i+1;
		}
		return false;
	}
	setframe(def ac, int ifr)	{	this.eval2("setframe",ac,ifr);	}
	setz(int z)	{	this.eval1("setz",z);	}
	/**************/
	eval(string sfunc)	{
		for(int i=0; i<lsim.size(); i++)	{<lsim.get(i)>.<sfunc>();	}
	}
	eval1(string sfunc, def darg)	{
		for(int i=0; i<lsim.size(); i++)	{<lsim.get(i)>.<sfunc>(darg);}
	}
	eval2(string sfunc, def darg1, def darg2)	{
		for(int i=0; i<lsim.size(); i++)	{<lsim.get(i)>.<sfunc>(darg1, darg2);}
	}
	eval3(string sfunc, def darg1, def darg2, def darg3)	{
		for(int i=0; i<lsim.size(); i++)	{<lsim.get(i)>.<sfunc>(darg1, darg2, darg3);}
	}
	int _find(string sfun, def id)	{
		for( int i=0; i<this.size; i++) if ( <this.get(i)>.<sfun>()==id ) return i;
		-1;
	}
	int _find1(string sfun, @id)	{
		for( int i=0; i<.size; i++) if ( <this.get(i)>.<sfun>(id) ) return i;
		-1;
	}
	each(string sfun)	{	for( int i=0; i<.size; i++) <.get(i)>.<sfun>(i);	}
	each1(string sfun, @d1)	{	for( int i=0; i<.size; i++) <.get(i)>.<sfun>(i, d1);	}
	each2(string sfun, @d1, @d2)	{	for( int i=0; i<.size; i++) <.get(i)>.<sfun>(i, d1, d2);	}
	bool ineach(string sfun)	{
		for( int i=0; i<.size; i++) if( !<.get(i)>.<sfun>(i) )	return false;
		true;
	}
	int find_closest(string sob, string sfun)	{
		if( .empty ) return;
		int id = 0, real il;
		real ilen = <.get(0)>.<sfun>(sob);
		for( int i=1; i<.size; i++)	{
			il = <.get(i)>.<sfun>(sob);
			if( il < ilen )	{
				id = i;
				il = ilen;
			}
		}
		id;
	}
	/**************/
	sortimgsfun(string sfun)	{	lsim.vecsort(sfun);	}
	sortimgs()	{	// sortowanie od najmniejszych
		lsim.vecsort("_scmpimg1");
	}
	bool _scmpimg1(string s0, string s1)	{
		( <s0>.getz() < <s1>.getz() || ( <s0>.getz()==<s1>.getz() && <s0>.getidobj() < <s1>.getidobj() ) );
	}
}

class gmimgvec : gmobjvec	{
	init()	{
		gmobjvec::init();
		new int _ix = 0;
		new int _iy = 0;
		new int _iz = 0;
		new int _ifound = -1;
		new string sanload = null;
	}
	_setpos(int x, int y)	{	|_ix, _iy| = x,y;	}
	int lodx()	{0;}
	int lody()	{0;}
	int getposx()	{	_ix;	}
	int getposy()	{	_iy;	}
	int getpos()	{	return _ix, _iy;	}
	int getpx() {	_ix;	}
	int getpy() {	_iy;	}
	int getw()	{	this.getex()-this.getpx();	}
	int geth()	{	this.getey()-this.getpy();	}
	int getcx() {	this.getpx()+this.getw()/2;	}
	int getcy() {	this.getpy()+this.geth()/2;	}
	int getz()	{	_iz;	}
	int getex()	{
		int ile = this.size();
		if( ile<=0 )	{	return _ix;	}
		int x = <this.get(0)>.getex();
		int x2;
		for( int i=1; i<ile; i++)	{
			x2 = <this.get(i)>.getex();
			if( x2>x )	{	x=x2;	}
		}
		x;
	}
	int getey()	{
		int ile = this.size();
		if( ile<=0 )	{	return _iy;	}
		int y = <this.get(0)>.getey();
		int y2;
		for( int i=1; i<ile; i++)	{
			y2 = <this.get(i)>.getey();
			if( y2>y )	{	y=y2;	}
		}
		y;
	}
	int _getpx()	{
		int ile = this.size();
		if( ile<=0 )	{	return _ix;	}
		int x = <this.get(0)>.getpx();
		int x2;
		for( int i=1; i<ile; i++)	{
			x2 = <this.get(i)>.getpx();
			if( x2<x )	{	x=x2;	}
		}
		x;
	}
	int _getpy()	{
		int ile = this.size();
		if( ile<=0 )	{	return _iy;	}
		int y = <this.get(0)>.getpy();
		int y2;
		for( int i=1; i<ile; i++)	{
			y2 = <this.get(i)>.getpy();
			if( y2<y )	{	y=y2;	}
		}
		y;
	}
	int _getw	{	.getex-._getpx;	}
	int _geth	{	.getey-._getpy;	}
	/*minx	{	.find_closest(null, func {(@s) .getpx; } );	}
	miny	{	.find_closest(null, func {(@s) .getpy; } );	}
	countborders	{
		_ix = .minx;
		_iy = .miny;
	}*/
	setz(int z)	{
		_iz = z;
		this.eval1("setz",z);
	}
	move(int x, int y)	{
		_ix +=x;
		_iy +=y;
		this.eval2("move",x,y);
	}
	setpos(int x, int y)	{
		_ix = x;
		_iy = y;
		this.eval2("setpos",x,y);
	}
	setpos2(int x, int y)	{
		_ix = x;
		_iy = y;
		if( !.empty )	{
			x -= <.get(0)>.getpx;
			y -= <.get(0)>.getpy;
			.move(-x,-y);
		}
	}
	changeframe(int ifr) {
		string s;
		for( int i=0; i<.size; i++)	{
			s = .get(i);
			<s>.setframe( <s>.actionnr(-1), ifr );
		}
	}
	nplay(int n)	{	.eval1("play",n);	}
	txtreset	{	for( int i=0; i<.size; i++) <.get(i)>.txtset("");	}
	anputgr()	{	this.eval("anputgr");	}
	anputy(int ypos)	{	this.eval1("anputy", ipos);	}
	int isin(int x, int y, bool bignorehidden, bool bignorealpha)	{
		for( int i=lsim.size()-1; i>=0; i--)	{
			if( <lsim.get(i)>.isin( x,y,bignorehidden,bignorealpha ) )	{
				_ifound=i;
				return i+1;
			}
		}
		_ifound = -1;
		false;
	}
	int isinfunc(int x, int y, string sfunc)	{
		for( int i=lsim.size()-1; i>=0; i--)	{
			if( <lsim.get(i)>.<sfunc>( x,y ) )	{
				_ifound=i;
				return i+1;
			}
		}
		_ifound = -1;
		false;
	}
	int isincut(int x, int y, bool bignorehidden, bool bignorealpha)	{
		for( int i=lsim.size()-1; i>=0; i--)	{
			if( <lsim.get(i)>.withincut(x,y) && <lsim.get(i)>.isin( x,y,bignorehidden,bignorealpha ) )	{
				_ifound=i;
				return i+1;
			}
		}
		_ifound = -1;
		false;
	}
	bool withincut(int x, int y)	{
		y; x;
		.ineach(func { (@id)
			int x = _;
			int y = _;
			.withincut(x,y);
			y; x;
			} );
		x = _;
		y = _;
	}
	int findif(string sfunc)	{	._find( sfunc,true);	}
	int getfound()	{	_ifound;	}
	string getsfound()	{	this.get(_ifound);	}
	int findfr(int id)	{	._find("framenr", id);	}
	int findsfr(string s)	{	._find("framename", s);	}
	int findac(int id)	{	._find("anactnr", id);	}
	int findsac(string sac)	{	._find("actionname", sac);	}
	int nearest_to(string sob)	{
		//.find_closest(sob, func {(string s) 0->length( .getpx-<s>.getpx, .getpy-<s>.getpy ); } );
		.find_closest(sob, func {(string s) cllen.ilen5(this,s); } );
	}
	string getsac(string sac)	{	.get( .findsac(sac) );	}
	string getsacfr(string sac, int fr)	{	for(int i=0; i<.size; i++) if( <.get(i)>.actionname==sac && <.get(i)>.framenr==fr ) return .get(i); null; }
	/*def find_min(string s)	{
		if( .empty ) return;
		int x = <s>.getpx;
		int y = <s>.getpy;
		int id = 0, int il;
		int ilen = id.length( <.get(0)>.getpx-x, <.get(0)>.getpy-y );
		for( int i=1; i<.size; i++)	{
			il = id.length( <.get(i)>.getpx-x, <.get(i)>.getpy-y );
			if( il < ilen )	{
				id = i;
				il = ilen;
			}
		}
	}*/
	blitto(string simg)	{	for( int i=0; i<.size; i++)	<simg>.blit(.get(i));	}
	sortz(int z)	{	for( int i=0; i<.size; i++) <.get(i)>.setz(z+i);	}
	/****************************/
	ancopies(string san, int ile)	{
		for( int i=0; i<ile; i++)	{
			<GAME>.copyanima(san, san+"_"+i);
			.add(san+"_"+i);
		}
	}
	loadallan(string sname, string sfile, int z)	{
		string s = gameapi.getgamename();
		<s>.newanima(sname,sfile,z);
		_ = <s>.newanfrbyactgr(sname, sname, this);
		<sname>.hide();
	}
	addsrcanima(string san) {       .var2("srcanima", san); }
	operator*(string s)	{
		string sg = gameapi.getgamename;
		string san;
		if ( s.contains(".pyz") ) {
			if( s.getb(0,1)=="$" )	{
				new vector _vtmp; _vtmp.type("string");
				_vtmp.vecbuildfromstring(s, "/");
				san = "an" + _vtmp.last->strsubes(".pyz");
				delete _vtmp;
			} else {
				san = "an" + s.strsubes(".pyz");
			}
			<sg>.newanima(san,s,0);
		} else san = s;
		sanload = san;
		_ = <sg>.newanactionsgr(san, san, this);
		<san>.hide();
		.addsrcanima(san);
	}
	operator<(string s)	{
		string sg = gameapi.getgamename;
		string san;
		if ( s.contains(".pyz") ) {
			san = "an" + s.strsubes(".pyz");
			<sg>.newanima(san,s,0);
		} else san = s;
		sanload = san;
		_ = <sg>.newanfrbyactgr(san, san, this);
		<san>.hide();
		.addsrcanima(san);
	}
	deleteloaded	{
		.deleteallgm;
		if( sanload!=null ) <gameapi.getgamename>.vardel(sanload);
	}
	deleteinit	{
		@s = gameapi.getgamename;
		for( int i=0; i<.size; i++)	{
			@s2 = .get(i);
			if( <s2>.gettype=="gmimgvec" )	{
				<s2>.deleteinit;
			}
			<s>.vardel(s2);
		}
		if( sanload!=null ) <gameapi.getgamename>.vardel(sanload);
	}
}

class gmadvvec : gmimgvec	{
	init	{	gmimgvec::init;	}
	int butisin(int x, int y, bool bignorehidden, bool bignorealpha)	{
		for( int i=lsim.size()-1; i>=0; i--)	{
			if( <lsim.get(i)>.butisin( x,y,bignorehidden,bignorealpha ) )	{
				_ifound=i;
				return i+1;
			}
		}
		_ifound = -1;
		false;
	}
}

class gmmaskvec : gmadvvec	{
	init()	{	gmadvvec::init;	}
	int butisin(int x, int y, bool bigvis, bool bigalpha)	{	gmimgvec::butisin(x,y,false,bigalpha);	}
}




class Subtitle	{
	init(string sdbfile, int borx)	{
		real rwidth = 0.5;
		new int col0; new int col1; new int col2;
		.setcolor(255,255,255);
		string spath = SNDPATH;
		
		new string ssubpos = dbconf.dbget("sgmsubtitlespos:");
		if( ssubpos==null ) ssubpos = "down";
		@s = dbconf.dbgets("sgmsubtitlespos:",2);
		new int isubpos = (s!=null ? s : 15);
		new bool bshadow = dbconf.dbgetint("igmsubshadow:");
		new int bblackbg = dbconf.dbgetint("igmsubblackbg:");
		
		new int iborx = borx;
		
		new int ifontsize = fntsubtitle.getsize;
		
		new db dbl;
		dbl.load(LANGDIR + sdbfile);
		int i=0;
		string s;
		while( i<dbl.getrowsno )	{
			if( dbl.getcolsno(i) < 2 || dbl.get(i,0)->getb(0,1)=="#" )
				dbl.removerow(i);
			else i++;
		}
		
		
		string s2;
		new vector v1;	v1.type("string");
		int cols = (iResX-2*borx)/(rwidth*ifontsize+1);
		
		int k, int j;
		int linie = 0;
		for( int i=0; i<dbl.getrowsno; i++)	{
			s = spath + dbl.get(i,0)+".wav";
			if( !engine.fileexist(s) )
				s = spath + dbl.get(i,0)+".ogg";
			dbl.set( i, 0, s );
			s = dbl.get(i,1);
			v1.vecbuildfromstring(s, " ");
			s2 = "";
			k = 1;
			for( j=0; j<v1.size; j++)	{
				if( s2.length + v1.get(j)->length + 1 <= cols )	s2 += " " + v1.get(j);
				else {
					if( k==1 )	dbl.set(i, k, s2);
					else dbl.add(i, s2);
					s2 = v1.get(j);
					k++;
				}
			}
			if( k==1 )	dbl.set(i, k, s2);
			else dbl.add(i, s2);
			if( k>linie ) linie = k;
		}
		
		new gmimgvec grtxt;
		new gmimgvec grtxts;
		for( int i=0; i<linie; i++)	{
			s = "txt"+i;
			if( bshadow )	{
				s2 = "txts"+i;
				classgame::newtext(s2,"","fntsubtitle",.black);
				grtxts.add(s2);
			} else if ( bblackbg )	{
				s2 = "imgs"+i;
				new img <s2>;
				grtxts.add(s2);
			}
			classgame::newtext(s,"","fntsubtitle",.getcolor);
			grtxt.add(s);
		}
		
		new db dbsnd;
		new timer timtxt;
		timtxt.settick(1);
		timtxt.setcycle(1);
		timtxt.addmethod("onfinish", func {
			if( !.cisplaying )	.hidesubs;
			else .play;
			} );
		.setz(12000);
	}
	geth	{
		if( grtxts.size )	<grtxts.first>.geth;
		else if ( grtxt.size )	<grtxt.last>.geth;
		else 0;
	}
	reset	{
		.stop;
		dbsnd.free;
	}
	hidesubs	{
		grtxt.hide;
		grtxts.hide;
	}
	setz(int z)	{
		grtxt.setz(z);
		grtxts.setz(z-1);
	}
	stop	{
		.hidesubs;
		timtxt.stop(false);
	}
	register(string ssnd, string sfile)	{
		@id = dbl.findbyrow(sfile);
		if( id>=0 )	{
			@r = dbsnd.findbyrow(ssnd);
			if( r>=0 )	dbsnd.set(r, 1, id);
			else {
				@r = dbsnd.addrow-1;
				dbsnd.add(r, ssnd);
				dbsnd.add(r, id);
			}
		}
	}
	getiddialog(string s)	{	dbsnd.findbyrow(s);	}
	int play(string s)	{
		.stop;
		@id = dbsnd.findbyrow(s);
		if( id>=0 )	{
			int ileznakow = 0;
			id = dbsnd.get(id, 1);
			@ile = dbl.getcolsno(id)-1;
			string s[2], int dx, int dy;
			grtxt.setpos( 0, 0 );
			int dy = 2;
			for( int i=0; i<ile; i++)	{
				s0 = grtxt.get(i);
				<s0>.txtset(dbl.get(id, i+1));
				ileznakow += <s0>.get->length;
				<s0>.setpos( (iResX-<s0>.getw)/2 + igmoffsetx, i*ifontsize + dy + igmoffsety );
				<s0>.show;
				if( bshadow )	{
					s1 = grtxt.get(i);
					<s1>.txtset(<s0>.get);
					<s1>.setpos(<s0>.getpx+1, <s0>.getpy+1);
					<s1>.show;
				} /*else if ( bblackbg )	{
					s1 = grtxts.get(i);
					dx = 4;
					dy = 2;
					//<s1>.create( <s0>.getw+ dx, <s0>.geth+dy, .black, 255 );
					//<s1>.setpos(<s0>.getpx-dx/2, <s0>.getpy-dy/2);
					<s1>.create( iResX, <s0>.geth, .black, bblackbg );
					<s1>.setpos( 0, <s0>.getpy );
					<s1>.setz( <s0>.getz-1 );
					<s1>.show;
				}*/
			}
			if( bblackbg )	{
				s0 = grtxt.first;
				s1 = grtxts.first;
				if( ssubpos=="up" )	{
					<s1>.create( iResX, <grtxt.get(ile-1)>.getey, .black, bblackbg );
					<s1>.setpos( igmoffsetx, igmoffsety );
				} else {
					<s1>.create( iResX, <grtxt.get(ile-1)>.getey - <s0>.getpy, .black, bblackbg );
					<s1>.setpos( igmoffsetx, <s0>.getpy+igmoffsety );
				}
				<s1>.setz( <s0>.getz-1 );
				<s1>.show;
			}
			if( ssubpos=="up" )	{
				dy = 0;
			} else {
				dy = iResY - ile*(ifontsize+dy)-isubpos;
				grtxt.move( 0, dy );
				if( bshadow || bblackbg ) grtxts.move(0, dy);
			}
			timtxt.play;
			ileznakow;
		} else 0;
	}
	setcolor(int r, int g, int b)	{
		col0 = r;
		col1 = g;
		col2 = b;
	}
	getcolor	{	return col0, col1, col2;	}
}

new int igmsubtitle = dbconf.dbgetint("igmsubtitle:");
new int igmlektor = dbconf.dbgetint("igmlektor:");
new int igmchardelay = dbconf.dbgetint("igmchardelay:");
if( igmsubtitle )	{
	string sf = dbconf.dbget("subtitles_font:");
	if( sf==null ) sf = sgmfontbold;
	int ifs = dbconf.dbgetint("subtitles_fontsize:");
	if( ifs <=0 ) ifs = 20;
	new font fntsubtitle;
	fntsubtitle.load( sf, ifs );
	new Subtitle subtitle( dbconf.dbget("subtitles_src:"), 50);
}

class classsound {
	init()	{
		new string _csplay = null;
		new timer timlektor;
		timlektor {
			//.var2("bsndfin", false);
			new bool bsndfin = true;
		};
		timlektor.addmethod("setsndfin", func { (bool b) bsndfin = b; } );
		timlektor.addmethod("onfinish", func {
			if( bsndfin )	{
				if( _csplay!=null ) <_csplay>.onfinish;
			} else bsndfin = true;
			} );
		if( igmsubtitle )	{
			subtitle.reset;
		}
	}
	creset()		{ _csplay = null; }
	string cgetactsnd()	{ _csplay; }
	bool cisactsnd(string ssnd)	{	ssnd==_csplay;	}
	crselfplay(string ssnd)	{
		if( !this.cisplaying() )	this.cbplay(ssnd);
		else if ( this.cgetactsnd()!=ssnd )	this.cbplay(ssnd);
	}
	cbselfplay(string ssnd)	{
		if( !.cisplaying || .cgetactsnd!=ssnd )	.cbplay(ssnd);
	}
	cbplay(string ssnd)	{
		if(this.cisplaying())
			.csplaystop(true);
		.cbsplay(ssnd);
	}
	cbsplay(string ssnd)	{
		_csplay = ssnd;
		if( ssnd!=null)
			.csubplay(ssnd);
	}
	cbplayfin(string ssnd, string sfun)	{
		<ssnd>.addmethod("onfinish", sfun);
		.cbplay(ssnd);
	}
	cbplay2(string ssnd)	{
		if(this.cisplaying())
			.csplaystop(false);
		.cbsplay(ssnd);
	}
	crplay(string ssnd)	{
		if( !.cisplaying )
			.cbsplay(ssnd);
	}
	/*crplay(string ssnd)	{
		if( _csplay!=null && <_csplay>.isplaying() )	return;
		_csplay = ssnd;
		if( ssnd!=null )
			.csubplay(ssnd);
		//	<ssnd>.play();
	}*/
	cbplayif(string ssnd)	{
		if(.cisplaying)
			.cbplay(ssnd);
	}
	crbgplay(string ssnd)	{
		if( ssnd != null && !<ssnd>.isplaying() )
			.csubplay(ssnd);
			//<ssnd>.play();
	}
	crandplay(string ssnd, int irand, string styp)	{
		if( irand.rand()==0 )	this.<"c"+styp+"play">( ssnd );
	}
	cplayf(string styp, string ssnd, string sfun)	{
		this.<"c"+styp+"play">(ssnd);
		if( <ssnd>.isplaying() && sfun!=null)	<ssnd>.addmethod("onfinish",sfun);
	}
	//cactsndstop(bool bfin)	{	if(_csplay!=null)	<_csplay>.stop(bfin);	}
	cactsndstop(bool bfin)	{
		if(.cisplaying)	.csplaystop(bfin);
	}
	csplaystop(bool bfin)	{
		if( timlektor.isplaying )	{
			timlektor.setsndfin(bfin);
			timlektor.stop(true);
		} else
			<_csplay>.stop(bfin);
	}
	cstopsnds(bool b)	{
		if( _csplay.in && .cisplaying )
			.cactsndstop(b);
	}
	bool cisplaying()	{
		_csplay!=null ? ( timlektor.isplaying || <_csplay>.isplaying ) : false;
	}
	csubplay(string s)	{
		if( igmsubtitle )	{
			int ilektor = igmlektor;
			if( !<s>.loaded )	{
				igmlektor = 0;
			}
			@dt = subtitle.play(s);
			if( igmlektor || dt<=0 ) <s>.play;
			else {
				timlektor.setdelay( dt * igmchardelay );
				timlektor.play;
			}
			igmlektor = ilektor;
		} else
			<s>.play;
	}
}

/***************************************************************************/
class classsndbank	{
	init()	{
		new int itype;
		new int ilicz = 0;
		new int iile;
		new string splay=null;
		new string ssnd = "snd";
	}
	/********************************/
	loadsingle(string sfile, int ile)	{
		if( ile<=0)	{	iile=0;	return;	}
		iile=ile;
		itype=0;
		for( int i=0; i<ile; i++)	newvars::newsnd( ssnd+i, sfile );
	}
	/********************************/
	load(string sfilebase, int ifilefrom, int ifileto, int ityp, int itypstart)	{
		iile = ifileto-ifilefrom+1;
		if(iile<=0)	{
			iile = 0;
			return;
		}
		newvars::newsnds( ssnd, 0, sfilebase, ifilefrom, ifileto);
		itype = ityp;			// 0 - po kolei, 1 - random
		if(itypstart==1)	{	// 0 - od pierwszego, 1 - randomowy
			ilicz = iile.rand( );
		}
	}
	addmethod(string ssig, string sfunc)	{
		for( int i=0; i<iile; i++)	<ssnd+i>.addmethod( ssig, sfunc );
	}
	stop(int ifin)	{	if(splay!=null)	<splay>.stop(ifin);	}
	int isplaying()	{	splay!=null ? <splay>.isplaying() : false;	}
	randplay( int irand )	{	if( irand.rand()==0 )	this.play();	}
	playid(int id)	{
		ilicz=id%iile;
		this.play();
	}
	play()	{
		this.stop(false);
		this.bgplay();
	}
	reset()	{	ilicz=0;	}
	/************************************************/
	rbgplay()	{	if( !this.isplaying() )	this.bgplay();	}
	rplay()		{	if( !this.isplaying() )	this.play();	}
	bgplay()	{
		splay = ssnd + ilicz;
		<splay>.play();
		if( itype==0)	ilicz = (ilicz+1)%iile;
		else if (itype==1)	ilicz = iile.rand();
	}
	setvol(int vol)	{	for( int i=0; i<iile; i++)	<ssnd+i>.setvol( vol );	}
}

class SoundSource	{
	init	{	}
	setvol(string ssnd, int srcvol, int outvol, real rad, real length)	{
		if( length.abs>=rad ) <ssnd>.setvol(outvol);
		else {
			srcvol = (1.0-length.abs/rad)*srcvol + outvol;
			if( srcvol > 100 ) srcvol=100;
			<ssnd>.setvol(srcvol);
		}
	}
}

/**************************************************************/
	// standardowe czynnosci przy grach, popakowane w metody
class classgame : newvars , classsound {
	init()	{
		newvars::init();
		classsound::init();
		new int _iconstid;
		new gmobjvec _grsfxs;
	}
	/**************************************************************/
	bkg=(@sfile)	{
		if( sfile.contains(".pyz") ) .newanima("anbkg", sfile, 0);
		else .newimg("imgbkg",sfile,0);
	}
	bgr=(@sfile)	{
		//this.csndplayloop("sndbgr",sfile);
		.csndbgr(sfile);
	}
	path=(@s)	{	.setgraphpath("scripts/"+s+"/");	}
	cycle=(@stimer, @sfun)	{	.cnewtimercyclefin(stimer,1,1,sfun);	}
	timer=(@stimer, @itime, @sfun) { .cnewtimerfin(stimer,itime,1,sfun);	}
	timplay(@stimer, @itime, @sfun) {
		.cnewtimerfin(stimer,itime,1,sfun);
		<stimer>.play;
	}
	def _getflags(string s)	{
		@bloop = false;
		if( s.contains("L") )	{
			s.strremove("L");
			bloop=true;
		}
		@bplay = false;
		if( s.contains("P") )	{
			s.strremove("P");
			bplay=true;
		}
		@bhide = false;
		if( s.contains("H") )	{
			s.strremove("H");
			bhide=true;
		}
		return s,bloop,bplay,bhide;
	}
	img=(@sfile)	{
		_ = ._build_img(sfile);
	}
	getlangfile(string s)	{
		@s2 = s.strsube(4) + "_" + LANG + s.gete(0,4);
		engine.fileexist( .getpath(s2) ) ? s2 : s;
	}
	_build_img(@sfile)	{
		|sfile,@bloop,@bplay,@bhide| = ._getflags(sfile);
		bool bgroup = false;
		if(sfile.contains("G"))	{
			sfile.strremove("G");
			bgroup = true;
		}
		@iz = 0;
		if( sfile.contains(" ") )	{
			iz = sfile.strgetfrom(" ");
			sfile = sfile.strgetto(" ");
		}
		string sname;
		if( sfile.contains("/") ) {
			new vector _v_sfile;
			_v_sfile.type("string");
			_v_sfile.vecbuildfromstring(sfile,"/");
			sname = _v_sfile.last->strsube(4);
			delete _v_sfile;
		} else sname = sfile.strsube(4);
		string s;
		if( sfile.contains(".pyz") ) {
			if( bgroup )	{
				s = "gr"+sname;
				.newgrimg(s, .getlangfile(sfile)->strsubes(".pyz"), iz);
			} else {
				s = "an" + sname;
				.newanima(s, .getlangfile(sfile), iz);
			}
		} else {
			s = "img" + sname;
			.newimg(s, .getlangfile(sfile), iz);
		}
		if( bloop ) <s>.anloopfin;
		if( bplay ) <s>.play(-1);
		if( bhide ) <s>.hide;
		s;
	}
	imgsgr=	{
		string sgr = _;
		string simg;
		new gmimgvec <sgr>;
		@s = _;
		while( A != s )	{
			<sgr>.add(._build_img(s));
			@s = _;
		}
	}
	imgs=	{	.withlist("img=");	}
	clone(string sob)	{
		<gameapi.getgamename> (this, .gettype, sob) { (@sthis, @styp, @sob)
			new <styp> <sob>;
			<sob>.copy(sthis);
		};
	}
	clones=	{	.withlist("clone");	}
	list=(@sname)	{
		@s=_;
		new gmobjvec <sname>;
		while(A!=s)	{
			<sname>.addbegin(s);
			s = _;
		}
	}
	list2={
		@s = .newconst("gmobjvec");
		.list=(s);
		s;
	}
	debug=(@b)	{	engine.setdebugstate(b);	}
	sfx=(string s)	{
		bool bloop2 = s.contains("N");
		if( bloop2 )	{
			s.strremove("N");
		}
		|s,@bloop,@bplay,_| = ._getflags(s);
		@ivol = 100;
		if( s.contains(" ") )	{
			ivol = s.strgetfrom(" ");
			s = s.strgetto(" ");
		}
		string sf = "fx"+s;
		//.newsnd(sf, "sfx/"+s+".wav");
		.newsfx( sf, s+".wav");
		<sf>.setvol( ivol );
		if( bloop ) <sf>.addmethod("onfinish","_stdsndloop");
		if( bplay ) <sf>.play;
		else if( bloop2 ) <sf>.playloop;
		_grsfxs.add(sf);
	}
	sfxs=	{	.withlist("sfx=");	}
	snd=(string sname, string sfile, string sfun)	{
		.newsndfree(sname, sfile + ".wav");
		<sname>.addmethod("onfinish", sfun);
	}
	tickstart	{
		if( !.hasvar("__timspeed") )	new TicksCounter __timspeed;
		__timspeed.start;
	}
	tickstop	{	__timspeed.print("ticker: ");	}
	/**************************************************************/
	csndplayloop(string ssnd, string sfile)	{
		this.newsndloop(ssnd,sfile);
		<ssnd>.play();
	}
	csndbgr(string sfile)	{
		//this.csndplayloop("sndbgr",sfile);
		.newbgr("sndbgr", sfile );
		.sndplayloop("sndbgr");
	}
	cloadcursor(string sfile)	{
		if( sfile.contains(".") )	{
			.newimg("imgkursor", sfile,0);
			sfile = "imgkursor";
		}
		<sfile>.hide();
		mouse.setcursor(sfile);
		engine.stdbutcursor(sfile);
// 		bsms.setown();
	}
	/****************************************************************/
	newimgarray(string sname, string styp, string sn, int ile)	{
		new gmimgvec <sname>;
		<sname>.buildarray(styp,sn,ile);
	}
	newfont(string sfnt, string sfile, int isize)	{
		new font <sfnt>;
		<sfnt>.load( sfile, isize );
	}
	monofont(string sfnt, int isize)	{	.newfont(sfnt, sgmfontmono, isize);	}
	newfontbold(string sfnt, int isize)	{	.newfont(sfnt, sgmfontbold, isize);	}
	string snewfont(string sfontfile, int isize)	{
		string s = .newconst("font");
		<s>.load( sfontfile, isize );
		return s;
	}
	string stdfont(int isize)	{	.snewfont( sgmfontfile, isize	);	}
	string stdmono(int isize)	{	.snewfont( sgmfontmono, isize);	}
	string stdbold(int isize)	{	.snewfont( sgmfontbold, isize);	}
	int getconstid	{	_iconstid++;	_iconstid-1;	}
	string newconst(string styp)	{
		string s = "const"+styp+.getconstid;
		new <styp> <s>;
		return s;
	}
	string consttext(string stext, int x, int y, int isize, int r, int g, int b)	{
		string s = this.newconst("text");
		string sf = .stdfont(isize);
		<s>.setfont(sf);
		<s>.set(stext);
		<s>.createtxt(r,g,b);
		<s>.setpos(x,y);
		return s;
	}
	newtext(string stxt, string stext, string sfont, int r, int g, int b)	{
		new text <stxt>;
		<stxt>.set(stext);
		<stxt>.setfont(sfont);
		<stxt>.createtxt(r,g,b);
	}
	newtextposz(string stxt, string stext, string sfont, int r, int g, int b, int x, int y, int z)	{
		.newtext(stxt,stext,sfont,r,g,b);
		<stxt>.anposz(x,y,z);
	}
	newgrimg(string sgr, string sfile, int z)	{
		new gmimgvec <sgr>;
		sgr .* (sfile+".pyz");
		<sgr>.setz(z);
	}
	/****************************************************************/
	cfinmethod(string sobj, string sfuncfin)	{	<sobj>.addmethod("onfinish", sfuncfin);	}
	cnewsndfin(string sname, string sfile, string sfunc)	{
		this.newsnd(sname,sfile);
		this.cfinmethod(sname,sfunc);
	}
	cnewsndsfin(string sbase, int inamestart, string sfilebase, int ifilefrom, int ifileto, string sfunc)	{
		this.newsnds(sbase, inamestart, sfilebase, ifilefrom, ifileto);
		this.caddobjsfunfin(sbase, inamestart, inamestart+( ifileto-ifilefrom), sfunc);
	}
	cnewsndfinbplay(string sname, string sfile, string sfunc)	{
		this.cnewsndfin(sname,sfile,sfunc);
		this.cbplay(sname);
	}
	cnewtimerfin(string sname, int idelay, int iticks, string sfunc)	{
		this.newtimer(sname,idelay,iticks);
		this.cfinmethod(sname,sfunc);
	}
	cnewtimercyclefin(string sname, int icycle, int iticks, string sfunc)	{
		this.newtimercycle(sname,icycle,iticks);
		this.cfinmethod(sname,sfunc);
	}
	/****************************************************************/
	caddobjsfun(string ssnd, int ifrom, int ito, string ssig, string sfunc)	{
		while( ifrom <= ito )	{
			<ssnd+ifrom>.addmethod( ssig, sfunc+ifrom );
			ifrom++;
		}
	}
	caddobjsfunfin(string ssnd, int ifrom, int ito, string sfunc)	{
		this.caddobjsfun( ssnd, ifrom, ito, "onfinish", sfunc );
	}
	/****************************************************************/
	newancounter(string scounter, string sname, string sfile, int z, int ile)	{
		this.newanimas( sname, sfile, z, ile);
		new classancounter <scounter>;
		<scounter>.set( sname, ile );
	}
	newancounterh(string scounter, string sname, string sfile, int z, int ile)	{
		this.newancounter( scounter, sname, sfile, z , ile );
		for( int i=0; i<ile; i++)	<sname+i>.hide();
	}
	newancounterf(string scounter, string sname, string sfile, int z, int ile, string sfun)	{
		this.newancounter( scounter, sname, sfile, z , ile );
		for( int i=0; i<ile; i++)	<sname+i>.addmethod("onfinish", sfun);
	}
	newancounterhf(string scounter, string sname, string sfile, int z, int ile, string sfun)	{
		this.newancounter( scounter, sname, sfile, z , ile );
		for( int i=0; i<ile; i++)	{
			<sname+i>.addmethod("onfinish", sfun);
			<sname+i>.hide();
		}
	}
	cnewanimafin(string sname, string sfile, int z, string sfunc)	{
		this.newanima(sname, sfile, z);
		<sname>.addmethod("onfinish", sfunc );
	}
	ccopyanimafin(string sname, string snew, string sfunc)	{
		this.copyanima(sname, snew);
		<snew>.addmethod("onfinish", sfunc );
	}
	/****************************************************************/
	cloadwavs(string sdb, string sfile)	{
		this.newdb( sdb, sfile );
		int id = 0;
		int ile = <sdb>.getrowsno();
		int i[6], string s[5];
		while( id < ile )	{
			i1 = <sdb>.getcolsno(id);
			i2 = 0;
			s1 = <sdb>.get( id, i2 );	i2++;
			if( s1.getb(0,1)!="#" )	{
				s3 = <sdb>.get( id, i2 );	i2++;
				if( s1=="wav" || s1=="sfx" )	{
					s2 = <sdb>.get( id, i2 );	i2++;
					if( s1=="sfx")	{
						this.newsfx( s3, s2 );
					} else { this.newsnd( s3, s2 ); }
					if( i2 < i1 )	{
						s1 = <sdb>.get( id, i2 );	i2++;
						s2 = <sdb>.get( id, i2 );	i2++;
						if( s1=="method" )	{
							<s3>.addmethod("onfinish", s2 );
						} else if (s1.gete(0,4)=="play")	{
							this.<"c"+s1.gete(4,10)+"playonfin">(s3, s2);
						} else if ( s1=="vol" )	{
							<s3>.setvol( s2 );
						}
					}
				} else if (s1=="group")	{
					s2 = <sdb>.get( id, i2 );	i2++;
					i3 = <sdb>.get( id, i2 );	i2++;
					i4 = <sdb>.get( id, i2 );	i2++;
					if( i2 < i1 )	{		// jest method
						s1 = <sdb>.get( id, i2 );	i2++;
						if( s1=="method" )	{
							s4 = <sdb>.get( id, i2 );	i2++;
							this.cnewsndsfin( s3, i3, s2, i3, i4, s4 );
						}
					} else {
						this.newsnds( s3, i3, s2, i3, i4 );
					}
				} else if (s1=="bank")	{
					s2 = <sdb>.get( id, i2 );	i2++;
					i0 = <sdb>.get( id, i2 );	i2++;
					i3 = <sdb>.get( id, i2 );	i2++;
					i4 = <sdb>.get( id, i2 );	i2++;
					i5 = <sdb>.get( id, i2 );	i2++;
					new classsndbank <s3>;
					<s3>.load( s2, i0, i3, i4, i5);
					if( i2<i1)	{
						s1 = <sdb>.get( id, i2 );	i2++;
						if( s1=="method")	{
							s4 = <sdb>.get( id, i2 );	i2++;
							<s3>.addmethod( "onfinish", s4 );
						} else if (s1=="vol")	{
							<s3>.setvol( <sdb>.get( id, i2 ) );
						}
					}
				} else if ( s1=="method" )	{
					s2 = <sdb>.get( id, i2 );	i2++;
					i3 = <sdb>.get( id, i2 );	i2++;
					i4 = <sdb>.get( id, i2 );	i2++;
					while( i3<=i4)	{
						<s2+i3>.addmethod("onfinish", s3);
						i3++;
					}
				} else if ( s1=="singlebank")	{
					s2 = <sdb>.get( id, i2 );	i2++;
					i3 = <sdb>.get( id, i2 );	i2++;
					new classsndbank <s3>;
					<s3>.loadsingle( s2, i3 );
				} else if ( s1=="bgr" )	{
					this.csndbgr( s3 );
					if( i2 < i1 )	{
						if( <sdb>.get( id, i2 )=="vol" )	{
							i2++;
							sndbgr.setvol( <sdb>.get( id, i2 ) );
							i2++;
						}
					}
				} else if ( s1=="music" )	{
					this.playmusic( s3 );
					if( i2 < i1 )	{
						if( <sdb>.get( id, i2 )=="vol" )	{
							i2++;
							sndbgr.setvol( <sdb>.get( id, i2 ) );
							i2++;
						}
					}
				}
			}
			id++;
		}
	}
	/****************************************************************/
	crestart()	{	gameapi.play( gameapi.getgamename() );	}
	/****************************************************************/
	cgetscreenshoot(string sfile, real rzoom)	{
		new img _imgsavebkg;
		_imgsavebkg.create(iResX,iResY,.white,255);
		_imgsavebkg.setz(2000);
		_imgsavebkg.blitscreen;
		
		if( rzoom!=1.0 )	{
			new filter _ftbg;
			_ftbg.link("_imgsavebkg");
			_ftbg.setsmooth(1);
			_ftbg.setzoom(rzoom);
		}
		_imgsavebkg.setpos(0,0);
		
		new img _im_1;
		_im_1.create(rzoom*iResX, rzoom*iResY, .white,255);
		_im_1.setpos(_imgsavebkg.getpx, _imgsavebkg.getpy);
		_im_1.blit("_imgsavebkg");
		
		_im_1.save(sfile);
		
		delete _im_1;
		if( rzoom!=1.0 )	{
			_ftbg.unlink;
			delete _ftbg;
		}
		delete _imgsavebkg;
	}
}


/***************************************************************************/

class clfindfunc	{
	init()	{}
	int _stdfindfunc(string sobj, int ifirst, int ilast, string sname, string sfunc)	{	
		while(ifirst<=ilast)	{
			if( <sobj + ifirst>.<sfunc>() ==sname )	return ifirst;
			ifirst++;
		}
		-1;
	}
	int _stdfindfunc2(string sobj, int iile, string sname, string sfunc)	{	
		._stdfindfunc(sobj, 0, iile-1, sname, sfunc);
	}
	/****************************************************************/
	cfindandeval2(string sobj, int iile, string sname, string sfunc, string seval)	{	
		.cfindandeval(sobj, 0, iile-1, sname, sfunc, seval);
	}
	cfindandeval(string sobj, int ifirst, int ilast, string sname, string sfunc, string seval)	{	
		int pos = ._stdfindfunc(sobj, ifirst, ilast, sname, sfunc);
		if(pos>=0)	<sobj+pos>.<seval>();
	}
}



/*****************************************************************/
class classbutton 	{
	init()	{
		new string san = "anbut";
		new string sbut = "but";
		new int iilebut = 0;
		new string sfxmon = null;
	}
	_cbuildbutname(string sname)	{	new string _sbutname=sname; }
	string cgetbutname()	{ return _sbutname; }
	build(string sfile, int z, string smouse)	{this.build2(sfile,z,smouse,null);	}
	build2(string sfile, int z, string smouse, string sgrp)	{	// wczytuje animacje i buduje z niej przyciski
		string smain = "_" + san;
		new anima <smain>;
		<smain>.load( sfile );
		<smain>.setz(z);
		int ile = <smain>.nofactions();
		int j;	int k;
		int iliczans = 0;
		string sn1, string sn2, string sn3;
		string spom;
		for(int i=0; i<ile; i++)	{
			sn1 = null;	sn2 = null;	sn3 = null;
			j = <smain>.nofframes(i);
			for(k=1; k<=j; k++)	{
				spom = san + iliczans;
				if(k==1)	{	sn1=spom; } 
				else if (k==2)	{ sn2 = spom; }
				else if (k==3)	{ sn3 = spom; }
				newvars::copyanima( smain, spom );
				<spom>.setframe( i, k-1 );
				iliczans++;
			}
			if( sgrp!=null && <sgrp>.contains( <smain>.nameofaction(i)) ) {
				<sn1>.setz(z-1);
			} else this.addbut(sn1, sn2, sn3, smouse);
		}
		<smain>.hide();
	}
	/***************************** \/ \/ \/ \/ \/ wewnetrzne \/ \/ \/ \/ \/ *************************************************/
	_buildfuncclick( string sname )	{	new string _sfunclick = sname; }
	_stdbutclick()	{	this.<_sfunclick>( this.getbutname() );		}
	_buildfuncrel( string sname )	{	new string _sfuncrel = sname; }
	_stdbutrel()	{	this.<_sfuncrel>( this.getbutname() );	}
	_buildfuncmovon( string sname )	{	new string _sfunmovon = sname; }
	_stdbutmovon()	{
		if( sfxmon!=null )	<sfxmon>.play();
		this.<_sfunmovon>( this.getbutname() );
	}
	_buildfuncmovoff( string sname )	{	new string _sfunmovoff = sname; }
	_stdbutmovoff()	{	this.<_sfunmovoff>( this.getbutname() );	}
	butsigfun(string sb, string sfunc, string ssig, string sfun1, string sfun2)	{
		if( sfunc==null )	return;
		<sb>.addmethod(sfun1, sfun1);
		<sb>.<sfun1>( sfunc );
		<sb>.addmethod(ssig, sfun2);
	}
	sigfunc(string sfunc, string ssig, string sfun1, string sfun2)	{
		for(int i=0; i<iilebut; i++)	this.butsigfun(sbut + i, sfunc, ssig, sfun1, sfun2);
	}
	print()	{for(int i=0; i<iilebut; i++)	engine.print( <sbut+i>.getbutname() );}
	setrect()	{
		string s;
		for( int i=0; i<iilebut; i++)	{
			s = <sbut+i>.getimg;
			<sbut+i>.setrect( <s>.getpx, <s>.getpy, <s>.getex, <s>.getey );
		}
	}
	setflags(bool bvis, bool balph)	{	for(int i=0; i<iilebut; i++)	<sbut+i>.setflags(bvis,balph);	}
	/***************************** /\ /\ /\ /\ /\ wewnetrzne /\ /\ /\ /\ /\ ************************************************/
	sfxonmovon(string ssnd)	{	sfxmon=ssnd;	}
	clickfunc(string sfunc)	{this.sigfunc(sfunc,"onclick", "_buildfuncclick", "_stdbutclick");	}
	relfunc(string sfunc)	{this.sigfunc(sfunc,"onrel", "_buildfuncrel", "_stdbutrel");	}
	movonfunc(string sfunc)	{this.sigfunc(sfunc,"onmoveon", "_buildfuncmovon", "_stdbutmovon");	}
	movofffunc( string sfunc)	{this.sigfunc( sfunc,"onmoveoff", "_buildfuncmovoff", "_stdbutmovoff");}
	/*****************************************************************/
	int ilebuts()	{	return iilebut;	}
	/*****************************************************************/
	int ifind(string sname)	{return clfindfunc::_stdfindfunc2(sbut, iilebut, sname, "getbutname");	}
	string sfind(string sname)	{
		int pos = clfindfunc::_stdfindfunc2(sbut, iilebut, sname, "getbutname");
		return pos>=0 ? sbut+pos : null;
	}
	/*****************************************************************/
	_cbutfun(string sname, string sfunc)	{
		clfindfunc::cfindandeval2(sbut, this.ilebuts(), sname, "getbutname", sfunc );
	}
	_callbutfunc(string sfunc)	{	for(int i=0; i<iilebut; i++)	<sbut+i>.<sfunc>();	}
	_cibutfunc(string sfunc, int ile)	{
		if( ile > iilebut )	ile = iilebut;
		for(int i=0; i<ile; i++)	<sbut+i>.<sfunc>();
	}
	ienable( int ile )	{	this._cibutfunc("enable", ile);	}
	benableall()	{	this.resumeall();	this.enableall();	}
	pauseall()	{	this._callbutfunc("pause");	}
	resumeall()	{	this._callbutfunc("resume");	}
	enableall()	{	this._callbutfunc("enable");	}
	disableall()	{	this._callbutfunc("disable");	}
	disabled	{	<sbut+0>.disabled;	}
	
	benable(string sname)	{	this.resume(sname);	this.enable(sname);	}
	disable(string sname)	{	this._cbutfun( sname, "disable");	}
	enable(string sname)	{	this._cbutfun( sname, "enable");	}
	pause(string sname)	{	this._cbutfun( sname, "pause");	}
	resume(string sname)	{	this._cbutfun( sname, "resume");	}
	
	resetall()	{	for(int i=0; i<iilebut; i++)	<sbut+i>.setcursorpos(0, 0);	}
	setcursorpos(int x, int y)	{	for(int i=0; i<iilebut; i++)	<sbut+i>.setcursorpos(x, y);	}
	/*****************************************************************/
	string getimg(string sname)	{
		string s= this.sfind(sname);
		return s!=null ? <s>.getimg() : null;	
	}
	callimgfun(string sname, string sfun)	{	<.getimg(sname)>.<sfun>;	}
	/*****************************************************************/
	newmouse(string sname, string snewmouse)	{
		string s = this.sfind(sname);
		if(s!=null)	<s>.setmouse( snewmouse );
	}
	addbut(string san1, string san2, string san3, string smouse)	{
		string spom = sbut + iilebut;
		newvars::newbutan( spom, san1, san2, san3, smouse);
		<spom>.addmethod("getbutname","cgetbutname");
		<spom>._cbuildbutname( <san1>.actionname() );	// nazwa buttonu to nazwa akcji
		iilebut++;
	}
	/*****************************************************************/
	_addfunc(string s, string sfclick, string sfrel, string sfmvon, string sfmvoff)	{
		if( s== null)	return;
		this.butsigfun( s, sfclick, "onclick", "_buildfuncclick", "_stdbutclick");
		this.butsigfun( s, sfrel, "onrel", "_buildfuncrel", "_stdbutrel");
		this.butsigfun( s, sfmvon, "onmoveon", "_buildfuncmovon", "_stdbutmovon");
		this.butsigfun( s, sfmvoff, "onmoveoff", "_buildfuncmovoff", "_stdbutmovoff");
	}
	addfuncto(string sname, string sfclick, string sfrel, string sfmvon, string sfmvoff)	{
		this._addfunc( this.sfind(sname), sfclick, sfrel, sfmvon, sfmvoff);
	}
	addfunctolast(string sfclick, string sfrel, string sfmvon, string sfmvoff)	{
		this._addfunc( sbut + (iilebut-1) , sfclick, sfrel, sfmvon, sfmvoff);
	}
	/*****************************************************************/
	_transmet(string sob, string sfunc, string smet, string s)	{
		new string <"_sob" + s> = sob;
		new string <"_sf" + s> = sfunc;
		this.<smet>( "_trf"+s );
	}
	transclickfunc(string sob, string sfunc)	{this._transmet( sob, sfunc, "clickfunc", "cl" );	}
	transrelfunc(string sob, string sfunc)	{this._transmet( sob, sfunc, "relfunc", "rl" );	}
	transmovonfunc(string sob, string sfunc){this._transmet( sob, sfunc, "movonfunc", "mn" );	}
	transmovofffunc(string sob, string sfunc){this._transmet( sob, sfunc, "movofffunc", "mf" );	}
	_trfcl(string s)	{	<_sobcl>.<_sfcl>(s);		}
	_trfrl(string s)	{	<_sobrl>.<_sfrl>(s);		}
	_trfmn(string s)	{
		if( sfxmon!=null )	<sfxmon>.play();
		<_sobmn>.<_sfmn>(s);
	}
	_trfmf(string s)	{	<_sobmf>.<_sfmf>(s);		}
}

class classsimplebutton {
	init()	{
		new string simgob=null;
		new gmimgvec grbut;
	}
	public stdbuild(string sfile, string smouse, int z)	{this.build(this.getgraphpath()+sfile, smouse, 0, 0, z, 0);	}
	public getimgfunc(string sfunc)	{	simgob==null ? 0 : <simgob>.<sfunc>();	}
	public setbutpos(int x, int y)	{	grbut.setpos(x,y);	}
	public build(string sfile, string smouse, int x, int y, int z, int iact)	{
		new button but1;
		but1 (this.getname()) {(string s) new string sbut = s; };
		but1.addmethod("onclick", func { this.<sbut+"_CLICK">(); });
		but1.addmethod("onrel", func { this.<sbut+"_REL">(); } );
		but1.addmethod("onmoveon", func { this.<sbut+"_MOVEON">(); });
		but1.addmethod("onmoveoff", func { this.<sbut+"_MOVEOFF">(); });
		
		if( sfile.contains(".pyz") )	{
			new anima anbut0;
			anbut0.load( sfile );
			anbut0.setpos(x,y);
			anbut0.setz(z);
			anbut0.setframe(iact,0);
			simgob="anbut0";
			grbut.add(simgob);
			string s0="anbut0";
			string s1=null;
			string s2=null;
			int ile = anbut0.nofframes(iact);
			if( ile>1 )	{
				new anima anbut1;
				anbut1.copy("anbut0");
				anbut1.setframe(iact,1);
				s1 = "anbut1";
				grbut.add(s1);
			}
			if (ile>2)	{
				new anima anbut2;
				anbut2.copy("anbut0");
				anbut2.setframe(iact,2);
				s1 = "anbut2";
				grbut.add(s1);
			}
			but1.setan(s0,s1,s2);
		} else {
			new img imgbut;
			simgob="imgbut";
			grbut.add(simgob);
			imgbut.load(sfile);
			imgbut.setpos(x,y);
			imgbut.setz(z);
			but1.set("imgbut",null,null);
		}
		but1.setmouse(smouse);
	}
}

/*****************************************************************/

class classmask : classbutton	{
	init()	{
		classbutton::init();
	}
	buildmask(string sfile, string smouse)	{
		this.build(sfile, 0, smouse);
		int ile = this.ilebuts();
		for(int i=0; i<ile; i++)	{
			<sbut+i>.setflags(false, false);
			<sbut+i>.hide();
		}
	}
	buildmaskfunc(string sfile, string smouse, string sfunc)	{
		this.buildmask(sfile, smouse);
		this.clickfunc(sfunc);
	}
	addmask(string sanim, string sname, string smouse, int bhide)	{		// dodanie np. ludka jako maski
		string spom = sbut + iilebut;
		newvars::newbutan( spom, sanim, null, null, smouse);
		<spom>.addmethod("getbutname","cgetbutname");
		sname==null ? <spom>._cbuildbutname(<sanim>.actionname()) : <spom>._cbuildbutname(sname);
		if(bhide)	{
			<spom>.setflags(false, false);
			<spom>.hide();
		}
		iilebut++;
	}
	addadvmask(string sanim, string sname, string smouse, string sfuncclick)	{
		this.addmask( sanim, sname, smouse, false );
		this.addfunctolast( sfuncclick, null, null, null);	
	}
}

/*****************************************************/
public _stdanloop()	{	this.play(-1); }
public _stdanhide()	{	this.hide();	}
public _stdsndloop()	{	this.play(); }
public __std_finish()	{	this.<this+"_FINISH">();	}
public looponfinish(string san)	{	<san>.addmethod("onfinish", "_stdanloop");	}
public hideonfinish(string san)	{	<san>.addmethod("onfinish", "_stdanhide");	}
/*****************************************************/
public string strsube(int ile)	{	this.getb( 0, this.length()-ile );	}
public string strsubb(int ile)	{	this.getb( ile, this.length() - ile );	}
public string strsubbs(string s)	{	this.strsubb( s.length() );	}
public string strsubes(string s)	{	this.strsube( s.length() );	 }
public string strgetto(string schar)	{
	@id = .find(schar);
	id<0 ? .get : .getb(0, id);
}
public string strgeteto(string schar)	{
	@id = .rfind(schar);
	id<0 ? .get : .getb(id+1, .length);
}
public bool streq(string s)	{	.get == s.getb(0, .length);	}
public string strgetfromto(int ipos, string schar)	{	this.getb(ipos, this.find(schar));	}
public string strgetfrom(string schar)	{	.getb(.find(schar)+schar.length, .length );	}
public strremove(string s)	{	.set( .strgetto(s) + .strgetfrom(s) ); }
public bool strisbetween(int b1, int b2)	{
	int ib;
	for(int i=0; i<.length; i++)	{
		ib = .getbyte(i);
		if( ib<b1 || ib>b2 )	return false;
	}
	true;
}
public bool strisint		{	.strisbetween(BYTE0, BYTE9);	}
public bool strisbin	{	.strisbetween(BYTE0, BYTE0+1);	}
public bool strisalpha	{	.strisbetween(BYTEa, BYTEz);	}
public streach(string sfun)	{
	string s;
	for( int i=0; i<.length; i++) {
		s = .getb(i,1);
		<s>.<sfun>(i);
	}
}
public string strdotpos(int pos)	{	.strgetto(".") + "." + .strgetfrom(".")->getb(0,pos);}
/*****************************************************/
public swap(string s1, string s2)	{
	[s1];
	<s1> = [s2];
	<s2> = _;
}
public bool stats(int ile)	{	(ile <= 0) ? false : ( 100->rand <= ile );}
public def between(def i1, def i, def i2)	{	( i < i1 ) ? i1 : (i>i2) ? i2 : i;}
public def max(def val1, def val2)	{	val1>val2 ? val1 : val2;	}
public def min(def val1, def val2)		{	val1<val2 ? val1 : val2;	}
/*************** do wykorzystania na obiektach!! ***********************************/
public movoffsetr	{	.move(igmoffsetx,0);	}
public movoffsetl	{	.move(-igmoffsetx,0);	}
public imgprint	{
	(this+": x="+.getpx+", y="+.getpy+", w="+.getw + ",h="+.geth + ",ex="+.getex +",ey="+.getey+", z="+.getz)->print;
}
public imgborders(int w, int r, int g, int b, int a)	{	.imgborderss(w,r,g,b,a,"1111"); }
public imgborderss(int w, int r, int g, int b, int a, string sbor)	{
	new img _img_bor;
	_img_bor.create(.getw, w, r,g,b,a);
	_img_bor.setpos(.getpx, .getpy );
	if(sbor.getb(3,1)=="1")
		.blit("_img_bor");
	_img_bor.move(0, .geth-w);
	if(sbor.getb(1,1)=="1")
		.blit("_img_bor");
	_img_bor.create(w,.geth,r,g,b,a);
	_img_bor.setpos(.getpx, .getpy);
	if(sbor.getb(0,1)=="1")
		.blit("_img_bor");
	_img_bor.move(.getw-w, 0);
	if(sbor.getb(2,1)=="1")
		.blit("_img_bor");
	delete _img_bor;
}
public imgroundborder(int w, int r, int g, int b, int a)	{
	.imgborders(w,r,g,b,a);
	.imgerasecorners;
}
public imgerasecorners	{
	@x = .getpx;
	@y = .getpy;
	.putrgba(x,y,.transparent);
	.putrgba(.getex-1,y,.transparent);
	.putrgba(.getex-1,.getey-1,.transparent);
	.putrgba(x,.getey-1,.transparent);
}
public real imgdrawline(string sbrush, int xstart, int ystart, int xstop, int ystop, real istep, real rdy)	{
	.imgfuncline("blit",sbrush,xstart,ystart,xstop,ystop,istep,rdy);
}
public real imgeraseline(string sbrush, int xstart, int ystart, int xstop, int ystop, real istep, real rdy)	{
	.imgfuncline("erase",sbrush,xstart,ystart,xstop,ystop,istep,rdy);
}
public imgputoncenter(string simg)	{	.setpos( <simg>.getcx-.getw/2, <simg>.getcy-.geth/2);	}
public real imgfuncline(string sfun, string sbrush, int xstart, int ystart, int xstop, int ystop, real istep, real rdy)	{
	@dx = xstop-xstart;
	@dy = ystop-ystart;
	real r;
	if( dx==0 )	{
		if( dy<0 )	{
			r = rdy+ystart;
			while( r>=ystop )	{
				<sbrush>.setpos(xstart, r);
				.<sfun>(sbrush);
				r-=istep;
			}
			ystop-r;
		} else if (dy>0)	{
			r = rdy+ystart;
			while( r<=ystop )	{
				<sbrush>.setpos(xstart, r);
				.<sfun>(sbrush);
				r+=istep;
			}
			r-ystop;
		} else rdy;
	} else {
		r = rdy.length(dx, dy);
		real rd;
		while( rdy<=r )	{
			rd = 1.0 - (r-rdy)/r;
			<sbrush>.setpos( (rd*dx)+xstart, (rd*dy)+ystart );
			.<sfun>(sbrush);
			rdy+=istep;
		}
		rdy-r;
	}
}
public anresizemets()	{	anima_pack::resizemethods(this.getname());	}
//public def anfirstnontr	{	classansearcher::firstnotrx1y(this);	}
public def anfirstnontr	{	classansearcher::_findnotr(this,.getpx, .getpy, 1, 0);	}
public anloopfin()	{	this.addmethod("onfinish", "_stdanloop");	}
public anloopplay(int iact)	{	this.anloopfin();	this.play(iact);	}
public anloopsplay(string sact)	{	this.anloopfin();	this.play(sact);	}
public anhidefin()	{	this.addmethod("onfinish","_stdanhide");	}
public anputgr()	{	this.setz( this.getey() );	}
public anputy(int ypos)	{	this.move(0, ypos - this.geth() - this.getpy());	}
public anputx(int xpos)	{	this.move(0, xpos - this.geth() - this.getpy());	}
public ansetposgr(int x, int y)	{	this.setpos(x,y);	this.anputgr();	}
public anplayz(int id, int z)	{	this.setz(z);	this.play(id);	}
public anplaygr(int id)	{	this.play(id);	this.anputgr();	}
public anplayzpos(int id, int z, int x, int y)	{	this.setpos(x,y);	this.anplayz(id,z);	}
public anplaypos(int x, int y)	{	this.setpos(x,y);	this.play(-1);	}
public anplayposgr(int x, int y)	{	this.ansetposgr(x,y);	this.play(-1);	}
public anplaypos2(int x, int y, string sact)	{	this.setpos(x,y);	this.play(sact);	}
public anplaypos3(int x, int y, int iact)	{	this.setpos(x,y);	this.play(iact);	}
public anhide()	{	this.stop(false);	this.hide();	}
public andownpos(int x, int y)	{	this.setpos( x, y-this.geth() );	}
public ansetbpos(int x, int y)	{	this.setpos( x-this.lodx(), y-this.lody() );	}
public ansetcpos(int x, int y)	{	.ansetbpos( x - .getw/2, y - .geth/2 );	}
public ancenterscreen {       .ansetcpos( iResX/2, iResY/2 ); }
public imgfit(int x, int y, int ex, int ey)	{
	if( .getpx < x ) .move( x-.getpx, 0 );
	if( .getpy < y ) .move( 0, y-.getpy );
	if( .getex > ex ) .move( ex-.getex, 0 );
	if( .getey > ey ) .move( 0, ey-.getey );
}
public imgfitscreen	{	.imgfit( igmoffsetx, igmoffsety, iResX+igmoffsetx, iResY+igmoffsety );	}
public ansetframe(int id)	{	this.setframe( this.actionnr(-1), id );	}
public ansetsframe(def d, string s)	{
	.setframe(d,0);
	int id = 0;
	while( id < .nofframes(-1) && .framename!=s )	{
		id++;
		.setframe(-1,id);
	}
}
public ansetlastframe(def act)	{	.setframe( act, .nofframes(act)-1 );	}
public int anonscreen()	{	clsurf.inscreen(this.getcx(), this.getcy(), this.getw()/2, this.geth()/2);	}
public objplayfin(string sfun)	{	this.addmethod("onfinish", sfun);	this.play();	}
public objloop()	{	this.addmethod("onfinish","_stdsndloop");	}
public objplayloop()	{	this.objloop;	this.play();	}
public anplayfin(def act, string sfun)	{	this.addmethod("onfinish", sfun);	this.play(act);	}
public anplaysmoothfin(def act, string sfun)	{	.addmethod("onfinish", sfun);	.playsmooth(act);	}
public anplayif(def act)	{ if( .isplaying(act)==false ) .play(act);	}
public anytoz()	{	this.setz(this.getposy());	}
public anposz(int x, int y, int z)	{	.setpos(x,y);	.setz(z);	}
public string annextaction(string sact)	{ this.nameofaction( (this.actionnr(sact)+1)%this.nofactions() );}
public int annextact	{ (.actionnr(-1)+1)%.nofactions; }
public ansetnextact	{	.setframe( (.actionnr(-1)+1)%.nofactions, 0 ); }
public ansetnextfr		{	.setframe( -1, (.framenr+1)%.nofframes(-1)); }
public ansetrandfr	{	.setframe(-1, .nofframes(-1)->rand);	}
public anhasaction(string sac)	{	.actionnr(sac) != .nofactions;}
public anaddfilter()	{	classanfilter::build(this.getname());	}
public anaddfx	{	AnimaFx::build( this );	}
public anputc(int x1, int y1, int x2, int y2)	{
	.ansetbpos(x1,y1);
	.move( (x2-x1-.getw)/2, (y2-y1-.geth)/2 );
}
public aninlod(int itoler)	{	itoler.length( .getpx - .lodx, .getpy - .lody ) <= itoler; }
public angetcpos	{	return .getcx, .getcy;	}
public anactnr	{	.actionnr(-1);	}
public angetcrgba	{	.getrgba(.getcx, .getcy);	}
public anisin(int x, int y, bool bv, bool ba)	{
	for( int i=0; i<.nofactions; i++)	{
		.setframe(i, 0);
		if( .isin(x,y,bv,ba) ) return i;
	}
	-1;
}
public anreload(string sfile)	{
	int id = .actionnr(-1);
	int fr = .framenr;
	bool bplay = .isplaying(-1)!=false;
	|int x, int y| = .getpos;
	int z = .getz;
	.load( .getpath(sfile) );
	.setpos(x, y);
	.setz(z);
	if( id < .nofactions ) {
		if( bplay ) .play(id);
		.setframe(id ,fr );
	} else .setframe(0 ,0);
}
public anclipob(string sob)	{	.clip(<sob>.getpx, <sob>.getpy, <sob>.getex, <sob>.getey);	}
public anclipscreen		{	.clip(0,0,igmappw,igmapph);	}
public ancopyan(string san)	{
	.setframe( <san>.actionnr(-1), <san>.framenr );
	<san>.isvisible ? .show : .hide;
	.setpos( <san>.getpos );
}
public anconstmove(int delay, int x, int y)	{
	.vars2(A, "mvx", x, "mvy", y);
	.setdelay(delay);
	.anplayfin(-1, func { .play(-1); .move(mvx, mvy); });
}
/**************** scale *****************/
public scmove(int x, int y)	{	.move( rgmscalex*x, rgmscaley*y );	}
public scpos(int x, int y)	{	.setpos( rgmscalex*x, rgmscaley*y );	}
/***************** text ****************/
public txtset(string s)	{	.set(s);	.create;	}
public txtsetcol(string s, int r, int g, int b)	{	.set(s);	.createtxt(r,g,b);	}
public txtshadow(int w, string sfont)	{
	if( !.hasvar("txts") )	{
		new text txts;
		txts.setfont(sfont);
	}
	txts.set(.get);
	txts.setpos(.getpx+w, .getpy+w);
	txts.setz(.getz-1);
	txts.show;
	txts.createtxt(0,0,0);
}
public txthides	{	.hide; if(.hasvar("txts")) txts.hide; }
public txtisin(int x, int y)	{
	x>=.getpx && x<.getpx+.getw && y>=.getpy && y<=.getpy+.geth;
}
public txtcenter(string sob)	{	.setpos( <sob>.getcx - .getw/2, <sob>.getcy - .geth/2 );}
public txtright(string sob)	{	.setpos( <sob>.getex - .getw, <sob>.getcy - .geth/2 );}
public txtcenterscreen		{	.setpos( (iResX-.getw)/2, (iResY-.geth)/2 );	}
/***************** vector ****************/
public vecinc(int pos)	{	this.set( pos, this.get(pos)+1 );	}
public vecdec(int pos)	{	this.set( pos, this.get(pos)-1 );		}
public vecnewint(int ile)	{
	this.free();
	if( ile>0 )	for( int i=0; i<ile; i++)	{	this.add(i);	}
}
public veccopy(string svec)	{
	this.free();
	for( int i=0; i< <svec>.size(); i++ )	this.add( <svec>.get(i) );
}
public int vecnextid(def val)	{
	int id = .find(val);
	if( id>=0 )	id = (id+1)%.size;
	id;
}
public int vecprevid(def val)	{
	int id = .find(val);
	if( id>0 )	id--;
	else if (id==0)	id = .size-1;
	id;
}
public def vecget(int id)	{
	( id>=0 && id<.size) ? .get(id) : null;
}
public def vecnext(def val)	{	.vecget( .vecnextid(val) );	}
public def vecprev(def val)	{	.vecget( .vecprevid(val) );	}
public def veclast()	{
	int ile = this.size();
	ile>0 ? this.get(ile-1) : null;
}
public def vecpop()	{
	@x = .last;
	.removeat( .size - 1 );
	x;
}
public veclimes(int ile)	{	while( .size > ile )	_ = .vecpop;	}
public def vecpopfront()	{
	def x = this.get(0);
	this.removeat( 0 );
	x;
}
public vecreplace(def d1, def d2)	{
	@id = .find(d1);
	if( id>=0 )	.set(id,d2);
}
public insertsort(int ile, string sgetfun, string scomparefun, string sswapfun)	{
	if( ile<=1 )	{	return;	}
	def s[2], int id, int i, int j;
	for( i=0; i<ile; i++)	{
		s0 = this.<sgetfun>(i);
		id = i;
		for( j=i+1; j<ile; j++)	{
			s1 = this.<sgetfun>(j);
			if( this.<scomparefun>(s1,s0) )	{
				s0 = s1;
				id = j;
			}
		}
		this.<sswapfun>(i,id);
	}
}
public obbuildfromstring(string s, string separator, string sfunadd)	{
	int pos = s.find(separator);
	while( pos>-1 )	{
		this.<sfunadd>( s.getb(0,pos) );
		s = s.strsubb(pos+1);
		pos = s.find(separator);
	}
	if( s.length()>0 )	{	this.<sfunadd>(s);	}
}
public obbuildfromstring2(string s, string separator, string sfunadd)	{
	int pos = s.find(separator);
	while( pos>-1 )	{
		if( pos>0 )	this.<sfunadd>( s.getb(0,pos) );
		s = s.strsubb(pos+1);
		pos = s.find(separator);
	}
	if( s.length()>0 )	{	this.<sfunadd>(s);	}
}
public vecsort(string scomparefun)	{ .insertsort( .size, "get", scomparefun,"swap" ); }
public string vecbuildfromstring(string s, string separator)	{
	this.free();
	this.obbuildfromstring(s,separator,"add");
}
public string vecbuildfromstring2(string s, string separator)	{
	this.free();
	this.obbuildfromstring2(s,separator,"add");
}
public vecremoveto(int ito)		{	for( int i=0; i<ito; i++ ) this.removeat(0);		}
public vecremovefrom(int ifrom)	{	while( ifrom<this.size() ) this.removeat(ifrom);	}
public vecfindfrom(int ifrom, def d)	{
	while (ifrom<.size)	{
		if( .get(ifrom)==d ) return ifrom;
		else ifrom++;
	}
	-1;
}
public vecposfromto(int i1, int i2)	{
	if( i1==i2 || .size==0 )	return;
	def x = .get(i1);
	if( i1>i2 )	for( int i=i1; i>i2; i--)	{	.set(i, .get(i-1));		}
	else if (i1<i2)	for( int i=i1; i<i2; i++)	{	.set(i, .get(i+1));	}
	.set(i2,x);
}
public vecposfirst( def x )	{
	int id = .find(x);
	if( id>=0 )	.vecposfromto(id, 0);
	else	.addbegin(x);
}
public vecposlast( def x )	{
	int id = .find(x);
	if( id>=0 )	.vecposfromto(id, .size-1);
	else	.addbegin(x);
}
public vecset(def x, def d2)	{
	int id = .find(x);
	if( id>=0 )	.set(id,d2);
}
public bool veceq(string svec)	{
	int id = .size;
	if( id != <svec>.size  )	return false;
	for( int i=0; i< id; i++)	if( .get(i)!=<svec>.get(i) ) return false;
	true;
}
public vecbuild	{	.withlist("addbegin");}
public bool veceq2	{
	new vector ___v;
	___v.type(.getvectype);
	___v.vecbuild;
	bool b = .veceq("___v");
	delete ___v;
	b;
}
public veccopydbrow(string sdb, int irow)	{	.free;	 .vecadddbrow(sdb,irow);	}
public vecadddbrow(string sdb, int irow)	{	for( int i=0; i< <sdb>.getcolsno(irow); i++)	.add( <sdb>.get(irow,i) );	}
public def vecchecknext(int id)	{
	id++;
	id < .size ? .get(id) : null;
}
public def vecsum	{
	if( .size )	{
		def sum = .get(0);
		for( int i=1; i<.size; i++)	{
			sum+=.get(i);
		}
		sum;
	} else 0;
}
public vecclosest(def val)	{
	int ile = .size;
	if( ile <= 0 ) return -1;
	int id = 0;
	def ipom = (val - .get(0))->abs;
	for( int i=1; i<ile; i++)	{
		def ipom2 = (val - .get(i))->abs;
		if( ipom2<ipom )	{
			id = i;
			ipom = ipom2;
		}
	}
	id;
}
public vecloadargs	{
	@s = _;
	while(s!=A)	{
		.addbegin(s);
		@s = _;
	}
}
/************** db ************************/
public dbbuild(int icol)	{
	if( icol<=0 )	return;
	icol--;
	.free;
	string s = _, int id;
	for( int i = 0; s!=A; )	{
		if( i==0 )	id = this.addbeginrow() - 1;
		this.addbegin(0,s);
		s = _;
		i = (i<icol)? i+1 : 0;
	}
}
public dbbuild2	{
	.free;
	string s = _;
	while( s!=A )	{
		if( s==null )	_ = .addbeginrow;
		else .addbegin(0,s);
		s = _;
	}
}
public dbaddvec(string svec)	{
	@id = .addrow-1;
	for( int i=0; i< <svec>.size; i++)	.add(id, <svec>.get(i));
}
public dbcopy(string sdb)	{	.dbcopyfromto(sdb, 0, <sdb>.getrowsno);}
public dbcopyrow(string sdb, int irow)	{	.dbcopyfromto(sdb,irow,irow+1);	}
public dbcopyfromto(string sdb, int i1, int i2)	{
	.free;
	.dbaddrowfromto(sdb,i1,i2);
}
public dbaddrowfromto(string sdb, int i1, int i2)	{
	int i, int j, int row;
	for( i =i1; i< i2; i++)	{
		row = .addrow-1;
		for( j=0; j< <sdb>.getcolsno(i); j++)	{
			.add( row, <sdb>.get(i,j) );
		}
	}
}
public dbadddbrowtorow(int myrow, string sdb, int row)	{
	for( int i=0; i< <sdb>.getcolsno(row); i++)	{
		.add( myrow, <sdb>.get(row,i) );
	}
}
public dbremovecol(int col)	{	for(int i=0; i<.getrowsno; i++) if( .getcolsno(i)>col ) .removeat(i,col);	}
public dbcopyfromtos(string sdb, string sfrom, string sto)	{
	.dbcopyfromto(sdb, <sdb>.findbyrow(sfrom)+1, <sdb>.findbyrow(sto));
}
public dbremovelast()	{
	.removerow( .getrowsno-1 );
}
public dbcuttosize(int isize)	{
	if( isize>0 ) while( .getrowsno > isize )	.dbremovelast;
	else	.free;
}
public dbaddlast(string svar)	{	this.add( this.getrowsno()-1, svar );	}
public dbaddstringrow(string s, string separator)	{
	_ = this.addrow();
	this.obbuildfromstring(s,separator,"dbaddlast");
}
public dbgetstringrow(int row)	{
	string s="";
	int ile = .getcolsno(row);
	for( int i = 0; i<ile; i++) s+= .get(row,i);
	s;
}
public dbaddrow	{
	@id = .addrow - 1;
	@s = _;
	while(A!=s)	{
		.addbegin(id, s);
		@s = _;
	}
}
public dbaddrowfrom(string sdb, int irow, int icol)	{
	if( <sdb>.rowinrange(irow) && icol>=0)	{
		int id = this.addrow()-1;
		int ile = <sdb>.getcolsno(irow);
		while( icol < ile )	{
			this.add( id, <sdb>.get( irow, icol ) );
			icol++;
		}
	}
}
public string dbchecknext(int irow, int icol)	{
	icol++;
	icol < this.getcolsno(irow) ? this.get(irow,icol) : null;
}
public string dbgets(string s, int icol)	{
	@id = .findbyrow(s);
	if( id>=0 && .getcolsno(id)>icol ) .get(id,icol);
	else null;
}
public string dbget(string s)	{ @id=.findbyrow(s); id>=0 ? .get( id, 1 ) : null; }
public int dbgetint(string s)	{ @id=.findbyrow(s); id>=0 ? .get( id, 1 )->to_i : 0; }
public int dbinsertless(int i1)	{
	int id = this.addrow()-1;
	this.add(id,i1);
	this.dbsort("cmpless");
	while( id>=0 )	{
		if( i1==this.get(id,0) )	return id;
		id--;
	}
	-1;
}
public bool dbdelvar(int irow, string svar)	{ this.dbdelvarn(irow,svar,1);}
public bool dbdelvarn(int irow, string svar, int n)	{
	int id = this.dbfindinrow(irow,svar);
	if( id>=0 )	{
		this.removen(irow,id,n);
		return true;
	}
	false;
}
public int dbfindinrow(int irow, string svar)	{
	if( this.rowinrange(irow) )	{
		for( int i=0; i<this.getcolsno(irow); i++)	if( this.get(irow,i)==svar )	return i;
	}
	-1;
}
public int dbfindbycol(int icol, string svar)	{
	for( int i=0; i<this.getrowsno(); i++)	{if( this.get(i,icol)==svar ) return i;}
	-1;
}
public bool dbrowcontains(int irow, string svar)	{	this.dbfindinrow(irow,svar)!=-1;	}
public string dbfirst(int id)		{	this.get(id,0);	}	
public bool cmpless(int i1, int i2)	{	i1<i2;	}
public bool cmpabove(int i1, int i2)	{	i1>i2;	}
public bool dbfirstless(int i1, int i2)	{	.get(i1,0) < .get(i2,0);	}
public dbsort(string scomparefun)	{	.insertsort( .getrowsno, "dbfirst",scomparefun, "swap" ); }
public dbsetall(string svar)	{	for( @i=0; i<.getrowsno; i++)	for(@j=0; j<.getcolsno(i); j++)	.set(i,j,svar);	}
public dbeach_row(string sfun)	{	for( @i=0; i<.getrowsno; i++) .<sfun>(i);	}
public dbeq(string sdb)	{
	if( .getrowsno != <sdb>.getrowsno ) return false;
	int ile, int j;
	for( int i=0; i<.getrowsno; i++)	{
		ile = .getcolsno(i);
		if( ile!=<sdb>.getcolsno(i) ) return false;
		for( j=0; j<ile; j++)	{
			if( .get(i,j)!=<sdb>.get(i,j) ) return false;
		}
	}
	true;
}
/************** int ************************/
public int randdiff(int zakres, int odjakiej)	{
	if( zakres<=1 )		return -1;
	for( int i1 = zakres.rand; i1==odjakiej; i1= zakres.rand )	{}
	i1;
}
public int bin_to_i	{
	string s = .get;
	int idwa = 1;
	int iout = 0;
	for( int i=s.length-1; i>=0; i--)	{
		if( s.getb(i,1)=="1") iout+=idwa;
		idwa*=2;
	}
	iout;
}



public string internal_filter	{
	@s = "__ft" + this;
	if( !.hasvar(s) ) {
		new filter <s>;
		<s>.buildfullname;
	}
	<s>.link(this);
	<s>.getfullname;
}

public string internal_timer	{
	@s = "__tim" + this;
	if( !.hasvar(s) ) {
		new timer <s>;
		<s>.setcycle(1);
		<s>.vars2(A, "sfunc", null);
	}
	s;
}
public unlink_internal_filter	{	<.internal_filter>.unlink;	}
public anhideonsetframe	{
	.var("bhideonsf");
	if( !.hasvar("bopacityfr") )	{
		.addmethod("onsetframe", "_stdanhide" );
	}
}

public anopacityframe	{
	.var("bopacityfr");
	.addmethod("onsetframe", func {
		@s = .framename;
		if( s.getb(0,2)=="op" )	{
			<.internal_filter>.setopacity( s.strsubb(2)->to_r/100.0 * 255 );
		} else <.internal_filter>.setopacity(255);
		if( .hasvar("bhideonsf") )
			.hide;
		} );
}

public ansetopacity(int iop)	{
	<.internal_filter>.setopacity(iop);
}
public anzoomin(int ms, string sfun)	{
	.ansetopacity(255);
	.anzoomfadeinout(ms,1,0,sfun);
}
public anzoomout(int ms, string sfun)	{
	.ansetopacity(255);
	.anzoomfadeinout(ms,-1,0,sfun);
}
public anfadein(int ms, string sfun)	{
	.anzoomfadeinout(ms,0,1,sfun);
}
public anzoomfadein(int ms, string sfun)	{
	.anzoomfadeinout(ms,1,1,sfun);
}
public anzoomfadeout(int ms, string sfun)	{
	.anzoomfadeinout(ms,-1,-1,sfun);
}
public anfadeout(int ms, string sfun)	{
	.anzoomfadeinout(ms,0,-1,sfun);
}
public anzoomfadeinout(int ms, int zoomdir, int dir, string sfun)	{
	if( dir>0 ) dir=1;
	else if (dir<0) dir=-1;
	
	if(zoomdir>0 ) zoomdir=1;
	else if(zoomdir<0) zoomdir=-1;
	
	.show;
	@sf = .internal_filter;
	@st = .internal_timer;
	<sf>.link(this);
	<st>.sfunc = (sfun);
	
	ms = ms / engine.getloopdelay;
	if( ms<=0 )	{
		if( dir>0 )	.ansetopacity(255);
		else	.ansetopacity(0);
		if( sfun!=null ) .<sfun>;
		return;
	}
	
	real step = 255.0/ms;
	if( step<1.0 ) step = 1.0;
	real stepzoom = 1.0/ms;
	<st>.vars2(A, "sfilter", sf, "rstep", step * dir, "ropacity", 0.0, "rstepzoom", stepzoom*zoomdir, "rzoom", 0.0);
	if( dir )	{
		<sf>.setopacity( dir==1 ? 0 : 255 );
		<st>.ropacity = ( <sf>.getopacity );
	}
	if( zoomdir )	{
		<sf>.setzoom( zoomdir==1 ? stepzoom : 1 );
		<st>.rzoom = ( <sf>.getzoomx );
	}
	<st>.addmethod("onfinish", func {
		ropacity += rstep;
		rzoom += rstepzoom;
		if( (ropacity>=255 && rstep>0) || (rzoom>=1 && rstepzoom>0) )	{
			if( rstepzoom>0 ) <sfilter>.setzoom( 1 );
			if( rstep>0 )	<sfilter>.setopacity(255);
			if( sfunc!=null ) <.getbuildername>.<sfunc>;
		} else if ( (ropacity<=0 && rstep<0) || (rstepzoom<0 && rzoom<-rstepzoom) )	{
			if( rstepzoom<0 ) .hide;
			if( rstep<0)	<sfilter>.setopacity(0);
			if( sfunc!=null ) <.getbuildername>.<sfunc>;
		} else {
			if( rstep !=0.0 )
				<sfilter>.setopacity(ropacity);
			if( rstepzoom!=0.0 )
				<sfilter>.setzoom(rzoom);
			.play;
		}
		} );
	<st>.play;
}

public imgbuildfromlist	{
	new vector __vtmp;
	__vtmp.type("string");
	__vtmp.vecloadargs;
	.imgbuildfromvec("__vtmp");
	delete __vtmp;
}
public imgbuildfromvec(string svec)	{
	if( <svec>.empty ) return;
	string s = <svec>.first;
	int x = <s>.getpx;
	int y = <s>.getpy;
	int ex = <s>.getex;
	int ey = <s>.getey;
	for( int i=1; i < <svec>.size; i++ )	{
		s = <svec>.get(i);
		if( x > <s>.getpx ) x = <s>.getpx;
		if( y > <s>.getpy ) y = <s>.getpy;
		if( ex < <s>.getex ) ex = <s>.getex;
		if( ey < <s>.getey ) ey = <s>.getey;
	}
	.create( ex-x, ey-y, .transparent );
	.setpos(x, y);
	for( i=0; i< <svec>.size; i++)	{
		.blit(<svec>.get(i));
	}
}

/***************************************************************************/
class classgamepause	{
	init()	{
		new button butpause;
		butpause.setrect( 0, 0, iResX, iResY );
		butpause.addmethod("onclick", "resume");
		butpause.disable();
	}
	resume()	{
		butpause.disable();
		gameapi.resume();
	}
	pause()	{
		gameapi.pause();
		butpause.enable();
		butpause.resume();
	}
}

class TicksCounter	{
	init()	{
		new int istart;
	}
	start()	{	istart = engine.getticks();	}
	stop()	{	istart = engine.getticks() - istart;	}
	get()		{	return istart;	}
	int stopget()	{	this.stop();	return this.get();	}
	print(string s)	{	engine.print(s+" delay: "+this.stopget()+" ms");	}
	put()	{	.print("");	}
}


class ObjController	{
	init()	{
		<GAME>.addgmobj(this);
	}
	removefromgame	{	<GAME>.removegmobj(this); }
}
class LObjController : ObjController, classlocker	{
	init()	{
		ObjController::init;
		classlocker::init;
	}
}

class gmbankvec : gmobjvec	{
	init	{
		gmobjvec::init;
		.var2("iid", -1);
	}
	startrand	{	if(.size>0) iid=.size->rand;	}
	play()	{
		this.stop(false);
		int ile = this.size();
		if( ile==0 ) return;
		iid = (iid+1)%ile;
		<this.get(iid)>.play();
	}
	onfinish()	{}
	stop(bool bfin)	{
		if( this.isplaying() )	{
			<this.getplay()>.stop(bfin);
			if( bfin ) this.onfinish();
		}
	}
	isplaying	{	( iid>=0 )	? <.getplay>.isplaying : false;	}
	getplay()	{	return this.get(iid);	}
}

class ClassGameController	{
	init	{
		new gmobjvec __grobj;
		new string GAME = this;
	}
	public addgmobj(string s)		{	__grobj.add(s);		}
	public removegmobj(string s)	{	__grobj.remove(s);	}
	public isgmobj(string s)	{	__grobj.contains(s);	}
	public deletegmobj(string s)	{
		if( .hasvar(s) )	{
			.removegmobj(s);
			delete <s>;
		}
	}
	mousemove	{
		__grobj.eval("onmousemove");
		.mouse_move;
	}
	mouselclick	{
		__grobj.eval("onmouselclick");
		.mouse_lclick;
	}
	mouserclick	{
		__grobj.eval("onmouserclick");
		.mouse_rclick;
	}
	mouselrel	{
		__grobj.eval("onmouselrel");
		.mouse_lrel;
	}
}

class GameController : ClassGameController, classlocker {
	init(string ssndbase)	{
		ClassGameController::init;
		classlocker::init();
		//new gmobjvec __grobj;
		
		new db _dbsnd;
		_dbsnd.setseparator("|");
		new string _sndbase = ssndbase;
		
		new timer __dblclick;
		__dblclick.delay(250);
		__dblclick.settick(1);
		
		new int _itimersnddelay = 10000;
	}
	public game_exit()	{
		//this.stdexportsnd();
	}
	/*************************************************/
	public setsndbase(string sb)	{	_sndbase=sb;	}
	public say(string styp, string stxt)	{	this.sayf(styp,stxt,null);	}
	public sayf(string styp, string stxt, string sfun)	{
		string s = this.getsndtxt(stxt);
		<s>.setstartstopflag(false,true);
		this.cplayf(styp, s, sfun);
	}
	public string getsndtxt(string stxt)	{
		string ssnd = "snd" + _sndbase + _dbsnd.getrowsno();
		this.addsnd( ssnd, stxt );
		return ssnd;
	}
	_sndtimerstart()	{
		return;
		int id = _dbsnd.dbfindbycol(1,this.getname());
		if( id>=0 )	engine.print( _dbsnd.get( id,2) );
		else 		engine.print( this.getname() + " not in _dbsnd");
		engine.print("");
	}
	public addsndf(string ssnd, string stxt, string sfun)	{
		this.addsnd(ssnd,stxt);
		if( sfun!=null )	{
			if( ssnd.getb(0,1)==":" ) ssnd = ssnd.strsubb(1);
			<ssnd>.addmethod("onfinish", sfun );
		}
	}
	public asf(string ssnd, string stxt)	{	this.addsndff( "snd" + ssnd, stxt, "end" + ssnd);	}
	public addsndff(string ssnd, string stxt, string sfun)	{
		this.addsndf(ssnd,stxt,sfun);
		//<ssnd>.setstartstopflag(false,true);
	}
	gmconsnd(string ssnd, string swav)	{
		new snd <ssnd>;
		<ssnd>.setstartstopflag(false,true);
		<ssnd>.load( .getsndpath+swav );
		if( igmsubtitle )	{
			subtitle.register(ssnd, .getsndpath+swav);
		}
	}
	public addsnd(string ssnd, string stxt)	{
		int id = _dbsnd.addrow()-1;
		string swav;
		if( ssnd.getb(0,1)==":" )	{
			ssnd = ssnd.strsubb(1);
			swav = _sndbase + "_" + ssnd + id + ".wav";
		} else swav = _sndbase + id + ".wav";
		string sg = gameapi.getgamename();
		if( igmsoundson && engine.fileexist( this.getsndpath() + swav ) )	{
			<sg>.gmconsnd( ssnd, swav );
		} else {
			<sg>.newtimer( ssnd, stxt.length()*_itimersnddelay, 1);
			<ssnd>.addmethod("onstart", "_sndtimerstart");
			<ssnd>.addmethod("setstartstopflag", func { (bool b1, bool b2) ; });
		}
		_dbsnd.add(id, swav);
		_dbsnd.add(id, ssnd);
		_dbsnd.add(id, stxt);
	}
	public addbank(string sbank, string sfunc)	{
		new gmbankvec <sbank>;
		string s = _;
		string s2;
		while( s!=A )	{
			s2 = this.getsndtxt(s);
			<sbank>.addbegin( s2 );
			if( sfunc!=null ) <s2>.addmethod("onfinish", sfunc );
			s = _;
		}
	}
	public exportbank(string sbase)	{
		new db <"__db"+sbase> (sbase)	{ (@sbase)
			.dbbuild(1);
			.setseparator("|");
			.dbeach_row( func { (@id)
				@s = this->strsubbs("__db");
				.addbegin(id, "snd"+s+id);
				.addbegin(id, s+id+".wav");
				} );
			if( igmdebug )
				.save("exports/"+sbase+".dlg");
		};
		delete <"__db"+sbase>;
	}
	public importbank(string sbank, string sbase, string sfun)	{
		new gmbankvec <sbank>;
		.importgroupto(sbase, sfun, null, sbank);
	}
	public exportsnd(string sfile)	{	if( igmdebug) _dbsnd.save(sfile);	}
	public stdexportsnd()	{	this.exportsnd( "exports/" + _sndbase + ".dlg" );	}
	public sounds=()	{	.buildsnds;	}
	public sounds_from(string sbase)	{
		new db __tmpdb;
		@stmpbase = _sndbase;
		.setsndbase(sbase);
		__tmpdb.load("exports/"+sbase+".dlg");
		_dbsnd.free;
		@s = _;
		int id, string sf;
		while( A!=s )	{
			@s1 = _;
			id = __tmpdb.dbfindbycol(1, s1);
			if( id>=0 )	{
				sf = .getsndpath + __tmpdb.get(id,0);
				if( engine.fileexist( sf ) )	{
					<GAME>.gmconsnd( s1, __tmpdb.get(id,0) );
					<s1>.addmethod("onfinish", s );
				} else	.addsndf( s1, __tmpdb.get(id,1), s );
			}
			@s = _;
		}
		_dbsnd.free;
		delete __tmpdb;
		.setsndbase(stmpbase);
	}
	public buildsnds()	{
		_dbsnd.free;
		new db __dbsnd;
		__dbsnd.dbbuild(3);
		.buildfromdb("__dbsnd");
		delete __dbsnd; 
	}
	public buildfromdb(string sdb)	{
		for( int i=0; i< <sdb>.getrowsno; i++)	{
			.addsndf( <sdb>.get(i,0), <sdb>.get(i,1), <sdb>.get(i,2) );
		}
		.stdexportsnd;
	}
	public importsnd(string sbase, string sfun)	{	this.importgroup(sbase, sfun, null );	}
	public importgroup(string sbase, string sfun, string sgr)	{	.importgroupto(sbase,sfun,sgr,null);	}
	public importgroupto(string sbase, string sfun, string sgr, string sgrto)	{
		new db __tmpdb;
		@stmpbase = _sndbase;
		.setsndbase(sbase);
		__tmpdb.load("exports/"+sbase+".dlg");
		_dbsnd.free();
		string s;
		for( int i=0; i<__tmpdb.getrowsno(); i++)	{
			s = __tmpdb.get(i,1);
			if( sgr==null || <sgr>.contains(s) )	{
				.addsndf( s, __tmpdb.get(i,2), sfun );
				if( sgrto!=null ) <sgrto>.add(s);
			}
		}
		_dbsnd.free();
		__tmpdb.free();
		delete __tmpdb;
		.setsndbase(stmpbase);
	}
	public freesnd()	{	_dbsnd.free();	}
	/*************************************************/
	/*public addgmobj(string s)		{	__grobj.add(s);		}
	public removegmobj(string s)	{	__grobj.remove(s);	}
	public isgmobj(string s)	{	__grobj.contains(s);	}
	public deletegmobj(string s)	{
		if( .hasvar(s) )	{
			.removegmobj(s);
			delete <s>;
		}
	}*/
	public lockall()		{
		__grobj.eval("lock");
		this.lock();	
	}
	public unlockall()		{
		__grobj.eval("unlock");
		this.unlock();
	}
	public gmunlockall	{	<GAME>.unlockall;	}
	public gmlockall	{	<GAME>.lockall;	}
	public lock=(bool b)	{	b ? .gmlockall : .gmunlockall; }
	gmcontrol_mousemove	{
		__grobj.eval("onmousemove");
		this.mouse_move();
	}
	gmcontrol_mouselclick	{
		__grobj.eval("onmouselclick");
		this.mouse_lclick();
		if( __dblclick.isplaying )	.mouse_dblclick;
		else __dblclick.play;
	}
	gmcontrol_mouserclick()	{
		__grobj.eval("onmouserclick");
		this.mouse_rclick();
	}
	gmcontrol_mouselrel()	{
		__grobj.eval("onmouselrel");
		this.mouse_lrel();
	}
	gmcontrol_mouserrel()	{
		__grobj.eval("onmouserrel");
		this.mouse_rrel();
	}
	gmcontrol_keydown()	{
		__grobj.eval("onkeydown");
		this.key_down();
	}
	mousemove	{	.gmcontrol_mousemove;	}
	mouselclick	{	.gmcontrol_mouselclick;	}
	mouselrel	{	.gmcontrol_mouselrel;	}
	mouserclick	{	.gmcontrol_mouserclick;	}
	mouserrel	{	.gmcontrol_mouserrel;	}
	keydown		{	.gmcontrol_keydown;	}
}

/* classadv : klasa do przygodowek	*/

new int PrzygodaNumer = 1;
new int PrzygodaMode = dbconf.dbgetint("PrzygodaMode:");

new classfullsave clsave("save.txt");
new string sgmlastscene = null;
new string sgmglobpath = null;	// dla gier, ktore sa w innym katalogu niz ich nazwa
new string sgmgame = null;		// jezeli .adv inaczej sie nazywa niz game

new CutScene ccs(igmoffsetx, igmoffsety, iResX, iResY);
ccs.setz(2000);

class classadv : classgame {
	init()	{
		classgame::init();
		new string _s_game_path;
		new bool bmslock = false;
	}
	//--------------- zgodnosc advcontroller z bangui
	advmslock			{	bmslock=true;	}
	advmsunlock			{	bmslock=false;	}
	advgetlock			{	bmslock;	}
	advmssetlock(bool block)	{	block ? .advmslock : .advmsunlock;	}
	//-------------------
	switch_path(string spath)	{
		_s_game_path = <gameapi.getgamename>.getgraphpath;
		<gameapi.getgamename>.setgraphpath(spath);
	}
	restore_path	{	<gameapi.getgamename>.setgraphpath(_s_game_path);	}
	/**************************************************************************/
	newclpathf(string spt, string san, string sfile, int x, int y, real rstep, int ityp)	{
		new classpathf <spt>;
		<spt>.build(san, this.getgraphpath() + sfile, x, y, rstep, ityp);
	}
	newclpathfcopy(string spt, string san, string sptf, real rstep)	{
		new classpathf <spt>;
		<spt>.buildfrom( san, sptf, rstep );
	}
	newpathf(string spathf, string sfile, int x, int y)	{
		new path <spathf>;
		<spathf>.build( this.getgraphpath() +sfile, x, y, 2.0, 1 );
	}
	/**************************************************************************/
	newclbut(string sbut, string sfile, int z, string smouse)	{
		new classbutton <sbut>;
		<sbut>.build( this.getgraphpath() + sfile, z, smouse );
	}
	newclmask(string sm, string sfile, string smouse)	{
		new classmask <sm>;
		<sm>.buildmask( this.getgraphpath() + sfile, smouse );
	}
	newclmaskfunc(string sm, string sfile, string smouse, string sfunc)	{
		new classmask <sm>;
		<sm>.buildmaskfunc( this.getgraphpath() + sfile, smouse, sfunc );
	}
	//---------------------- SAVE ----------------------
	advsaveonstart	{
		clsave.set("GAME_game", gameapi.getgamename);
		clsave.set("GAME_sgmgame", sgmgame);
		clsave.set("GAME_sgmglobpath", sgmglobpath);
		clsave.set("GAME_sgmlastscene", sgmlastscene);
		clsave.set("GAME_ccs", ccs.isvisible);
		.advautosave;
	}
	advautosave	{
		clsave.save("autosave.txt");
		modadvglob.savepck("autosave");
	}
	advautoload	{	._advload("autosave");	}
	advcacheload	{	._advload("cache");	}
	advcachesave	{	._advsave("cache");	}
	_advload(string s)	{
		modadvglob.delheros;
		modadvglob.loadpck(s);
		
		clsave.load(s+".txt");
		sgmgame = clsave.get("GAME_sgmgame");
		sgmglobpath = clsave.get("GAME_sgmglobpath");
		sgmlastscene = clsave.get("GAME_sgmlastscene");
		if( clsave.bis("GAME_ccs") ) ccs.show; else ccs.hide;
		gameapi.play( clsave.get("GAME_game") );
	}
	_advsave(string s)	{
		new classfullsave _saver(s + ".txt");
		_saver.load("autosave.txt");
		_saver.stdsave;
		delete _saver;
		new vector _vcsave;	_vcsave.type("string");
		new vector _vcsv2;	_vcsv2.type("string");
		_vcsave.vecload("grpck_autosave.txt");
		_vcsave.vecsave("grpck_"+s+".txt");
		@s2;
		for( int i=0; i<_vcsave.size; i++)	{
			s2 = _vcsave.get(i);
			_vcsv2.vecload(s2 + "autosave_name.txt" );
			_vcsv2.vecsave(s2 + s + "_name.txt" );
			_vcsv2.vecload(s2 + "autosave_file.txt" );
			_vcsv2.vecsave(s2 + s + "_file.txt" );
		}
		delete _vcsave;
		delete _vcsv2;
// 		arPocket.save( "saves/" + this+sfilepref + "_name.txt" );
// 		arPocketFile.save( "saves/" + this+sfilepref + "_file.txt" );
	}
	getsavename	{	"save"+PrzygodaNumer;	}
	advload_game	{	._advload(.getsavename);	}
	advsave_game	{	._advsave(.getsavename);	}
	//-------------- STAN GRY --------------
	advstdstate		{	sgmstate=="stdadv";	}
	advsetstdstate		{	.advsetstate("stdadv");	}
	advsetstate(string s)	{	sgmstate = s;	}
	//-------------- przejscia -----------
	stdexitdefadv(string spath, string sgame)	{
		clsave.set("GAME_snextgame", sgame);
		clsave.set("GAME_snextgamepath", spath);
		clsave.set("GAME_snextgametype", "-def");
		.stdexitgame;
	}
	stdexitadvadv(string spath, string sgame)	{
		clsave.set("GAME_snextgame", sgame);
		clsave.set("GAME_snextgamepath", spath);
		clsave.set("GAME_snextgametype", "-adv");
		.stdexitgame;
	}
	stdexit(string sgame)	{
		clsave.set("GAME_snextgame", sgame);
		clsave.set("GAME_snextgamepath", null);
		clsave.set("GAME_snextgametype", "-mg");
		.stdexitgame;
	}
	stdexitgame	{
		ccs.buildfromscreen;
		sgmstate = "end";
		string sNextGame = clsave.get("GAME_snextgame");
		match(clsave.get("GAME_snextgametype"))	{
			"-def" => .gotoadv(clsave.get("GAME_snextgamepath"), sNextGame);
			"-adv" => .gotoadv2(clsave.get("GAME_snextgamepath"), sNextGame);
			? => gameapi.play(sNextGame);
		}
	}
	gotoadv(string spath, string sgame)	{
		sgmlastscene = gameapi.getgamename;
		sgmglobpath = spath;
		sgmgame = sgame;
		gameapi.play("gameadvdef");
	}
	gotoadv2(string spath, string sgame)	{
		sgmlastscene = gameapi.getgamename;
		sgmglobpath = spath;
		sgmgame = null;
		gameapi.play(sgame);
	}
}

class classquest	{
	init()	{
		new vector vqst;
		vqst.type("string");
	}
	int isdone(string sqst)	{	return vqst.contains(sqst);	}
	int notdone( string sqst )	{	return !vqst.contains(sqst);	}
	done(string sqst)	{	if( !vqst.contains(sqst) )	vqst.add(sqst);		}
	reset()	{	vqst.free();	}
	save(string sfile)	{	vqst.save( sfile );	}
	load(string sfile)	{	vqst.load( sfile );	}
}

new classquest clqs;

/***************************************************************************/

public winsave(string sval)	{
	new db _db_win;
	_db_win.load("output.db");
	@id = _db_win.addrow-1;
	_db_win.add(id, sval);
	_db_win.save("output.db");
	delete _db_win;
}

/***************************************************************************/

public saveexist(string sfile)	{	engine.fileexist( .getsavepath + sfile );	}

public vecsave(string sfile)	{	.save(.getsavepath + sfile);	}

public vecload(string sfile)	{	.load( .getsavepath + sfile );	}

class classfullsave	{
	init(string sfile)	{
		new db dbsav;
		dbsav.setseparator("|");
		new string sstdfile;
		.setfile(sfile);
		//.var2("saveonset",0);
		new bool saveonset = 0;
	}
	public save(string sfile)	{	dbsav.save( .getsavepath + sfile );	}
	
	_load(string sfile)	{
		if( engine.fileexist(sfile) )	{
			dbsav.free;
			dbsav.load(sfile);
		}
	}
	public load(string sfile)	{	._load( .getsavepath + sfile );	}
	public print()	{	dbsav.print();	}
	public printvar(string svar)	{	engine.print(this + ".var: "+svar+" = " +.get(svar));	}
	public setfile(string sf)	{	sstdfile = sf;	}
	public stdload()	{	this.load(sstdfile);	}
	public stdsave()	{	this.save(sstdfile); }
	public free()	{	dbsav.free();	}
	public set(string sname, string svar)	{
		int id = dbsav.findbyrow(sname);
		if( id>=0 )	{
			dbsav.set(id,1,svar);
		} else {
			id = dbsav.addrow()-1;
			dbsav.add( id, sname );
			dbsav.add( id, svar );
		}
		if( saveonset )
			this.stdsave();
	}
	public bset(string sname)	{	this.set(sname,true);	}
	public string get(string sname)	{
		int id = dbsav.findbyrow(sname);
		id>=0?dbsav.get(id,1):null;
	}
	public bool is(string sname, string svar)	{
		int i = dbsav.findbyrow(sname);
  		i>=0?dbsav.get(i,1)==svar:false;
	}
	//public bool bis(string sname)	{	return this.is(sname,true);	}
	public bool bis(string sname)	{
		int i = dbsav.findbyrow(sname);
		i>=0?dbsav.get(i,1)!=false:false;
	}
	bool has(string sname)	{ dbsav.findbyrow(sname) >= 0; }
	public bool bgo(string sname)	{
		if( !.bis(sname) )	{
			.bset(sname);
			true;
		} else false;
	}
	public saveonset=(bool b)	{	saveonset=b;	}
	public remove(string sname)	{
		int i = dbsav.findbyrow(sname);
		if( i>=0 ) {
			dbsav.removerow(i);
			if( saveonset )
				this.stdsave();
		}
	}
}



class StringChecker	{
	init()	{}
	/*bool isdigit(string s)	{	s.to_i == s;	}
	int getint(string s)	{	return s.to_i();	}
	real getreal(string s)	{	return s.to_r();	}	
	bool isreal(string s)	{	return this.isdigit(s)&&s.contains(".");	}
	bool isstring(string s) {	return s.getb(0,1)=="\"";	}
	string getstring(string s)	{	return s.strsubb(1);	}*/
	bool isdigit(string s)		{	s.to_i()!=0 || s.getb(0,1)=="0";	}
	int getint(string s)		{	s.to_i();	}
	real getreal(string s)		{	s.to_r();	}	
	bool isreal(string s)		{	this.isdigit(s) && s.contains(".");	}
	bool isstring(string s) 	{	s.getb(0,1)=="\"";	}
	string getstring(string s)	{	s.strsubb(1);	}
}

class Script	{
	init(string sfile)	{
		new db __dbcode;
		new string __sdb;
		new int __irow;
		new int __icol;
		new string __sreads;
		
		new vector __vec;
		__vec.type("string");
		
		new string __sarg;
		new int __iarg;
		new real __rarg;
		
		new StringChecker __csc;
		new map2 __mp("int");		// odnosniki do funkcji
		for( int i=0; i<10; i++)	new string <"ARG"+i>;
		
		this.load(sfile);
	}
	public ARG=(int id, string s)	{ <"ARG"+id> = s; }
	public ARG(int id)	{ ["ARG"+id]; }
	public load(string sfile)	{
		if( sfile==null )	return;
		if( sfile.contains(".") )	{		// znaczy sie plik jest
			__sdb = "__dbcode";
			__dbcode.loadbeh(sfile);
		} else {
			__sdb = sfile;		// odwolanie przez inna baze
		}
		__mp.free();
		for( int i=0; i < <__sdb>.getrowsno(); i++)	{
			if( <__sdb>.get(i,0)=="func" )
				__mp.add( <__sdb>.get(i,1), i );
		}
		this.call("init");
	}
	public def get(string svar)	{	[svar];	}
	bool isvar(string s)		{	s.getb(0,1)=="$";	}
	string getvar(string s)	{
		s = s.strsubb(1);
		if( !engine.varexist(s) )
			new def <s>;
		s;
	}
	bool isfunc(string s)	{	s.contains(".") && !__csc.isreal(s);	}
	getfunc(string sfun)	{
		__vec.free();
		__vec.add( sfun.strgetto(".") );
		__vec.add( sfun.strgetfrom(".") );
	}
	string _get()	{
		__icol++;
		<__sdb>.get(__irow,__icol-1);
	}
	bool isnext()	{
		if( __icol < <__sdb>.getcolsno(__irow) )	{
			__sreads=<__sdb>.get(__irow,__icol);
			true;
		} else
			false;
	}
	perror(bool expr, string sout)	{
		if( expr )
			engine.print("error: " + sout);
	}
	interpcall(string scal)	{
		this.getfunc(scal);
		string sob = __vec.get(0);
		if( sob.getb(0,1)=="*" ) sob=[sob.strsubb(1)];
		string sfun = __vec.get(1);
		if( sfun.getb(0,1)=="*" ) sob=[sfun.strsubb(1)];
		__vec.free();
		__icol++;	// omin '('
		string s = this._get();
		while( s!=")" )	{
			this.getexpr(s);	// odloz na stos argumenty
			s = this._get();
		}
		if( sob=="this" ) sob=null;
		this.callfun(sob,sfun);
	}
	string getvname(string s)	{
		if( this.isvar(s) )	{
			s=this.getvar(s);
		} else if(__csc.isreal(s))	{
			__rarg = s.to_r();
			s = "__rarg";
		} else if( __csc.isdigit(s) ) {
			__iarg = s;
			s = "__iarg";
		} else if( __csc.isstring(s) ) {
			__sarg = __csc.getstring(s);
			s = "__sarg";
		}
		s;
	}
	bool isscriptfun(string s)	{	s.contains("->");	}
	string getscriptfun(string s)	{	s.strsubb(2);	}
	getexpr(string sexpr)	{
		if( __csc.isstring(sexpr) )	{
			<this.getvname(sexpr)>.get();
		} else if( this.isfunc(sexpr) )	{
			this.interpcall(sexpr);
		} else if(this.isscriptfun(sexpr))	{
			int r = __irow;
			int c = __icol;
			this.call( this.getscriptfun(sexpr) );
			__irow = r;
			__icol = c;
		} else {
			<this.getvname(sexpr)>.get();
		}
	}
	bool cmp()	{
		bool bodp=false;
		def d0 = this.getexpr(this._get());
		string s2 = this._get();		// typ porownania
		def d1 = this.getexpr( this._get() );
		match(s2)	{
			"==" =>	{	bodp = d0 == d1;	}
			"!=" =>	{	bodp = d0 != d1;	}
			"<" =>	{	bodp = d0 < d1;	}
			">" =>	{	bodp = d0 > d1;	}
			"<=" =>	{	bodp = d0 <= d1;	}
			">=" =>	{	bodp = d0 >= d1;	}
			? => ;
		}
		s2 = this._get();
		if( s2=="||" )	
			bodp || this.cmp();
		else if (s2=="&&")
			bodp && this.cmp();
		else	bodp;
	}
	public containsfun(string sfun)	{	__mp.contains(sfun);	}
	public call(string sfun)	{
		if( !__mp.contains(sfun) )	return;
		
		__irow = __mp.get( sfun );
		__irow++;
		__icol=0;
		
		bool bgo = true;
		bool bif = false, bool bifexp, bool bwhile=false;
		bool belif=false;
		int iwhilerow;
		string s[3], int i[3];
		while( bgo )	{
			__icol=0;
			s0 = this._get();
			match(s0)	{
				"new"=>{
					s0 = this._get();
					s1 = this._get();
					s1 = s1.strsubb(1);	// pozbadz sie $
					if( this.isnext() )	{
						if( __sreads=="[" )	{
							__icol++;
							i0 = this._get();
							for(i1=0; i1<i0; i1++)	{
								new <s0> <s1+i1>;
							}
						} else {		// powinien byc "(" dla konstruktora
							__icol++;
							while( this.isnext() && __sreads!=")" )	this.getexpr( this._get() );
							new <s0> <s1>;
						}
					} else {
						new <s0> <s1>;
					}
					__irow++;
				}
				"delete" =>	{	delete <this.getvar(this._get())>;	__irow++;	}
				(s0=="if" || belif || bwhile)?s0:"" => {
	// 				belif ? this.perror(!bif,"else without if") : this.perror(bif,"if within if");
					__icol++;		// '('
					bifexp = this.cmp();
					if(s0=="if") bif=true;
					belif=false;
					bwhile = false;
					__irow++;
					if( !bifexp )	{
						i1=1;
						while(i1)	{
							s0 = <__sdb>.get(__irow,0);
							if( s0=="else"||s0=="elif"||s0=="fi"||s0=="done") i1=0;
							else	__irow++;
						}
					}
				}"else" => { 	this.perror(!bif,"else without if");
					__irow++;
					if( bifexp )	{
						while(<__sdb>.get(__irow,0)!="fi")
							__irow++;
					}
				} "fi" =>	{	this.perror(!bif,"fi without if");
					bif=false;
					bifexp = false;
					belif=false;
					__irow++;
				} "elif"=>	{
					if( bifexp )	{
						__irow++;
						while(<__sdb>.get(__irow,0)!="fi")
							__irow++;
					} else {
						belif = true;
					}
				} "end" =>	bgo=false;
				"while" =>	{
					iwhilerow = __irow;
					bwhile = true;
				}"done" =>	{
					if( bifexp )	{
						__irow = iwhilerow;
					} else {
						__irow++;
					}
				}"print" =>	{
					s0 = "";
					while( this.isnext() )
						s0 += this.getexpr( this._get() ); 
					engine.print( s0 );
					__irow++;
				}"return" => 	{
					if( this.isnext() )	{
						this.getexpr( __sreads );
					}
					return;
				} ? => { 
					if (s0.getb(0,1)=="$")	{
						s0 = this.getvar( s0 );
						__icol++;		// olej <<
						<s0> = this.getexpr(this._get());
						while( this.isnext() )	{
							__icol++;		// omin znak dzialania
							def d2 = this.getexpr( this._get() );
							match(__sreads)	{
								"+"	=>	<s0> += d2;
								"-"	=> 	<s0> -= d2;
								"*"	=>	<s0> *= d2;
								"/"	=>	<s0> /= d2;
								"%"	=>	<s0> %= d2;
								?	=>	;
							}
						}
					} else
						this.getexpr( s0 );
					__irow++; 
				}
			}
			if( __irow >= <__sdb>.getrowsno() )	{
				this.perror(1,"function "+sfun+" not finished!");
				bgo=false;
			}
		}
	}
}


public animaloader_load(string sdbfile)	{
	new db _dbanl;
	_dbanl.loadbeh( .getpath(sdbfile) );
	string s[3];
	int col;
	for( int i=0; i< _dbanl.getrowsno; i++) 	{
		if( _dbanl.getcolsno(i) > 0 )	{
			col = 0;
			match(_dbanl.get(i,col))	{
				"an:" => {
					col++;
					s0 = _dbanl.get(i,col); col++;
					if( s0.contains(".pyz") )	{
						s1 = "an" + s0.strsubes(".pyz");
						.newanima(s1, s0, 0);
					} else {
						.copyanima( _dbanl.get(i,col) , s0 );
						col++;
					}
					for( int j=col; j<_dbanl.getcolsno(i); j++)	{
						match( _dbanl.get(i,j) )	{
							"-z" => {
								j++;
								<s1>.setz( _dbanl.get(i,j) );
							}
							"-hide" => <s1>.hide;
							"-opacityframe" => <s1>.anopacityframe;
							"-nplay" => {
								j++;
								<s1>.play( _dbanl.get(i,j)->to_i );
							}
							"-play" => {
								j++;
								<s1>.play( _dbanl.get(i,j) );
							}
							"-delay" => {
								j++;
								<s1>.setdelay( _dbanl.get(i,j) );
							}
							"-drawmode" => {
								s0 = _dbanl.get(i,j);	j++;
								if( s0=="lineardodge" )	{
									<s1>.setdrawmode(1);
								}
							}
							"-hideonstart" => {
								<s1>.anhideonsetframe;
							}
							? => j = .animaloader_an(s1, "_dbanl", i, j);
						}
					}
				}
				? => ;
			}
		}
	}
}

public animaloader_an(string san, string sdb, int row, int col)	{
	col;
}
public transparent	{	return 0,0,0,0;	}
public red			{	return 255,0,0;	}
public green		{	return 0,255,0;	}
public blue			{	return 0,0,255;	}
public white		{	return 255,255,255; }
public black		{	return 0,0,0;		}
public grey(int c)	{	return c,c,c;		}
public yellow		{	return 255,255,0;	}

class Color	{
	init	{
		.vars(A,"r","g","b","a");
	}
	operator=(string scol)	{	this.set( <scol>.get() );	}
	img=(@simg)	{
		|r,g,b,a| = <simg>.getrgba( classansearcher::firstnotrx1y(simg) );
	}
	get			{	return r,g,b,a;	}
	set(int r2, int g2, int b2, int a2)	{	|r,g,b,a| = r2,g2,b2,a2;	}
	rgb=(int r2, int g2, int b2)	{	|r,g,b|=r2,g2,b2;	}
	rgb	{	return r,g,b;	}
	print	{	engine.print("Color::" + this + " (r,g,b,a) = ("+r+","+g+","+b+","+a+")");	}
}

/***************************************************************************/

class classasker : newvars	{
	init()	{
		newvars::init();
		new string sfuncyes = null;
		new string sfuncno = null;
		new string ssndask;
		new string ssndyes;
		new string ssndno;
		new classsound clsnd;
	}
	reset()	{
		sfuncyes=null;	sfuncno=null;
		buts.resetall();
	}
	setfuncs(string syes, string sno)	{
		sfuncyes = syes;
		sfuncno = sno;
	}
	fxonmovon(string ssnd)	{	buts.sfxonmovon(ssnd);	}
	setmouse(string smouse)	{
		buts.newmouse("yes", smouse);
		buts.newmouse("no", smouse);
	}
	load(string sfile, int z)	{
		new classbutton buts;
		buts.build(sfile, z, null);
		buts.transclickfunc( engine.actclassname(), "butclick");
		buts.transmovonfunc( engine.actclassname() , "butmovon");
		buts.disableall();
	}
	ask( string sask, string syes, string sno, string sf1, string sf2 )	{
		this.setfuncs(sf1,sf2);
		this.ask2( sask, syes, sno );
	}
	ask2( string sask, string syes, string sno )	{
		ssndask=sask;
		ssndyes = syes;
		ssndno = sno;
		gameapi.pause();
		buts.benableall();
		buts.pause("bkg");
		clsnd.creset();
		clsnd.cbplay( sask );
		.<this+"_ask">;
	}
	/**********************************************/
	butmovon(string sc)	{
		/*if( ssndask!=null )	{
			if( <ssndask>.isplaying()==true )	{
				return;
			}
		}*/
		if( sc=="yes" )	{
			<ssndask>.stop(false);
			clsnd.cbplay( ssndyes );
		} else if (sc=="no")	{
			<ssndask>.stop(false);
			clsnd.cbplay( ssndno );
		}
	}
	butclick(string sc)	{
		if( sc=="bkg" )	return;
		gameapi.resume();
		buts.disableall();
		clsnd.cactsndstop(false);
		if( sc=="yes" && sfuncyes!=null)	{
			this.<sfuncyes>();
			.<this+"_yes">;
		} else if( sc=="no" && sfuncno!=null)	{
			this.<sfuncno>();
			.<this+"_no">;
		}
	}
	disabled	{	buts.disabled;	}
	setcursorpos(int x, int y)	{	buts.setcursorpos(x,y);	}
}

/***************************************************************************/
class classplacepointer	{
	init()	{
		new anima anpointer;
		anpointer.addmethod("onfinish", func { this.play(-1); } );
		new int _iz = 1000;
	}
	public load(string sfile)	{
		anpointer.load(sfile);
		this.setz(_iz);
		anpointer.hide();
	}
	public setz(int iz)	{
		_iz = iz;
		anpointer.setz(iz);
	}
	public stop()	{	anpointer.stop(false);	}
	public stoph()	{	anpointer.stop(false);	anpointer.hide();	}
	public show(int x, int y, string sdir)	{
		anpointer.setpos(x,y);
		anpointer.play(sdir);
	}
	move(@x, @y)	{	anpointer.move(x,y);	}
	public showob(string sob, string sdir)	{	this.show(<sob>.getcx(), <sob>.getcy(), sdir);	}
	public showpob(string sob, string sdir)	{	this.show(<sob>.getpx(), <sob>.getpy(), sdir);	}
}

class SimpleCounter	{
	init(int ilength)	{
		.var2("length", ilength );
		new int iid = 0;
	}
	int next()	{	iid = (iid+1)%length;		iid;	}
	set(int i)	{	iid=i;	}
	reset()	{	iid=0;	}
	get()	{	iid;	}
}

/******************************************/

module clstrdigit	{
	init()	{}
	public string getdigit(int idigit, int ilepozycji)	{
		string s = idigit;
		while( s.length() < ilepozycji )	s = "0" + s;
		return s;
	}
	public string gettime(int itime, string smod)	{
		return this.getstime( this.geth(itime), this.getm(itime), this.gets(itime), 
			smod.contains("h"), smod.contains("m"), smod.contains("s") );
	}
	public string getstime(int ih, int im, int is, bool bh, bool bm, bool bs)	{
		string s = "";
		if( bh ) s+= ih;
		if( bm ) s+= (bh?":":"") + this.getdigit(im,2);
		if( bs ) s+= ((bh||bm)?":":"") + this.getdigit(is,2);
		return s;
	}
	public int geth(int itime)	{	return itime/3600;	}
	public int getm(int itime)	{	return (itime/60)%60;	}
	public int gets(int itime)	{	return itime%60;	}
	public string getns(int itime, int n)	{	return this.getdigit( this.gets(itime),n );	}
	public string getnm(int itime, int n)	{	return this.getdigit( this.getm(itime),n );	}
	string getbinary(int ival)	{
		string s = "";
		while(ival>0)	{
			s = "" + (ival%2) + s;
			ival/=2;
		}
		return s;
	}
	string bintohex(string sval)	{
		string s;
		match(sval.length%4)	{
			3=>"0"; 2=> "00"; 1=> "000";
			? => "";
		}
		s = _;
		sval = s + sval;
		s = "";
		for( int i=0; i<sval.length; i+=4)	{
			match(sval.getb(i,4))	{
				"0000" => "0";	"0001" => "1";	"0010" => "2";	"0011" => "3";
				"0100" => "4";	"0101" => "5";	"0110" => "6";	"0111" => "7";
				"1000" => "8";	"1001" => "9";	"1010" => "A";	"1011" => "B";
				"1100" => "C";	"1101" => "D";	"1110" => "E";	"1111" => "F";
				? => ;
			}
			s += _;
		}
		s;
	}
}

public string getbinary			{	clstrdigit::getbinary(.get);		}
public string getdigit(int ile)		{	clstrdigit::getdigit(.get,ile);		}
public string getbindigit(int ile)	{	clstrdigit::getdigit( .getbinary,ile);	}

class Text	{
	init(string sfont, int ifontsize, int ifr, int ifg, int ifb, int x, int y, int z)	{
		if( sfont==null )	sfont = sgmfontfile;
		if( sfont.contains(".ttf") )	{
			new font _fnt;
			_fnt.load( sfont, ifontsize );
			sfont = "_fnt";
		}
		new int iR = ifr;
		new int iG = ifg;
		new int iB = ifb;
		new int iFontSize = ifontsize;
		new text txt;
		txt.setfont(sfont);
		txt.setz(z);
		txt.setpos(x,y);
		txt.show;
		
		new text txtbg;
		txtbg.hide();
	}
	public hide()	{	txt.hide;	}
	public show()	{	txt.show;	}
	public setpos(int x, int y)	{	txt.setpos(x,y);	}
	public set(string s)	{
		txt.set( s );
		txt.createtxt( iR, iG, iB );
	}
	public string get()	{	return txt.get;	}
	public setbg(int ir, int ig, int ib, int ia)	{
		txtbg.setbkg(txt.getpx()-iFontSize/2, txt.getpy()-iFontSize/2,
			txt.getw()+iFontSize, iFontSize*2, ir, ig, ib, ia );
		txtbg.setborders(1,255,255,255,128);
		txtbg.show();
	}
	operator=(string val)	{	this.set(val);	}
	move(int x, int y)	{	txt.move(x,y);	}
}

class Cypher : Text	{
	init(string sfont, int ifontsize, int ifr, int ifg, int ifb, int x, int y, int z)	{
		Text::init(sfont, ifontsize, ifr, ifg, ifb, x, y, z );
		this.set(0);
	}
	add(int dt)	{	this.set( dt + this.get );	}
	iget()		{	this.get->to_i;		}
	operator+(int val)	{	this.add(val);	}
	operator++()	{	this.add(1);	}
	operator--()	{	this.add(-1);	}
	operator-(int val)	{	this.add(-val);	}
	operator=(int val)	{	this.set(val);	}
	operator==(int val)	{	.get==val;	}
	operator!=(int val)	{	.get!=val;	}
	operator>(int val)	{	.get>val;	}
	operator<(int val)	{	.get<val;	}
}

class SecCounter	{
	init(string sdigits, int starttime, int dt)	{
		new string sdigit = sdigits;
		.vars2(A, "istarttime", starttime, "idtime", dt, "itime", 0);
		this.reset();
		this.cnewtimerfin("timcyk",1000,1, func { .play; <.getbuildername>.tick; } );
	}
	public play()	{	timcyk.play();	}
	public stop()	{	timcyk.stop(false);}
	public string sgettime()	{	return clstrdigit.gettime(itime, sdigit);	}
	public int gettime()	{	return itime;	}
	public tick	{	.update(idtime);	}
	public reset()	{
		//this.update(-itime);
		itime = istarttime;
	}
	public update(int isec)	{
		itime+=isec;
	}
}

class TextTimeCounter : Text, SecCounter	{
	init(string sfont, int ifontsize, int ifr, int ifg, int ifb, int x, int y, int z, string sdigits, int starttime, int dt)	{
		Text::init(sfont, ifontsize, ifr, ifg, ifb, x, y, z);
		SecCounter::init(sdigits, starttime, dt);
		.reset;
		.update(0);
	}
	public update(int isec)	{
		SecCounter::update(isec);
		this.set( this.sgettime() );
		if( itime<=0 && idtime<0 )	{
			.<this + "_finish">;
		}
	}
}

class gfxObject	{
	init(string sob)	{	new string sgfxobj = sob; }
	setpos		{	<sgfxobj>.setpos;	}
	move		{	<sgfxobj>.move;	}
	getpos		{	<sgfxobj>.getpos;	}
	getposx		{	<sgfxobj>.getposx;	}
	getposy		{	<sgfxobj>.getposy;	}
	getpx		{	<sgfxobj>.getpx;	}
	getpy		{	<sgfxobj>.getpy;	}
	getw			{	<sgfxobj>.getw;	}
	geth			{	<sgfxobj>.geth;	}
	getcx		{	<sgfxobj>.getcx;	}
	getcy		{	<sgfxobj>.getcy;	}
	getex		{	<sgfxobj>.getex;	}
	getey		{	<sgfxobj>.getey;	}
	lodx			{	<sgfxobj>.lodx;	}
	lody			{	<sgfxobj>.lody;	}
	setz			{	<sgfxobj>.setz;		}
	getz			{	<sgfxobj>.getz;	}
	show		{	<sgfxobj>.show;	}
	hide			{	<sgfxobj>.hide;	}
	isvisible		{	<sgfxobj>.isvisible;	}
	bool isin		{	<sgfxobj>.isin;		}
}

class gfxSquare : Color, gfxObject	{
	init(int x1, int y1, int w1, int h1)	{
		Color::init;
		.vars(A, "w", "h");
		w=w1; h=h1;
		new img imggfx;
		imggfx.setpos(x1,y1);
		gfxObject::init("imggfx");
	}
	build	{	imggfx.create(w,h,r,g,b,a);	}
	shadow(int dx, int dy, int alpha)	{
		|@x,@y| = imggfx.getpos;
		imggfx.setpos(0,0);
		new img _img1;
		new img _img2;
		if( imggfx.getw>0 )	{
			_img1.create(w,h,.transparent);
			_img1.blit("imggfx");
		} else _img1.create(w,h,.get);
		_img2.create(w,h,.black,alpha);
		if( dx<0 )	{
			_img1.move(-dx, 0);
			x+=dx;
		} else	_img2.move( dx, 0 );
		if( dy<0 )	{
			_img1.move(0,-dy);
			y+=dy;
		} else	_img2.move( 0, dy );
		w += dx.abs;
		h += dy.abs;
		imggfx.create(w, h, .transparent);
		imggfx.blit("_img2");
		imggfx.blit("_img1");
		delete _img1;
		delete _img2;
		imggfx.move(x,y);
	}
	blackborder(int width, int a2)	{	.border(width,width, .black,a2);	}
	border(int width, int height, int r2, int g2, int b2, int a2)	{
		|@x,@y| = imggfx.getpos;
		imggfx.setpos(0,0);
		new img _img;
		if( imggfx.getw>0 )	{
			_img.create(w,h,.transparent);
			_img.blit("imggfx");
		} else _img.create(w,h,.get);
		_img.move(width,height);
		w += 2*width;
		h += 2*width;
		imggfx.create(w,h,r2,g2,b2,a2);
		imggfx.blit("_img");
		delete _img;
		imggfx.move(x,y);
	}
}

class Rect	{
	init(int _x, int _y, int _w, int _h)	{
		.vars(A, "x", "y", "w", "h");
		.set(_x, _y, _w, _h);
		new vector vecgr; vecgr.type("string");
		vecgr.add("gmimgvec");
	}
	x2	{	x+w;	}
	y2	{	y+h;	}
	set(int _x, int _y, int _w, int _h)	{ x=_x; y=_y; w=_w; h=_h; }
	setborders(int _x, int _y, int _x2, int _y2)	{
		x=_x; y=_y; w=_x2-_x; h=_y2-y;
	}
	fit(string simg)	{
		if( vecgr.contains( <simg>.gettype) ) {
			@dx = x-<simg>._getpx;
			if( dx>0 ) <simg>.move(dx,0);
			@dy = y-<simg>._getpy;
			if( dy>0 ) <simg>.move(0,dy);
		} else {
			@dx = x-<simg>.getpx;
			if( dx>0 ) <simg>.move(dx,0);
			@dy = y-<simg>.getpy;
			if( dy>0 ) <simg>.move(0,dy);
		}
		dx = .x2-<simg>.getex;
		if( dx<0 ) <simg>.move(dx,0);
		dy = .y2-<simg>.getey;
		if( dy<0 ) <simg>.move(0,dy);
	}
	fitrand(string simg)	{	<simg>.ansetbpos( x+(w-<simg>.getw)->rand, y+(h-<simg>.geth)->rand);	}
	fitgrouprand(string sgr)	{	for( int i=0; i< <sgr>.size; i++) .fitrand( <sgr>.get(i) );	}
	fitgroup(string sgr)	{	for( int i=0; i< <sgr>.size; i++) .fit( <sgr>.get(i) );	}
	bool isin(int _x, int _y)	{	_x>=x && _x<x+w && _y>=y && _y<y+h;	}
}

class ImgRect	{
	init	{
		.vars2(A, "ix",0,"iy",0,"iw",0,"ih",0,"bvis",1, "iz", 0);
	}
	setpos(int x, int y)	{	ix=x; iy=y;	}
	move(int x, int y)	{	ix+=x; iy+=y;	}
	getpos			{	return ix,iy;	}
	getposx			{	ix;		}
	getposy			{	iy;		}
	getpx			{	ix;		}
	getpy			{	iy;		}
	getw			{	iw;		}
	geth			{	ih;		}
	getcx			{	ix+iw/2;	}
	getcy			{	iy+ih/2;	}
	getex			{	ix+iw;		}
	getey			{	iy+ih;		}
	lodx			{	0;		}
	lody			{	0;		}
	setz(int z)		{	iz=z;		}
	getz			{	iz;		}
	show			{	bvis = true;	}
	hide			{	bvis = false;	}
	isvisible		{	bvis;		}
	bool isin(int x, int y, bool bv, bool ba)	{
		if( bv==false || .isvisible )
			x>=ix && x<ix+iw && y>=iy && y<iy+ih;
		else false;
	}
	setrect(int x, int y, int x2, int y2)	{
		ix=x; iy=y; iw=x2-x; ih=y2-y;
	}
	print	{
		("x: "+ix+", y: "+iy+", w: "+iw+", h: "+ih)->print;
	}
	operator=(string srec)	{
		|ix,iy,iw,ih,iz,bvis| = <srec>.getpx, <srec>.getpy, <srec>.getw, <srec>.geth, <srec>.getz, <srec>.isvisible;
	}
}

/***************************************************************************/

class classfadeinout		{
	init()	{
		new timer timf;
		new string _sob;
		new int _istep;
		new int _ival;
		new int _ib1;
		new int _ib2;
		new string _sfun;
		new string _sfunfin;
		new string _sobfin;
		timf.addmethod("onfinish", "_ctimffin");
	}
	/***************\/\/\/\/\/ wewnetrzne \/\/\/\/\/\/************************************/
	_cfinito(int v)	{
		<_sob>.<_sfun>( v );
		if( _sfunfin!=null)	{
			if( _sobfin==null )
				this.<_sfunfin>();
			else <_sobfin>.<_sfunfin>;
		}
	}
	_ctimffin()	{
		_ival+=_istep;
		if( _ival > _ib2 )	{
			this._cfinito( _ib2 );
		} else if( _ival<_ib1 )	{
			this._cfinito( _ib1 );
		} else {
			<_sob>.<_sfun>( _ival );
			this.play();
		}
	}
	_play( int icycle, int istep, string sob, string sfun, int ib1, int ib2, string sob2, string sfun2 )	{
		_sobfin = sob2;
		_sfunfin = sfun2;
		_ib1 = ib1;
		_ib2 = ib2;
		int i = istep.abs();
		if( icycle <= 0 || i==ib1 || i>ib2 )	return;
		_sfun = sfun;
		timf.setcycle( icycle );
		_sob = sob;
		if( istep>0 )	_ival = _ib1;
		else if( istep<0 )	_ival=_ib2;
		else return;
		<sob>.<sfun>( _ival );
		_istep = istep;
		timf.play();
	}
	/******************* /\/\/\/\/\/\/\ wewnetrzne /\/\/\/\ ****************************/
	imgtransparency(int icycle, int istep, string simg, string sfun)	{
		this._play( icycle, istep, simg, "transparency", 0, 255, null, sfun );
	}
	setopacity(int icycle, int istep, string simg, string sfun)	{
		this._play( icycle, istep, simg, "setopacity", 0, 255, null, sfun );
	}
	sndvolume(int icycle, int istep, string ssnd, string sfun)	{
		this._play( icycle, istep, ssnd, "setvol", 0, 100, null, sfun );
	}
	/***************************************************/
	isplaying	{	timf.isplaying;	}
}

class CutScene : gfxObject	{
	init(int x1, int y1, int x2, int y2)	{
		new int X1;	new int Y1;
		new int X2;	new int Y2;
		new img _gsq;
		.build(x1, y1, x2, y2);
		gfxObject::init("_gsq");
		new string _sfunc1;
		new string _sob1;
		new string _sfunc2;
		new string _sob2;
		new int _idelay = 10;
		new classfadeinout _clfio;
	}
	build(int x1, int y1, int x2, int y2)	{
		|X1, Y1, X2, Y2| = x1, y1, x2, y2;
		_gsq.create(X2-X1,Y2-Y1,.black,255);
		_gsq.setpos(X1,Y1);
		_gsq.hide;
		_gsq.transparency(0);
	}
	buildblack	{	.build(X1,Y1,X2,Y2);	}
	buildfromfile(string sfile)	{
		@z = .getz;
		new img _imtmp;
		_imtmp.load(sfile);
		_gsq.transparency(255);
		_gsq.blit("_imtmp");
		delete _imtmp;
		_gsq.hide;
		_gsq.transparency(0);
	}
	buildfromscreen	{
		_gsq.transparency(255);
		_gsq.blitscreen;
		_gsq.hide;
		_gsq.transparency(0);
	}
	cloneto(string simg)	{
		<simg>.clone("_gsq");
	}
	delay(int n)	{	_idelay=n;	}
	transparency(int n)	{	_gsq.transparency(n);	}
	playfin(string sfunc1, string sfunc2)	{	.playobfin(null,sfunc1, null, sfunc2);	}
	playobfin(string sob1, string sfunc1, string sob2, string sfunc2)	{
		_sob1 = (sob1==null) ? gameapi.getgamename : sob1;
		_sfunc1 = sfunc1;
		_sob2 = (sob2==null) ? gameapi.getgamename : sob2;
		_sfunc2 = sfunc2;
		_gsq.show;
		_gsq.transparency(0);
		_clfio._play( 1, _idelay, this, "transparency", 0, 255, this, func {
			.callfun(_sob1, _sfunc1);
			_gsq.show;
			_clfio._play( 1, -_idelay, this, "transparency", 0, 255, this, "_callfun2" );
			} );
	}
	close(string sfunc1)	{	.obclose(gameapi.getgamename, sfunc1);	}
	obclose(string sob, string sfunc1)	{
		_sob1 = sob;
		_sfunc1 = sfunc1;
		_gsq.transparency(0);
		_gsq.show;
		_clfio._play( 1, _idelay, this, "transparency", 0, 255, this, func {
			_gsq.hide;
			.callfun(_sob1, _sfunc1);
			} );
	}
	enter(string sfunc2)	{	.obenter(gameapi.getgamename, sfunc2);	}
	obenter(string sob, string sfunc2)	{
		_sob2 = sob;
		_sfunc2 = sfunc2;
		_gsq.transparency(255);
		_gsq.show;
		_clfio._play( 1, -_idelay, this, "transparency", 0, 255, this, "_callfun2" );
	}
	_callfun2	{
		_gsq.hide;
		.callfun(_sob2, _sfunc2);
	}
	isplaying	{	_clfio.isplaying;	}
	show	{
		_gsq.transparency(255);
		_gsq.show;
	}
}


public string allchars	{	"a0 t_!@#$%^&*()_+-=[]\\|}{;':\",./<>?`~"; }

class TextTyper : classlocker, gfxObject {
	init(string sfont, int isize, int ir, int ig, int ib, string schars, int ilimit)	{
		classlocker::init();
		sfont = .checkfont(sfont, isize);
		new int iR = ir;
		new int iG = ig;
		new int iB = ib;
		new string sChars = schars;
		new int iLimit = ilimit;		// 0 - unlimited
		
		.vars2(A,"Sdir","left", "W", 0, "iFontSize", isize, "X", 0, "Y", 0);
		
		new text txt1;
		txt1.setfont(sfont);
		txt1.set("");
		new text txt2;
		txt2.setfont(sfont);
		txt2.set("_");
		txt2.createtxt(iR,iG,iB);
		txt2.hide();
		
		new text txtpass;
		txtpass.setfont(sfont);
		txtpass.hide;
		new bool bpass = false;
		
		new string _sob=null;
		new string _sfun=null;
		
		this.cnewtimerfin("timcyk",300,1,"fintimcyk");
		
		gfxObject::init("txt1");
	}
	setaspasswd	{
		bpass = true;
		txt1.hide;
		txtpass.setz( txt1.getz );
		txtpass.show;
		.copytopass;
	}
	copytopass	{
		@id = txt1.get->length;
		string s = "";
		for( int i=0; i<id; i++)	s += "*";
		txtpass.txtset(s);
		txtpass.setpos( txt1.getpx, txt1.getpy );
	}
	setastext	{
		bpass = false;
		txt1.show;
		txtpass.hide;
	}
	public isin(int x, int y, bool bv, bool ba)	{	txt1.isin(x,y,bv,ba);	}
	getcol	{	return iR,iG,iB;	}
	fintimcyk()	{
		if( this.getlock() )	return;
		this.updatecyk();
		this.play();
	}
	updatecyk()	{
		if( txt2.isvisible() )	{
			txt2.hide();
		} else {
			txt2.setpos( txt1.getex(), txt1.getpy() );
			txt2.show();
		}
	}
	public enable()	{
		this.unlock();
		this.updatecyk();
		timcyk.play();
	}
	public disable()	{
		txt2.hide();
		timcyk.stop(false);
		this.lock();
	}
	public onenter(string sob, string sfun)	{	_sob=sob;	_sfun=sfun;	}
	public setpos(int x, int y)	{
		X = x;
		Y = y;
		//txt1.setpos(x,y);
		.updatetxt(.get);
	}
	public move(int x, int y)	{	.setpos(X+x, Y+y); }
	public setz(int z)	{	txt1.setz(z);txt2.setz(z);	}
	public get()	{
		string s = txt1.get();
		( s.length()>0 ) ? s : "";
	}
	getpx	{	txt1.getpx;	}
	getpy	{	txt1.getpy;	}
	getcx	{	txt1.getcx;	}
	getcy	{	txt1.getcy;	}
	geth	{	txt1.geth;	}
	getey	{	txt1.getpy + iFontSize;	}
	clip(int x1, int y1, int x2, int y2)	{
		txt1.clip(x1,y1,x2,y2);
		txt2.clip(x1,y1,x2,y2);
	}
	public length	{	txt1.get->length;	}
	public set(string s)	{	txt1.set(s);	}
	public txtset(string s)	{	txt1.txtsetcol(s,.getcol);	}
	public limit=(int il)	{	iLimit=il;	}
	public onkeydown()	{
		if( this.getlock() )	return;
		.<this+"_ontype">;
		if( keyboard.iskeydown("enter") )	{
			this.disable();
			this.callfun(_sob,_sfun);
			.<this+"_onenter">;
			return;
		}
		string s;
		if( sChars.contains("t") && keyboard.iskey("tab") )	s = " ";
		else s = keyboard.getkey();
		string s2 = txt1.get();
		if( ( (keyboard.isalpha && sChars.contains("a") ) || ( keyboard.isdigit && sChars.contains("0") )
			|| sChars.contains(s) ) && (iLimit<=0 || iLimit>s2.length)  )	{
			//txt1.set( s2+s );
			//txt1.createtxt(iR,iG,iB);
			.updatetxt(s2+s);
			this.updatecyk();
		} else if (keyboard.iskey("backspace") && s2.length()>0)	{
			//txt1.set( s2.strsube(1) );
			//txt1.createtxt(iR,iG,iB);
			.updatetxt( s2.strsube(1) );
			this.updatecyk();
		}
		.<this+"_ontyped">;
	}
	updatetxt(string s)	{
		txt1.set(s);
		txt1.createtxt(iR, iG, iB);
		if( Sdir == "center" )	txt1.setpos( X+(W-txt1.getw)/2, Y );
		else if (Sdir=="right")	txt1.setpos( X+W-txt1.getw, Y );
		else txt1.setpos(X, Y);
		if( bpass )	.copytopass;
		.<this+"_onwrite">;
	}
}

class ConTextTyper : TextTyper, ObjController	{
	init()	{
		TextTyper::init();
		ObjController::init();
	}
}

new string sTextBoxTyperSys = null;
class TextBoxTyper : LObjController, ImagePos	{
	init(string sfont, int ish, int isw, int ir, int ig, int ib, string schars, int x, int y, int w, int h, int dy)	{
		LObjController::init;
		ImagePos::init;
		new @Font = .checkfont(sfont, ish);
		.vars2(A,"Cols", w/isw, "Rows", h/(ish+dy), "X", x, "Y", y, "Row", 0, "enablemove", true, "W", w,
			"insystem", false, "H", h, "isvisible", 1, "clipx1", x, "clipy1", y, "clipx2", 0, "clipy2", 0, "clipped", false );
		new @Size = ish;
		new @Dy = dy;
		new @Z = 0;
		string s;
		new gmimgvec grtt;
		new gmimgvec gren;
		for( int i=0; i<Rows; i++)	{
			s = "tt"+i;
			new TextTyper <s>(Font,ish,ir,ig,ib,schars,Cols);
			<s>.W = (w);
			<s>.Sdir = ("left");
			<s>.setpos( x, y+i*(ish+dy) );
			grtt.add(s);
		}
	}
	settyper(int id, string sfont, int ish, int isw, int ir, int ig, int ib, string schars, string sdir)	{
		int x;
		int y;
		string s;
		string stext = "";
		if( id<0 ) {
			x = <grtt.last>.X;
			y  = <grtt.last>.getey+Dy;
			id = grtt.size;
			grtt.add("tt"+id);
		} else {
			s = grtt.get(id);
			x = <s>.X;
			y = <s>.getpy;
			stext = <s>.get;
			grtt.movefrom( s, 0, ish - <s>.iFontSize );
			delete <s>;
		}
		s = "tt" + id;
		new TextTyper <s>(sfont,ish,ir,ig,ib,schars,W/isw);
		<s>.W = (W);
		<s>.Sdir = (sdir);
		<s>.updatetxt(stext);
		<s>.setz(Z);
		<s>.setpos( x, y );
	}
	move(int x, int y)	{	grtt.move(x,y); gren.move(x,y); X+=x; Y+=y;	}
	size	{	grtt.size;	}
	setz(int z)	{	Z = z; grtt.setz(z);	gren.setz(z); }
	getz	{	Z;	}
	show	{	isvisible=1; grtt.show;	}
	hide		{	isvisible=0;	grtt.hide;		}
	clip(int x1, int y1, int x2, int y2)	{
		clipped = true;
		clipx1=x1;	clipy1=y1;	clipx2=x2;	clipy2=y2;
		for( int i=0; i<grtt.size; i++) <grtt.get(i)>.clip(x1,y1,x2,y2);
	}
	getw	{	W;	}
	geth	{	H;	}
	enumerate(int dx)	{
		string s[2];
		for( int i=0; i<grtt.size; i++)	{
			s0 = "txte"+i;
			new text <s0>;
			gren.add(s0);
			<s0>.setz(Z);
			<s0>.setfont(Font);
			<s0>.txtsetcol(""+(i+1)+".", tt0.getcol);
			<s0>.setpos(X-<s0>.getw-dx,Y+i*(Size+Dy));
		}
	}
	cut(int id)	{	Rows=id;	}
	enable	{	.unlock;	.activateact;	}
	disable	{	.lock; grtt.eval("disable");	}
	actual	{	"tt"+Row;	}
	activate(int id)	{
		.unlock;
		if( id>=0 && id<Rows )	{
			if( insystem )	{
				if( <GAME>.isgmobj(sTextBoxTyperSys) && sTextBoxTyperSys!=this )	<sTextBoxTyperSys>.deactivate;
				sTextBoxTyperSys = this;
			}
			.deactivate;
			Row = id;
			<"tt"+ Row>.enable;
			.<this+"_activate">;
		}
	}
	activateact	{	.activate(Row);	}
	deactivate	{	<"tt"+Row>.disable;	}
	onkeydown	{
		if(.getlock)	return;
		.<this+"_boxontype">;
		if( keyboard.iskeydown("enter") )		{
			@s = .getid(Rows-1);
			s.clear;
			if( s.length==0 && enablemove )	{
				for( @i=Rows-1; i>Row+1; i--)	.setid( .getid(i-1), i);
				if( Row+1<Rows) .setid("", Row+1);
			}
			.activate(Row+1);
		} else if (keyboard.iskey("up") && Row>0) .activate(Row-1);
		else if (keyboard.iskey("down") && Row<Rows-1) .activate(Row+1);
		else if (keyboard.iskey("pgdown"))	{
			if(Row<Rows-10) .activate(Row+10);
			else .activate(Rows-1);
		} else if (keyboard.iskey("pgup"))	{
			if(Row>9) .activate(Row-10);
			else .activate(0);
		} else if ((keyboard.iskey("backspace") || keyboard.iskey("delete")) && <.actual>.length==0 ) {
			if( enablemove )	{
				for( @i=Row; i<Rows-1; i++)	.setid( .getid(i+1), i);
				.setid("",Rows-1);
			}
			if( keyboard.iskey("backspace") )
				.activate(Row-1);
		} else grtt.eval("onkeydown");
	}
	onmouselclick	{
		if(.getlock)	return;
		|int x, int y| = mouse.getpos;
		//if(  )	{
		if( (clipped && clsurf.isin(x,y,clipx1,clipy1,clipx2,clipy2)) || (!clipped && clsurf.isin2(x,y,X,Y,W,H)) )	{
			.deactivate;
			//.activate( ((y-Y)*Rows)/H );
			for( int i=0; i<.size; i++)	{
				if( <"tt"+i>.getey > y ) {
					.activate(i);
					return;
				}
			}
		} else {
			.<this+"_OUTSIDE">;
		}
	}
	int isin(int x, int y, bool bv, bool ba)	{
		if( bv && !isvisible ) return 0;
		clsurf.isin2(x,y,X,Y,W,H);
	}
	string getid(int id)	{	<"tt"+id>.get;	}
	string getact		{	<"tt"+Row>.get;	}
	int idpx(int id)	{	<"tt"+id>.getpx;	}
	int idpy(int id)	{	<"tt"+id>.getpy;	}
	//int getpy	{	.idpy(0);	}
	//int getpx	{	.idpx(0);	}
	int getpx	{	X;	}
	int getpy	{	Y;	}
	string get	{	.getfrom(0);	}
	string getfrom(int id)	{	.getlinesfrom(id,"");	}
	string getlinesfrom(int id, string send)	{
		string s = "";
		for( int i=id; i<grtt.size; i++) s += <"tt"+i>.get + send;
		s;
	}
	string getlines	{	.getlinesfrom(0," ");	}
	int nonempty(int id)	{
		string s;
		for( ; id<grtt.size; id++)	{
			s = <"tt"+id>.get;
			s.clear;
			if( s.length > 0 ) return id;
		}
		-1;
	}
	clear	{	grtt.txtreset;	}
	setid(string s, int id)	{	if( grtt.size>=id )	<"tt"+id>.txtset(s);	}
	settext(int ile)	{
		while(ile>0)	{
			ile--;
			.setid(_,ile);
		}
	}
	copytodb(string sdb)	{
		<sdb>.free;
		for( int i=0;i<grtt.size; i++)	{
			<sdb>.add( <sdb>.addrow-1, <grtt.get(i)>.get);
		}
	}
	copyfromdb(string sdb)	{	.copyfromdbii(sdb, 0, <sdb>.getrowsno);	}
	copyfromdbss(string sdb, string s1, string s2)	{	.copyfromdbii(sdb, <sdb>.findbyrow(s1)+1, <sdb>.findbyrow(s2) );	}
	copyfromdbii(string sdb, int row1, int row2)	{
		if( row1==-1 || row2==-1 ) return;
		.clear;
		if( row2-row1 > .size ) row2 = row1+.size;
		for( int i=row1; i<row2; i++)	{
			if( <sdb>.getcolsno(i) )
				.setid( <sdb>.get(i,0), i-row1 );
		}
	}
	copyfromdbrow(string sdb, int row, int startcol)	{
		int size = <sdb>.getcolsno(row);
		if( size>.size ) size = .size;
		for( int i=startcol; i<size; i++)
			.setid( <sdb>.get(row,i), i-startcol );
	}
	save(string sfile)	{
		new db __tmpdb;
		.copytodb("__tmpdb");
		__tmpdb.setseparator("|");
		__tmpdb.save(sfile);
		delete __tmpdb;
	}
	load(string sfile)	{
		new db __tmpdb;
		__tmpdb.load(sfile);
		.copyfromdb("__tmpdb");
		delete __tmpdb;
	}
	/*H	{
		if( grtt.size )	<grtt.last>.getey-<grtt.first>.getpy;
		else 0;
	}*/
}

class GUITextBoxTyper : TextBoxTyper	{
	init(string sfont, int ish, int isw, int ir, int ig, int ib, string schars, int x, int y, int w, int h, int dy)	{
		TextBoxTyper::init(sfont,ish,isw,ir,ig,ib,schars,x,y,w,h,dy);
		.vars2(A,"rewinder", null, "rewinderbg", null);
	}
	setrewinder(string s)	{
		rewinder = s;
		rewinderbg = s + "bg";
	}
	activate(int id)	{
		TextBoxTyper::activate(id);
		.updaterewactual;
	}
	updaterewactual	{	.updaterewpos(Row);	}
	updaterewpos(int id)	{
		if( rewinder!=null )	{
			@s = "tt"+id;
			if( <s>.getpy < <rewinderbg>.getpy )		<rewinder>.rewind( 0, <rewinderbg>.getpy - <s>.getpy );
			else if (<s>.getey > <rewinderbg>.getey)		<rewinder>.rewind( 0, <rewinderbg>.getey - <s>.getey );
		}
	}
}

/****************************************************************/
class DelayTaker	{
	init()	{
		new bool bonrel = false;
		new bool bstart = false;
		new bool bclickrel = true;
		this.cnewtimerfin("timwez",300,1, func { bonrel=true; } );
	}
	public setclickrel(bool b)	{	bclickrel=b;	}
	public setdelay(int idelay)	{	timwez.delay(idelay);	}
	public take()	{
		if( bclickrel )	{
			timwez.play();
			bonrel=false;
		} else bonrel=true;
		bstart=true;
		
	}
	public ret()	{
		bonrel=false;
		bstart=false;
		timwez.stop(false);
	}
	public bool isonclick()	{
		this.stoptimer();
		( bstart && !bonrel );
	}
	public bool isonrel()	{
		this.stoptimer();
		( bstart && bonrel );
	}
	public bool istaken()	{	bstart;	}
	public stoptimer()	{	timwez.stop(false);	}
}


class ImgMover	{
	init()	{
		new string smoved=null;
		new int ilastx;
		new int ilasty;
		new int irelx;
		new int irely;
	}
	public mssetobj(string s)	{	this.setobj(s,mouse.getpos);	}
	public setobj(string s, int x, int y)	{	this.set(s,x,y,0,0);	}
	public setcobj(string s)	{	.setobj(s, <s>.getcx, <s>.getcy);	}
	public setpobj(string s)	{	.setobj(s, <s>.getpx, <s>.getpy);	}
	public set(string s, int x, int y, int dx, int dy)	{
		ilastx = <s>.getposx()-dx;
		ilasty = <s>.getposy()-dy;
		irelx = x-<s>.getpx();
		irely = y-<s>.getpy();
		smoved = s;
	}
	public msmove()		{	this.move(mouse.getpos);	}
	public msftmove()	{	this.ftmove(mouse.getpos);	}
	public move(int x, int y)	{
		if( smoved!=null )	<smoved>.setpos( x-<smoved>.lodx()-irelx, y-<smoved>.lody()-irely );
	}
	public ftmove( int x, int y)	{	if( smoved!=null )	<smoved>.setpos( x, y );	}
	public retobj()	{	this.ret(0,0);	}
	public ret(int dx, int dy)	{
		<smoved>.setpos(ilastx+dx, ilasty+dy);
		this.free();
	}
	public put(int x, int y)	{
		<smoved>.setpos(x,y);
		this.free();
	}
	public free()			{	smoved=null;	}
	public string getmover()	{	smoved;	}
	public string getfree		{	@s = smoved; .free; s; }
	public bool moving()		{	smoved!=null;	}
	public setmoved(string s)	{	smoved=s;	}
}

class ConImgMover : ImgMover, ObjController	{
	init()	{
		ImgMover::init();
		ObjController::init();
	}
	onmousemove()	{	this.msmove();	}
	onmouselclick	{	.<this+"_GET">;	}
	onmouselrel	{	if( smoved!=null ) .<this+"_PUT">;	}
}

class DelayImgMover : classlocker, ImgMover	{
	init()	{
		classlocker::init;
		ImgMover::init();
		new DelayTaker cldt; 
		.var2("b2clicks",false);
	}
	public setclickrel(bool b)	{	cldt.setclickrel(b);	}
	public reset	{	cldt.ret;	}
	_put	{
		if( !b2clicks )
			cldt.ret;
		.<this+"_PUT">;
	}
	_get	{
		.<this+"_GET">;
	}
	set(string s, int x, int y, int dx, int dy)	{
		ImgMover::set(s,x,y,dx,dy);
		if( !b2clicks )
			cldt.take;
	}
	onmousemove()	{	this.msmove();	}
	onmouselclick()	{
		if( this.getlock() ) return;
		if( b2clicks )	{
			if( !.moving )	._get;
			else ._put;
		} else {
			if( cldt.isonclick() )	this._put();
			else if (!cldt.istaken())
				._get;
		}
	}
	onmouselrel()	{
		if( this.getlock() ) return;
		if( cldt.isonrel() && !b2clicks )
			this._put();
	}
}

class DelayMover : DelayImgMover, ObjController	{
	init()	{
		DelayImgMover::init();
		ObjController::init();
	}
}


class Rewinder : classlocker	{
	init(int x1, int y1, int x2, int y2)	{
		classlocker::init();
		new string sarrowdir;
		new int ilenx;
		new int ileny;
		new string sgr;
		new string sorientation;
		new bool bvertical;
		new bool bfilteritem = false;
		
		// clip obiektow
		new int ibx1=0;
		new int ibx2=iResX;
		new int iby1=0;
		new int iby2=iResY;
		
		new int iodleg = 2;	// odleglosc pomiedzy przedmiotami
		
		new ImgMover clmv;
		
		this.cnewtimercyclefin("timtick", 1, 1, "timfin");
		
		// granice
		.vars2(A, "borx1", x1, "bory1", y1, "borx2", x2, "bory2", y2);
		
		new snd fxrew;
// 		fxrew.addmethod("onfinish", func { this.play(); } );
	}
	public movefilter()		{	bfilteritem=true;	}
	public movenormal()	{	bfilteritem=false;	}
	public setfxrew(string sfile)	{
		fxrew.load(this.getsndpath()+sfile);
	}
	public getitem(string s, int x, int y)	{
		/*clmv.set(s,x,y,<sgr>.getpx(),<sgr>.getpy());
		<s>.clip(0,0,800,600);
		<sgr>.movefrom(s, 0, -<s>.geth);
		<sgr>.remove(s);*/
		<s>.setz( <s>.getz+1 );
		clmv.set(s,x,y,<sgr>.getpx(),<sgr>.getpy());
		<s>.clip(0,0,iResX,iResY);
		if( sorientation=="up" || sorientation=="down")	{
			<sgr>.movefrom(s, -(<s>.getw+iodleg), 0 );
			<s>.move( <s>.getw,0 );
		} else {
			<sgr>.movefrom(s, 0, -(<s>.geth+iodleg));
			<s>.move(0, <s>.geth );
		}
		<sgr>.remove(s);
	}
	public bool pickup(int x, int y)	{
		if( <sgr>.isin(x,y,true,true) )	{
			this.getitem( <sgr>.getsfound(), x, y );
			return true;
		}
		return false;
	}
	public bool mspickup()	{	return this.pickup(mouse.getpos );	}
	public freeitem()	{	clmv.free();	}
	public moveitem()	{
		if( bfilteritem )		clmv.msftmove();
		else		clmv.msmove();
	}
	public retitem()	{
		string s = clmv.getmover();
		clmv.ret(<sgr>.getpx(),<sgr>.getpy());
		this.putitem(s);
	}
	public putitem(string s)	{
		if( sorientation=="up" || sorientation=="down")	{
			<s>.move( <sgr>.getex-<s>.getpx+iodleg, 0);
		} else {
// 			@dx = anupstd.getex - <s>.getw;
// 			<s>.setpos( dx - <s>.lodx, <sgr>.getey-<s>.lody);
			<s>.move( 0, <sgr>.getey-<s>.getpy+iodleg);
		}
		<sgr>.add(s);
		<s>.setz( <s>.getz-1 );
		<s>.clip(ibx1,iby1,ibx2,iby2);
	}
	public string getmoved()	{	return clmv.getmover();	}
	public int getbutw()	{	return anupstd.getw();	}
	public int getbuth()	{	return anupstd.geth();	}
	public movearrows(int x, int y)	{	grarrows.move(x,y);	}
	public build(string sfile, int z, string scursor, string sorient, int dt, string sgrelem)	{
		sgr = sgrelem;
// 		this.newanima("anupstd",sfile,z);
		new anima anupstd;
		anupstd.load(sfile);
		anupstd.setz(z);
		
		anupstd.setframe("up",0);
		this.copyanima("anupstd","anupact");
		anupact.setframe("up",1);
		this.copyanima("anupstd","andownact");
		andownact.setframe("down",1);
		this.copyanima("anupstd","andownstd");
		andownstd.setframe("down",0);
		this.newbutan("butup","anupstd","anupact",null,scursor);
		this.newbutan("butdown","andownstd","andownact",null,scursor);
		butup.addmethod("onmoveon","_rewbutmoveon");
		butdown.addmethod("onmoveon","_rewbutmoveon");
		butup.addmethod("onmoveoff","_rewstrzalkaoff");
		butdown.addmethod("onmoveoff","_rewstrzalkaoff");
		butup.addmethod("onclick","_rewbutclick");
		butdown.addmethod("onclick","_rewbutclick");
		butup.addmethod("onrel","_rewbutrel");
		butdown.addmethod("onrel","_rewbutrel");
		sorientation=sorient;
		new gmimgvec grarrows;
		_ = "grarrows" .+ "anupstd" .+ "anupact" .+ "andownact" .+ "andownstd";
		
		int dy, int dx, int ix, int iy;
		if( sorientation=="up" || sorientation=="down")	{
			bvertical = false;
			ilenx = dt;
			if( sorientation=="down")	{
				anupstd.setpos(borx1,bory2-anupstd.geth());
				anupact.setpos(borx1,bory2-anupact.geth());
				andownstd.setpos(borx2-andownstd.getw(),bory2-andownstd.geth());
				andownact.setpos(borx2-andownact.getw(),bory2-andownact.geth());
				dy = andownstd.getey();
			} else {
				anupstd.setpos(borx1,bory1);
				anupact.setpos(borx1,bory1);
				andownstd.setpos(borx2-andownstd.getw(),bory1);
				andownact.setpos(borx2-andownact.getw(),bory1);
				dy = bory1;
			}
			ibx1 = anupstd.getex()+iodleg;
			ibx2 = andownstd.getpx()-iodleg;
			dx = ibx1;
		} else {
			bvertical = true;
			ileny = dt;
			if( sorientation=="right")	{
				anupstd.setpos(borx2-anupstd.getw(),bory1);
				anupact.setpos(borx2-anupact.getw(),bory1);
				andownstd.setpos(borx2-andownstd.getw(),bory2-andownstd.geth());
				andownact.setpos(borx2-andownact.getw(),bory2-andownact.geth());
				dx = anupstd.getex();
			} else {
				anupstd.setpos(borx1,bory1);
				anupact.setpos(borx1,bory1);
				andownstd.setpos(borx1,bory2-andownstd.geth());
				andownact.setpos(borx1,bory2-andownact.geth());
				dx = borx1;
			}
			iby1 = anupstd.getey()+iodleg;
			iby2 = andownstd.getpy()-iodleg;
			dy = iby1;
		}
		butup._rewbuildbut(this.getname(),"up");
		butdown._rewbuildbut(this.getname(),"down");
		
		int ile = <sgrelem>.size();
		<sgrelem>._setpos(dx,dy);
		new int ilimx = dx;
		new int ilimy = dy;
		string s;
		for(int i=0; i<ile; i++)	{
			s = <sgr>.get(i);
			if( sorientation=="right")	{
				<s>.setpos( dx - <s>.getw() - <s>.lodx(), dy - <s>.lody() );
				dy += <s>.geth()+iodleg;
			} else if (sorientation=="left")	{
				<s>.setpos( dx - <s>.lodx(), dy - <s>.lody() );
				dy += <s>.geth()+iodleg;
			} else if (sorientation=="up")	{
				<s>.setpos( dx - <s>.lodx(), dy - <s>.lody() );
				dx += <s>.getw()+iodleg;
			} else if (sorientation=="down")	{
				<s>.setpos( dx - <s>.lodx(), dy - <s>.geth() - <s>.lody() );
				dx += <s>.getw()+iodleg;
			}
			<s>.clip(ibx1,iby1,ibx2,iby2);
		}
	}
	/*************************************/
	_rewbuildbut(string s, string s2)	{
		new string _sob = s;
		new string _sdir;
		if( s2=="up" )	{
			if(bvertical==false)	{	_sdir = "left";	}
			else {	_sdir = "up";	}
		} else if (s2=="down")	{
			if(bvertical==false)	{	_sdir = "right";	}
			else {	_sdir = "down";	}
		}
	}
	_rewbutmoveon()	{
		//this.mstrzalkaon(_sdir);
		this.<_sob+"_"+_sdir+"_MOVEON">();
	}
	_rewbutclick()	{
		this.mstrzalkaon(_sdir);
		this.<_sob+"_"+_sdir+"_CLICK">();
	}
	mstrzalkaon(string s)	{
		sarrowdir=s;
		timtick.play();
	}
	_rewbutrel	{
		sarrowdir=null;
		timtick.stop(false);
		fxrew.stop(false);
	}
	_rewstrzalkaoff()	{
		sarrowdir=null;
		timtick.stop(false);
		fxrew.stop(false);
		this.<_sob+"_"+_sdir+"_MOVEOFF">();
	}
	timfin()	{
		if( this.getlock() )	{	return;	}
		bool bok = false;
		if( sarrowdir!=null && !<sgr>.empty())	{
			if( sarrowdir=="up")	{
				if( <sgr>.getey() > andownstd.getpy() - ileny )	{
					<sgr>.move(0,-ileny);
					bok=true;
				}
			} else if (sarrowdir=="down") {
				if( <sgr>.getpy() < ilimy )	{
					<sgr>.move(0,ileny);
					bok=true;
				}
			} else if (sarrowdir=="left")	{
				if( <sgr>.getex() > andownstd.getpx() - ilenx )	{
					<sgr>.move(-ilenx,0);
					bok=true;
				}
			} else if (sarrowdir=="right") {
				if( <sgr>.getpx() < ilimx )	{
					<sgr>.move(ilenx,0);
					bok=true;
				}
			}
		}
		if( bok )	{
			if( !fxrew.isplaying() )	fxrew.play();
		} else {
			fxrew.stop(false);
		}
		this.play();
	}
}

class ConRewinder : Rewinder, ObjController {
	init()	{
		Rewinder::init();
		ObjController::init();
		new DelayTaker cldt; 
	}
	public getitem(string s, int x, int y)	{
		Rewinder::getitem(s,x,y);
		cldt.take();
	}
	_put()	{
		cldt.ret();
		this.<this + "_PUT">();
	}
	onmousemove()	{	this.moveitem();	}
	onmouselrel()	{
		if( this.getlock() )	return;
		if( cldt.isonrel() )	{	this._put();	}
	}
	onmouselclick()	{
		if( this.getlock() ) return;
		if( cldt.isonclick() )	{
			this._put();
		} else if ( !cldt.istaken() )	{
			this.<this+"_GET">();
		}
	}
}

class Button : LObjController	{
	init	{
		LObjController::init;
		.unlock;
		new gmimgvec grbuts;
		.vars2(A,"sobject", null, "sclicked",null,"bcheck2klik", 0);
		
		new int ipadclick = 0;
	}
	print		{	grbuts.print;		}
	sort		{	grbuts.sortimgs;	}
	addgroups	{	grbuts.addgroups;	grbuts.sortimgs;	}
	addgroup(string s)	{	grbuts.addgr(s);	grbuts.sortimgs;	}
	addlist		{	grbuts.addlist;		grbuts.sortimgs;	}
	add(string sob)	{	grbuts.add(sob);	grbuts.sortimgs;	}
	addonce(string sob)	{ grbuts.addonce(sob);	grbuts.sortimgs;	}
	addlocker(string sob)	{
		.add(sob);
		classlocker::setaslocker(sob);
	}
	removebutlist	{	.withlist("removebut"); }
	removebut(string sbut)	{
		grbuts.remove(sbut);
		if( sbut==sobject ) sobject=null;
		if( sbut==sclicked ) sclicked = null;
	}
	load(string sname, string sfile, string sfuninit) {
		<GAME>.varnew("gmimgvec", sname);
		sname .* sfile;
		<sname>.each( sfuninit );
		.addgroup(sname);
	}
	remove(string sname)	{
		if( <GAME>.hasvar(sname) )	{
			//for( int i=0; i < <sname>.size; i++ )	grbuts.remove( <sname>.get(i) );
			grbuts.removegr(sname);
		}
	}
	loadfrom(string sname, string spath, string sfile, string sfuninit) {
		@s = .getgraphpath;
		.setgraphpath(spath);
		.load(sname,sfile,sfuninit);
		.setgraphpath(s);
	}
	onmouselclick	{
		if( .getlock ) return;
		
		if( .checktouchpad && bcheck2klik )	{
			if( ipadclick )	{
				@s = sobject;
				//.onmousemove;
				if( s==sobject )	{
					ipadclick=0;
					._butmouselclick;
				} else if ( sobject==null )	{
					ipadclick=0;
				}
			} else {
				ipadclick=1;
				//.onmousemove;
			}
		} else {
			._butmouselclick;
		}
	}
	_butmouselclick	{
		.<this + "_lclick">;
		if( sobject!=null)	{
			sclicked = sobject;
			if (<sobject>.hasaddedmet("butclick") )
				<sobject>.butclick;
		}
	}
	onmouselrel	{
		if( .getlock ) return;
		if( .checktouchpad )	{
			.lastoff;
		}
		.<this + "_lrel">;
		if( sclicked!=null && <sclicked>.hasaddedmet("butlrel") )	{
			<sclicked>.butlrel;
		} else sclicked=null;
	}
	onmousemove	{
		if( .getlock ) return;
		if( sclicked!=null )	{
			if( <sclicked>.hasaddedmet("butmoving") )	<sclicked>.butmoving;
		}
		|int x, int y| = mouse.getpos;
		if(grbuts.isinfunc(x,y,"isbutin") )	{
			@s = grbuts.getsfound;
			if( s!=sobject )	{
				.lastoff;
				sobject = s;
				.<this + "_moveon">;
 				if( <s>.hasaddedmet("butmoveon") )
					<s>.butmoveon;
			}
		} else {
			.lastoff;
		}
	}
	lastoff	{
		if( sobject!=null )	{
			.<this + "_moveoff">;
			if( <sobject>.hasaddedmet("butmoveoff") )
				<sobject>.butmoveoff;
			sobject = null;
		}
	}
	/*
	virtual bool isbutin(int x, int y)	{ 0; }
	virtual butclick	{}
	virtual butmoveon {}
	virtual butmoveoff {}*/
}
new snd sndfxmoveonms;
sndfxmoveonms.load("sounds/sfx/butmoveon2.ogg");
sndfxmoveonms.setvol(50);
public Button_isin		{	.addmethod("isbutin", func { (@x,@y) .isin(x,y,1,0); } );	}
public Button_isinvis		{	.addmethod("isbutin", func { (@x,@y) .isin(x,y,0,0); } );	}
public Button_isinalpha		{	.addmethod("isbutin", func { (@x,@y) .isin(x,y,1,1); } );	}
public Button_isinvisalpha	{	.addmethod("isbutin", func { (@x,@y) .isin(x,y,0,1); } );	}
public Button_moveon		{
	.addmethod("butmoveon", func {
		sndakskermovon.playif;
		advmouse.setbut;
		if( .nofframes(-1)>1 ) .setframe(-1,1);
	} );
}
public Button_moveonplay		{
	.addmethod("butmoveon", func {
		sndakskermovon.play;
		advmouse.setbut;
		if( .isplaying(-1)==false ) .play(-1);
	} );
}
public Button_moveoff		{	.addmethod("butmoveoff", func { advmouse.setstd; .setframe(-1,0);} );	}
public Button_moveonms		{	.addmethod("butmoveon", func { advmouse.setbut; } );			}
public Button_moveonfxms	{	.addmethod("butmoveon", func { advmouse.setbut; sndfxmoveonms.playif; } );			}
public Button_moveoffms		{	.addmethod("butmoveoff", func { advmouse.setstd; } );			}
public Button_std		{	.Button_isin; .Button_moveon; .Button_moveoff;				}
public Button_stdalpha		{	.Button_isinalpha; .Button_moveon; .Button_moveoff;			}
public Button_stdms		{	.Button_isinalpha; .Button_moveonms; .Button_moveoffms;			}

class Buttons : LObjController	{
	init(string sfile)	{
		LObjController::init;
		.unlock;
		new gmimgvec grbuts;
		new int __id = 0;
		new string sanbut = "anbut";
		.newanima(sanbut, sfile, 10);
		_ = .newanactionsgr(sanbut, sanbut, "grbuts");
		anbut.hide;
		grbuts.setz(10);
		grbuts.removeif( func {
			if( .actionname=="bkg" ) { .setz( .getz-1); true; }
			else false; 
			});
		new string slastb = null;
		.vars2(A,"sobject", null, "bvisible", true, "balpha", true);
		
		new int ipadclick = 0;
		.var2("bcheck2klik", false);
	}
	_release()	{
		if( .checktouchpad )	{
			ipadclick = 0;
		}
		<slastb>.setframe(-1,0);
		.copyobj;
		.<this + "_moveoff">();
		slastb = null;
		//bsms.setstd;
		advmouse.setstd;
	}
	getbut	{	grbuts.getsfound;	}
	onmousemove()	{
		if( .getlock ) return;
		grbuts.setframe(-1,0);
		def id =  grbuts.isin(mouse.getpos,bvisible,balpha);
		if( slastb!=null ) <slastb>.setframe(-1, 1);
		if( id ) {
			string s = grbuts.getsfound;
			if( s!=slastb )	{
				if( slastb!=null )	._release;
				slastb = s;
				<s>.setframe(-1,1);
				.copyobj;
				//bsms.setact;
				advmouse.setact;
				.<this + "_moveon">();
			}
		} else if( slastb!=null )	{
			._release;
		}
		//slastb==null ? bsms.setstd : bsms.setact;
	}
	copyobj()	{	sobject = <slastb>.actionname;	}
	onmouselclick()	{
		if( .getlock ) return;
		
		if( .checktouchpad && bcheck2klik )	{
			if( ipadclick )	{
				ipadclick=0;
				._butmouselclick;
			} else {
				ipadclick=1;
				.onmousemove;
			}
		} else {
			._butmouselclick;
		}
	}
	_butmouselclick	{
		if( slastb!=null )	{
			.copyobj;
			.<this + "_lclick">;
		}
	}
	onmouselrel	{
		if( .getlock ) return;
		if( slastb!=null )	{
			.copyobj;
			.<this + "_lrel">;
		}
	}
	disable	{
		.lock;
		grbuts.hide;
		if( slastb!=null )	{
			//bsms.setstd;
			advmouse.setstd;
			slastb=null;
		}
	}
	enable	{
		.unlock;
		grbuts.show;
	}
}

class TextDb : classlocker, ObjController, gfxObject {
	init(string sfont, int isize, string sdbfile, int r, int g, int b, int x, int y, int dy, int z, string sdir)	{
		classlocker::init;
		ObjController::init;
		new string sFont = sfont;
		new string sFontBold = null;
		new string sFontItalic = null;
		new string sFontBoldItalic = null;
		new bool bhtml = false;
		
		string s;
		int id, int i;
		if( sfont.contains("$") )	{
			bhtml = true;
			new vector vfont; vfont.type("string");
			vfont.vecbuildfromstring( sfont, "$" );
			
			for( i=0; i<vfont.size; i++)	{
				s = vfont.get(i);
				if( s.contains("_italic") && s.contains("_bold") )	{
					sFontBoldItalic = s;
				} else if ( s.contains("_italic") )	{
					sFontItalic = s;
				} else if ( s.contains("_bold") )	{
					sFontBold = s;
				} else sFont = s;
			}
			if( sFont.contains("$") )	{
				if( sFontItalic!=null ) sFont = sFontItalic;
				else if( sFontBold!=null ) sFont = sFontBold;
				else sFont = sFontBoldItalic;
			}
			sfont = sFont;
		} else sfont = .checkfont( sfont, isize );
		new int iFontSize = isize;
		
		.var2("Z",z);
		string skey = null;
		if( sdbfile.contains(":") )	{
			skey = sdbfile.strgetto(":") + ":";
		}
		if( sdbfile.contains(".db") )	{
			if( skey =="$path:" )	{
				new db dbtxt;
				dbtxt.load( sdbfile.strsubbs(skey) );
			} else .newdb( "dbtxt", sdbfile );
		} else {
			match(skey)	{
				"$lang:" => .lang_db("dbtxt", sdbfile.strsubbs(skey) );
				"$var:" => {
					new db dbtxt;
					dbtxt.dbcopy( sdbfile.strsubbs(skey) );
				}
				"$row:" => {
					new db dbtxt;
					s = sdbfile.strsubbs(skey)->strgetto(",");
					id = sdbfile.strgetfrom(",");
					for( i=0; i< <s>.getcolsno(id); i++)	{
						_ = dbtxt.addrow;
						dbtxt.add(i, <s>.get(id,i) );
					}
				}
				? => {
					new db dbtxt;
					dbtxt.dbaddlast( sdbfile );
				}
			}
		}
		int w = 0, int ile = dbtxt.getrowsno;
		
		if( sdir.getb(0,5)=="limit" )	{
			int lim = sdir.strsubbs("limit_");
			new vector vtmp; vtmp.type("string");
			new vector vtmp2; vtmp2.type("string");
			for( int i=0; i<dbtxt.getrowsno; i++)	{
				vtmp.vecbuildfromstring( dbtxt.get(i,0), " " );
				for( int j=0; j<vtmp.size; j++)
					vtmp2.add(vtmp.get(j));
			}
			dbtxt.free;
			string s = "";
			string s2;
			for( i=0; i<vtmp2.size; i++)	{
				s2 = vtmp2.get(i);
				if( (s+s2)->length < lim )	{
					s += s2 + " ";
				} else {
					j = dbtxt.addrow-1;
					dbtxt.add(j, s);
					s = s2 + " ";
				}
			}
			j = dbtxt.addrow-1;
			dbtxt.add(j, s);
			ile = dbtxt.getrowsno;
		}
		
		new gmimgvec grtxt;
		grtxt._setpos(x,y);
		for( i=0; i< ile; i++)	{
			s = "txt" + i;
			new text <s>;
			@s1 = dbtxt.get(i,0);
			if( bhtml )	{
				if( s1.contains("<b>") ) { sfont = sFontBold; s1.strremove("<b>"); }
				else if( s1.contains("<bi>") ) { sfont = sFontBoldItalic; s1.strremove("<bi>"); }
				else if( s1.contains("<i>") ) { sfont = sFontItalic; s1.strremove("<i>"); }
				else sfont = sFont;
			}
			<s>.setfont( sfont );
			
			<s>.set( s1 );
			<s>.setpos(x,y);
			y+=isize+dy;
			<s>.setz(z);
			<s>.createtxt(r,g,b);
			if( <s>.getw>w ) w = <s>.getw;
			grtxt.add(s);
		}
		.var2("Rows", ile);
		if( sdir == "right" || sdir =="center" )	{
			for( i=0; i<ile; i++)	{
				s = "txt" + i;
				if( sdir == "center" )	{
					<s>.move( (w-<s>.getw)/2, 0 );
				} else {
					<s>.move( w-<s>.getw, 0 );
				}
			}
		}
		.var2("W", w);
		gfxObject::init("grtxt");
	}
	stdshadow(int dt)	{	.setshadow(0,0,0,dt);	}
	setshadow(int r, int g, int b, int dt)	{
		string s[2];
		string sfont = ._checkfont(sFont, iFontSize, "_fntbrd");
		for( int i=0; i< dbtxt.getrowsno; i++)	{
			s0 = "txt" + i;
			s1 = "txts" + i;
			new text <s1>;
			<s1>.set( <s0>.get );
			<s1>.setfont( sfont );
			<s1>.setz( <s0>.getz-1 );
			<s1>.setpos( <s0>.getpx+dt, <s0>.getpy+dt );
			<s1>.createtxt(r,g,b);
			grtxt.add(s1);
		}
	}
	setz(int z)	{
		/*for( int i=0; i< dbtxt.getrowsno; i++)	{
			<"txt" + i>.setz(z);
			<"txts" + i>.setz(z-1);
		}*/
		Z = z;
		grtxt.setz(z);
	}
	getz	{ Z;	}
	isin(int x, int y, bool bv, bool ba)	{	grtxt.isin(x,y,bv,ba);	}
	view	{
		@s = _;
		string s2;
		while(A!=s)	{
			s2 = grtxt.get(s);
			<s2>.show;
			s2 = "txts" + s2.strsubbs("txt");
			if( engine.varexist(s2) ) <s2>.show;
			@s=_;
		}
	}
	blitto(string simg)	{
		string s;
		for( int i=0; i<grtxt.size; i++)	{
			s = grtxt.get(i);
			<s>.buildfullname;
			<simg>.blit(<s>.getfullname);
			<GAME>.vardel(<s>.getfullname);
		}
	}
	setcol(int r, int g, int b)	{
		for( int i=0; i<grtxt.size; i++) <grtxt.get(i)>.createtxt(r,g,b);
	}
	clip(int x1, int y1, int x2, int y2)	{
		for( int i=0; i<grtxt.size; i++) <grtxt.get(i)>.clip(x1,y1,x2,y2);
	}
	setpos(int x, int y)	{
		@dx = x-grtxt.getposx;
		@dy = y-grtxt.getposy;
		grtxt.move(dx, dy);
		//for( int i=0; i<grtxt.size; i++) <grtxt.get(i)>.setpos(x+,y1,x2,y2);
	}
}

class Lexer	{
	init	{}
	buildlex	{
		.vars(A,"id","found");
		new vector vconsts;
		vconsts.type("string");
		new vector vtmp1;
		vtmp1.type("string");
		new vector vtmp2;
		vtmp2.type("string");
		
		new int dot = "."->getbyte(0);
		new string _literal_char = "\"";
	}
	setliteralchar(string s)	{	_literal_char=s;	}
	getliteralchar	{	_literal_char;	}
	bool _isvar(int b1, int b2)	{
		int i = id;
		found = "";
		int ib;
		while(i<.length)	{
			ib = .getbyte(i);
			if( ib>=b1 && ib<=b2 )	{
				found += .getb(i,1);
				i++;
			} else {
				if( (ib>=BYTEa && ib<=BYTEz) || (ib>=BYTEA && ib<=BYTEZ) || ib==BYTE_ )	found="";
				i = .length;
			}
		}
		found.length;
	}
	bool isreal	{
		int i = id;
		found = "";
		int ib;
		bool kropka=true;
		while(i<.length)	{
			ib = .getbyte(i);
			if( (ib>=BYTE0 && ib<=BYTE9) || (ib==dot&&kropka) )	{
				if( ib==dot ) kropka=false;
				found += .getb(i,1);
				i++;
			} else i = .length;
		}
		if( kropka || found.getb(0,1)=="." || found.gete(0,1)=="." ) found="";
		found.length;
	}
	bool isident	{
		int i = id;
		found = "";
		int ib;
		while(i<.length)	{
			ib = .getbyte(i);
			if( (ib>=BYTEa && ib<=BYTEz) || (ib>=BYTEA && ib<=BYTEZ) || ib==BYTE_ ||
				(i>id && ib>=BYTE0 && ib<=BYTE9) )	{
				found += .getb(i,1);
				i++;
			} else i = .length;
		}
		found.length;
	}
	bool isliteral	{
		if( .check!=.getliteralchar )	return false;
		int i = id+1;
		found = "";
		string s;
		while(i<.length)	{
			s = .getb(i,1);
			if( s==.getliteralchar )	{
				//found += s;
				return true;
			} else {
				found += s;
				i++;
			}
		}
		false;
	}
	bool isconst	{
		string s0;
		bool b = .isident;
		for( int i=0; i< vconsts.size; i++)	{
			s0 = vconsts.get(i);
			if( b )	{
				if( s0 == found )	return true;
			} else {
				found = .getb(id, s0.length);
				if( s0 == found ) return true;
			}
		}
		false;
	}
	gettoken(string svec, bool bideal)	{
		<svec>.free;
		while( .notend )	{
			if (.check==" ")	id++;
			else if (.isconst)	{	<svec>.add("$const"); <svec>.add(.read);	}
			else if (.isreal )		{<svec>.add( "$real" );	.next; if( bideal ) <svec>.add( found );}
			else if (.isint )		{<svec>.add( "$int" );	.next; if( bideal ) <svec>.add( found );}
			else if (.isident )	{<svec>.add( "$alpha" );	.next; if( bideal ) <svec>.add( found );}
			else if (.isliteral )	{<svec>.add( "$literal" );	.next; id+=2; if( bideal ) <svec>.add( found );}
			else	{<svec>.add("$error"); id++; }
		}
	}
	int expectdb(string sdb, bool bideal)	{	// identyczne lub parse
		int j, string s;
		for( int i=0; i< <sdb>.getrowsno; i++)	{
			//vtmp2.veccopydbrow(sdb,i);
			vtmp2.free;
			for( j=0; j< <sdb>.getcolsno(i); j++)	{
				s = <sdb>.get(i,j);
				s.clear;
				if( s!="" ) vtmp2.add(s);
			}
			if( .expectvec("vtmp2", bideal) )	return i;
		}
		-1;
	}
	bool expectvec(string svecsrc, bool bideal)	{
		id = 0;
		.gettoken("vtmp1", bideal);
		/*vtmp1.print;
		<svecsrc>.print;*/
		vtmp1.veceq(svecsrc);
		/*bool b = vtmp1.veceq(svecsrc);
		if( !b ) {
			("wrong expect "+.get)->print;
			vtmp1.print;
			<svecsrc>.print;
		}
		b;*/
	}
	bool expects(string s, string ssep, bool bideal)	{
		vtmp2.vecbuildfromstring(s,ssep);
		.expectvec("vtmp2", bideal);
	}
	consts=	{	vconsts.withlist("addbegin");	}
	setas(string sob)	{
		<sob>.addmethod("buildlex", "buildlex");
		<sob>.buildlex;
		<sob>.addmethod("start",	func { (string s) .set(s);	id=0; } );
		<sob>.addmethod("notend",	func {	id<.length;	} );
		<sob>.addmethod("getnext",	func { if( id==.length ) return null;
					id++;	.getb(id-1,1);	} );
		<sob>.addmethod("next",	func { id+=found.length;	} );
		<sob>.addmethod("check",	func { if( id==.length ) return null; found=.getb(id,1); found; });
		<sob>.addmethod("ischar",	func { (string s) s.contains( .getb(id,1) ); } );
		<sob>.addmethod("isint",	func{	._isvar(BYTE0, BYTE9);	} );
		<sob>.addmethod("isreal", "isreal");
		<sob>.addmethod("isbinary",	func{	._isvar(BYTE0, BYTE0+1);	} );
		<sob>.addmethod("isident",	"isident" );
		<sob>.addmethod("isconst",	"isconst" );
		<sob>.addmethod("_isvar", "_isvar");
		<sob>.addmethod("read",	func { .next;	found;	} );
		<sob>.addmethod("isliteral", "isliteral");
		<sob>.addmethod("gettoken", "gettoken");
		<sob>.addmethod("expects", "expects");
		<sob>.addmethod("expectvec", "expectvec");
		<sob>.addmethod("expectdb", "expectdb");
		<sob>.addmethod("consts=", "consts=");
		<sob>.addmethod("setliteralchar", "setliteralchar");
		<sob>.addmethod("getliteralchar", "getliteralchar");
	}
}


class AnimaFx	{
	init {}
	build(string san)	{
		<san>.addmethod("_buildanfx", func {
			new db dbsnd;
			dbsnd.dbbuild(3);
			for( int i=0; i<dbsnd.getrowsno; i++) dbsnd.set(i,0, dbsnd.get(i,0)+"_"+dbsnd.get(i,1));
			} );
		<san>._buildanfx;
		<san>.addmethod("onsetframe", func {
			@id = dbsnd.findbyrow(.actionname+"_"+.framenr);
			if( id>=0 ) {
				<"fx"+dbsnd.get(id,2)>.play;
			}
			} );
	}
}

class Localize	{
	init	{}
	_lang_db(string sname, string sfile, string sfunload)	{
		new db <sname>;
		<sname>.<"load"+sfunload>( .lang_path(sfile) + ".db");
	}
	lang_db(string sname, string sfile)	{ ._lang_db(sname,sfile,"");	}
	lang_dbscript(string sname, string sfile)	{ ._lang_db(sname,sfile,"script");	}
	lang_dbbeh(string sname, string sfile)	{ ._lang_db(sname,sfile,"beh");	}
	lang_path(string sfile)	{ LANGDIR + gameapi.getgamename + "_" + sfile + LANG; }
}

class PyzCounter	{
	init(string sanima, int timestep)	{
		new int istart;
		new int istop;
		new int istep;
		new int idigits = 50;
		new int iactual;
		new string _sanima = sanima;
		.vars2(A, "idx",2, "itimestep", timestep);
		
		new gmimgvec grcnt;
		for( int i=0; i<idigits; i++ )	{
			string s = "pcc" + sanima + i;
			.copyanima(sanima, s);
			<s>.hide;
			grcnt.add(s);
		}
		.timer = ("timcnt", timestep, func {
			iactual += istep;
			.view(iactual);
			if( iactual==istop )	{
				<.getbuildername>.<.getbuildername+"_finish">;
			} else .play;
			} );
	}
	getcypher(int id)	{	"pcc" + _sanima + id;	}
	start(int start, int stop, int step)	{
		istart = start;
		istop = stop;
		istep = step;
		iactual = istart;
		.view(istart);
		timcnt.play;
	}
	showcypher(int i, int cypher)	{
		string s = .getcypher(i);
		<s>.setframe(0, cypher);
		<s>.show;
	}
	stop	{
		timcnt.stop(false);
	}
	view(int cnt)	{
		grcnt.hide;
		grcnt.setpos(0,0);
		if( cnt==0 )	{
			.showcypher(0,0);
		} else {
			for( int i=0; cnt > 0; i++ )	{
				.showcypher(i, cnt%10);
				cnt=cnt/10;
			}
			int w = 0;
			for( int j=i-1; j>=0; j-- )	{
				<.getcypher(j)>.move( w, 0 );
				w = w + <.getcypher(j+1)>.getw;
			}
		}
	}
}
/*************************************************************************/

class AnMover	{
	init(string san, real x, real y)	{
		new timer tmov;
		tmov.settick(1);
		tmov.setcycle(1);
		//new real rdx = x;
		//new real rdy = y;
		.vars2(A, "rdx", x, "rdy", y);
		new real rsx = 0;
		new real rsy = 0;
		new string sanima = san;
		tmov.addmethod("onfinish", func {
			.move;
			.builder_func("_finish");
			.play;
			} );
	}
	move	{
		rsx += rdx;
		rsy +=rdy;
		int x = rsx;
		int y = rsy;
		if( x || y ) {
			<sanima>.move(x,y);
			rsx-=x;
			rsy-=y;
		}
	}
	reset	{
		rsx=0;
		rsy=0;
	}
	play	{
		.reset;
		tmov.play;
	}
	stop	{	tmov.stop(false);	}
}

public SetAnMover_tmov_onfinish	{	<.getbuildername>.sam_move; .play;	}
class SetAnMover	{
	init	{}
	setas(string sanima, real x, real y)	{
		<sanima>.addmethod("setanmover", "setanmover");
		<sanima>.setanmover(x,y);
		<sanima>.addmethod("sam_move", "sam_move");
		<sanima>.addmethod("sam_copy", "sam_copy");
		<sanima>.addmethod("sam_addtimer", func {
			new timer tmov;
			tmov.settick(1);
			tmov.setcycle(1);
			tmov.addmethod("onfinish", "SetAnMover_tmov_onfinish" );
			} );
		<sanima>.addmethod("sam_playtimer", func { tmov.play; }		);
		<sanima>.addmethod("sam_stoptimer", func { tmov.stop(false); }	);
	}
	setanmover(real x, real y)	{
		new real rdx = x;
		new real rdy = y;
		new real rsx = 0;
		new real rsy = 0;
		.var2("sam_speed", 1.0);
	}
	sam_move	{
		rsx += (rdx*sam_speed);
		rsy += (rdy*sam_speed);
		int x = rsx;
		int y = rsy;
		if( x || y ) {
			.move(x,y);
			rsx-=x;
			rsy-=y;
			if( .hasvar("ansamcopy") )	{
				ansamcopy.move(x,y);
				if( rdx>0 )	{
					if( ansamcopy.getpx > rollerx )	{
						@dx = ansamcopy.getpx -.getw;
						ansamcopy.move( dx, 0 );
						.move( dx, 0 );
					}
				}
			}
		}
	}
	sam_copy	{
		.vars2(A, "rollerx", 0, "rollerex", iResX);
		.copyanima(this, "ansamcopy");
		ansamcopy.show;
		if( rdx>0 )	{
			ansamcopy.ansetbpos( .getpx - .getw, .getpy );
			//("act: "+.actionname + ","+ansamcopy.actionname + " z: "+.getz+","+ansamcopy.getz+" x: "+.getpx+","+ansamcopy.getpx)->print;
		}
	}
}

/*************************************************************************/
class classlives	{
	init()	{}
	set(int ile, int idamage, int x, int y, int h, int r1, int g1, int b1, int a1, int r2, int g2, int b2, int a2, int z, string sside)	{
		new int iside;
		
		if( sside=="left")iside=-1;
		else	iside=1;
		
		new int iilezyc = ile;
		new int ibum	= idamage;
		int idl = iilezyc*ibum;
		new int iposxsila = x;
		new int iendxsila = x+idl;
		new int iposysila = y;
		newvars::newcanvas( "imgsilapodkladka",idl, h, r1, g1, b1, a1, z-1 );
		newvars::newcanvas( "imgsila",idl, h, r2, g2, b2, a2, z );
		imgsila.setpos( iposxsila, iposysila );
		imgsila.clip(iposxsila, 0,  imgsila.getex(), 600);
		imgsilapodkladka.setpos( iposxsila, iposysila );
	}
	reset()	{
		imgsila.setpos( iposxsila, iposysila );
	}
	damage(int idam)	{
		imgsila.move( iside*idam*ibum, 0);
	}
	int destroyed()	{
		if( iside<0)	return imgsila.getex() < iposxsila;
		return imgsila.getpx() > iendxsila;
	}
	heal(int idam)	{
		imgsila.move( -iside*idam*ibum, 0 );
		if( iside > 0 )	{
			if( imgsila.getpx() < iposxsila )	{
				imgsila.setpos( iposxsila, iposysila );
			}
		} else {
			if( imgsila.getpx() > iposxsila )	{
				imgsila.setpos( iposxsila, iposysila );
			}
		}
	}
}


class imganima : gmimgvec	{
	init	{
		gmimgvec::init;
		new int idgran = 0;
		new timer timan;
		timan.settick(1);
		timan.addmethod("onfinish", func {
			idgran++;
			@s = .getbuildername;
			if( idgran == <s>.size )	{
				<s>.<s+"_finish">;
			} else {
				.setframe(idgran);
				<s>.<s+"_endframe">;
				.play;
			}
			} );
	}
	load(string simg, string sfiletype, int istart, int istop, int icycle)	{
		timan.setcycle(icycle);
		for( int i=istart; i<istop; i++)	{
			@s = simg + i;
			.newimg("an" + s, s + "." + sfiletype, 0);
			.add("an" + s);
		}
		.setframe(0);
	}
	play	{
		.setframe(0);
		timan.play;
	}
	setframe(int id)	{
		.hide;
		idgran = id;
		<.get(id)>.show;
	}
}


class GuiItem	{
	init	{}
	/****************** rotujacy obiekt **************************/
	setasrototaker(string sanima, real ilerot, real ileobrotow)	{
		<sanima>.addmethod("_setasrototaker", func { (@ilerot, @ileobrotow)
			.vars2(A, "ilerotos",ilerot, "idrotos", 0.0, "ikatos", (ileobrotow*360.0)/ilerot,
				"rzoomx", 0.0, "rzoomy", 0.0, "rzoomstepx", 0.0, "rzoomstepy", 0.0,
				"rmovx", 0.0, "rmovy", 0.0, "istartalfa", 128,
				"iendx", 0.0, "iendy", 0.0,
				"irotodir", 1, "izoomdir", 0);
			new filter ftroto;
			ftroto.setpivottype(2);
			
			new timer timrotocenter;
			timrotocenter.setcycle(1);
			timrotocenter.addmethod("onfinish", func {
				if( <.getbuildername>.rototaker_setroto )
					.play;
				} );
			//SetAnMover::setas(this, 0.0, 0.0);
			} );
		<sanima>._setasrototaker(ilerot, ileobrotow);
		<sanima>.addmethod("rototaker_start", "rototaker_start");
		<sanima>.addmethod("rototaker_startwh", "rototaker_startwh");
		<sanima>.addmethod("rototaker_startact", "rototaker_startact");
		<sanima>.addmethod("rototaker_setroto", "rototaker_setroto");
		<sanima>.addmethod("rototaker_endroto", func { .<"rototaker_"+ this + "_endroto">; } );	// std funkcja, mozna podmienic
	}
	bool rototaker_setroto	{
		if( izoomdir )	{
			@r = idrotos/ilerotos;
			@rx = rzoomx + rzoomstepx*r;
			@ry = rzoomy + rzoomstepy*r;
			ftroto.rotatezoomxy( irotodir*ikatos, rx, ry );
		} else {
			@r = (ilerotos-idrotos);
			@rx = rzoomx + rzoomstepx*r;
			@ry = rzoomy + rzoomstepy*r;
			ftroto.rotatezoomxy( irotodir*ikatos, rx, ry );
			r = idrotos/ilerotos;
		}
		if( istartalfa<255 )	{
			real iop = istartalfa;
			ftroto.setopacity( iop + (255.0-iop) * r );
		}
		//.move(rmovx, rmovy);
		real r1 = (iendx - .getposx) * r * rx;
		real r2 = (iendy - .getposy) * r * ry;
		.move(r1, r2);
		idrotos++;
		if( idrotos<ilerotos ) true;
		else {
			ftroto.unlink;
			.rototaker_endroto;
			false;
		}
	}
	rototaker_startact(int endx, int endy, string sact)	{
		.rototaker_start( .getpx, .getpy, endx, endy, .getw, .geth, sact );
	}
	rototaker_start(int startx, int starty, int endx, int endy, real startw, real starth, string sact)	{
		.setframe(sact,0);
		.setpos(startx,starty);
		.rototaker_startwh(endx, endy, startw, starth, .getw, .geth);
	}
	rototaker_startwh(int endx, int endy, real startw, real starth, real endw, real endh)	{
		
		iendx = endx;
		iendy = endy;
		rmovx = ( endx-.getcx)->to_r/ilerotos;
		rmovy = ( endy-.getcy)->to_r/ilerotos;
		
		if( endw>startw )	{
			rzoomx = startw/endw;
			rzoomstepx = (endw-startw)/endw;
			izoomdir=1;
		} else {
			izoomdir=0;
			rzoomx = endw/startw;
			rzoomstepx = (1.0-rzoomx)/ilerotos;
		}
		if( endh > starth )	{
			rzoomy = starth/endh;
			rzoomstepy = (endh-starth)/endh;
		} else {
			rzoomy = endh/starth;
			rzoomstepy = (1.0-rzoomy)/ilerotos;
		}
		
		ftroto.link(this);
		
		idrotos = 0;
		if( .rototaker_setroto )
			timrotocenter.play;
	}
	/****************** rotujacy obiekt **************************/
}


class CalcFPS	{
	init	{
		new real rfps1;
		new real rfps2;
		new real rfps3;
		new real rsec = 1000.0;
		new real rstart = 1.0;
		.cycle = ("tickfps", func {	<.getbuildername>.tick; .play;	});
	}
	stdset(int size, int posx, int posy)	{	.set(.stdfont(size), .white, posx, posy, 1000);	}
	set(string sfont, int r, int g, int b, int posx, int posy, int z)	{
		.newtext("txtfps", 0, sfont, r,g,b);
		txtfps.setz(z);
		.setpos(posx,posy);
	}
	setpos(int x, int y)	{ txtfps.setpos(x,y);	}
	tick	{
		real rstop = engine.getticks;
		if( rstop>rstart )	{
			rfps1 = rfps2;
			rfps2 = rfps3;
			rfps3 = rsec/(rstop-rstart);
			//txtfps.txtset( rsec/(rstop-rstart) );
			txtfps.txtset( "delay: "+(rstop-rstart)+ " fps: "+ (rfps1+rfps2+rfps3)/3);
		} else txtfps.txtset( "inf" );
		rstart = rstop;
	}
	play	{	tickfps.play;	}
	stop	{	tickfps.stop(false);	}
}

class Film : gfxObject	{
	init	{
		new img imfilm;
		imfilm.buildfullname;
		gfxObject::init("imfilm");
		
		new string sfilmpath;
		new db dbfilm;
		new db dbfilm2;
		
		new int istartklatka;
		new int iklatka;
		new int iendklatka;
		new string sprefilm;
		new int ifilmcycle; 
		new string smusic;
		
		new int igameloopdelay = igmdelay;
		
		new gmobjvec grsfx;
		new gmimgvec grbuf;
		
		.vars2(A, "bcenter", 0, "bborders", 0, "musicclass", null, "bbuffer", 0, "sfileformat", "jpg" );
		
		.cycle = ("timfilm", func {
			.nextframe;
			if( iklatka<=iendklatka )	{
				timfilm.play;
			} else {
				.retfps;
				@s = .getbuildername;
				if( <s>.hasaddedmet("onfinish") )	{
					<s>.onfinish;
				}
			}
			} );
	}
	bufferfilm	{
		
	}
	retfps	{	engine.setloopdelay(igameloopdelay);	}
	setfilmfps	{
		igameloopdelay = engine.getloopdelay;
		int ifps = dbfilm.dbgetint("fps:");
		if( ifps>0 )
			engine.setfps(ifps);
	}
	setcycle(int icycle)	{
		timfilm.setcycle(icycle);
		ifilmcycle=icycle;
	}
	nextframe	{
		.loadframe;
		iklatka++;
	}
	loadframe	{
		@id = dbfilm.findbyrow(iklatka);
		if( id>=0 )	{
			for( int i=1; i<dbfilm.getcolsno(id); i++)	{
				match( dbfilm.get(id,i) )	{
					"fadeout:" => {
						i++;
						if( musicclass!=null )
							<musicclass>.fadeout( dbfilm.get(id,i) );
					}
					? => {
						@s = dbfilm.get(id,i);
						<s>.setvol( dbfilm.<"volume_"+id+"_"+i> );
						<s>.play;
					}
				}
			}
		}
		@z = imfilm.getz;
		@x = imfilm.getpx;
		@y = imfilm.getpy;
		if( bbuffer )	{
			@s = grbuf.get(iklatka-istartklatka);
			<s>.createfrombuffer;
			imfilm.copy(s);
			<s>.hide;
			imfilm.show;
			if( iklatka>istartklatka )	{
				<grbuf.get(iklatka-istartklatka-1)>.free;
			}
		} else {
			imfilm.load( sfilmpath + sprefilm +iklatka+"."+sfileformat );
			imfilm.show;
		}
		imfilm.setz(z);
		if( bcenter )	imfilm.setpos( (igmappw-imfilm.getw)/2, (igmapph-imfilm.geth)/2 );
		else imfilm.setpos(x,y);
	}
	playfilm(string spath, string sdbfile)	{
		.load(spath, sdbfile);
		.play;
	}
	load(string spath, string sdbfile)	{
		if( .isplaying ) .free;
		sfilmpath = spath;
		
		dbfilm.load( spath + sdbfile + ".db" );
		
		istartklatka = dbfilm.dbgetint("start:");
		iklatka = istartklatka;
		iendklatka = dbfilm.dbgetint("end:");
		sprefilm = dbfilm.dbget("prefix:");
		smusic = dbfilm.dbget("music:");
		@id = dbfilm.findbyrow("format:");
		if( id>=0 ) sfileformat = dbfilm.get(id,1);
		
		bbuffer = dbfilm.dbgetint("buffer:");
		if( bbuffer )	{
			for( int i=istartklatka; i<=iendklatka; i++)	{
				@s = "imbuf"+i;
				new img <s>;
				<s>.loadbuffer( sfilmpath + sprefilm +i+"."+sfileformat );
				grbuf.add(s);
			}
		}
		
		for( int i=0; i<dbfilm.getrowsno; i++)	{
			@s = dbfilm.get(i,0);
			if( StringChecker::isdigit(s) )	{
				for( int j=1; j<dbfilm.getcolsno(i); j++)	{
					@s2 = dbfilm.get(i,j);
					match( s2 )	{
						"fadeout:" => {
							j++;
						}
						? => {
							s = "fx" + s2.strgetto(" ");
							int vol = 100;
							if( !.hasvar(s) )	{
								.sfx = (s2);
							} else if ( s2.contains(" ") )
								vol = s2.strgetfrom(" ");
							dbfilm.var2("volume_"+i+"_"+j, vol);
							dbfilm.set(i,j, s );
							grsfx.addonce(s);
						}
					}
				}
			}
		}
	}
	play	{
		iklatka = istartklatka;
		.nextframe;
		if( bborders && !.hasvar("imramkaup"))	{
			new img imramkaup;
			new img imramkadown;
			new img imramkaleft;
			new img imramkaright;
			int dh = 0.5 + (igmapph-imfilm.geth)->to_r/2.0;
			@z = .getz - 1;
			if( dh > 0 )	{
				imramkaup.create(igmappw, dh, .black, 255);
				imramkaup.setz(z);
				
				//imramkadown.create(igmappw, dh, .black, 255);
				imramkadown.copy("imramkaup");
				imramkadown.setpos(0, igmapph-dh);
			}
			int dw = 0.5 + (igmappw-imfilm.getw)->to_r/2.0;
			if( dw > 0 )	{
				imramkaleft.create(dw, igmapph, .black, 255);
				imramkaleft.setz(z);
				
				imramkaright.copy("imramkaleft");
				imramkaright.setpos( igmappw-dw, 0 );
			}
		}
		if( smusic!=null && musicclass!=null )	{
			<musicclass>.playstr(smusic);
		}
		.setfilmfps;
		timfilm.play;
	}
	free	{
		imfilm.free;
		for( int i=0; i<grsfx.size; i++ )	{
			delete <grsfx.get(i)>;
		}
		for( i=0; i<grbuf.size; i++)
			delete <grbuf.get(i)>;
		grbuf.free;
		grsfx.free;
		.retfps;
	}
	showframe(int idframe)	{
		if( idframe < istartklatka ) idframe=istartklatka;
		else if (idframe > iendklatka ) idframe = iendklatka;
		iklatka = idframe;
		.loadframe;
	}
	showfirstframe	{	.showframe(istartklatka);	}
	showlastframe	{	.showframe(iendklatka);		}
	isplaying	{	timfilm.isplaying;	}
	stop(bool b)	{
		.retfps;
		if( b )	{
			iklatka=iendklatka;
		}
		timfilm.stop(b);
	}
	getimg	{	imfilm.getfullname;	}
}


class classadvobject	{
	init()	{
		this.addasadvobject();
	}
	addasadvobject()	{
		if( !AdventureGame ) return;
		string s = this.getname();
		grmsmove.addonce(s);
		grmslrel.addonce(s);
		grmslclick.addonce(s);
		grmsrclick.addonce(s);
	}
	removefromadvobjs()	{
		if( !AdventureGame ) return;
		string s = this.getname();
		grmsmove.remove(s);
		grmslrel.remove(s);
		grmslclick.remove(s);
		grmsrclick.remove(s);
	}
	virtual onmousemove(int x, int y)	{}
	virtual onmouselclick(int x, int y)		{}
	virtual onmouselrel(int x, int y)		{}
	virtual onmouserclick(int x, int y)		{}
}


class advDelayMover : DelayImgMover, classadvobject	{
	init	{
		classadvobject::init;
		DelayImgMover::init;
		b2clicks = true;
	}
	onmousemove(int x, int y)		{DelayImgMover::onmousemove;}
	onmouselclick(int x, int y)		{DelayImgMover::onmouselclick;}
	onmouselrel(int x, int y)		{DelayImgMover::onmouselrel;}
}

/*
	klasa bazowa, zawiera podstawowe metody i zmienne bohatera przygodowki
	Dominik Dagiel 3 III 2006
*/

class classadvanhero	{
	init()	{}
	public setashero(string sanima, string sfunonfinish)	{
		<sanima>.addmethod("buildhero", "buildhero");
		<sanima>.addmethod("onendframe", "heroendframe1");
		<sanima>.buildhero();
		<sanima>.addmethod("buildheroframe", "buildheroframe");
		<sanima>.addmethod("onfinish", "herofinish");
		<sanima>.addmethod("getdir", "getdir");
		<sanima>.addmethod("setdir", "setdir");
		<sanima>.addmethod("thisfinish", "thisfinish");
		<sanima>.addmethod("playspec", "playspec");
		<sanima>.addmethod("playspec2", "playspec2");
		<sanima>.addmethod("herostop", "herostop");
		<sanima>.addmethod("herostart", "herostart");
		<sanima>.addmethod("herostand", "herostand");
		<sanima>.addmethod("setstdfin", "setstdfin");
		<sanima>.addmethod("getpocket", "getpocket");
		<sanima>.addmethod("haspocket", "haspocket");
		<sanima>.addmethod("setstandbase", "setstandbase");
		<sanima>.setstdfin( sfunonfinish );
	}
	buildheroframe(string san)	{	<san>.addmethod("onendframe", "heroendframe");	}
	setstdfin(string s)	{	this.addmethod("onstdfinish", s);	}
	setstandbase(string s)	{	_sstandbase = s;	}
	buildhero()	{
		new string _sbase;	// baza akcji
		new int _istate = 0;	// 0 - neutral, 1 - start, 2 - body, 3 - stop
		//new string _sfinfun;	// metoda do wywolania na finish akcji bohatera
		.vars2(A, "_sobfin", null, "_sfinfun", null);
		//new string _sobfin;	// obiekt na ktorym wywolac metode na finish (jak null to this)
		new bool _bplaystop;	// czy odegrac stop
		new int _iiloscsek;	// ilosc sekwencji
		new int _itypsort;		// 0 - po kolei, 1 - random
		new int idsort;		// kolejny nr kawalka
		new string _sobstart;	// obiekt na finish start
		new string _sfunfinstart;	// metoda na finish start
		new bool bthisfin = false;	// czy finish jest w animacji a nie z zewnatrz
		new string _sstandbase = "stand";
	}
	getpocket()		{	_spocketpref + this.getname(); }
	bool haspocket()	{	engine.varexist(_spocketpref+this.getname());	}
	thisfinish(bool bfin)	{	bthisfin=bfin;	}
	string getdir()		{	this.actionname()->gete(0,2);	}
	setdir(string sdir)	{	.setframe( .actionname->strsube(2) + sdir, .framenr );	}
	playspec(string sbase, int iloscsek, int itypsort, bool bstart, string sobstart, string sfunfinstart,
		bool bstop, string sobfin, string sfinfun, string sdir)	{
		_sbase = sbase;
		_iiloscsek = iloscsek;
		_itypsort = itypsort;
		_bplaystop = bstop;
		_sobfin = sobfin;
		_sfinfun = sfinfun;
		_sobstart = sobstart;
		_sfunfinstart = sfunfinstart;
		if( iloscsek > 0 )	{
			if( itypsort==0 )	{	idsort = 1;	}
			else if (itypsort==1)	{	idsort = iloscsek.rand + 1; }
		}
		if( bstart )	{
			_istate = 1;
			this.play( sbase + "start" + sdir );
		} else {
			this.setframe( sbase + (iloscsek>0?"1"+sdir:sdir), 0 );
			this.herostart();
		}
	}
	playspec2(string sact, string sobfin, string sfinfun)	{
		string s = ( sact.length()<2 ) ? "" : sact.strsube(2);
		this.playspec( s, 0, 0, false, null, null, false, sobfin, sfinfun, sact.gete(0,2));
	}
	herostop()	{
		_istate = 3;
		if( _bplaystop )	{
			_bplaystop = false;
			this.thisfinish(true);
			this.play( _sbase + "stop" + this.getdir() );
		} else {
			this.stop(true);
		}
	}
	herostart()	{
		_istate = 2;
		this.play( _sbase + (_iiloscsek>0 ? idsort : "") + this.getdir() );
	}
	herofinish()	{
		if( _istate==2 && bthisfin )	_istate=3;
		if (_istate==0 )	{		// standardowy finish
			this.herostand();	// 28.V.2006
			this.onstdfinish();
// 			this.< this.getname() + "_FINISH">();
			string sanimo = this.getname();
			string sevent = <sanimo>.actionname();
			this.<sanimo+"_FINISH">();
			this.<sanimo+"_ACTION_"+sevent+"_FINISH">();
		} else if( _istate==1)	{
			this.herostart();
			this.callfun(_sobstart,_sfunfinstart);
		} else if( _istate==2 )	{
			string s;
			if( _iiloscsek > 0 )	{
				if( _itypsort==0)	{	idsort = (idsort%_iiloscsek)+1;	}
				else if (_itypsort==1)	{	idsort = _iiloscsek.rand + 1; }
				s = _sbase + idsort + this.getdir();
			} else s = this.actionname();
			this.play( s );
		} else if ( _istate==3 )	{		// koniec stop
			_istate = 0;
			this.herostand();	// 28.V.2006
			this.thisfinish(true);
			this.callfun(_sobfin,_sfinfun);
		}
	}
	herostand()	{
		string s = _sstndpref + this.getname();
		if( engine.varexist(s) )	{
			this.play( _sstandbase + this.actionname()->gete(0,2) );
			<s>.play();
		}
	}
	heroendframe1()	{	this.< this.getname() + "_ENDFRAME" >();	}
	heroendframe()	{
		this.setz( this.getposy()-clcamera.getposy );
		if( this.haspocket() )	{
			<this.getpocket()>.pocketpos( this.getposx(), this.getposy() - this.geth()/2);
		}
		this.< this.getname() + "_ENDFRAME" >();
	}
}

/******************************************************/

class classadvhero 	{
	init()	{
		new string _sanim;		// podlinkowana animacja
		new bool _bisvecile = false;	// czy operacja sklada sie z kawalkow
		
		new string _sbase = null;		// bazowa nazwa akcji
		new string _sbase2 = null;
		new int izakres = 0;		// length of string _sbase
		
		new string _sbs2;
		new string _sbutoper;
		new string _smetpart;
		
		new string _simgbut;	// button z ktorego czyta dane
		new string _sptfname = this.getname();
	}
	string getptfname()		{	_sptfname;	}
	public link(string sanim)	{	_sanim = sanim;	}
	public link2(string sanima, string sbase)	{
		this.link(sanima);
		this.checkamounts( sbase );
	}
	public anstand()	{	<_sanim>.play("stand"+this.getdir());	}
	public ansay()		{	<_sanim>.play("talk"+this.getdir());	}
	public string getdir()	{	<_sanim>.actionname()->gete(0, 2);	}
	public int nofpieces()	{	this.nofpiecesdir( this.getdir() ); }
	public int nofpiecesdir(string sdir)	{ _bisvecile ? vecile.get( vecdirs.find(sdir) ) : 0;	}
	public setbase2(string sbase, string sbase2)	{
		this.setbase(sbase);
		_sbase2 = sbase2;
	}
	public setbase(string sbase)	{
		_sbase = sbase;
		izakres = sbase.length();
	}
	public getpropdir(string sdir)	{	sdir=="auto" ? this.getdir() : sdir;	}
	/*****************************/
	_buildamounts()	{
		if( !_bisvecile )	{
			_bisvecile = true;
			new vector vecdirs;
			vecdirs.type("string");
			vecdirs.beginadd("begin", "uu", "ru", "rr", "rd", "dd", "ld", "ll", "lu" );
			new vector vecile;
		}
	}
	_clearvecile()	{
		vecile.free();
		vecile.resize( 8, 0 );
	}
	public checkamounts(string sbase)	{
		this.setbase(sbase);
		this._buildamounts();
		this._clearvecile();
		if( _sanim == null )	return;
		int ile = <_sanim>.nofactions();
		string s1, int i1;
		
		for(int  i=0; i < ile; i++)	{
			s1 = <_sanim>.nameofaction(i);
			if( s1.getb(0,izakres) == sbase )	{
				i1 = s1.getb( izakres, 10 );
				if( i1>0 )	{	// jest kolejna animacja gadania
					vecile.vecinc( vecdirs.find( s1.gete(0,2) ) );
				}
			}
		}
	}
	public getanim	{	_sanim;	}
	/********************************/
	virtual calllastfun()	{
		this.< this.getcallfin() >();
		<_simgbut>.checkonce;
	}
	_calllastfunfin()	{
		this.calllastfunfin();
		this.advmsunlock();
	}
	virtual calllastfunfin()	{	this.< this.getcallfin() + "_FINISH" >();	}
	virtual string getcallfin()	{	_sanim+_smetpart+_sbutoper;	}
	_cplay(string sbase, string sfun, string sdir)	{
		this.advmslock();		// blokuj mysz
		<_sanim>.thisfinish(true);
		if( sbase==null )	{
			<_sanim>.setdir( .getpropdir(sdir) );
			if( sfun!=null )	this.<sfun>();
		} else {
			<_sanim>.playspec( sbase, 0, 0, false, null, null, false, 
				this.getname(), sfun, this.getpropdir(sdir) );
		}
	}
	_cplay1(string sbase, string sdir)	{	this._cplay(sbase,"_cplay1_2", sdir);	}
	_cplay1_2()	{
		this.calllastfun();
		this._callbehs();
	}
	_callbehs()	{
		this.advmsunlock();
		this.callbehs();
	}
	virtual callbehs()	{
		string s = this.getcallfin();
		this.behexist("beh_"+s) ? this.playbehobfin( "beh_" + s, this.getname(), "_calllastfunfin" ) : this._calllastfunfin();
	}
	_cplay2_2()	{
		this.calllastfun();
		this._cplay(_sbs2, "_callbehs", this.getdir() );
	}
	_cplay2(string sbase1, string sbase2, string sdir)	{
		_sbs2 = sbase2;
		this._cplay(sbase1, "_cplay2_2", sdir);
	}
	bool no_turn(string sfun)	{
		string sptf = _spathpref + _sanim;
		string sdir = .getpropdir( <_simgbut>.getbutdir );
		if( engine.varexist(sptf) && .getdir != sdir )	{
			<sptf>.heroturn(sdir, this, sfun);
			false;
		} else true;
	}
	_heroplay1	{	.heroplay1(_simgbut);	}
	_heroplay2	{	.heroplay2(_simgbut);	}
	public heroplay1(string simg)	{
		_simgbut=simg;
		if( .no_turn("_heroplay1") )	{
			_sbutoper = <simg>.getbutname();
			this._cplay1( <simg>.getbase1(), this.getpropdir( <simg>.getbutdir() ) );
		}
	}
	public heroplay2(string simg)	{
		_simgbut=simg;
		if( .no_turn("_heroplay2") )	{
			_sbutoper = <simg>.getbutname();
			this._cplay2( <simg>.getbase1(), <simg>.getbase2(), this.getpropdir( <simg>.getbutdir() ) );
		}
	}
	_setbase2(string styp)	{	this.setbase2( modadv.get(styp,1), modadv.get(styp,2) );	}
	_setbase(string styp)	{	this.setbase( modadv.get( styp, 1 ) );	}
	public heroplay3(string simg, string sb)	{
		<simg>.setbutbase1(modadv.get(sb,1));
		<simg>.setbutbase2(modadv.get(sb,2));
		this.heroplay2(simg);
	}
	/********************************/
}

/******************************************************/
new snd _fxtakeitem;
class classherotaker : classadvhero	{
	init() {
		classadvhero::init();
		_smetpart = "_PICKUP_";
	}
	public herotake(string simg)	{	this.heroplay2(simg);	}
	virtual calllastfun()	{
		if( <_sanim>.haspocket() )	{
			_fxtakeitem.play;
			if( <_simgbut>.hideontake )
				<_simgbut>.hide();		// zabranie przedmiotu
			else <_simgbut>.setbuttyp("but");
			< <_sanim>.getpocket() >.additem( _sbutoper, <_simgbut>.getpocket );
		}
		classadvhero::calllastfun();
	}
}

/******************************************************/

class classherolooker : classadvhero	{
	init()	{
		classadvhero::init();
		_smetpart = "_OPERATE_";
	}
	public herolook(string simg)	{	this.heroplay2(simg);	}
	public herooperate(string simg)	{	this.heroplay2(simg);	}
	public heroopendoor(string simg)	{	this.heroplay3(simg,"open:");	}
	public heroclosedoor(string simg)	{	this.heroplay3(simg,"close:");	}
}

/******************************************************/

class classherouser : classadvhero	{
	init()	{
		classadvhero::init();
		new string _stool;
	}
	public herouse(string stool, string simg)	{
		//_stool = this.getusetool();
		_stool = stool;
		_smetpart = "_USE_"+_stool+"_ON_";
		< <_sanim>.getpocket() >.itemhide();
		//this.heroplay2(simg);
		_simgbut=simg;
		_sbutoper = <simg>.getbutname();
		this._cplay2( <simg>.baseuse1, <simg>.baseuse2, this.getpropdir( <simg>.getbutdir() ) );
	}
	virtual calllastfun()	{
		this.< _sanim + "_USE_" + _stool>();
		this.< _sanim + "_USE_ON_" + _sbutoper>();
		this.< this.getcallfin() >();
	}
	virtual calllastfunfin()	{
		this.< _sanim + "_USE_" + _stool + "_FINISH">();
		this.< _sanim + "_USE_ON_" + _sbutoper + "_FINISH">();
		this.< this.getcallfin() + "_FINISH" >();
	}
	virtual callbehs()	{
		string s = this.getname();
		if( this.behexist( "beh_" + this.getcallfin() ) )	{
			this.playbehobfin( "beh_" + this.getcallfin(), s, "_calllastfunfin" );
		} else  if( this.behexist( "beh_" + _sanim + "_USE_ON_" + _sbutoper ) )	{
			this.playbehobfin( "beh_" + _sanim + "_USE_ON_" + _sbutoper, s, "_calllastfunfin" );
		} else  if( this.behexist( "beh_" + _sanim + "_USE_" + _stool ) )	{
			this.playbehobfin( "beh_" + _sanim + "_USE_" + _stool, s, "_calllastfunfin" );
		} else if ( this.behexist( "beh_"+_sanim+"_USE" ) )	{
			this.playbehobfin( "beh_" + _sanim + "_USE", s,"_calllastfunfin" );
		} else {
			this._calllastfunfin();
		}
	}
}

/******************************************************/
/**	metody rozpoczynajace sie na "c" sa metodami klasy, natomiast na "ob" dotycza obiektu "pathf" **/

class classpathf : classadvhero	{
	init()	{ 
		classadvhero::init();
		new path ptf;
		new string swalkto = null;
		new string _sfunnopath = null;
		new string _sfunvisit = null;
		new int destx;	// dla startgo
		new int desty;	// jezeli jest startgo
		new bool bzmien = false;
		new bool bzatrzym = false;
		new string _sitem=null;
		new string _sobzmien = null;
		new string _sfunzmien = null;
		new int _istep;
		new int _itmpspeed;
		.vars2(A, "ispathto", 1);
		ptf.addmethod("onfinish", "_cptffin");
		ptf.addmethod("onvisit","_cptvisit");
		this.addsigs("_cptfstdreach", "_cptfstdarrive");
		this._setbase( "go:" );
	}
	_buildan(string san)	{
		ptf.linkanima(san);
		this.link(san);
	}
	public build(string san, string sfile, int x, int y, int istep, int ityp)	{
		_istep = istep;
		ptf.build(sfile, x, y, istep, ityp);
		this._buildan(san);
	}
	public buildfrom(string san, string spathf, int istep)	{
		_istep = istep;
		ptf.copy(spathf, istep );
		this._buildan(san);
	}
	public addsigs(string sreach, string sarrive)	{
		if(sreach!=null)	{
			ptf.addmethod("onreach", sreach);
		}
		if(sarrive!=null)	{
			ptf.addmethod("onarrive", sarrive);
		}
	}
	public sigonnopath(string snopath)	{	_sfunnopath = snopath;	}
	public sigonvisit(string svisit)	{	_sfunvisit = svisit;	}
	_cptfstdreach(string s)	{}
	_cptfstdarrive()	{}
	/************************** funkcje dla pathf ***************************************/
	public move(int x, int y)	{	ptf.move( x, y );	}
	public setpos(int x, int y)	{	ptf.setpos(x,y);	}
	public show()	{	ptf.show();	}
	public hide()	{	ptf.hide();	}
	public enable(int id)	{	ptf.enable(id);	}
	public disable(int id)	{	ptf.disable(id);	}
	public setanstep(int istep)	{	_istep=istep; ptf.setanstep(istep);	}
	public mulspeed(int speed)	{	_itmpspeed=speed*_istep; ptf.setanstep(_itmpspeed);	}
	public retstep	{	.setanstep(_istep);	}
	public int getanstep()	{	return _istep;	}
	public int getposx()	{	return ptf.getposx(); }
	public int getposy()	{	return ptf.getposy(); }
	public int getpx()	{	return ptf.getpx(); }
	public int getpy()	{	return ptf.getpy(); }
	public int getidan()	{	return ptf.getidan(); }
	public int getidan2()	{	return ptf.getidan2(); }
	public int getidgo()	{	return ptf.getidgo(); }
	public int getidanpath()	{	return ptf.getidanpath(); }
	public int getidan2path()	{	return ptf.getidan2path(); }
	public int getidgopath()	{	return ptf.getidgopath(); }
	public excludev(int id)	{	ptf.excludev(id);	}
	public linkfilter()	{	ptf.linkfilter();	}
	public unlinkfilter()	{	ptf.unlinkfilter();	}
	public unlinkanima()	{	ptf.unlinkanima();	}
	public linkanima(string san)	{ ptf.linkanima(san);	}
	public setscalepower(real rs)	{	ptf.setscalepower(rs);	}
	public setzsize(real rs)	{	ptf.setzsize(rs);	}
	public bool iswayto(int x, int y)	{	return ptf.iswayto(x,y);	}
	public scalean()	{	ptf.scalean();	}
	public int getfromver(int ifrom, int ile, int ito)	{	return ptf.getfromver(ifrom,ile,ito);	}
	public int getgover(int ile)	{	return ptf.getgover(ile);	}
	public int getanver(int ile)	{	return ptf.getanver(ile);	}
	public int getxver(int id)	{	return ptf.getxver(id);	}
	public int getyver(int id)	{	return ptf.getyver(id);	}
	public int getbyname(int idpath)	{	return ptf.getbyname(idpath);	}
	public walkbase(string sb)	{	ptf.setbase(sb);	}
	public letturn(int id)	{ ptf.letturn(id);	}
	public bool canturn	{	ptf.canturn;	}
	public string vecdir(int x, int y)	{	ptf.vecdir(x,y);	}
	public int ptfgoto(int x, int y)	{	ptf.goto( x, y );	}
	public setmovetype(int id)	{	ptf.setmovetype(id);	}
	/*****************************************************************/
	public walkto2(string simg, int x, int y)	{
		swalkto = simg;
		if( this.cangoto(x,y) )	{
			x = ptf.goto( x, y );
		} else if ( _sfunnopath!=null )	{
			this.<_sfunnopath>();
		}
	}
	public int walkto(string simg, int x, int y)	{
		swalkto = simg;
		.letturn( simg == null );
		if( this.iswalking() )	{
			if( ptf.iswayto(x,y) )	{
				bzmien = true;
				destx = x;
				desty = y;
				return 0;
			} else {
				bzatrzym = true;
				return -1;
			}
		} else {
			return ptf.goto( x, y );
		}
	}
	public int iswaytover(int idver)	{
		idver = <slastpathf>.getbyname(idver);
		ptf.iswayto( .getxver(idver) - .getposx, .getyver(idver) - .getposy );
	}
	public real length(int x, int y)	{	ptf.length(x,y);	}
	public real lengthver(int idver)	{
		idver = <slastpathf>.getbyname(idver);
		.length( .getxver(idver) - .getposx, .getyver(idver) - .getposy );
	}
	public int goto(int x, int y)	{
		return this.walkto( null, x, y );
	}
	public int gotorel(int x, int y)	{
		return this.goto( <_sanim>.getpx() + x, <_sanim>.getey() + y );
	}
	public turn(string sdir)	{	ptf.turn(sdir);	}
	public int iswalking()	{	return ptf.iswalking();	}
	public stand()	{	ptf.stand(); 	}
	public stop(bool bstop)	{	ptf.stop(bstop);	}
	public int getidpath(int x, int y)	{	return ptf.getidpath( x, y);	}
	public bool cangoto(int x, int y)	{
		int id = ptf.getidpath(x,y);
		return id == -1 ? false : ptf.isenabled(id);
	}
	/************** wyjscia do zaawansowanego chodzenia ***********************/
	_cptfreachpocket()	{
		<this.getptfname()+"look">.herolook(swalkto);
	}
	_cptfreachbut()	{
		<this.getptfname()+"look">.herolook(swalkto);
	}
	_cptfreachdoors()	{
		<this.getptfname()+"look">.herooperate(swalkto);
	}
	_cptfreachitem()	{
		<this.getptfname()+"take">.herotake(swalkto);
	}
	_cptfherofin()	{
		this.herostand();
		if( swalkto!=null )	{
			this.<_sanim + "_REACH_" + <swalkto>.getbutname() >();	
			if( this.ismainhero( _sanim ) )	{
				string s = null;
				if( <_sanim>.haspocket() )
					s = < <_sanim>.getpocket()>.getitem();
				if( s!=null )	{
					<this.getptfname()+"use">.herouse(s,swalkto);
				} else {
					this.< "_cptfreach" + <swalkto>.gettyp() >();
				}
			}
			swalkto=null;
		} else {
			this.<_sanim+"_ARRIVE">();
			this._cptheroendpath();
		}
	}
	sigonzmien(string sob, string sfun)	{	_sobzmien=sob;	_sfunzmien=sfun;	}
	_cptheroendpath()	{
		this.callfun(_sfinob, _sfinfun );
		if( _bylfin )	_bylfin=false;
		else {
			_sfinfun = null;
			_sfinob = null;
		}
	}
	_cptfnopath()	{	this.< _sanim+"_NOPATH">();	}
	_cptfvisit()	{	this.<_sanim+"_VISIT">();	}
	public prepareforhero()	{
		ptf.addmethod("onfinish", "_cptfherofin");
		new string _sfinob;
		new string _sfinfun;
		new bool _bylfin;
		this.sigonnopath("_cptfnopath");
		this.sigonvisit("_cptfvisit");
	}
	public herowalkto2(int x, int y, string sob, string sfinfun)	{
		this.herowalkto(null,x,y,sob,sfinfun);
	}
	public herowalkto(string simg, int x, int y, string sob, string sfinfun)	{
		<_sstndpref + _sanim>.stop();		// wylaczenie standera
		_sfinob = sob;
		_sfinfun = sfinfun;
		if( sfinfun!=null )	_bylfin = true;
		if( this.walkto(simg, x,y)==-1 )	{
			//this.callfun(sob,sfinfun);
			//engine.print(this.getname() + " nie ma przejscia do " + simg + " call:"+sob+"."+sfinfun);
			ispathto = 0;
		} else ispathto = 1;
	}
	public heroturn(string sdir, string sob, string sfinfun)	{
		_sfinob = sob;
		_sfinfun = sfinfun;
		if( sfinfun!=null )	_bylfin = true;
		.turn(sdir);
	}
	public advgoto(int x, int y)	{
		this.herowalkto2(x,y,null,null);
	}
	public advwalkto(string simg, int x, int y)	{
		this.herowalkto(simg,x,y,null,null);
	}
	public advvisit(string simg)	{
		if( <simg>.reachable() )
			this.advwalkto( simg, <simg>.getgox(), <simg>.getgoy() );
	}
	public herostand()	{
		.retstep;
		this.stand();
		<_sanim>.herostand();
	}
	public stophero	{
		.herostand;
		bzatrzym = true;
	}
	/*****************************************************************/
	_cptvisit()	{
		this.<_sfunvisit>();	// zmienione 27 vi 2008
		if( bzmien )	{
			bzmien = false;
			if( this.goto(destx, desty)==-1 )	{
				this.<_sfunnopath>();
			} else {
				.callfun(_sobzmien, _sfunzmien);
			}
		} else if (bzatrzym)	{
			bzatrzym=false;
			this.stop(true);
		} /*else {
			this.<_sfunvisit>();
		}*/
	}
	_cptffin()	{
		if( swalkto!=null )	{
			ptf.onreach(swalkto);		// dotarcie do zadanego obiektu
			swalkto=null;
		} else {
			ptf.onarrive();		// dotarcie do punktu
		}
	}
	/**********************/
	anposx	{	<_sanim>.getposx;	}
	anposy	{	<_sanim>.getposy;	}
	bzmien	{	bzmien;	}
	bzmien=(bool b)	{	bzmien = b;	}
	checkreach(string simg)	{
		if( !ispathto && simg!=null && !.behplaying)	{
			_b_rewind = !.playbehif("beh_"+_sanim+"_NOPATH_"+<simg>.getbutname);
		}
	}
}

class classwalkerqueue	{
	init()	{
		new timer timwq;
		timwq.settick(1);
		timwq.setcycle(1);
		timwq.addmethod("onfinish","_timwqfin");
		new vector vecpt;
		vecpt.type("string");
		new int iverlen = 1;
		new int igox;
		new int igoy;
		new string _simg;
		new bool bniezmien = true;
	}
	_timwqfin()	{
		this.checkqueue();
		this.play();
	}
	public start()	{
		//timwq.play();
	}
	int ptpos(string spt)	{	vecpt.find(spt);	}
	public remove(string spt)	{
		int id = .ptpos(spt);
		if( id>=0 )	{
			if( id==0 )	{
				<vecpt.first>.sigonzmien(null, null);
				vecpt.removeat(0);
				if( vecpt.size )
					<vecpt.first>.sigonzmien(this, "ptzmien");
			} else vecpt.removeat(id);
		}
	}
	public stop()	{	timwq.stop(false);	}
	public add(string spt)	{
		_ = <spt>.iswayto( <spt>.anposx, <spt>.anposy );
		vecpt.add(spt);
		if( vecpt.size==1 )
			<vecpt.first>.sigonzmien(this, "ptzmien");
	}
	ptzmien	{
		// zapisz stan: bzmien
		bniezmien = false;
		.walkto(_simg, igox+clcamera.getposx, igoy+clcamera.getposy);
		<vecpt.first>.bzmien = (false);
		bniezmien = true;
	}
	public goto(int x, int y)	{
		this.walkto(null,x,y);
	}
	public visit(string simg)	{
		if( <simg>.reachable() && vecpt.size )	{
			.<vecpt.first + "_WALKTO_"+simg>;
			this.walkto(simg, <simg>.getgox(), <simg>.getgoy() );
		}
	}
	public setverlen(int ilen)	{	iverlen = ilen;	}
	public stand	{
		for( int i=0; i<vecpt.size; i++)	{
			<vecpt.get(i)>.stop(false);
			<vecpt.get(i)>.herostand;
		}
	}
	public mulspeed(int ile)	{
		for( int i=0; i<vecpt.size; i++)	<vecpt.get(i)>.mulspeed(ile);
	}
	public walkto(string simg, int x, int y)	{
		igox = x - clcamera.getposx;
		igoy = y - clcamera.getposy;
		_simg = simg;
		iverlen = 1;
		
		int ile = vecpt.size();
		if( ile<=0 )	{	return;	}
		string sfirst = vecpt.first;
		<sfirst>.advwalkto( simg, x, y );
		int i[2], string s;
		//i1 = <sfirst>.getidgo;
		for( int i=1; i<ile; i++ )	{
			s = vecpt.get(i);
			i1 = <sfirst>.getidgo;
			if( bniezmien )	{
				i0 = <sfirst>.getgover(iverlen);
			} else {
				<s>.advwalkto( simg, x, y );
				i0 = <s>.getgover(i*iverlen);
			}
			
			if( i0<0 ) {
				i0 = <sfirst>.getgover(iverlen);
				if( i0<0 ) i0 = <sfirst>.getidan;
			}
			if( i0==i1 && bniezmien ) i0=-1;
			sfirst = s;
			if( i0 >= 0 )	{
				<s>.advwalkto( null, <s>.getxver(i0), <s>.getyver(i0) );
			} else {
				<s>.stop(false);
				<s>.herostand();
			}
		}
		<sfirst>.checkreach(simg);
		/*for( i=0; i<ile; i++)	{
			for(i0=i+1; i0<ile; i0++)	{
				s = vecpt.get(i);
				s2 = vecpt.get(i0);
				if( <s>.iswalking && !<s2>.iswalking && <s>.getidgopath==<s2>.getidgopath)	{
					<s>.stop(false);
					<s>.herostand;
					//i1 = <s>.getidanpath;;
					//<s>.advwalkto( simg, <s>.getxver(i1), <s>.getyver(i1) );
				}
			}
		}*/
		/*int j, string s;
		for( int i=0; i<ile; i++)	{
			s = vecpt.get(i);
			<s>.advwalkto(simg,x,y);
			for( j=i+1; j<ile; j++)	{
				<vecpt.get(j)>.excludev( <s>.getidgo() );
			}
		}*/
	}
	public checkqueue()	{
		int ile = vecpt.size();
		if( ile<=1 )	{	return;	}
		int j, string s[2], int ian, int ian2;
		for( int i=0; i<ile; i++)	{
			s0 = vecpt.get(i);
			if( <s0>.iswalking() )	{
				ian = <s0>.getidan();
				ian2 = <s0>.getidan2();
				for( j=i+1; j<ile; j++)	{
					s1 = vecpt.get(j);
					if( <s1>.iswalking() )	{
						<s1>.excludev( ian );
						<s1>.excludev( ian2 );
					}
				}
			}
		}
	}
}



class classstndgroup	{
	init()	{
		new gmobjvec grstnd;
	}
	public pause()	{
		grstnd.eval("lock");
		this.stop();
	}
	public resume()	{
		if( .advstdstate )	{
			grstnd.eval("unlock");
			this.play();
		}
	}
	public add(string sstander)	{	grstnd.add(sstander);	}
	public remove(string sst)	{	grstnd.remove(sst);	}
	public stop()	{	grstnd.eval("stop");	}
	public play()	{	grstnd.eval("play");	}
	public reset()	{	grstnd.eval("reset");}
}

class classadvstander : classlocker 	{
	init()	{
		classlocker::init();
		new timer timstand;
		timstand.settick(1);
		new int _i_idle = 12000;
		
		timstand.addmethod("onfinish", "_timstandfin");
		
		new string sanim = this.getname();
		sanim = sanim.strsubbs( _sstndpref );
		._make_idle;
		new string _sbeh = "beh_" + sanim + "_IDLE";
		
		modstnd.add( this.getname() );
	}
	_make_idle	{
		timstand.delay(_i_idle+_i_idle.rand);
	}
	_timstandfin()	{
		._make_idle;
		string s = gameapi.getgamename();
		if( <s>.behexist( _sbeh )  && !this.getlock() )	<s>.playbeh( _sbeh );
	}
	public play()	{	if( !this.getlock() && !timstand.isplaying() )	timstand.play();	}
	public stop()	{	timstand.stop(false);	}
	public setdelay(int idelay)	{
		_i_idle = idelay;
		if( _i_idle<=0 ) _i_idle=1;
		timstand.setdelay(idelay);
	}
	public reset()	{	this.stop();	this.play();	}
}


/*
	klasa obslugujaca "rozmawianie" postaci
	Dominik Dagiel	3 III 2006
*/

class classtalker : classadvhero	{
	init()	{
		classadvhero::init();
		this._setbase( "talk:" );
		
		new snd sndtalk;
		sndtalk.buildfullname;
		sndtalk.setstartstopflag(false, true);
		sndtalk.addmethod("onfinish", "_ctalkfin");
		
		new timer timtalk;
		timtalk.settick(1);
		new real rdelay = 1.0;
		timtalk.addmethod("onfinish","_ctalkfin");
		
		new gmimgvec txttalk;
		new int _iletxt=10;
		string s;
		for( int i=0; i<_iletxt; i++ )	{
			s = "txttalk"+i;
			new text <s>;
			txttalk.add(s);
		}
		new font fonttalk;
		txttalk.hide();
		new vector vecpom;
		vecpom.type("string");
		new int iTxtLim = 30;
		new int irtxt;
		new int igtxt;
		new int ibtxt;
		new string stextdb;		// baza z tekstem do mowienia
		new string _swav;
		
		this.buildfullname();
		
		new string stalktype;
		this.settalktype("snd");	// typ: (snd, txt, film) -> kombinacje
	}
	public set(string san)	{
		this.link(san);
	}
	public settextdb(string s)	{	stextdb=s;	}
	public setfont(string sfile, int size)	{
		fonttalk.load(sfile,size);
		txttalk.eval1("setfont","fonttalk");
	}
	public setsnd(string sfile)	{
		/*if( !sfile.contains(".wav") )	{
			_swav = sfile;
			sfile+=".wav";
		} else {
			_swav = sfile.strsubes(".wav");
		}
		sndtalk.load( this.getsndpath() + sfile );*/
		//sndtalk.advloadsnd(sfile);
		
		sndtalk.advloadsnd( sfile );
	}
	public herosay1(string sfinfun)	{
		this.herosay(1, true, true, null, sfinfun );
	}
	public herosay(int itypsort, bool bstart, bool bstop, string sobfin, string sfinfun)	{
		this.herosaydir( itypsort, bstart, bstop, sobfin, sfinfun, this.getdir() );
	}
	public herosaydir(int itypsort, bool bstart, bool bstop, string sobfin, string sfinfun, string sdir)	{
		<_sanim>.thisfinish(false);
		if( !bstart )	{
			<_sanim>.playspec(_sbase, this.nofpiecesdir(sdir), itypsort, bstart, null, null,
					bstop, sobfin, sfinfun, sdir);
			this.<stalktype>();
		} else {
			<_sanim>.playspec(_sbase, this.nofpiecesdir(sdir), itypsort, bstart, this.getfullname(), "_ctalkstart",
					bstop, sobfin, sfinfun, sdir);
		}
	}
	public thisfinish(bool bthisfin)	{	<_sanim>.thisfinish(bthisfin);	}
	public stop(bool b)	{
		if( stalktype.contains("snd") )	{
			//sndtalk.stop(b);
			if( .cisactsnd(sndtalk.getfullname) )
				.cactsndstop(b);
			else sndtalk.stop(b);
			timtalk.stop(false);
		} else {
			timtalk.stop(b);
		}
	}
	public settalktype(string stype)	{
		stalktype = "_cplay";
		if( stype.contains("snd") )	stalktype += "snd";
		if( stype.contains("txt") )		stalktype += "txt";
		if( stype.contains("film") )	stalktype += "film";
	}
	_csay()	{
		if( stextdb!=null )	{
			int id = <stextdb>.findbyrow(_swav);
			if( id<0 )	{	return;	}
			
			vecpom.vecbuildfromstring( <stextdb>.get(id,2), " " );
			string s="", int itlk=0, int x, int y;
			if( stalktype.contains("txt") )	{
				x = <_sanim>.getcx();
				y = <_sanim>.getpy();
			} else {
				x = 400;
				y = 590;
			}
			int x1=0, int x2=iResX, int y1=0, int y2=iResY;
			string s1;
			for( int i=0; i<vecpom.size(); i++)	{
				s+=vecpom.get(i)+" ";
				if( s.length()>iTxtLim )	{
					s1 = "txttalk"+itlk;
					<s1>._cprinttxt(s,x,y,itlk);
					if( <s1>.getpx() < x1 )	{	x1=<s1>.getpx();	}
					if( <s1>.getex() > x2 )	{	x2=<s1>.getex();	}
					if( <s1>.getpy() < y1 )	{	y1=<s1>.getpy();	}
					if( <s1>.getey() > y2 )	{	y2=<s1>.getey();	}
					s="";
					itlk++;
				}
			}
			if( s.length()>0 )	{
				s1 = "txttalk"+itlk;
				<s1>._cprinttxt(s,x,y,itlk);
				if( <s1>.getpx() < x1 )	{	x1=<s1>.getpx();	}
				if( <s1>.getex() > x2 )	{	x2=<s1>.getex();	}
				if( <s1>.getpy() < y1 )	{	y1=<s1>.getpy();	}
				if( <s1>.getey() > y2 )	{	y2=<s1>.getey();	}
				itlk++;
			}
			x2-=iResX;
			y2-=iResY;
			if( x1>0 )	{	x1=0;	}
			if( y1>0 )	{	x1=0;	}
			txttalk.move(0-x1+x2, -itlk*txttalk0.geth()-y1+y2 );
			if( txttalk0.getpy()<0 )	{
				txttalk.move(0,-txttalk0.getpy());
			}
			timtalk.delay( rdelay*500*vecpom.size() );
		}
	}
	_cprinttxt(string s, int x, int y,int id)	{
		this.set(s);
		this.createtxt(irtxt,igtxt,ibtxt);
		this.setpos( x-this.getw()/2, y+id*this.geth() );
		this.setz(2000);
		this.show();
	}
	public _cplaysnd()	{
		.cbsplay(sndtalk.getfullname);
		//sndtalk.play();
	}
	public _cplaysndtxt()	{
		._cplaysnd;
		this._csay();
	}
	public _cplaysndtxtfilm()	{
		._cplaysnd;
		this._csay();
	}
	public _cplaysndfilm()	{
		this._csay();
	}
	public _cplaytxt()	{
		this._csay();
		timtalk.play();
	}
	public _cplaytxtfilm()	{
		this._csay();
		timtalk.play();
	}
	public _cplayfilm()	{
		this._csay();
		timtalk.play();
	}
	/******  do tekstu pisanego ****************************/
	public setdelay(real r)	{	rdelay=r;	}
	public settxtcolor(int r, int g, int b)	{
		irtxt=r;	igtxt=g;	ibtxt=b;
	}
	/**********************************/
	_ctalkstart()	{
		this.<stalktype>();
	}
	_ctalkfin()	{
		txttalk.hide();
		<_sanim>.herostop();
	}
	/**********************************/
}

class classtxttalker : classadvhero	{
	init()	{
		classadvhero::init();
		this._setbase( "talk:" );
		
		new int iR;
		new int iG;
		new int iB;
		new int ibR;
		new int ibG;
		new int ibB;
		new int ibA;
		new int ibrr;
		new int ibrg;
		new int ibrb;
		new int ibra;
		new int ibw;
		new db dbtxt;
		new int iSize;
		new gmimgvec grtxt;
		new gmimgvec grtxt2;
		string s;
		for( int i=0; i<25; i++ )	{
			s = "txt"+i;
			new text <s>;
			grtxt.add(s);
			<s>.hide();
		}
		new text imgtxt;
		imgtxt.hide();
		
		new bool bplaying = false;
		
		new string slang;
		this.setlang("pol");
	}
	public setlang(string s)	{	slang = s;	}
	public bool isplaying()		{	bplaying;	}
	public setfont(string sfont)	{
		grtxt.eval1("setfont",sfont);
		iSize = <sfont>.getsize();
	}
	public setfontcolor(int ir, int ig, int ib)	{
		iR=ir; iG=ig; iB=ib;
	}
	public setfontbg(int ibr, int ibg, int ibb, int iba)	{
		ibR=ibr; ibG=ibg; ibB=ibb; ibA=iba;
	}
	public setbgframe(int iw, int ir2, int ig2, int ib2)	{
		ibrr = ir2; ibrg = ig2; ibrb = ib2; ibra=255; ibw=iw;
	}
	public set(string san, int iz)	{
		this.link(san);
		grtxt.setz(iz);
		imgtxt.setz(iz-1);
	}
	public herosay(string sfile, int x, int y)	{
		this.herosaydir(sfile,x,y,this.getdir());
	}
	public herosaydir(string sfile, int x, int y, string sdir)	{
		if( sdir=="auto")	{	sdir=this.getdir();	}
		bplaying = true;
		dbtxt.load( this.getgraphpath() + sfile + "." + slang);
		string s;
		grtxt2.free();
		int iw=0;
		int ile = dbtxt.getrowsno();
		for( int i=0; i<ile; i++)	{
			s = "txt"+i;
			<s>.set( dbtxt.get(i,0) );
			<s>.createtxt(iR, iG, iB);
			<s>.setpos(x,y);
			y+=iSize;
			<s>.show();
			if( <s>.getw()>iw)	{	iw=<s>.getw();	}
			grtxt2.add(s);
		}
		imgtxt.setbkg(txt0.getpx()-iSize/2, txt0.getpy()-iSize/2, iw+iSize, iSize*(ile+1), ibR, ibG, ibB, ibA );
		imgtxt.setborders(ibw,ibrr,ibrg,ibrb,ibra);
		imgtxt.show();
		if( _sanim!=null )	{
			<_sanim>.thisfinish(false);
			<_sanim>.playspec(_sbase, 0, 0, false, null, null,
					false, null, null, sdir);
		}
	}
	public stop()	{
// 		if( bplaying==false )	{	return;	}
		bplaying = false;
		grtxt2.hide();
		imgtxt.hide();
		if( _sanim!=null )	{
			<_sanim>.thisfinish(true);
			<_sanim>.play("stand" + this.getdir());
		}
	}
}



/*
	klasy obslugujace plany tla oraz kamere 
*/

class classbgplan : gmobjvec {
	init() {
		gmobjvec::init;
		new real rpx;
		new real rpy;
		new real scalex;
		new real scaley;
		new int _ix;
		new int _iy;
	}
	public setscale(real rsx, real rsy)	{	|scalex, scaley| = rsx, rsy;	}
	public move(real x, real y)	{
		rpx+=x;	rpy+=y;
		int ix = rpx, int iy = rpy;
		rpx-=ix;	rpy-=iy;
		if( ix || iy )	{
			_ix += ix;
			_iy += iy;
			gmobjvec::move(ix,iy);
		}
	}
	public movebgr(real x, real y)	{	.move( scalex*x, scaley*y );	}
	int getpx	{	_ix;	}
	int getpy	{	_iy;	}
}

class classgrplans : gmobjvec	{
	init()	{
		gmobjvec::init();
		new real _rxp;
		new real _ryp;
	}
	public move(real x, real y)	{
		_rxp += x;	_ryp += y;
		this.eval2("movebgr",x,y);
	}
	public real getposx()	{	return _rxp;	}
	public real getposy()	{	return _ryp;	}
	public shift(int x, int y)	{
		_rxp+=x;	_ryp+=y;
		this.eval2("move",x,y);
	}
}

class CameraPos	{
	init(real x, real y)	{
		new real _x;
		new real _y;
		.setpos(x,y);
	}
	setpos(real x, real y)	{ _x=x; _y=y;	}
	getposx	{	_x;	}
	getposy	{	_y;	}
}

class classadvcamera	{
	init()	{
		new classgrplans grbgrs;
		new string sancamera=null;
		new string smsmvfun = null;
		|new real _rxmod, new real _rymod| = 0.05, 0.05;
		|new real rleft, new real rtop, new real rright, new real rbottom| = 0.0, 0.0, igmappw-1, igmapph-1;
		|new int icamx, new int icamy| = igmappw/2, igmapph/2;
		|new real rborx, new real rbory| = igmappw-1, igmapph-1;
		new real _lastx = 0;
		new real _lasty = 0;
		new string _sfunxedge = null;
		new string _sfunyedge = null;
		new CameraPos _campos(0,0);
		
		new timer timcamera;
		timcamera.settick(1);
		timcamera.setcycle(1);
		timcamera.addmethod("onfinish","_camerafin");
	}
	_camerafin()	{
		this.checkcamera();
		this.play();
	}
	public setscreen(int x1, int y1, int x2, int y2)	{
		rleft=x1;	rtop=y1;
		rright=x2;	rbottom = y2;
		rborx = x2;
		rbory = y2;
		_lastx = x1;
		_lasty = y1;
		icamx = (x1+x2)/2;
		icamy = (y1+y2)/2;
		//grbgrs.startpos(x1,y1);
	}
	public remove(string sob)	{	for( int i=0; i< grbgrs.size; i++)	<grbgrs.get(i)>.remove(sob);	}
	public funxedge(string sfun)	{	_sfunxedge=sfun;	}
	public funyedge(string sfun)	{	_sfunyedge=sfun;	}
	public setcenter(int x, int y)	{	| icamx, icamy | = x, y;	}
	public setborders(int x, int y){	|rright, rbottom| = x-1, y-1;	}
	public countcenter	{	.setcenter( rleft+(rright-rleft)/2, rtop+(rbottom-rtop)/2 );	}
	public real getposx()	{	return grbgrs.getposx();	}
	public real getposy()	{	return grbgrs.getposy();	}
	public setmetonmsmove(string s)	{	smsmvfun=s;	}
	public start()	{	timcamera.play();	}
	public stop()	{	timcamera.stop(false);	}
	public setactor(string sactor)	{	sancamera=sactor;	}
	public setcampos(int x, int y)	{
		_campos.setpos(x,y);
		.setactor("_campos");
	}
	public bool isactor(string sob)	{	return sob==sancamera;	}
	public string getactor()	{	return sancamera;	}
	public scalemodifiers(real rx, real ry)	{
		| _rxmod, _rymod | = rx, ry;	
	}
	public newbgr(string sbgr, real rscalex, real rscaley)	{
		new classbgplan <sbgr>;
		this.addbgr(sbgr,rscalex,rscaley);
	}
	public addbgr(string sbgr, real rscalex, real rscaley)	{
		<sbgr>.setscale(rscalex,rscaley);
		grbgrs.add(sbgr);
	}
	public findinbgr(string sob)	{
		for( int i=0; i< grbgrs.size; i++ )	{
			if( <grbgrs.get(i)>.contains(sob) )
				return grbgrs.get(i);
		}
		null;
	}
	public removefrombgr(string sob)	{
		for( int i=0; i< grbgrs.size; i++ )	{
			<grbgrs.get(i)>.remove(sob);
		}
	}
	public addtobgr(string sbgr, string sob)	{	<sbgr>.add(sob);	}
	public setscene()	{	this._setscene(1.0,1.0);	}
	_setscene(real _rx, real _ry)	{
		if( sancamera==null ) return;
		real x = icamx - <sancamera>.getposx();
		x*=_rx;
		real y = icamy - <sancamera>.getposy();
		y*=_ry;
		real ix = this.getposx()+x;
		real iy = this.getposy()+y;
		if( ix >= rleft )	x = -this.getposx();
		else if (ix+rright<=rborx)	x = rborx - (this.getposx()+rright);
		
		if( iy >= rtop )	y = -this.getposy();
		else if (iy+rbottom<=rbory)	y = rbory - (this.getposy()+rbottom);
		
		if( x||y )	{
			grbgrs.move(x,y);
			if( smsmvfun!=null )	this.<smsmvfun>();
		}
		if( x==0 && _lastx!=0 && _sfunxedge!=null )	.<_sfunxedge>;
		if( y==0 && _lasty!=0 && _sfunyedge!=null )	.<_sfunyedge>;
		_lastx = x;
		_lasty = y;
	}
	public checkcamera()	{
		if( sancamera==null )	return;
		this._setscene( _rxmod, _rymod );
	}
	public moveplans(int x, int y)	{
		rleft+=x;	rright+=x;
		rtop+=y;	rbottom+=y;
		rborx+=x;
		rbory+=y;
		icamx+=x;	icamy+=y;
		grbgrs.shift(x,y);
	}
}

/*
	tworzy z button z obiektu graficznego
*/

class classadvbut	{
	init(string sname)	{
		this.setadvbutmets(sname, "but");
	}
	setasbutton(string san, string sname)	{
		classadvbut::setasbutton2(san,sname,"but");
	}
	setasbutton2(string san, string sname, string styp)	{	// rozszerzanie obiektu o button
		<san>.addmethod("setadvbutmets","setadvbutmets");
		<san>.addmethod("setbuttyp","setbuttyp");
		<san>.addmethod("updatemousecursor","updatemousecursor");
		<san>.addmethod("refreshmousecursor","refreshmousecursor");
		<san>.addmethod("setadvbutpos","setadvbutpos");
		<san>.addmethod("setbutdir","setbutdir");
		<san>.addmethod("setbutbase1","setbutbase1");
		<san>.addmethod("setbutbase2","setbutbase2");
		<san>.addmethod("setbutbase","setbutbase");
		<san>.addmethod("getbase1","getbase1");
		<san>.addmethod("getbase2","getbase2");
		<san>.addmethod("getbutdir","getbutdir");
		<san>.addmethod("getbutname","getbutname");
		<san>.addmethod("gettyp","gettyp");
		<san>.addmethod("reachable", "reachable");
		<san>.addmethod("setreach", "setreach");
		<san>.addmethod("getgox","getgox");
		<san>.addmethod("getgoy","getgoy");
		
		<san>.addmethod("enable","enable");
		<san>.addmethod("disable","disable");
		<san>.addmethod("enabled","enabled");
		<san>.addmethod("setonce", "setonce" );
		<san>.addmethod("checkonce", "checkonce" );
		
		<san>.addmethod("setpocket", func { (string s) _spocket = s; } );
		<san>.addmethod("getpocket", func { _spocket; } );
		
		<san>.addmethod("moveon","moveon");
		<san>.addmethod("moveoff","moveoff");
		<san>.addmethod("clickon","clickon");
		<san>.addmethod("butlrel","butlrel");
		
		<san>.addmethod("becomebut", func { classadvbut::setasbut(this); });
		<san>.addmethod("becomeitem", func { classadvbut::setasitem(this); });
		<san>.addmethod("becomedoors", func { classadvbut::setasdoors(this); });
		
		<san>.addmethod("copyposfrompt", func { (string spt, int id)
			int i0 = <spt>.getbyname(id);
			.setadvbutpos(<spt>.getxver(i0) - <spt>.getposx, <spt>.getyver(i0) - <spt>.getposy );
			} );
		
		<san>.addmethod("butisin", func { (int x, int y, bool bv, bool ba)
			if( balpha==-1 )
				.isin(x,y,bv,ba);
			else .isin(x,y,bv,balpha);
			} );
		
		<san>.addmethod("ismask", func { bismask; } );
		<san>.addmethod("setbmask", func { (bool b) bismask = b; });
		
		<san>.addmethod("preparetosort", "preparetosort" );
		
		<san>.setadvbutmets(sname, styp);
		<san>.setreach(true);
	}
	setonce(string s)	{ _sonce = s; }
	checkonce	{
		if(_sonce!=null && !clsave.bis(_sonce))	{
			clsave.bset(_sonce);
			.disable;
		}
	}
	setadvbutmets(string sname, string styp)	{
		new string _styp = styp;
		new string _sname = sname;
		new int igox = this.getposx();		// jak dojsc do tego..
		new int igoy = this.getposy();
		new string sgox = null;
		new string sgoy = null;
		new string _sbutdir = "auto";
		new string _sbase1 = modadv.get("look:",1);
		new string _sbase2 = modadv.get("look:",2);
		new bool breachable = false;
		new string _spocket = sname;
		new string _sonce = null;
		new bool bismask = false;
		
		.vars2(A, "baseuse1", _sbase1, "baseuse2", _sbase2, "hideontake", true, "smousecursor", "active",
			"balpha", -1, "bautohint", true, "bshownonvis", false);
		.updatemousecursor;
		
		this.enable();
	}
	setasmask(string san)	{
		<san>.addmethod("butisin", func { (int x, int y, bool bv, bool ba)
			if( balpha==-1 )
				.isin(x, y, false, ba);
			else .isin(x, y, false, balpha);
			} );
		<san>.setbmask(true);
	}
	/*********************************/
	enable()	{
		if( AdventureGame )
			grbuts.addonce( this.getname() );
	}
	disable()	{
		if( AdventureGame )
			grbuts.remove(this.getname());
	}
	enabled()	{
		if( AdventureGame )
			grbuts.contains(this.getname());
		else 0;
	}
	/*********************************/
	setbutbase(string s1, string s2)	{
		.setbutbase1(s1);
		.setbutbase2(s2);
	}
	setreach(bool b)	{	breachable=b;	}
	reachable()		{	breachable;	}
	setbuttyp(string s)	{	_styp = s;	}
	updatemousecursor	{
		match(_styp)	{
			"but" => "active";
			"doors" => "exit";
			"item" => "take";
			? => smousecursor;
		}
		smousecursor = _;
	}
	refreshmousecursor(string scursor)	{
		smousecursor = scursor;
		.updatemousecursor;
		if( _slastms == this )
			advmouse.set(smousecursor);
	}
	/*************************/
	butlrel()	{}		// mouselrel
	clickon()	{	if( this.reachable() )	{	clwalkq.visit( this.getname() );	}	}
	moveon()	{
		if( sItemMover==null )	{
			advmouse.set(smousecursor);
		} else {
			<sItemMover>.checkusebutton(this, "setactive");
		}
	}
	moveoff()	{	advmouse.setstd();	}
	/*************************/
	setadvbutpos(string x, string y)	{	sgox=x; sgoy=y; igox = x; igoy=y;		}
	setbutdir(string sdir)	{	_sbutdir=sdir;	}
	setbutbase1(string sb1)	{	_sbase1=sb1; baseuse1 = sb1;	}
	setbutbase2(string sb2)	{	_sbase2=sb2; baseuse2 = sb2;	}
	string getbase1()	{	_sbase1;	}
	string getbase2()	{	_sbase2;	}
	string getbutdir()	{	_sbutdir;	}
	string getbutname()	{	_sname;	}
	string gettyp()		{	_styp;	}
	int getgox()	{
		if( sgox=="-hero" )	{
			sgoy=="-main" ? <smainhero>.getposx() : <sgoy>.getposx();
		} else if (sgox=="-but")	{
			<sgoy>.getcx;
		} else igox + clcamera.getposx();
	}
	int getgoy()	{
		if( sgox=="-hero" )	{
			sgoy=="-main" ? <smainhero>.getposy() : <sgoy>.getposy();
		} else if (sgox=="-but")	{
			<sgoy>.getey;
		} else igoy + clcamera.getposy();
	}
	/*******  virtuale  ****/
	virtual int getposx()	{	0;	}
	virtual int getposy()	{	0;	}
	virtual int getz()		{	0;	}
	virtual int butisin(int x, int y, bool bigv, bool biga)	{	0;	}
	virtual preparetosort(int x, int y)	{}
	virtual endsort	{}
	/***************************/
	public setasbut(string san)	{
		//<san>.setbutbase( modadv.get("take:",1), modadv.get("take:",2) );
		<san>.smousecursor = ("active");
	}
	public setasitem(string san)	{
		<san>.setbutbase( modadv.get("take:",1), modadv.get("take:",2) );
		<san>.smousecursor = ("take");
	}
	public setasdoors(string san)	{
		<san>.setbutbase( modadv.get("doors:",1), modadv.get("doors:",2) );
		<san>.smousecursor = ("exit");
	}
}

class classadvitem : classadvbut	{
	init(string sname)	{
		classadvbut::init(sname, "item");
		this.setbutbase( modadv.get("take:",1), modadv.get("take:",2) );
	}
	setasbutton(string san, string sname)	{
		classadvbut::setasbutton2(san, sname, "item");
		<san>.setbutbase( modadv.get("take:",1), modadv.get("take:",2) );
	}
}

class classadvdoors : classadvbut	{
	init(string sname)	{
		classadvbut::init(sname, "doors");
		this.setbutbase( modadv.get("doors:",1), modadv.get("doors:",2) );
	}
	setasbutton(string san, string sname)	{
		classadvbut::setasbutton2(san, sname, "doors");
		<san>.smousecursor=("active");
		<san>.setbutbase( modadv.get("doors:",1), modadv.get("doors:",2) );
	}
}

/* 
	behavioury : skladowe cut-scen w przygodzie
*/

class classbehhero 	{
	init()	{
		new string _snextbeh = null;
		new string _stdfinfun = null;	// std funkcja przekazana do odegrania na finish
		new string _stdfinobj = null;
		new string _stype = null;	// typ behavioura
		new string _scaller;	// kto go wywoluje (tego behavioura)
		new bool bblock = true;	// blokuj przed dzialaniami gracza
		//new string bonce = null;	// jednorazowego uzytku
		new bool bparal = false;
		.vars2(A, "bskip", false);
	}
	public skip	{
		if( bskip ) {
			match( .gettyp )	{
				"sndplay" => {
					if( .cisactsnd(sndp.getfullname) ) .csplaystop(false);
					else sndp.stop(false);
					.behreturn;
				}
				"talk" => {
					<_stalkpref+_san>.stop(false);
					.advanstand(_san);
					.behreturn;
				}
				? => ;
			}
		}
	}
	public behreturn	{	.finishbeh(_scaller);	}
	public gonext(string scaller)	{
		bool bfin = false;
		if( bparal )	{
			bfin = <_sstarter>.behret( this.getname() );
		} else if ( <_sstarter>.isenumer() && _sstarter!=this.getname())	{
			bfin = true;
		} else {
			if( _snextbeh!=null )	{
				.classbehhero_preeval;
				<_snextbeh>.eval( scaller );
				.classbehhero_posteval;
			} else {
				bfin = true;
			}
		}
		if( bfin )	{
			this.finishbeh(scaller);
		}
	}
	public finishbeh(string scaller)	{
		if( scaller!=null )	{
			<scaller>.reteval();
		} else {
			modstnd.resume();
			string s = this.getactbeh();
			<_sstarter>.callbehfin();
			if( this.getactbeh()==s )	{
				this.setactbeh(null);
			}
		}
	}
	public playfin(string sob, string sfun)	{
		this.setfinfun(sob,sfun);
		_bmslock = this.advgetlock();
		if( bblock )	// 12.11.2012 - dodane, zeby nie blokowal kursora jesli beh jest -nb (no block)
			this.advmssetlock( bblock );	// zapamietuje mysz
		modstnd.pause();	// stop standery
		this.eval(null);
	}
	public eval(string scaller)	{
		this.setactbeh( this.getname() );		// zapamietanie kto teraz "gra"
		_scaller = scaller;
		this._eval();	
	}
	public rewind()	{
		//if( bblock==false && .hasaddedmet("_rew")/* || igmdebug*/)	{
		if( .hasaddedmet("_rew") )	{
			this._rew();
		}
	}
	public reteval()	{
		this.gonext(_scaller);
	}
	callbehfin()	{
		if( bblock )
			this.advmssetlock( _bmslock );	// przywrocenie blocka myszy
		
		this.callfun(_stdfinobj,_stdfinfun);
		_stdfinobj = null;
		_stdfinfun = null;
		
		this.< this.getname()->strsubbs( _sbeh )+"_FINISH">();
	}
// 	_rewenter	{}
// 	_rewclose	{}
	_evalenter	{
		ccs.obenter(this, "reteval");
	}
	_evalclose	{
		ccs.obclose(this, "reteval");
	}
	_evalmusic	{
		_music.playvec(vmus.getfullname, 0);
		.reteval;
	}
	_evalreturn	{
		.behreturn;
	}
	_evalscript()	{
		if( _id>=0 )	{
			int id = _id;
			@s = <_sdb>.get(_row,id);
			while( s!=")" )	{
				<_sscr>.ARG=(id-_id, s);
				id++;
				s = <_sdb>.get(_row,id);
			}
		}
		<_sscr>.call( _sfun2 );
		this.reteval();
	}
// 	_rewscript()	{}
	_evalmet()	{
		if( _icol>=0 )	{
			int id = _icol;
			@s = <_sdb>.get(_irow,id);
			while( s!=")" )	{
				s;
				id++;
				s = <_sdb>.get(_irow,id);
			}
		}
		if( _stypecall=="::" )	{
			<_sob2>::<_sfun2>;
		} else
			this.callfun(_sob2,_sfun2);
		this.reteval();
	}
// 	_rewmet()	{}
	_evalsave()	{
		if( ssavval.getb(0,1)=="@" )	{
			int pom = ssavval.strsubb(1);
			clsave.set( ssavvar, pom + clsave.get(ssavvar) );
		} else
			clsave.set( ssavvar, ssavval );
		this.reteval();
	}
// 	_rewsave()	{}
	_evalgame()	{
		string s = gameapi.getgamename;
		match( _styp )	{
			"-def" => <s>.playfromscript(_spath, _sgame);
			"-adv" => <s>.playnewgamepath(_sgame, _spath);
			? => <s>.playnewgame(_sgame);
		}
		this.reteval();
	}
// 	_rewgame()	{}
	_evalread()	{	clhilarytxt.herosaydir( _sread, _ix, _iy, _sdir );	}
	_rewread()	{
		clhilarytxt.stop();
		this.reteval();
	}
	_evalwait()	{	timwait.play();	}
	//_rewwait()	{	timwait.stop(true);	}
	_evaltalk()	{
		string sptf = _spathpref + _san;
		string s = _stalkpref + _san;
		if( engine.varexist(sptf) && <s>.getdir != <s>.getpropdir(_sdir) )	{
			<sptf>.heroturn(_sdir, this, "_evaltalk");
			return;
		}
		this.advanstand(_san);
		<s>.settalktype( modadv.gettalktype() );
		<s>.setsnd( __swav );
		<s>.checkamounts( __sbase );
		<s>.herosaydir(isort, bstt, bstp, this.getname(), "reteval", <s>.getpropdir(_sdir) );
	}
	_rewtalk()	{	<_stalkpref+_san>.stop(true);	}
	_evalsetpos()	{
		int x, int y;
		string _sptf = _spathpref + _san;
		if( _idestx=="-id" )	{
			y=<_sptf>.getbyname(_idesty);
			x = <_sptf>.getxver(y);
			y = <_sptf>.getyver(y);
			<_san>.setpos(x ,y  );
		} else {
			x=_idestx;
			y=_idesty;
			<_san>.setpos(x + clcamera.getposx() ,y + clcamera.getposy() );
		}
		if( _bssc ) clcamera.setscene;
		if( engine.varexist(_sptf) ) <_sptf>.scalean();
		<_san>.setz( <_san>.getposy );
		if( _sdir!="auto" )	<_san>.setdir(_sdir);
		this.reteval();
	}
// 	_rewsetpos()	{}
	_evalwalk()	{
		int x, int y;
		if( _idestx=="-id" )	{
			y=<_sptf>.getbyname(_idesty);
			x = <_sptf>.getxver(y) - <_sptf>.getposx;
			y = <_sptf>.getyver(y) - <_sptf>.getposy;
		} else if (_idestx == "-hero")	{
			x = <_idesty>.getposx;
			y = <_idesty>.getposy;
			bool b = true;
			if( <_sptf>.ptfgoto(x,y)>=0 )	{
				y = <_sptf>.getgover(1);
				if( y>=0 )	{
					x = <_sptf>.getxver(y);
					y = <_sptf>.getyver(y);
					b = false;
				}
			}
			<_sptf>.stop(false);
			if(b)	{
				@s = _sptf.strsubbs( _spathpref );
				x = <s>.getposx;
				y = <s>.getposy;
			}
		} else {
			x=_idestx;
			y=_idesty;
		}
		<_sptf>.herowalkto2( x + clcamera.getposx(), 
			y + clcamera.getposy(), this.getname(), "reteval" );
	}
	_evalturn	{
		string s = _sdir;
		if( !s.in(A, "uu", "ru", "rr", "rd", "dd", "ld", "ll", "lu") )	{
			string s2 = <_sptf>.getanim;
			s = <_sptf>.vecdir( <s>.getposx-<s2>.getposx, <s>.getposy-<s2>.getposy );
		}
		<_sptf>.heroturn(s, this, "reteval");
	}
// 	_rewwalk()	{}
	_evalanorder()	{
		this.advanstand(_san);
		_ = this.analizeaninstr(_sdb, _irow, _icol, _san);
		this.reteval();
	}
// 	_rewanorder()	{}
	_evalanplay()	{
		if( !<_san>.hasvar("bthisfin") )	{
			<_san>.setasadvanima;
		}
		this.advanstand(_san);
		<_san>.thisfinish(true);
		if( StringChecker::isdigit(_sact) ) _sact = <_san>.nameofaction(_sact);
		<_san>.playspec2( _sact, this.getname(), "reteval");
	}
	_evalanfin	{
		<_san>.anfadein( _time, .fullname_callfun(this, "reteval") );
	}
	_evalanfout	{
		<_san>.anfadeout( _time, .fullname_callfun(this, "reteval") );
	}
	_rewanplay()	{	/*<_san>.stop(true);*/	}
	_evalsndbg()	{
		//_sndbg.play();
		.cbsplay(_sndbg.getfullname);
		this.reteval();
	}
// 	_rewsndbg()	{}
	_evalsndplay()	{
		//sndp.play();
		int ilektor = igmlektor;
		if( !sndp.file_loaded )	{
			igmlektor = 0;
		}
		.cbsplay(sndp.getfullname);
		igmlektor = ilektor;
	}
	_rewsndplay()	{
		if( .cisactsnd(sndp.getfullname) ) .csplaystop(true);
		else sndp.stop(true);
	}
	_evalcall()	{
		string s = scallobj;
		if( s.contains("$") )	{
			s = s.strsubb(1);
			s = engine.varexist(s) ? [s] : <sscript>.get(s);
			if( s==null )	{
				this.reteval();
				return;
			}
		}
		s = this.getbeh(s);
		<s>.eval( this.getname() );
	}
// 	_rewcall()		{}
	_evalnull()	{	this.reteval();	}		// obiekt niezdefiniowany
// 	_rewnull()	{}
	_evalstart()	{
		int i, string s;
		vbif.free;
		if( bonce!=null )	{
			//s = this.getname()->strsubbs( _sbeh );
			if( !clsave.bis( bonce ) )	{
				clsave.bset( bonce ); 
			} else {
				.behreturn;
				return;
			}
		}
		if( (iisifsave==0&&clsave.is(sisifsave,sisifvar)) || (iisifsave==1&&!clsave.is(sisifsave,sisifvar)) )	{
			.behreturn;
			return;
		}
		if( brand)	{
			i = vecbehs.size();
			i>0 ? < vecbehs.get( i.rand ) >.eval( _scaller ) : this.reteval();
		} else if( bparal)	{
			vecbehs2.veccopy("vecbehs");
			for( i=0; i<vecbehs.size(); i++)	{
				<vecbehs.get(i)>.eval( _scaller );
			}
		} else if (ienumer>0)	{
			<vecbehs.get( this.nextenum()-1 )>.eval( _scaller );
		} else	{
			this.reteval();
		}
	}
// 	_rewstart()	{}
	_ifst(bool b, bool b2)	{
		match(ifst)	{
			1 => b && b2;
			2 => b || b2;
			? => b;
		}
	}
	bool _oper_check(string s)	{
		//s=="|" ? 2 : s=="&";
		match(s)	{
			"|" => 2;
			"&" => 1;
			? => 0;
		}
	}
	_ifcheck	{
		bool b[2];
		string s[2];
		int i1 = istart;
		ifst = 0;	// initial state
		while(i1<istop)	{
			s0 = <_db>.get(irow, i1);
			s1 = <_db>.dbchecknext(irow, i1);
			match( s1 )	{
				"=", "!=", "<", "<=", ">", ">=" => {
					i1+=2;
					match( s1 )	{
						/*"="  => b1 = clsave.is(s0, <_db>.get(irow, i1) );
						"!=" => b1 = !clsave.is(s0, <_db>.get(irow, i1) );
						"<"  => b1 = clsave.get(s0)->to_r < <_db>.get(irow, i1);
						"<=" => b1 = clsave.get(s0)->to_r <= <_db>.get(irow, i1);
						">"  => b1 = clsave.get(s0)->to_r > <_db>.get(irow, i1);
						">=" => b1 = clsave.get(s0)->to_r >= <_db>.get(irow, i1);*/
						"="   => b1 =._getifvar(s0) == <_db>.get(irow, i1);
						"!="  => b1 =._getifvar(s0) != <_db>.get(irow, i1);
						"<"   => b1 =._getifvar(s0)->to_r < <_db>.get(irow, i1)->to_r;
						"<="  => b1 =._getifvar(s0)->to_r <= <_db>.get(irow, i1)->to_r;
						">"   => b1 =._getifvar(s0)->to_r > <_db>.get(irow, i1)->to_r;
						">="  => b1 =._getifvar(s0)->to_r >= <_db>.get(irow, i1)->to_r;
						? => ;
					}
					b0 = ._ifst(b1, b0);
					ifst = ._oper_check( <_db>.dbchecknext(irow, i1) );
					if( ifst ) i1++;
				}
				"&" => { i1++;
					//b1 = ( (s0.getb(0,1)=="!") ? (!clsave.bis(s0.strsubb(1))) : clsave.bis(s0) );
					//b1 = ( s0.getb(0,1)=="!" ? (!._is_ifvar(s0.strsubb(1),"1")) : ._is_ifvar(s0,"1") );
					b0 = ._ifst(._is_ifvar(s0), b0);
					ifst=1;
				}
				"|" => { i1++;
					//b1 = ( (s0.getb(0,1)=="!") ? (!clsave.bis(s0.strsubb(1))) : clsave.bis(s0) );
					//b1 = ( s0.getb(0,1)=="!" ? (!._is_ifvar(s0.strsubb(1),"1")) : ._is_ifvar(s0,"1") );
					b0 = ._ifst(._is_ifvar(s0), b0);
					ifst=2;
				}
				? => {
					//b1 = ( (s0.getb(0,1)=="!") ? (!clsave.bis(s0.strsubb(1))) : clsave.bis(s0) );
					//b1 = ( s0.getb(0,1)=="!" ? (!._is_ifvar(s0.strsubb(1),"1")) : ._is_ifvar(s0,"1") );
					b0 = ._ifst(._is_ifvar(s0), b0);
				}
			}
			i1++;
		}
		<_sstarter>.bif=(b0);
		b0;
	}
	_getifvar(string svar)			{
		svar.getb(0,1)=="." ? <gameapi.getgamename>.<svar.strsubb(1)> : clsave.get(svar);	
	}
	_is_ifvar(string svar)	{
		bool b = 0;
		if( svar.getb(0,1)=="!" )	{
			b = 1;
			svar = svar.strsubb(1);
		}
		svar = ._getifvar(svar);
		bool b2 = ( (svar == null || svar=="0") ? false : true);
		b ? !b2 : b2;
	}
	_checkif	{
		if( ._ifcheck )	{
			.reteval;
		} else {
			<_sstarter> (this) { (string s)
				int poz = 0;
				int end = vecbehs.size;
				int found = 0;
				for(int i =vecbehs.find(s)+1; i<end; i++ )	{
					match( <vecbehs.get(i)>.gettyp )	{
						"IF" => poz++;
						"FI" => {
							if( poz==0 )	{
								found = i;
								i = end;
							} else poz--;
						}
						"ELSE", "ELIF" => {
							if( poz==0 )	{
								found = i;
								i = end;
							}
						}
						? => ;
					}
					//!<vecbehs.get(i)>.gettyp->in(A,"FI","ELSE","ELIF")
				}
				<vecbehs.get(found)>.eval(_scaller);
			};
		}
	}
	_evalIF	{
		<_sstarter>.ifpush;
		._checkif;
	}
	_gotofi(string s)	{
		int poz = 0;
		for( int i = vecbehs.find(s)+1; i<vecbehs.size; i++) {
			match(<vecbehs.get(i)>.gettyp)	{
				"IF" => poz++;
				"FI" => {
					if( poz==0 )	{
						<vecbehs.get(i)>.eval(_scaller);
						return;
					} else poz--;
				}
				? => ;
			}
		}
	}
	_evalELIF	{
		if( <_sstarter>.bif )	{
			<_sstarter>._gotofi(this);
		} else ._checkif;
	}
	_evalELSE	{
		if( <_sstarter>.bif ) <_sstarter>._gotofi(this);
		else .reteval;
	}
	_evalFI	{
		<_sstarter>.ifpop;
		.reteval;
	}
// 	_rewIF	{}
// 	_rewELSE	{}
// 	_rewFI	{}
// 	_rewELIF	{}
	/***********************/
	gettyp	{	_stype;	}
	settype(string stype)	{
		_stype = stype;
		this.addmethod("_eval", "_eval" + stype );
		if( .hasmet("_rew"+stype) )	{
			this.addmethod("_rew", "_rew" + stype );
		}
	}
	setflags(string snextob)	{
		 _snextbeh = snextob;	
	}
	setfinfun(string stdfinobj, string stdfinfun)	{
		_stdfinobj = stdfinobj;
		_stdfinfun = stdfinfun;
	}
	setasstarter(string bone, bool brandom, bool bpar, bool block, int ienum, int iifsave, string sifsave, string sifvar)	{
		this.settype("start");
		new string _sstarter=this.getname();
		new bool brand = brandom;
		new bool _bmslock;		// tmp do przechowania locka myszy
		new vector vecbehs;
		bblock = block;
		vecbehs.type("string");
		new string bonce = bone;
		bparal = bpar;
		new int ienumer = ienum;
		if( ienum>0 )	{
			new int _iencnt = 1;
		} else if( bpar )	{
			new vector vecbehs2;
			vecbehs2.type("string");
		}
		new int iisifsave=iifsave;
		if( iifsave>=0 )	{
			new string sisifsave = sifsave;
			if( sifvar!=null )
				new string sisifvar = sifvar;
		}
		new vector vbif;
	}
	bif	{	vbif.last;	}
	bif=(bool b)	{	vbif.set( vbif.size-1, b);	}
	ifpush	{	vbif.add(1);	}
	ifpop	{	_ = vbif.pop;	}
	int isenumer()	{
		ienumer;	
	}
	int nextenum()	{
		if( _iencnt > vecbehs.size() )	{
			_iencnt = ienumer+1;
		} else {
			_iencnt++;
		}
		_iencnt-1;
	}
	addtostarter(string sob)	{
		vecbehs.add( sob );
		<sob>.var2("behstarter", this);
		<sob>.bskip = (bskip);
	}
	bool getblock()	{	bblock;	}
	addflags(string sst,  bool block, bool bpar)	{
		new string _sstarter=sst;
		bblock = _stype=="read" ? false : block;
		bparal = bpar;	// czy nalezy wykonac rownolegle
	}
	bool behret(string sob)	{
		vecbehs2.remove(sob);
		vecbehs2.size()==0;
	}
	_setasif(string sdb, int row, int i1, int i2)	{
		new int istart = i1;
		new int istop = i2;
		new string _db = sdb;
		new int irow = row;
		new int ifst = 0;
	}
	setasIF(string sdb, int row, int i1, int i2)	{
		.settype("IF");
		._setasif(sdb, row, i1, i2);
	}
	setasELIF(string sdb, int row, int i1, int i2)	{
		.settype("ELIF");
		._setasif(sdb, row, i1, i2);
	}
	setas(string s)	{	.settype(s);	}
	setasscript(string sscr, string sfun, string sdb, int row, int id)	{
		this.settype("script");
		new string _sscr = sscr;
		new string _sfun2 = sfun;
		new int _id = id;
		new string _sdb = sdb;
		new int _row = row;
	}
	setasuse(string sitem)	{
		.settype("use");
		new string _sitem = sitem;
	}
	_evaluse	{
		<_spocketpref+.getmainhero>.pckremove( _sitem );
		.reteval;
	}
// 	_rewuse	{ }
	_evaltopck	{
		<_spocketpref+.getmainhero>.additem( _sitem, _sfile );
		.reteval;
	}
// 	_rewtopck	{}
	setastopck(string sitem, string sfile)	{
		.settype("topck");
		new string _sitem = sitem;
		new string _sfile = sfile;
	}
	setasmet(string sob, string sfun, string stypecall, string sdb, int irow, int icol)	{
		this.settype("met");
		new string _sob2 = sob;
		new string _sfun2 = sfun;
		new string _sdb = sdb;
		new string _stypecall = stypecall;
		new int _irow = irow;
		new int _icol = icol;
	}
	setassaver(string svar, string sval)	{
		this.settype("save");
		new string ssavvar = svar;
		new string ssavval = sval;
	}
	setasnewgamer(string styp, string spath, string sgame)	{
		this.settype("game");
		new string _sgame=sgame;
		new string _styp = styp;
		new string _spath = spath;
	}
	setasreader(string sfile, int x, int y, string sdir)	{
		this.settype("read");
		new string _sread = sfile;
		new int _ix = x;
		new int _iy = y;
		new string _sdir = sdir;
	}
	setaswaiter(int delay)	{
		this.settype("wait");
		new timer timwait;
		timwait.settick(1);
		timwait.delay(delay);
		timwait._csplbuild( this.getname(), "reteval" );
		timwait.addmethod("onfinish", "_csplfinish");
	}
	setassndbg(string ssnd, int vol)	{
		this.settype("sndbg");
		new snd _sndbg;
		_sndbg.buildfullname;
		_sndbg.setstartstopflag(false, true);
		//_sndbg.load( this.getsndpath() + ssnd + ".wav" );
		@s = ssnd + ".wav";
		if( !engine.fileexist(s) ) s = ssnd+".ogg";
		_sndbg.advloadsnd(s);
		_sndbg.setvol(vol);
	}
	_loadsnd	{
		
	}
	setasanorder(string sdb,int irow,  int icol, string san)	{
		this.settype("anorder");
		new string _sdb = sdb;
		new int _irow = irow;
		new int _icol = icol;
		new string _san = san;
	}
	setascaller(string sbeh, string sscr)	{
		this.settype("call");
		new string scallobj = sbeh;
		new string sscript = sscr;
	}
	_csplbuild(string sob, string sfin)	{
		new string _sobj = sob;
		new string _sfinfun = sfin;
	}
	_csplfinish()	{
		this.callfun(_sobj, _sfinfun);
	}
	setassndplayer(string sfile, int vol)	{
		this.settype("sndplay");
		new snd sndp;
		sndp.buildfullname;
		sndp.setstartstopflag( false, true );
		@s = sfile + ".wav";
		if( !engine.fileexist(s) ) s = sfile+".ogg";
		sndp.advloadsnd(s);
		sndp._csplbuild( this.getname(), "reteval" );
		sndp.addmethod("onfinish", "_csplfinish");
		sndp.setvol(vol);
	}
	setasposer(string san, string  idestx, int idesty, int bssc, string sdir )	{
		this.settype("setpos");
		new string _san = san;
		new string _idestx = idestx;
		new int _idesty = idesty;
		new bool _bssc = bssc;
		new string _sdir = sdir;
	}
	setasturn(string sptf, string sdir)	{
		this.settype("turn");
		new string _sptf = sptf;
		new string _sdir = sdir;
	}
	setaswalker(string sptf, string idestx, string idesty )	{
		this.settype("walk");
		new string _sptf = sptf;
		new string _idestx = idestx;
		new string _idesty = idesty;
	}
	setasanplayer(string san, string sact)	{	
		this.settype("anplay");
		new string _san = san;
		new string _sact = sact;
	}
	setasanfin(string san, int time)	{	
		this.settype("anfin");
		new string _san = san;
		new int _time = time;
	}
	setasanfout(string san, int time)	{	
		this.settype("anfout");
		new string _san = san;
		new int _time = time;
	}
	setastalker(string san, string swav, string sbase, int itypsort,
			bool bstart, bool bstop, string sdir )	{
		this.settype("talk");
		new string _san = san;
		
		new string __swav = swav+".wav";
		if( !engine.fileexist(__swav) ) __swav = swav+".ogg";
		new string __sbase = sbase;
		
 		new int isort = itypsort;
 		new bool bstt = bstart;
 		new bool bstp = bstop;
 		new string _sdir = sdir;
	}
	setasenter	{	.settype("enter");	}
	setasclose	{	.settype("close");	}
	setasmusic(string sdb, int row, int colstart, int colend)	{
		.settype("music");
		new vector vmus;	vmus.type("string");
		vmus.buildfullname;
		while ( colstart>=0 && colstart<colend )	{
			vmus.add( <sdb>.get(row, colstart) );
			colstart++;
		}
	}
	setasreturn	{	.settype("return");	}
}

new snd _fx_pocket;
_fx_pocket.load("sounds/sfx/harfa.wav");

new string sItemMover = null;	// advpocket, ktory aktualnie przenosi przedmiot z kieszeni i chce gdzies uzyc

class classadvpocket : classadvobject, classadvbut, gmimgvec	{
	init(string sname)	{
		classadvobject::init();
		classadvbut::init(sname);
		gmimgvec::init();
		this.setbuttyp("pocket");
		.setreach(true);
		.setadvbutpos("-hero","-main");
		new int iX;
		new int iY;
		new int iNumItems = 0;
		new int iMaxItems = 14;
		new int iScale;
		new string sState = "closed";
		new string _sanim = this.getname();
		_sanim = _sanim.strsubbs( _spocketpref );
		new string sItem = null;
		new string sFocusItem = null;
		
		new string _sbase = "anpocket";
		new int _ibase = _sbase.length();
		
		new int _ipcz = 1000;
		this.setz(_ipcz);
		
		new string sitempath;
		new vector arPocket;
		arPocket.type("string");
		new vector arPocketFile;
		arPocketFile.type("string");
		this.cnewtimercyclefin("tim", 1, 1, "evalpocket");
		
		sitempath = modadv.get("itempath:",1);
		
		int z = this.getz();
		new anima imitem;
		imitem.anloopfin();
		imitem.setz(z+1);
		new img immarker;
		immarker.load( sitempath + "itemmarker.png" );
		immarker.setz(z-1);
		immarker.hide();
		
		this.hide();
		
		new bool bskip=false;
	}
	/*******************************/
	addtoadv()	{		// jezeli jest globalna kieszen
		this.addtogamevars(this.getname());
		this.enable();
		this.addasadvobject();
	}
	removefromadv()	{
		this.disable();
		this.removefromadvobjs();
	}
	hidepocket()	{
		if( sState!="closed")	{
			if( sState!="close" )	{
				this.pockettoggle();
				tim.stop(false);
			}
			while(sState!="closed")	{
				tim.evalpocket();
				tim.stop(false);
			}
		}
	}
	exitpocket	{
		sState = "closed";
		tim.stop(false);
		.hide;
	}
	/*******************************/
	skip()	{	bskip=true;	}
	skipitem()	{	if( sItem!=null )	{	bskip=true;	}	}
	additem(string sname, string sfile)	{
		if( arPocket.contains(sname) ) return;
		arPocket.add(sname);
		arPocketFile.add(sfile);
// 		string s = _sbase+iNumItems;
		string s = _sbase + sname;
		new anima <s>;
		this.add(s);
		<s>.load( sitempath + sfile + ".pyz" );
		//<s>.setframe("in",0);
		<s>.play(0);
		<s>.setz( this.getz() );
		<s>.hide();
		iNumItems++;
	}
	savestate(string sfilepref)	{
		arPocket.vecsave( "saves/" + this+sfilepref + "_name.txt" );
		arPocketFile.vecsave( "saves/" + this+sfilepref + "_file.txt" );
	}
	loadstate(string sfilepref)	{
		new vector vpcp;	vpcp.type("string");
		new vector vpcf;		vpcf.type("string");
		vpcp.vecload( "saves/" + this+sfilepref + "_name.txt" );
		vpcf.vecload( "saves/" + this+sfilepref + "_file.txt" );
		for( int i=0; i< vpcp.size; i++)	.additem( vpcp.get(i), vpcf.get(i) );
		delete vpcp;
		delete vpcf;
	}
	removeitem(string sname)	{
		@id = arPocket.find(sname.strsubbs(_sbase));
		if( id<0 ) return;
		arPocket.removeat(id);
		arPocketFile.removeat(id);
		this.remove( sname );
		delete <sname>;
		iNumItems--;
		if ( sState == "opened" ){	this.hide();	}
	}
	useitem()	{
		if( sItem!=null )	{
			this.removeitem( sItem );
			this.itemhide();
		}
	}
	pckremove(string sname)	{	.removeitem( _sbase + sname );	}
	evalpocket(){
		this.play();
		if ( sState == "open" ){
			iScale+=16;
		} else if ( sState == "close" ){
			iScale-=16;
		}
		if ( iScale > 116 ){
			this.stop(false);
			iScale = 116;
			sState = "opened";
		} else if ( iScale < 0 ){
			this.stop(false);
			iScale = 0;
			sState = "closed";
		}
		real dRadius = (iScale * iScale )/550;
		//real dRadius = iScale.sqrt(iScale)*2;
		real dAngle;
		string s;
		for (int i=0; i< iNumItems; i++){
			dAngle = dRadius*i-(dRadius*iNumItems/2.0) -90.0 + dRadius/2;
			s = this.get(i);
			<s>.setpos( dAngle.cos() * iScale + iX - 76/2, dAngle.sin() * iScale + iY - 75/2 );
			//<s>.show();
			if( <s>.isvisible )
				<s>.play(0);
		}
		if ( sState == "closed" ){
			this.hide();
		}
	}
	pocketpos(int x, int y)	{
		int ix = x-iX;
		int iy = y-iY;
		this.move(ix,iy);
		iX=x;
		iY=y;
	}
	pockettoggle(){
		if ( sState == "opened" ){
			sState = "close";
			immarker.hide();
			tim.play();
		} else if ( sState == "closed" ){
			sState = "open";
			if( arPocket.size > 0 )
				_fx_pocket.play;
			iX = <_sanim>.getposx();
			iY = <_sanim>.getposy()-<_sanim>.geth()/2;
			this.itemhide();
			this.show();
			tim.evalpocket();
			tim.play();
		} else if ( sState == "open" ){
			sState = "close";
		} else if ( sState == "close" ){
			sState = "open";
		}
	}
	string getitem()	{	return sItem!=null ? sItem.strsubbs(_sbase) : null;	}
	itemhide(){
		sFocusItem = null;
		sItem = null;
		imitem.stop(false);
		imitem.hide();
		sItemMover = null;
	}
	printstate	{
		sState.print;
		bskip.print;
	}
	itemclick()	{
		this.skip();
		if ( sState == "closed" ){
			this.pockettoggle();
		} else if ( sState == "opened" ){
			if ( sFocusItem != null ){
				if( sItem!=null )	{
					.pockettoggle;
					_b_rewind = !.playbehif( "beh_"+_sanim+"_USE_"+sItem.strsubbs(_sbase)+"_ON_"+sFocusItem.strsubbs(_sbase) );
					.itemhide;
				} else {
					sItem = sFocusItem;
					imitem.copy(sItem);
					<sFocusItem>.hide();
					//imitem.play("out");
					imitem.play(1);
					imitem.setz( this.getz() + 1 );
					this.setitempos();
					sItemMover = this;
					//this.pockettoggle();
				}
			} else {
				this.pockettoggle();
			}
		} else if ( sState == "open" ){
			this.pockettoggle();
		} else if ( sState == "close" ){
			this.pockettoggle();
		}
	}
	preparetosort(int x, int y)	{
		int id = gmimgvec::isin(x,y,1,1);
		if( id==0 )	{
			.setz( <_sanim>.getz );
		}
	}
	endsort	{	.setz(_ipcz);	}
	int butisin(int x, int y, bool bignorehidden, bool bignorealpha)	{
		int id = gmimgvec::isin(x,y,bignorehidden,bignorealpha);
		if( id )	{
			sFocusItem = this.get( id-1 );
		} else {
			sFocusItem = null;
			id = <_sanim>.isin(x,y,bignorehidden,bignorealpha);
		}
		return id;
	}
	hide	{
		.eval1("stop",false);
		.eval("hide");
		immarker.hide;
	}
	setitempos()	{
		imitem.setpos( mouse.getpx()-76/2, mouse.getpy()-75/2 );
	}
	itemmoveoff()	{
		if ( sState == "opened" ){
			immarker.hide();
		}
	}
	itemmoveon()	{
		if ( sState == "opened" ){
			if (sFocusItem != null){
				immarker.show();
				immarker.setpos( <sFocusItem>.getcx-immarker.getw/2, <sFocusItem>.getcy-immarker.geth/2 );
			} 
		}
	}
	checkusebutton(string sbut, string splay)	{
		if( .behexist("beh_"+_sanim+"_USE_"+sItem.strsubbs(_sbase)+"_ON_"+<sbut>.getbutname) ||
		 (sFocusItem != null && .behexist("beh_"+_sanim+"_USE_"+sItem.strsubbs(_sbase)+"_ON_"+sFocusItem.strsubbs(_sbase)) ) )
			advmouse.<splay>;
	}
	// classadvbut
	moveon()	{
		if( sItemMover==null )	{
			if( .ismainhero || .behexist("beh_"+.getmainhero+"_OPERATE_"+_sanim) )	{
				advmouse.setactive();
			}
		} else {
			<sItemMover>.checkusebutton(this, "setactive");
		}
	}
	// 
	onmouselclick(int x, int y)	{
		if(bskip)	{
			bskip=false;
			if( sItem!=null && sState=="opened" && sFocusItem==null) .pockettoggle;
		} else {
			if( .ismainhero )
				sState=="opened" || sState=="open"  ? this.pockettoggle() : this.itemhide();
		}
	}
	onmouserclick(int x, int y)	{
		if( .butisin(x,y,true,true) )	{
			if( sState=="opened" && sFocusItem!=null )	{
				_ = .playbehif( "beh_"+_sanim+"_ITEM_"+sFocusItem.strsubbs(_sbase) );
				//.pockettoggle;
			} else if( .ismainhero ) {
				_ = .playbehif( "beh_RCLICK_"+_sanim );
			}
		}
	}
	onmousemove(int x, int y)	{
		if ( sItem != null ){	this.setitempos();	}
		if ( sState == "opened" && this.butisin(x,y,true,true) )	{
			this.itemmoveon();
		}
	}
	/**************** button **********/
	moveoff()	{
		advmouse.setstd();
		this.itemmoveoff();	
	}
	ismainhero	{	.getmainhero == _sanim;	}
	clickon()	{
		if( .ismainhero )	{
			//.skipitem;
			clwalkq.stand;
			.itemclick;
		} else {
			clwalkq.visit( this );
		}
	}
}

/* 
	klasa oblugujaca postac z gry
	Dominik Dagiel 3 III 2006
*/

new db gdbsound;			// baza dialogow

new string _slhpref = "cllh";	// prefix do obiektu classloadedhero
new string _spathpref = "pt";	// prefix do obiektu classpathf
new string _spocketpref = "pc";	// prefix do pocket
new string _sstndpref = "stnd";	// prefix do standera
new string _stalkpref = "ctlk";

new bool AdventureGame;

public advgetscreenshoot	{
	<gameapi.getgamename>.cgetscreenshoot(.getsavepath + "slot" + PrzygodaNumer + ".bmp", 0.3);
}

module modadv	{
	init()	{
		new db dbload;
		new string stalktype;
		this.settalktype("snd");
		new Script scrl(null);
		new string _stalk;
	}
	/********************************/
	public execute(string sfunc)		{	scrl.call(sfunc);		}
	public loadscript(string sfile)		{	scrl.load(sfile);			}
	/********************************/
	public loadsounds(string sfile)	{
		gdbsound.load(sfile);
		if( igmdebug )	{
			gdbsound.save( "exports/adv.dlg" );
		}
	}
	public string gettalktype()	{	stalktype;	}
	public settalktype(string s)	{	stalktype=s;	}
	/********************************/
	public load(string sfile)			{
		dbload.loadscript(sfile);
		_stalk = this.get("talk:",1);
	}
	public string get(string styp, int ipos)	{
		int id = dbload.findbyrow(styp);
		if( id<0 )	{
			engine.print("modadv.dbload: can't find "+styp);
			null;
		} else
			dbload.get( id, ipos );
	}
}

module modadvglob	{
	init()	{
		new gmobjvec grhero;
		new gmobjvec grfiles;
		new gmobjvec grpck;
	}
	bool addhero(string sname, string sfile, bool bpocket)	{
		clsave.set("hero_"+sname+"_active",1);
		int id = grhero.find(sname);
		if( id>=0 ) {
			if( grfiles.get(id)!=sfile )	{
				grfiles.set(id, sfile);
				<sname>.load( .getpath(sfile) );
			}
			<sname>.addtogamevars(sname);
			if( bpocket )
				<_spocketpref+sname>.addtoadv();
			false;
		} else {
			this.newanima(sname,sfile,0);
			<sname>.addtogamevars(sname);
			grhero.add(sname);
			grfiles.add(sfile);
			if( bpocket )	{
				string s = _spocketpref+sname;
				if( !.hasvar(s) )	{
					new classadvpocket <s>(sname);
					//<s>.addtogamevars(s);
					grpck.add(s);
					<s>.addtoadv;		// kolejny raz dodaje do advcontroller
					//<s>.enable;
				} else	{
					<s>.addtoadv;
				}
			}
			true;
		}
	}
	reloadhero(string sname)	{
		int id = grhero.find(sname);
		if( id>=0 )	{
			string s = grfiles.get(id);
			._delhero(sname, false);
			_ = .addhero(sname, s, false);
		}
	}
	delhero(string sname)	{	._delhero(sname, true);	}
	delheros	{	while( grhero.size )	.delhero(grhero.first);	}
	_delhero(string sname, bool bdelpck)	{
		clsave.set("hero_"+sname+"_active",0);
		int id = grhero.find(sname);
		if(id>=0)	{
			/*delete <sname>;
			grhero.removeat(id);
			grfiles.removeat(id);**/
			/*if( <gameapi.getgamename>.hasvar("clcamera") )	{
				clcamera.remove(sname);
			}*/
			/*sname = _spocketpref + sname;
			if( this.hasvar(sname) && bdelpck)	{
				delete <sname>;
				grpck.remove(sname);
			}*/
			string sname2 = _spocketpref + sname;
			if( this.hasvar(sname2) && bdelpck)	{
				grpck.remove(sname2);
				<sname2>.removefromadv;
				delete <sname2>;
				//("deleted "+sname2)->print;
			}
			grhero.removeat(id);
			grfiles.removeat(id);
			delete <sname>;
			//("deleted "+sname)->print;
		}
	}
	savepck(string s)	{
		grpck.vecsave("grpck_"+s+".txt");
		for( int i=0; i<grpck.size; i++)	{	<grpck.get(i)>.savestate(s);	}
	}
	loadpck(string sfile)	{
		@s2, @s;
// 		engine.setdebugstate(1);
		for( int i=0; i< grpck.size; i++)	{
			s2 = grpck.get(i);
			<s2>.removefromadv;
			delete <s2>;
		}
		grpck.vecload("grpck_"+sfile+".txt");
		for( i=0; i<grpck.size; i++)	{
			s2 = grpck.get(i);
			new classadvpocket <s2>( s2.strsubbs(_spocketpref) );
			<s2>.loadstate(sfile);
			<s2>.removefromadv;
		}
	}
	onexit()	{
		string s;
		for( int i=0; i<grhero.size(); i++)	{
			s = grhero.get(i);
			<s>.stop(false);
			<s>.hide();
			if( .hasvar(_spocketpref+s) )	<_spocketpref+s>.exitpocket;
			s = _spathpref + s;
			<s>.unlinkanima();
		}
	}
	print	{
		grhero.print;
		grfiles.print;
		grpck.print;
	}
}

class classloadedhero	{
	init()	{
		new string sanhero;
		new bool bplaystart = false;
		new bool bplaystop = false;
	}
	public setplaystart(bool b)	{	bplaystart = b;	}
	public setplaystop(bool b)	{	bplaystop = b;	}
	public getstartstop()	{	return bplaystart, bplaystop;	}
}

class classadvcontroller : classadv	{
	init()	{
// 		new TicksCounter ctc;
		AdventureGame = true;
		
		classadv::init();
		
// 		engine.setdebugstate(1);
		
		//this.setwavpath( modadv.get("sndpath:", 1) );
		.setwavpath(SNDPATH);
		
		new snd __sndplay	{
			.vars2(A,"sfun", null,"sob",null);
			.setstartstopflag(false, true);
			.addmethod("onfinish", func {	.callfun(sob, sfun);	} );
		};
		
		.advsetstdstate;
		
// 		new string _slhpref = "cllh";	// prefix do obiektu classloadedhero
// 		new string _spathpref = "pt";	// prefix do obiektu classpathf
// 		new string _spocketpref = "pc";	// prefix do pocket
// 		new string _sstndpref = "stnd";	// prefix do standera
// 		new string _stalkpref = "ctlk";
		
		new classstndgroup modstnd;
		new Music _music;
		_music.smixer = ("engine");
		
		new timer _tim_dbclk;
		_tim_dbclk.setdelay(200);
		
		new int _if_pos = -1;
		
		new classobjcounter clcbeh("_dbbh");		// prefix do bazy danych bahaviourow
		
		new string _sbeh = "clbeh";	// prefix obiektu behaviour
		new int iidbeh;		// id behavioura niedeklarowanego poprzez nazwe
		
		new classobjcounter clcadv("dbadv");	// bazy danych z przygoda
		
		new db dbmacros;
		new vector _vecarg;	// argumenty wolania makr
		_vecarg.type("string");
		
		new classadvcamera clcamera;	// kamera
		clcamera.setmetonmsmove("advmsmove");
		
		new classwalkerqueue clwalkq;	// kolejnosc chodzenia
		
		new gmadvvec grbuts;		// obiekty do analizowania (buttons)
		new gmimgvec grmsmove;		// kieszenie bohaterow i inne do move
		new gmimgvec grmslclick;
		new gmimgvec grmsrclick;
		new gmimgvec grmslrel;
		
		new gmobjvec grsndsrcs;		// dzwieki odleglosciowe
		new classobjcounter csndsrc("csndsrc");
		.cycle = ("_timsndsrc", func {
			grsndsrcs.eval( func {
				int cx;
				int cy;
				@s = .getmainhero;
				if( s==null )	{
					cx = iResX/2;
					cy = iResY/2;
				} else {
					cx = <s>.getposx;
					cy = <s>.getposy;
				}
				real len;
				if( slinkedobj=="-pos" )	{
					len = len.length(iobjx-cx+clcamera.getposx, iobjy-cy+clcamera.getposy);
				} else {
					len = len.length( <slinkedobj>.getcx-cx, <slinkedobj>.getcy-cy );
				}
				//SoundSource::setvol(slinkedfx, <slinkedfx>.getvol, ioutervol, rradious, len);
				SoundSource::setvol(slinkedfx, imaxvol, ioutervol, rradious, len);
				//setvol(string ssnd, int srcvol, int outvol, real rad, real length)	{
				} );
			.play;
			} );
		_timsndsrc.play;
		
		new string _susetool = null;
		new string _slastms = null;
		new bool _b_rewind = true;
		
		new string sactbeh = null;		// aktualny beh
		new string slastpathf;		// ostatni pathfinder to podawania pozycji buttonow
		
		new int licznik=0;
		
		new string smainhero = null;
		
		.advsaveonstart;
		
		if( sgmgame==null )	{
			sgmgame = this.getname();
		}
		new string sprivgame = sgmgame;
		sgmgame = null;
	}
	initadventure	{	// wydzielone, zeby moc zaimplementowac metode w klasach dziedziczacych
		string s, string s2;
		s2 = sprivgame.strsubbs("game");
		if( sgmglobpath!=null )	{
			s = sgmglobpath;
			sgmglobpath = null;
		} else {
			s = s2;
		}
		this.setgraphpath("scripts/" + s + "/" );
		this.loadadventure( s2 + ".adv");
		grbuts.sortimgs();
		
		if( smainhero==null )	{	smainhero = clcamera.getactor();	}
		
		clcamera.start();
		clcamera.setscene();
		clwalkq.start();
		clwalkq.setverlen(1);
		
		advmouse.setstd();
		
		//.playbehoninit;
		
		grbuts.sortimgs();
		
		.cycle = ("_advtimmove", func { .advbutrefresh; .play; } );
		_advtimmove.play;
	}
	public playbehoninit	{
		if( .behexist("preinit") )	{
			.playbehobfin("preinit", this, "playbehinit");
		} else .playbehinit;
	}
	public playbehinit	{
		if ( clsave.bis(sprivgame+"visited") ){
			if ( this.playpostinit( "behinit_FROM_" + sgmlastscene ) )	{
			} else if ( this.playpostinit( "behinit" ) )	{
			}
//			else <gameapi.getgamename()>.postinit();
		} else {
			clsave.bset(sprivgame+"visited");
			if( this.playpostinit( "behinit0_FROM_" + sgmlastscene ) )	{}
			else if ( this.playpostinit( "behinit0" ) )	{}
			else if ( this.playpostinit( "behinit_FROM_" + sgmlastscene ) )	{}
			else if ( this.playpostinit( "behinit" ) )	{}
//			else <gameapi.getgamename()>.postinit();
		}
	}
	public getmainhero()	{
		smainhero;
	}
	public setmainhero(string s)	{
		smainhero=s;
	}
	public bool ismainhero(string s)	{	smainhero==s;	}
	public setactbeh(string s)	{	sactbeh = s;	}
	public string getactbeh()	{	sactbeh;	}
	public skipactbeh	{
		if( .getactbeh!=null )
			<.getactbeh>.skip;
	}
	public setusetool(string s)	{	_susetool=s;	}
	public getusetool()	{	_susetool;	}
	public ishintablebut	{
		bautohint && (.isvisible || .ismask || bshownonvis);
	}
	/********************************/
	bool playpostinit( string sbeh ){ 
		this.playbehobfinif( sbeh, gameapi.getgamename(), "postinit");
	}
	public playbeh(string sname)	{
		this.playbehfin(sname,null);
	}
	public bool playbehif(string sname)	{
		if ( this.behexist( sname ) ){
			this.playbehfin(sname,null);
			true;
		} else
			false;
	}
	public playbehfin(string sname, string sfunfin)	{
		this.playbehobfin(sname,null,sfunfin);
	}
	public bool playbehfinif(string sname, string sfunfin)	{
		if ( this.behexist( sname ) ){
			this.playbehfin(sname,sfunfin);
			true;
		} else
			false;
	}
	public playbehobfin(string sname, string sobfin, string sfunfin)	{
		<this.getbeh(sname)>.playfin(sobfin, sfunfin);
	}
	public bool playbehobfinif(string sname, string sobfin, string sfunfin)	{
		if ( this.behexist( sname ) ){
			this.playbehobfin(sname,sobfin,sfunfin);
			true;
		} else
			false;
	}
	public playnewgamepath(string sgame, string spath)	{
		sgmglobpath = spath;
		sgmlastscene = sprivgame;
		clsave.set("lastscene", sgmlastscene);
		gameapi.play(sgame);
	}
	public playnewgame(string sgame)	{
		this.playnewgamepath(sgame, null);
	}
	public playfromscript(string spath, string sgame)	{
		sgmgame = sgame;
		this.playnewgamepath( modadv.get("defaultadv:",1), spath );
	}
	/********************************/
	string getheroloader(string swavbase)	{
		swavbase = _slhpref + swavbase;
		engine.varexist(swavbase) ? swavbase : null;
	}
	/*********************************/
	public advanstand(string san)	{
		string s =  _spathpref + san;
		if( engine.varexist( s ) && <s>.iswalking() )	{
			<s>.stop(false);
			<s>.stand();
		}
	}
	public reloadhero(string sfile)	{
		.anreload(._getheropath(sfile));
		string sptf = _spathpref + this;
		<sptf>.linkanima(this);
		<sptf>.linkfilter;
		<sptf>.scalean;
	}
	analizeanopts(string sdb, int irow, int icol, int ilecol, string san, string sgrp, string styp)	{
		real r[2], string s1, string s2;
		bool b0 = false, bool b1 = false, int i[3], bool bfont=false;
		while( icol < ilecol )	{
			icol++;
			match(<sdb>.get(irow,icol-1))	{
				"-stt" => {	b0 = <sdb>.get(irow,icol);	icol++;	}
				"-stp"=> {	b1 = <sdb>.get(irow,icol);	icol++;	}
				"-wav"=> { s1 = _slhpref + <sdb>.get(irow,icol);	icol++;
					new classloadedhero <s1>;
					<s1>.varset( "sanhero", san );
					<sgrp>.add( s1 );
				}
				"-path" => {
					classadvanhero::buildheroframe(san);	// on end frame anputgr
					s1 = <sdb>.get(irow,icol);	icol++;	// pathfinder
					r0 = <sdb>.get(irow,icol);	icol++;	// step
					s2 = _spathpref+san;
					this.newclpathfcopy( s2, san, s1, r0);
					<s2>.prepareforhero();
					s1 = s2 + "look";	new classherolooker <s1>;	<s1>.link( san );
					s1 = s2 + "use";	new classherouser <s1>;		<s1>.link( san );
					s1 = s2 + "take";	new classherotaker <s1>;	<s1>.link( san );
				}
				"-ft"=> {	s2 = _spathpref+san;
					r0 = <sdb>.get(irow,icol);	icol++;	// z depth
					r1 = <sdb>.get(irow,icol);	icol++;	// scale power
					<s2>.linkfilter();
					<s2>.setzsize(r0);
					<s2>.setscalepower(r1);
				}
				"-stnd"=> { <_sstndpref+san>.setdelay(<sdb>.get(irow,icol)); icol++; }
				"-txt" => { i0 = <sdb>.get(irow,icol);	icol++;
					i1 = <sdb>.get(irow,icol);	icol++;
					i2 = <sdb>.get(irow,icol);	icol++;
					<_stalkpref+san>.settxtcolor(i0,i1,i2);
				}
				"-font" => {	bfont=true;
					s1 = <sdb>.get(irow,icol);	icol++;
					s2 = <sdb>.get(irow,icol);	icol++;
					if( styp=="hero:" )	{
						<_stalkpref+san>.setfont( s1, s2 );
					}
				}
				? => icol = this.analizeaninstr( sdb ,irow, icol-1, san);
			}
		}
		if( !bfont && styp=="hero:")	{
			<_stalkpref+san>.setfont( modadv.get("font:",1), modadv.get("font:",2) );
		}
		<sgrp>.eval1("setplaystart", b0 );
		<sgrp>.eval1("setplaystop", b1 );
		<sgrp>.free();
	}
	setasadvanima()	{
		classadvanhero::setashero( this.getname(), "cadvherofinish");
	}
	analizebut(string styp, string sdb, int irow, int icol)	{
		string s[3], int i[2];
		s0 = <sdb>.get(irow,icol);	icol++;	// nazwa
		s1 = <sdb>.get(irow,icol);	icol++;	// nazwa annki
		if( s1.contains(".pyz") )	{
			s2 = s1;
			s1 = "an" + s1.strsube(4);
			.newanima( s1, s2, 0);
		}
		styp = styp.strsube(1);
		//<"classadv"+styp.strsube(1)>::setasbutton(s1,s0);
		classadvbut::setasbutton2(s1, s0, styp);
		classadvbut::<"setas"+styp>(s1);
		<s1>.setadvbutpos( <s1>.getcx(), <s1>.getcy() );
		while( icol < <sdb>.getcolsno(irow) )	{
			icol++;
			match( <sdb>.get(irow,icol-1) )	{
				"-pos"=> {	s0 = <sdb>.get(irow,icol);	icol++;	// x
					s2 = <sdb>.get(irow,icol);	icol++;	// y
					if(s0=="-id" && slastpathf!=null)	{
						i0 = <slastpathf>.getbyname(s2);
						s0 = <slastpathf>.getxver(i0) - <slastpathf>.getposx();
						s2 = <slastpathf>.getyver(i0) - <slastpathf>.getposy();
					}
					<s1>.setadvbutpos(s0,s2);
				}
				"-bs1"	=> {	<s1>.setbutbase1( <sdb>.get(irow,icol) ); icol++;}
				"-bs2"	=> {	<s1>.setbutbase2( <sdb>.get(irow,icol) ); icol++;}
				"-us1" => {	<s1>.baseuse1=( <sdb>.get(irow,icol) ); icol++;}
				"-us2" => {	<s1>.baseuse2=( <sdb>.get(irow,icol) ); icol++;}
				"-useon"	=> {	<s1>.setbutbase1( modadv.get("use:",1) );
					<s1>.setbutbase2( modadv.get("use:",2) );
				}
				"-dir"	=> {	<s1>.setbutdir( <sdb>.get(irow,icol) ); icol++;}
				"-noreach"=> 	<s1>.setreach(false);
				"-nh" => <s1>.hideontake = (false);
				"-pck" =>  {	<s1>.setpocket( <sdb>.get(irow,icol) ); icol++;}
				"-mask" => { classadvbut::setasmask(s1); <s1>.hide;	}
				"-inpck" => {
					if( <s1>.hideontake )	{
						<s1>.hide();		// zabranie przedmiotu
					} else <s1>.setbuttyp("but");
					s0 = .getmainhero;
					if( s0==null ) s0 = clcamera.getactor;
					< <s0>.getpocket >.additem( <s1>.getbutname, <s1>.getpocket );
				}
				"-disable" => <s1>.disable;
				"-once" => {
					s0 = <sdb>.get(irow,icol);	icol++;
					<s1>.setonce( s0 );
					if( clsave.bis(s0) ) <s1>.disable;
				}
				"-cursor" => {
					s0 = <sdb>.get(irow,icol);	icol++;
					<s1>.smousecursor = (s0);
				}
				"-balpha" => {
					i0 = <sdb>.get(irow,icol);	icol++;
					<s1>.balpha = (i0);
				}
				"-noautohint" => <s1>.bautohint = (false);
				? => {
					icol = .subanalizebut( s1, sdb, irow, icol, <sdb>.get(irow,icol-1) );
				}
			}
		}
	}
	virtual int subanalizebut(string sbut, string sdb, int irow, int icol, string sord)	{ icol; }
	_getheropath(string s)	{
		string sp = .getpath(s);
		if( engine.fileexist(sp) )
			"$" + sp;
		else "$" + modadv.get("heropath:",1) + s;
	}
	public loadadventure(string sfile)	{
		string sdb = clcadv.get();
		string sgrp = "grpers"+clcadv.size();
		new db <sdb>;
		//<sdb>.loadbeh(this.getgraphpath()+sfile);
		<sdb>.loadbeh( .getpath(sfile) );
		int ile = <sdb>.getrowsno();
		int i[4], string s[3], bool b[2], bool bhero;
		real r[2];
		
		s0 = sdb + "script";
		new Script <s0>(sdb);
		
		string spath = "";
		new gmobjvec <sgrp>;
		for( int i=0; i<ile; i++)	{
			i0 =0 ;
			i1 = <sdb>.getcolsno(i);
			s0 = <sdb>.get(i,i0);	i0++;
			match(s0)	{
				"setpath:" => {
					spath = <sdb>.get(i,i0);	i0++;
					this.setgraphpath(spath);
				} "nopath:" => {
					spath = "";
					this.setgraphpath(spath);
				} "func"	=> {		// funkcja skryptu
					while( <sdb>.get(i,0)!="end" )	i++;
				} "sndpath:"	=> {
					s0 = <sdb>.get(i,i0);	i0++;
					this.setwavpath(s0);
				} "hero:", "an:"	=> {
					i2 = <sdb>.dbdelvar(i,"-global");
					i3 = <sdb>.dbdelvar(i,"-pck");
					s2 = <sdb>.get(i,i0);	i0++;	// anima
					if( s2.contains(".pyz") )	{
						s1 = s2;
						s2 = "an"+s2.strsubes(".pyz");
					} else {
						s1 = <sdb>.get(i,i0);	i0++;	// file
					}
					if( s0=="hero:" )	{
						/*if( s1.contains(".pyz") && !engine.fileexist(.getpath(s1)) )
							s1 = "$" + modadv.get("heropath:",1) + s1;*/
						if( s1.contains(".pyz") )	{
							s1 = ._getheropath(s1);
							//s1.print;
						}
					}
					if( s1.contains(".pyz") )	{
						if( i2 )	{
							if(modadvglob.addhero(s2,s1,i3))
								<s2>.setasadvanima();
							i1--;
						} else {
							this.newanima(s2, s1, 0);
							<s2>.setasadvanima();
							if( s0=="hero:" && i3)	new classadvpocket <_spocketpref + s2>(s2);
						}
					} else {
						this.copyanima(s1, s2);
						<s2>.setasadvanima();
						if( s0=="hero:" && i3)	new classadvpocket <_spocketpref + s2>(s2);
					}
					if(i3)	i1--;
					if( s0=="hero:" )	{
						new classadvstander <_sstndpref+s2>;
						//classadvanhero::buildheroframe(s2);
						
						//new classadvpocket <_spocketpref + s2>(s2);
						
						s1 = _stalkpref+s2;
						new classtalker <s1>;
						<s1>.set(s2);
						<s1>.settextdb("gdbsound");
					}
					this.analizeanopts(sdb, i, i0, i1, s2, sgrp, s0);
				} "rect:"	=>	{
					s0 = <sdb>.get(i,i0); i0++; // nazwa
					new ImgRect <s0>;
					s1 = <sdb>.get(i,i0);
					if( !StringChecker::isdigit(s1) )	{
						<s0> .= (s1);
						i0++;
					} else {
						<s0>.setrect( s1.to_r * igmappw, <sdb>.get(i,i0+1)->to_r * igmapph,
							<sdb>.get(i,i0+2)->to_r * igmappw, <sdb>.get(i,i0+3)->to_r * igmapph );
							i0+=4;
					}
				} "anaac:"	=>	{
					i2 = <sdb>.dbdelvar(i,"-mask");
					i3 = 0;
					s0 = <sdb>.get(i,i0);	i0++;	// anima
					if( s0.contains(".pyz") )	{
						s1 = s0;
						s0 = "an" + s0.strsubes(".pyz");
					} else {
						s1 = <sdb>.get(i,i0);	i0++;	// z ktorej..
					}
					if( i2 )	{
						i1--;
						new gmmaskvec <s0>;
					} else {
						new gmadvvec <s0>;
					}
					if( s1.contains(".pyz") )	{
						.newanima("_" + s0, s1, 0);
						s1 = "_" + s0;
						i3 = 1;
					}
					i2 = this.newanactionsgr(s1, s0, s0);
					i0 = this.analizeaninstr( sdb ,i, i0, s0);
					if( i3 ) <s1>.hide;
				} "anaf:"	=> {
					s0 = <sdb>.get(i,i0);	i0++;	// anima
					//s1 = <sdb>.get(i,i0);	i0++;	// z ktorej..
					if( s0.contains(".pyz") )	{
						s1 = s0;
						s0 = "an" + s0.strsubes(".pyz");
					} else {
						s1 = <sdb>.get(i,i0);	i0++;	// z ktorej..
					}
					new gmimgvec <s0>;
					if( s1.contains(".pyz") )	{
						.newanima("_" + s0, s1, 0);
						s1 = "_" + s0;
					}
					i2 = this.newanfrbyactgr(s1, s0, s0);
					i0 = this.analizeaninstr( sdb ,i, i0, s0);
				} "anfac:"	=> {
					i2 = <sdb>.dbdelvar(i,"-mask");
					s0 = <sdb>.get(i,i0);	i0++;	// anima
					if( i2 )	{
						i1--;
						new gmmaskvec <s0>;
					} else {
						new gmadvvec <s0>;
					}
					s1 = <sdb>.get(i,i0);	i0++;	// z ktorej..
					s2 = <sdb>.get(i,i0);	i0++;	// akcja
					i2 = this.newanframesgr(s1, s0, <s1>.actionnr(s2), s0);
					i0 = this.analizeaninstr( sdb ,i, i0, s0);
				} "anac:"	=> {
					i2 = <sdb>.dbdelvar(i,"-adv");
					s0 = <sdb>.get(i,i0);	i0++;	// anima
					s1 = <sdb>.get(i,i0);	i0++;	// z ktorej..
					s2 = <sdb>.get(i,i0);	i0++;	// akcja
					if( StringChecker::isdigit(s2) )	s2 = <s1>.nameofaction(s2);
					this.copyanimaact(s1, s0, s2);
					if( i2 )	{
						i1--;
						<s0>.setasadvanima();
					}
					i0 = this.analizeaninstr( sdb ,i, i0, s0);
				} "anf:" => {
					i2 = <sdb>.dbdelvar(i,"-mask");
					s0 = <sdb>.get(i,i0);	i0++;	// anima
					s1 = <sdb>.get(i,i0);	i0++;	// z ktorej..
					s2 = <sdb>.get(i,i0);	i0++;	// akcja
					i3 = <sdb>.get(i,i0);	i0++;	// klatka
					this.copyanima( s1, s0 );
					<s0>.setframe(s2,i3);
					if( i2 )	{
						i1--;
						<s0>.setasadvanima();
					}
					i0 = this.analizeaninstr( sdb ,i, i0, s0);
				} "anorder:" => {
					s0 = <sdb>.get(i,i0);	i0++;	// anima
					i0 = this.analizeaninstr( sdb ,i, i0, s0);
				} "behfile:" => {
					this.loadbehaviours( <sdb>.get(i,i0) );
					i0++;
				} "include:" =>	{	// another adv specification
					this.loadadventure( <sdb>.get(i,i0) );
					i0++;
				} "walkqueue:" => {
					while( i0<i1 )	{
						clwalkq.add( _spathpref + <sdb>.get(i,i0) );
						i0++;
					}
				} "font:" => {
					s0 = <sdb>.get(i,i0);	i0++;	// nazwa
					s1 = <sdb>.get(i,i0);	i0++;	// plik
					i2 = <sdb>.get(i,i0);	i0++;	// size
					new font <s0>;
					<s0>.load( s1, i2 );
				} "bkg:" => {
					s0 = <sdb>.get(i,i0);	i0++;	// plik
					//this.csetbkg(s0);
					if( s0.contains(".pyz") )	.newanima("imgbkg", s0, 0);
					else .newimg("imgbkg",s0,0);
				
					i0 = this.analizeaninstr( sdb ,i, i0, "imgbkg");
				} "img:" => {
					s0 = <sdb>.get(i,i0);	i0++;	// nazwa
					if( s0.gete(0,4)->in(A, ".jpg", ".png") )	{
						s1 = s0;
						s0 = "img" + s0.strsube(4);
					} else {
						s1 = <sdb>.get(i,i0);	i0++;	// plik
					}
					this.newimg(s0,s1,0);
					i0 = this.analizeaninstr( sdb ,i, i0, s0);
				} "but:", "doors:", "item:" => {
					this.analizebut(s0, sdb, i, i0);
				} "camera:" => {
					r0 = <sdb>.get(i,i0);	i0++;	// xmodfifier
					r1 = <sdb>.get(i,i0);	i0++;	// ymodifier
					clcamera.scalemodifiers(r0,r1);
					while(i0<i1)	{
						s0 = <sdb>.get(i,i0);	i0++;
						if( s0=="-size")	{
							i2 = <sdb>.get(i,i0);	i0++;
							i3 = <sdb>.get(i,i0);	i0++;
							clcamera.setborders( i2, i3 );
						} else if (s0=="-center")	{
							i2 = <sdb>.get(i,i0);	i0++;
							i3 = <sdb>.get(i,i0);	i0++;
							clcamera.setcenter( i2, i3 );
						} else if (s0=="-sizebg")	{
							clcamera.setborders(imgbkg.getw(), imgbkg.geth());
						} else if (s0=="-sizescreen")	{
							clcamera.setborders( igmappw, igmapph );
						}
					}
				} "actor:" => {	clcamera.setactor(<sdb>.get(i,i0)); i0++;
				} "bgr:" => {
					s0 = <sdb>.get(i,i0);	i0++;	// plan
					r0 = <sdb>.get(i,i0);	i0++;	// scalex
					r1 = <sdb>.get(i,i0);	i0++;	// scaley
					new classbgplan <s0>;
					clcamera.addbgr(s0, r0, r1);
				} "pathfinder:" => {
					slastpathf = <sdb>.get(i,i0);	i0++;	// nazwa
					s1 = <sdb>.get(i,i0);	i0++;	// file
					if( s1.contains(".ptf") )	{	
						i2 = 20;
						i3 = 20;
					} else {// znaczy, ze wgrywany z grafiki
						i2 = <sdb>.get(i,i0);	i0++;	// dx
						i3 = <sdb>.get(i,i0);	i0++;	// dy
					}
					this.newpathf(slastpathf, s1, i2, i3);
				} "script:" =>	{
					s0 = <sdb>.get(i,i0);	i0++;	// nazwa
					s1 = <sdb>.get(i,i0);	i0++;	// file
					new Script <s0>(s1);
				} "func:" => {		// wywolanie wewnetrznej funkcji
					s1 = <sdb>.get(i,i0); i0++;
					i1--;		// usuwamy nawiasy
					for(i2=clcadv.size-1; i2 >=0; i2--)	{
						s0 = clcadv.getid(i2) + "script";
						if( <s0>.containsfun(s1) )	{
							for(i2=3; i2< i1; i2++)
								<s0>.ARG = ( i2-3, <sdb>.get(i, i2) );
							i2 = -1;
							<s0>.call(s1);
						}
					}
				}
				"IF" => {
					_if_pos++;
					i = ._found_if(sdb, i, i0, i1);
				}
				"ELSE" => i = ._goto_fi(sdb, i+1);
				"FI" => {
					_if_pos--;
					if( _if_pos<-1 )	("FI error! "+this+"."+ .methodname)->print;
				}
				"bsave:" =>{ 	clsave.bset(<sdb>.get(i,i0)); i0++;}
				"save:" => {
					s0 = <sdb>.get(i,i0); i0++;
					s1 = <sdb>.get(i,i0); i0++;
					clsave.set(s0,s1);
				}
				"stdptf:" => {	slastpathf = <sdb>.get(i,i0); i0++;	}
				"sfxs:" => {
					while(i0<i1)	{
						s2 = <sdb>.get(i,i0);
						s0 = "fx" + s2;
						if( <sdb>.dbchecknext(i,i0)=="-f" )	{
							i0+=2;
							s2 = <sdb>.get(i,i0);	// file
						}
						i0++;
						.newsfx(s0, s2);
						i2=1;
						while(i2 && i0<i1)	{
							match(<sdb>.get(i, i0))	{
								"-v" => {
									i0++;
									<s0>.setvol( <sdb>.get(i,i0) );
								}
								"-l" => <s0>.addmethod("onfinish","_stdsndloop");
								"-p" => <s0>.play;
								"-pl","-lp","-n" => <s0>.playloop;
								"-tp" => <s0> { timpauza.play; };
								"-tp1" => <s0> { timpauza.bloop=(false); timpauza.play;	};
								"-t" => {
									i0++;
									<s0>.timer=("timpauza", <sdb>.get(i,i0), func {
										bool b = true;
										if( bfirst ) bfirst = false;
										else b = bloop;
										if( b )
											<.getbuildername>.play;
										} );
									<s0> {
										.addmethod("onfinish", func { timpauza.play; } );
										timpauza.vars2(A, "bloop", true, "bfirst", true);
									};
								}
								? => {
									i0--;
									i2 = 0;
								}
							}
							i0++;
						}
					}
				}
				"met:" => {
					s1 = <sdb>.get(i,i0); i0++;
					if( s1.contains(".") )	{
						s2 = s1.strgetto(".");
						s1 = s1.strgetfrom(".");
						if( s2=="" || s2=="this" ) s2 = gameapi.getgamename;
					} else
						s2 = gameapi.getgamename;
					if( s2==gameapi.getgamename )
						<s2>::<s1>;
					else <s2>.<s1>;
				}
				"sndsrc:" => {
					s2 = csndsrc.get;
					new int <s2>;
					<s2>.vars2(A, "slinkedfx",null, "ioutervol",0, "rradious",0.0, "slinkedobj",null,
						"iobjx",0, "iobjy",0, "imaxvol", 0);
					<s2>.slinkedfx = (<sdb>.get(i,i0)); i0++;
					<s2>.imaxvol = ( < <s2>.slinkedfx>.getvol );
					<s2>.ioutervol = (<sdb>.get(i,i0)); i0++;
					<s2>.rradious = (<sdb>.get(i,i0)); i0++;
					s1 = <sdb>.get(i,i0);	// obiekt
					<s2>.slinkedobj = (s1);
					if( s1=="-pos") {
						i0++;
						<s2>.iobjx = (<sdb>.get(i,i0)); i0++;
						<s2>.iobjy = (<sdb>.get(i,i0));
					}
					match( <sdb>.dbchecknext(i,i0) )	{
						"-v" => {
							i0+=2;
							<s2>.imaxvol = ( <sdb>.get(i,i0) );
						}
						? =>;
					}
					i0++;
					grsndsrcs.add(s2);
					//SoundSource::setvol(slinkedfx, ivolume, 0, rradious, ((iResX/2)-<slinkedobj>.getcx)->abs);
					_timsndsrc.stop(true);
				}
				? => {
					i0 = <gameapi.getgamename>.subloadadventure(sdb,i,i0, s0);
				}
			}
		}
		<sdb>.readonly();
	}
	virtual int subloadadventure(string sdb, int irow, int icol, string sord)	{ icol; }
	int _found_if(string sdb, int row, int col, int cols)	{
		col++;		// opusc nawias
		int i2 = 0;
		bool odp = 0;
		cols--;
		string s[2];
		while( col<cols )	{
			s0 = <sdb>.get(row, col);
			s1 = <sdb>.dbchecknext(row, col);
			match(s1)	{
				")","|", "&" => {
					//odp = ._check_if(i2, odp, s0.getb(0,1)=="!" ? (!clsave.bis(s0.strsubb(1))) : clsave.bis(s0) );
					odp = ._check_if(i2, odp, (s0.getb(0,1)=="!" ? (!._check_if_var(s0.strsubb(1), true)) : ._check_if_var(s0, true) ) );
					if( s1=="|" ) i2 = 1;
					else if (s1=="&") i2 = 2;
				}
				"=" => {
					col+=2;
					//odp = ._check_if(i2, odp, clsave.is(s0, <sdb>.get(row, col)) );
					odp = ._check_if(i2, odp, ._check_if_var(s0, <sdb>.get(row, col)) );
					i2 = ._check_if2( <sdb>.dbchecknext(row, col) );
				}
				"!=" => {
					col+=2;
					odp = ._check_if(i2, odp, !._check_if_var(s0, <sdb>.get(row, col)) );
					i2 = ._check_if2( <sdb>.dbchecknext(row, col) );
				}
				"<" => {
					col+=2;
					odp = ._check_if(i2, odp, ._check_if_lessvar(s0, <sdb>.get(row, col)) );
					i2 = ._check_if2( <sdb>.dbchecknext(row, col) );
				}
				">" => {
					col+=2;
					odp = ._check_if(i2, odp, ._check_if_greatervar(s0, <sdb>.get(row, col)) );
					i2 = ._check_if2( <sdb>.dbchecknext(row, col) );
				}
				"<=" => {
					col+=2;
					odp = ._check_if(i2, odp, ._check_if_lesseqvar(s0, <sdb>.get(row, col)) );
					i2 = ._check_if2( <sdb>.dbchecknext(row, col) );
				}
				">=" => {
					col+=2;
					odp = ._check_if(i2, odp, ._check_if_greatereqvar(s0, <sdb>.get(row, col)) );
					i2 = ._check_if2( <sdb>.dbchecknext(row, col) );
				}
				? => ;
			}
			col+=2;
		}
		if( !odp )	{
			._goto_fi(sdb, row+1);
		} else row;
	}
	_check_if_var(string svar, string sval)	{ svar.getb(0,1)=="." ? <gameapi.getgamename>.<svar.strsubb(1)> == sval : clsave.is( svar, sval ); }
	_check_if_lessvar(string svar, string sval)	{ clsave.get(svar)->to_r < sval.to_r; 	}
	_check_if_greatervar(string svar, string sval)	{ clsave.get(svar)->to_r > sval.to_r; }
	_check_if_lesseqvar(string svar, string sval)	{ clsave.get(svar)->to_r <= sval.to_r; }
	_check_if_greatereqvar(string svar, string sval)	{ clsave.get(svar)->to_r >= sval.to_r; }
	_goto_fi(string sdb, int row)	{
		int poz = _if_pos;
		while( 1 )	{
			match( <sdb>.get(row,0) )	{
				"IF" => poz++;
				"ELSE" => if( poz==_if_pos ) return row;	// for robi potem i++
					//else poz--;
				"FI" => if( poz==_if_pos ) {
						_if_pos--;
						return row;	// for robi potem i++
					} else poz--;
				? => ;
			}
			row++;
		}
	}
	int _check_if2(string s)	{
		match(s)	{
			"|" => 1;
			"&" => 2;
			? => 0;
		}
	}
	bool _check_if(int opt, bool b, bool bnew)	{
		match( opt )	{
			1 => b || bnew;
			2 => b && bnew;
			? => bnew;
		}
	}
	behrewind()			{	if( sactbeh!=null )	<sactbeh>.rewind();	}
	bool behplaying()		{	sactbeh!=null;	}
	bool behempty			{	sactbeh==null;	}
	bool behexist(string sname)	{	engine.varexist( this.getbeh(sname) );	}
	string getbeh(string sname)	{	_sbeh+sname;	}
	string newbehname()	{
		string s = _sbeh + "_" + iidbeh;
		iidbeh++;
		s;
	}
	string newbeh()	{
		string s = this.newbehname();
		new classbehhero <s>;
		s;
	}
	def _checkvol(string sdb,int irow, int id)	{
		if( <sdb>.dbchecknext(irow, id)=="-v" )	{
			id+=2;
			return <sdb>.get(irow, id), id+1;
		} else return 100, id+1;
	}
	loadbeh(string sdb, int irow, int icol, int id, string sstarter, string sprevobj, bool brand, bool bpar)	{
		string s[4], bool bblock = <sstarter>.getblock(), bool bread;
		s0 = <sdb>.get(irow,id);	id++;
		s1 = this.newbeh();
		int i[2];
		match(s0)	{
			"IF", "ELIF" => {
				i0 = id+1;
				while( <sdb>.get(irow, id)!=")" ) id++;
				<s1>.<"setas"+s0>(sdb, irow, i0, id);
				id++;
			}
			"FI", "ELSE" => <s1>.setas(s0);
			"call:" => {	s0 = <sdb>.get(irow,id);	id++;
				<s1>.setascaller( s0, sdb+"script" );
			}
			"walk:" => {	s0 = <sdb>.get(irow,id);	id++;	// kto
				s2 = <sdb>.get(irow,id);	id++;	// destx lub "id"
				s3 = <sdb>.get(irow,id);	id++;	// desty lub idpath
				<s1>.setaswalker( _spathpref + s0, s2, s3 );
			}
			"turn:" => {	s0 = <sdb>.get(irow,id);	id++;	// kto
				s2 = <sdb>.get(irow,id);	id++;	// dir
				<s1>.setasturn( _spathpref + s0, s2 );
			}
			"setpos:" => {	s0 = <sdb>.get(irow,id);	id++;	// kto
				s2 = <sdb>.get(irow,id);	id++;	// id lub x
				i1 = <sdb>.get(irow,id);
				i0 = 0;
				s3 = <sdb>.dbchecknext(irow,id);
				if( s3=="-ssc" )	{
					i0 = 1;
					id++;
					s3 = <sdb>.dbchecknext(irow,id);
				}
				if( s3=="-dir" )	{
					id+=2;
					s3 = <sdb>.get(irow, id);
				} else {
					s3 = "auto";
				}
				id++;
				<s1>.setasposer( s0, s2, i1, i0, s3 );
			}
			"game:" => {	s0 = <sdb>.get(irow,id);	id++;	// nazwa gry
				match( s0 )	{
					"-def", "-adv" => {
						<s1>.setasnewgamer(s0, <sdb>.get(irow, id), <sdb>.get(irow, id+1) );
						id+=2;
					}
					? => <s1>.setasnewgamer(null, null, s0);
				}
			}
			"ref:" => {		id = this.buildbeh( "_" + iidbeh, sdb, irow, id );
				s0 = this.newbehname();
				<s1>.setascaller( s0.strsubbs(_sbeh), sdb+"script" );
			}
			"anplay:" => {	s0 = <sdb>.get(irow,id);	id++;
				s2 = <sdb>.get(irow,id);	id++;
				<s1>.setasanplayer(s0, s2);
			}
			"anfin:" => {	s0 = <sdb>.get(irow,id);	id++;
				i0 = <sdb>.get(irow,id);	id++;
				<s1>.setasanfin(s0, i0);
			}
			"anfout:" => {	s0 = <sdb>.get(irow,id);	id++;
				i0 = <sdb>.get(irow,id);	id++;
				<s1>.setasanfout(s0, i0);
			}
			"anorder:" =>	{	s2 = <sdb>.get(irow,id);	id++;
				<s1>.setasanorder(sdb, irow, id, s2);
				id = this.analizeaninstr(sdb,irow,id,null);
			}
			"sndbg:" =>	{	s0 = <sdb>.get(irow,id);
				|i0, id| = ._checkvol(sdb,irow,id);
				<s1>.setassndbg(SNDPATH + s0, i0);
			}
			"sndplay:" =>	{	s0 = <sdb>.get(irow,id);
				|i0, id| = ._checkvol(sdb,irow,id);
				<s1>.setassndplayer(SNDPATH + s0, i0);
			}
			"fxplay:" => 	{	s0 = <sdb>.get(irow,id);
				|i0, id| = ._checkvol(sdb,irow,id);
				<s1>.setassndplayer(SFXPATH + s0, i0);
			}
			"fxbg:" => 	{	s2 = <sdb>.get(irow,id);
				|i0, id| = ._checkvol(sdb,irow,id);
				<s1>.setassndbg(SFXPATH + s2, i0);
			}
			"wait:" =>	{	i0 = <sdb>.get(irow,id);	id++;
				<s1>.setaswaiter(i0);
			}
			"read:" =>	{	s0 = <sdb>.get(irow,id);	id++;	// plik
				i0 = <sdb>.get(irow,id);	id++;	// x
				i1 = <sdb>.get(irow,id);	id++;	// y
				s2 = "auto";
				if( <sdb>.getcolsno(irow)>id )	{
					s2 = <sdb>.get(irow,id);
					if( s2=="-dir" )	{
						id++;
						s2 = <sdb>.get(irow,id); id++;
					}
				}
				<s1>.setasreader(s0,i0,i1,s2);
			}
			"met:" =>	{
				s0 = <sdb>.get(irow,id);	id++;
				s3 = gameapi.getgamename;
				@styp = null;
				if( s0.contains(".") )	styp = ".";
				if( s0.contains("::") )	styp = "::";
				if( styp!=null )	{
					s2 = s0.strgetto(styp);
					s0 = s0.strgetfrom(styp);
					if( s2=="" || s2=="this" ) s2 = s3;
				} else
					s2 = s3;
				s3 = <sdb>.dbchecknext(irow,id-1);
				if( s3=="(" )	{
					id++;
					i0=id;
					s3 = <sdb>.get(irow,id);
					id++;
					while( s3!=")" )	{
						s3 = <sdb>.get(irow,id);
						id++;
					}
				} else i0 = -1;
				<s1>.setasmet(s2, s0, styp, sdb, irow, i0 );
			}
			"bsave:" =>	{	s0 = <sdb>.get(irow,id);	id++;
				<s1>.setassaver(s0,"1");
			}
			"save:" =>	{	s0 = <sdb>.get(irow,id);	id++;
				s2 = <sdb>.get(irow,id);	id++;
				<s1>.setassaver(s0,s2);
			}
			"script:" =>	{	s0 = <sdb>.get(irow,id);	id++;
				s2 = <sdb>.get(irow,id);	id++;
				<s1>.setasscript(s0,s2);
			}
			"func:" =>	{
				s2 = <sdb>.get(irow,id);
				
				for(i1=clcbeh.size-1; i1 >= 0; i1--)	{
					s0 = clcbeh.getid(i1) + "script";
					if( <s0>.containsfun(s2) )	{
						i1 = -1;
					}
				}
				//s0 = sdb + "script";
				
				if( <sdb>.dbchecknext(irow,id)=="(" )	{
					i1 = id+2;
					while( <sdb>.get(irow,id)!=")" ) id++;
				} else {
					i1 = -1;
				}
				id++;
				<s1>.setasscript(s0,s2, sdb, irow, i1);
			}
			"use:" => {	s0 = <sdb>.get(irow,id);	id++;
				<s1>.setasuse(s0);
			}
			"topck:" => {
				s2 = <sdb>.get(irow,id);	// przedmiot
				if( <sdb>.dbchecknext(irow,id)=="-pck" )	{
					id+=2;
					s3 = <sdb>.get(irow,id);
				} else s3 = s2;
				id++;
				<s1>.setastopck(s2, s3);
			}
			"enter:"	=> <s1>.setasenter;
			"close:"	=> <s1>.setasclose;
			"music:"	=> {
				i1 = id+1;
				while( <sdb>.get(irow,id)!=")" ) id++;
				<s1>.setasmusic(sdb, irow, i1, id);
				id++;
			}
			"return" => <s1>.setasreturn;
			? => {
				i1 = .subloadbeh(s0, s1, sdb, irow, id);
				if( i1>=id )	{
					id = i1;
				} else {		// talker
					s3 = s0.strgetto("_");
					s2 = this.getheroloader( s3 );
					if( s2==null )	{
						if( igmdebug ) engine.print(s1+": "+s0+" loadbeh error: no hero linked to "+s3);
						return s1, icol;
						//<s1>.setassndplayer(s0);
					} else {
						|bool bstart, bool bstop| = <s2>.getstartstop();
						string sdir="auto", string sbase=modadv.varget("_stalk"), int itypsort=1;
						bread = id<icol;
						while(bread)	{
							s3 = <sdb>.get(irow,id);	id++;
							match(s3)	{
								"-stt" =>	{	bstart = <sdb>.get(irow,id);	id++;}
								"-stp"=>	{	bstop = <sdb>.get(irow,id);	id++;}
								"-base"=>	{	sbase = <sdb>.get(irow,id);	id++;}
								"-r" =>	itypsort=1; 
								"-nr" =>	itypsort = 0;
								"-dir" =>	{	sdir = <sdb>.get(irow,id);	id++;}
								? => {	bread = false;	id--;	}
							}
							if( bread && id>=icol )	{
								bread = false;
							}
						}
						<s1>.setastalker( <s2>.varget("sanhero"), SNDPATH+s0, sbase,
							itypsort, bstart, bstop, sdir );
						
					}
				}
			}
		}
		<sstarter>.addtostarter( s1 );
		
		if( brand==false)	{
			<sprevobj>.setflags(s1);
			<s1>.addflags( sstarter, bblock, bpar );
		} else {
			<sprevobj>.setflags(null);
			<s1>.addflags( sstarter, bblock, false );
		}
		/*if( id < icol )	{
			this.loadbeh(sdb,irow,icol,id,sstarter,s1,brand, bpar);
		}*/
		return s1, id;
	}
	virtual int subloadbeh(string sord, string sbeh, string sdb, int irow, int icol)	{
		icol;
	}
	int buildbeh(string sname, string sdb, int irow, int icol)	{
		int id = dbmacros.findbyrow( <sdb>.get(irow, icol) );
		if( id<0 )	{
			engine.print("no such macro: "+ <sdb>.get(irow, icol) );
			return -1;	
		}	// nie ma takiego makra
		while( <sdb>.get(irow, icol) != "(" )	{	icol++;	}
		icol++;
		int id2 = <sdb>.addrow() -1;
		string s = <sdb>.get( irow, icol ); icol++;
		_vecarg.free();
		while( s!=")" )	{		// sczytanie argumentow
			_vecarg.add( s );
			s = <sdb>.get( irow, icol ); icol++;
		}
		int ile = dbmacros.getcolsno( id );
		int i1;
		<sdb>.add( id2, sname );
		string s2;
		for( int i=1; i<ile; i++)	{
			s = dbmacros.get( id, i );
			s2 = "";
			while( s.contains("$") )	{
				s2 += s.strgetto("$");
				s = s.strgetfrom("$");
				if( s.getb(0,1)=="[" )	{
					i1 = s.strgetfrom("[");
					s = s.strgetfrom("]");
				} else {
					i1 = s;
					s = "";
				}
				s2 += _vecarg.get( i1-1 );
			}
			if( s!="" ) s2 += s;
			<sdb>.add( id2, s2 );
		}
		icol;
	}
	virtual subaddbehs(string sdb)	{}
	loadbehaviours(string sfile)	{
		string sdb = clcbeh.get();
		new db <sdb>;
		//<sdb>.loadbeh(this.getgraphpath()+sfile);
		<sdb>.loadbeh( .getpath(sfile) );
		.subaddbehs(sdb);
		string s = sdb + "script";
		new Script <s>(sdb);
		int i[2], string s[4], bool brand, bool bread, string bonce, bool bpar, bool bblock, int ienumer;
		int iifsave, string sifsave, string sifvar;
		for( int i=0; i< <sdb>.getrowsno(); i++)	{
			i1 = 0;
			s0 = <sdb>.get(i,i1);	i1++;
			match(s0)	{
				"macro:" => { dbmacros.dbaddrowfrom( sdb, i, 1 );
				} "include:" => {	this.loadbehaviours(<sdb>.get(i,i1));
					i1++;
				} "build:" => { i1 = this.buildbeh( <sdb>.get(i,i1), sdb, i, i1+1 );
				} "func" => 	{ while( <sdb>.get(i,0)!="end" )	i++;
				} "IF" => { _if_pos++;	i = ._found_if( sdb, i, i1, <sdb>.getcolsno(i) );
				} "ELSE" => { i = ._goto_fi(sdb, i+1);
				} "FI" => {
					_if_pos--;
					if( _if_pos< -1 )	("FI error! "+this+"."+ .methodname)->print;
				}
				? => {
					i0 = <sdb>.getcolsno(i);
					s0 = this.getbeh(s0);
					new classbehhero <s0>;
					brand = false;
					bread = true;
					bonce = null;
					bpar = false;
					bblock = true;
					//bblock = false;
					sifvar = null;
					iifsave = -1;
					ienumer=0;
					while(bread)	{
						s1 = <sdb>.get(i,i1);	i1++;
						match(s1)	{
							"-nr"	=>	brand = false;
							"-once"	=>	{ bonce = <sdb>.get(i,i1);	i1++;}
							"-par"=>	bpar = true;
							"-r"	=>	brand = true;
							"-nb"=>	bblock = false;
							"-b"=>		bblock = true;
							"-en"=>	{	ienumer = <sdb>.get(i,i1);	i1++;}
							"-bif"=>	{	iifsave = 1;
								sifsave = <sdb>.get(i,i1);	i1++;
								sifvar=true;
							}
							"-bnif"=>	{	iifsave = 0;
								sifsave = <sdb>.get(i,i1);	i1++;
								sifvar=true;
							}
							"-if"	=>	{	iifsave = 1;
								sifsave = <sdb>.get(i,i1);	i1++;
								sifvar = <sdb>.get(i,i1);	i1++;
							}
							"-nif" =>	{	iifsave = 0;
								sifsave = <sdb>.get(i,i1);	i1++;
								sifvar = <sdb>.get(i,i1);	i1++;
							}
							?	=>	{
								bread = false;
								<s0>.setasstarter(bonce, brand, bpar, bblock, ienumer, iifsave, sifsave, sifvar);
								//this.loadbeh(sdb, i, i0, i1-1, s0, s0, brand, bpar);
								
								// loadbeh(string sdb, int irow, int icol, int id, string sstarter, string sprevobj, bool brand, bool bpar)	{
								/*if( id < icol )	{
									this.loadbeh(sdb,irow,icol,id,sstarter,s1,brand, bpar);
								}*/
								i1--;
								while( s1.getb(0,1)=="-" )	{
									match(s1)	{
										"-skip" => {
											<s0>.bskip = (true);
											i1++;
										}
										? => i1 = .behstarteropt(s0, sdb, i, i1, s1);
									}
									s1 = <sdb>.get(i, i1);
								}
								s1 = s0;	// sstarter
								while( i1<i0 )	{
									|s1, i1| = .loadbeh( sdb, i, i0, i1, s0, s1, brand, bpar);
								}
							}
						}
					}
				}
			}
		}
		<sdb>.readonly();
	}
	virtual int behstarteropt(string sbeh,string sdb,int irow,int iordcol, string sord)	{ iordcol+1; }
	int analizeaninstr(string sdb,int irow,  int icol, string san)	{
		bool bread = true;
		if( icol >= <sdb>.getcolsno(irow) )	{	bread=false;	}
		bool banalize = false;
		if( san!=null )	{
			banalize=true;
			this.advanstand(san);
		}
		int i[3];
		string s[2];
		real r[3];
		while(bread)	{
			s1 = <sdb>.get(irow,icol);	icol++;
			match(s1)	{
				"-z"		=>	{
					if( banalize)	{
						s0 = <sdb>.get(irow,icol);
						if( StringChecker::isdigit(s0) )
							<san>.setz( s0 );
						else <san>.setz( <s0>.getz );
					}
					icol++;
				}
				"-pos"	=>	{	s0 = <sdb>.get(irow,icol);	icol++;
					i2 = <sdb>.get(irow,icol);	icol++;
					if( banalize)	{
						if(s0=="-id")	{
							s0 = _spathpref+san;
							i0 = <s0>.getbyname(i2);
							i1 = <s0>.getxver(i0) - <s0>.getposx;
							i2 = <s0>.getyver(i0) - <s0>.getposy;
						} else {
							i1 = rgmscalex * s0.to_i;
							i2 = rgmscaley*i2;
						}
						//<san>.setpos( i1+ clcamera.getposx(), i2+ clcamera.getposy() );
						<san>.setpos( i1, i2 );
					}
				}
				"-move"	=>	{	i1 = <sdb>.get(irow,icol);	icol++;
					i2 = <sdb>.get(irow,icol);	icol++;
					if( banalize)	{
						<san>.move( rgmscalex*i1, rgmscaley*i2 );
					}
				}
				"-putgr"	=>	if( banalize )	<san>.anputgr();
				"-vis"	=>	{	i0 = <sdb>.get(irow,icol);	icol++;
					if( banalize )	i0==false ? <san>.hide() : <san>.show();
				}
				"-show"	=>	if( banalize )	<san>.show();
				"-hide"	=>	if( banalize )	<san>.hide();
				"-dir"	=>	{s0 = <sdb>.get(irow,icol);	icol++;
					if( banalize)	{
						s1 = <san>.actionname();
						i0 = <san>.framenr();
						<san>.setframe( s1.strsube(2) + s0, 0 );
					}
				}
				"-smooth" =>	{
					i0 = <sdb>.get(irow,icol);	icol++;
					if( banalize )	{
						<san>.setsmooth(i0);
					}
				}
				"-play", "-smplay" => {
					if( banalize)	{
						s0 = (s1=="-play" ? "play" : "playsmooth");
						<san>.<s0>( <sdb>.get(irow,icol) );
					}
					icol++;
				}
				"-nplay", "-nsmplay" => {
					i0 = <sdb>.get(irow,icol);	icol++;
					if( banalize)	{
						s0 = (s1=="-nplay"? "play" : "playsmooth");
						if( <san>.gettype=="anima") <san>.<s0>(i0);
						else <san>.nplay( i0 );
					}
				}
				"-nplayif"	=>	{i0 = <sdb>.get(irow,icol);	icol++;
					if( banalize)	{
						<san>.anplayif( i0 );
					}
				}
				"-conplay"	=>	{i0 = <sdb>.get(irow,icol);	icol++;
					if( banalize )	{
						i1 = <san>.framenr;
						<san>.play(i0);
						<san>.setframe(-1,i1);
					}
				}
				"-lplay"	=>	{
					if( banalize)	<san>.anloopsplay( <sdb>.get(irow,icol) );
					icol++;
				}
				"-bgr"	=>	{s1 = <sdb>.get(irow,icol);	icol++;
					if( banalize)	{
						<s1>.add(san);
						if( engine.varexist( _spathpref + san ) )	<s1>.add( _spathpref+san );
					}
				}
				"-sc"		=>
					if( banalize)	{
						s1 = _spathpref+san;
						if( engine.varexist( s1 ) )	<s1>.scalean();
					}
				"-ssc"	=>	if( banalize)	clcamera.setscene();
				"-actor"	=>	if( banalize)	clcamera.setactor(san);
				"-mhero"	=>	if( banalize)	this.setmainhero(san);
				"-puty"	=>	{s0 = <sdb>.get(irow,icol);	icol++;
					if( banalize)	s0=="resy" ? <san>.anputy( iResY-1 ) : <san>.anputy(s0);
				}
				"-stopf"	=>	if( banalize )	<san>.stop(false);
				"-stoph"	=>	if( banalize )	{
					<san>.stop(false);
					<san>.hide;
				}
				"-setaction" =>	{s0 = <sdb>.get(irow,icol);	icol++;
					if( banalize)	{
						if( StringChecker::isdigit(s0) )	<san>.setframe(s0.to_i, 0);
						else <san>.setframe(s0, 0);
						<san>.stop(false);
					}
				}
				"-setframe"	=>	{
					s0 = <sdb>.get(irow,icol);	icol++;
					s1 = <sdb>.get(irow,icol);	icol++;
					if( banalize)	{
						i0 = ( s1=="-act" ? .framenr : s1 );
						if( StringChecker::isdigit(s0) )	<san>.setframe(s0.to_i, i0);
						else <san>.setframe(s0, i0);
						<san>.stop(false);
					}
				}
				"-randfr"	=> 	{
					if( banalize )	<san>.ansetrandfr;
				}
				"-stand"	=>	{
					if( banalize)	<san>.setstandbase(<sdb>.get(irow,icol));
					icol++;
				}
				"-delay"	=>	{
					if( banalize)	<san>.setdelay(<sdb>.get(irow,icol));
					icol++;
				}
				"-opshow"	=>	{
					s0 = <sdb>.get(irow,icol);	icol++;
					if( banalize )	<san>.anfadein( s0, null );
				}
				"-ophide"	=>	{
					s0 = <sdb>.get(irow,icol);	icol++;
					if( banalize )	<san>.anfadeout( s0, null );
				}
				"-step" => {
					if( banalize)	< _spathpref + san >.setanstep(<sdb>.get(irow,icol));
					icol++;
				}
				"-sb1" => {	if( banalize)	< san >.setbutbase1(<sdb>.get(irow,icol));	// dla buttona
					icol++;	}
				"-sb2" => {	if( banalize)	< san >.setbutbase2(<sdb>.get(irow,icol));	// dla buttona
					icol++;	}
				"-lineardodge" => {
					s0 = <sdb>.get(irow,icol);	icol++;
					if( banalize )	{
						s1 = "_ft"+san;
						if( !.hasvar(s1) )	{
							new filter <s1>;
							<s1>.link(san);
						}
						<s1>.lineardodge(s0);
						/*<san>.addmethod("onstart", func { .hide; } );
						<san>.hide;*/
					}
				}
				"-drawmode" => {
					s0 = <sdb>.get(irow,icol);	icol++;
					if( banalize )	{
						if( s0=="lineardodge" )	{
							<san>.setdrawmode(1);
						}
					}
				}
				"-anmover" => {
					s0 = <sdb>.get(irow,icol);	icol++;
					if( s0=="-loop" )	{
						r0 = <sdb>.get(irow,icol);	icol++;
						r1 = <sdb>.get(irow,icol);	icol++;
						i2 = 1;
					} else {
						r0 = s0;
						r1 = <sdb>.get(irow,icol);	icol++;
						i2 = 0;
					}
					if( banalize )	{
						SetAnMover::setas( san, r0, r1);
						if( i2 ) <san>.sam_copy;
						<san>.sam_addtimer;
						<san>.sam_playtimer;
					}
				}
				"-hideonstart" => {
					if( banalize )	{
						//<san>.addmethod("onsetframe", func { .hide; } );
						<san>.anhideonsetframe;
					}
				}
				"-transparency" => {
					s0 = <sdb>.get(irow,icol);	icol++;
					if( banalize )	{
						<san>.transparency(s0);
					}
				}
				"-roto" => {
					r1 = <sdb>.get(irow,icol);	icol++;	// kat dodatni
					r0 = <sdb>.get(irow,icol);	icol++;	// kat ujemny
					real speed = <sdb>.get(irow,icol);	icol++;	// speed - minus startuj w lewo, plus w prawo
					int delay = <sdb>.get(irow,icol);	icol++;
					if( banalize )	{
						i0 = <san>.getpx;
						i1 = <san>.getpy;
						<san>.setframe(1,0);
						<san>.ansetbpos(i0, i1);
						<san>.var2("idopframe", 0);
						<san>.addmethod("setopacityframe", func {
							if( .nofframes(0) > 1 ) {
								@s = .nameofframe(0,idopframe);
								if( s.getb(0,2)=="op" ) <.internal_filter>.setopacity( s.strsubb(2)->to_r/100.0*255.0+0.5 );
								idopframe = (idopframe+1)%.nofframes(0);
							}
							} );
						
						s1 = < <san>.internal_filter>.getfullname;
						<s1>.setpivottype(2);
						<s1>.setsmooth(1);
						<san>.setopacityframe;
						
						s0 = "_timroto"+san;
						.cycle = (s0, func {
							real rkats = pkat - mkat;
							real rspeed = 1.0;
							real r = <ftsan>.getangle;
							if( speed < 0.0 )	{
								if( r <= mkat )	speed = -speed;
								r = (r-mkat)/rkats;
							} else {
								if( r >= pkat ) speed = -speed;
								r = (pkat-r)/rkats;
							}
							if( r._rin1(0.1) ) {
								rspeed = 0.4;
								//r.print;
							//} else if ( r._rin1(0.15) ) { rspeed = 0.6; }
							} else if ( r._rin1(0.2) ) rspeed = 0.8;
							//if( rspeed != 1.0 ) ("speed limit : " + rspeed )->print;
							<ftsan>.rotate(rspeed*speed);
							<san>.setopacityframe;
							.play;
							} );
						<s0>.setcycle(delay);
						<s0>.vars2(A, "san", san, "ftsan", s1, "mkat", r0, "pkat", r1, "speed", speed);
						<s0>.play;
					}
				}
				"-buildroto", "-buildrotorle" => {
					bool brle = ( s1 == "-buildrotorle" ? true : false );
					r1 = <sdb>.get(irow,icol);	icol++;	// kat dodatni
					r0 = <sdb>.get(irow,icol);	icol++;	// kat ujemny
					real speed = <sdb>.get(irow,icol);	icol++;	// speed - minus startuj w lewo, plus w prawo
					int delay = <sdb>.get(irow,icol);	icol++;
					if( banalize )	{
						i0 = <san>.getpx;
						i1 = <san>.getpy;
						<san>.setframe(1,0);
						<san>.ansetbpos(i0, i1);
						
						real r3 = 0.0;
						speed = speed.abs;
						i0 = 0;
						string sprev = null;
						for( real r2 = r0; r2<=r1; r2+=r3 )	{
							real r4 = ((r2-r0)/(r1-r0))->abs;
							
							if( r4._rin1(0.1) ) r3 = 0.4*speed;
							else if ( r4._rin1(0.2) ) r3 = 0.8*speed;
							else r3 = speed;
							//r3.print;
							
							s1 = "_imgroto"+i0+san;
							new img <s1>;
							<s1>.buildrotozoom(san, r2, 1.0, 1.0);
							while( sprev!=null && <s1>.getw==<sprev>.getw && <s1>.geth==<sprev>.geth &&
								<s1>.getpx==<sprev>.getpx && <s1>.getpy==<sprev>.getpy )	{
								r4 = 0.2;
								r2 += r4*r3;
								r3 *= (r4 + 1.0);
								<s1>.buildrotozoom(san, r2, 1.0, 1.0);
							}
							<s1>.setz( <san>.getz );
							<s1>.hide;
							if( brle ) <s1>.rle;
							/*(s1 + " roto=" + r2 + ", x="+<s1>.getpx + ", y=" + <s1>.getpy + ", w=" + <s1>.getw +
								", h="+<s1>.geth)->print;*/
							
							sprev = s1;
							i0++;
						}
						s0 = "_timroto"+san;
						.cycle = (s0, func {
							<slastimg>.hide;
							slastimg = "_imgroto"+idimg+san;
							<slastimg>.show;
							idimg = idimg+dir;
							if( idimg < 0 )	{
								idimg=0;
								dir = 1;
							} else if( idimg >= ileimgs ) {
								idimg = ileimgs-1;
								dir = -1;
							}
							.play;
							} );
						<s0>.setcycle(delay);
						<s0>.vars2(A, "san", san, "ileimgs", i0, "slastimg", s1, "idimg", 0, "dir", 1);
						<san>.hide;
						<"_imgroto0"+san>.show;
						<s0>.play;
					}
				}
				"-opacityframe" => {
					if( banalize ) <san>.anopacityframe;
				}
				"-rle" =>	{ if( banalize) <san>.rle;	}
				"-bitmask" => {
					i0 = <sdb>.get(irow,icol);	icol++;
					if( banalize )	{
						<san>.bitmask(i0);
					}
				}
				?	=>	{
					i0 = icol;
					icol = .subanalizeaninstr(san, sdb, irow, icol, s1);
					if( i0==icol+1 )	{
						bread = false;		// natrafil na inny string, icol-1 przywroc go do analizy
					}
				}
			}
			if( bread && icol>=<sdb>.getcolsno(irow) )	bread = false;
		}
		return icol;
	}
	real _rin1(real r)	{	.get<r || .get>(1.0-r);	}
	virtual int subanalizeaninstr(string san, string sdb, int irow, int icol, string sord)	{	icol-1;	}
	/*******************************/
	cadvherofinish()	{}
	/*******************************/
	butmoveoff(string sbut)	{
		<sbut>.moveoff();
		this.< <sbut>.getbutname() + "_MOVEOFF">();
		if( !.behplaying )
			_b_rewind = !.playbehif( "beh_"+ <sbut>.getbutname +"_MOVEOFF" );
	}
	butmoveon(string sbut)	{
		<sbut>.moveon();
		this.< <sbut>.getbutname() + "_MOVEON">();
		if( !.behplaying )
			_b_rewind = !.playbehif( "beh_"+ <sbut>.getbutname +"_MOVEON" );
	}
	advfocusedbut	{	_slastms;	}
	advbutrefresh	{
		|int x, int y| = mouse.getpos();
		int id = grbuts.butisin(x,y,true,true);
		if( id )	{
			string s = grbuts.get(id-1);
			if( s!=_slastms )	{
				if( _slastms!=null )	this.butmoveoff(_slastms);
				_slastms = s;
				this.butmoveon(s);
			}
		} else {
			if( _slastms!=null )	{
				this.butmoveoff(_slastms);
				_slastms = null;
			}
		}
		grmsmove.eval2("onmousemove", x, y);
		moddbg.msmove();
	}
	advmsmove()	{
		if ( !this.advgetlock() ){
			.advbutrefresh;
		}
	}
	butclickon(string sbut)	{
		//string s = _spocketpref+this.getmainhero();
		//if( engine.varexist(s) )	<s>.skipitem();
		<sbut>.clickon();
		//this.< <sbut>.getbutname() + "_CLICKON">();
		if( !.behplaying )
			_b_rewind = !.playbehif( "beh_"+ <sbut>.getbutname +"_LCLICK" );
	}
	butrelease(string sbut)	{
		//string s = _spocketpref+this.getmainhero();
		//if( engine.varexist(s) )	<s>.skipitem();
		<sbut>.butlrel();
		//this.< <sbut>.getbutname() + "_RELEASE">();
	}
	advmsclick()	{
		if( _tim_dbclk.isplaying )	{
			clwalkq.mulspeed(2);
			return;
		} else _tim_dbclk.play;
		_b_rewind = true;
		if( !bmslock )	{
			|int x, int y| = mouse.getpos();
			grbuts.eval2("preparetosort",x,y);
			grbuts.sortimgs;	// dodane 6.09.2010 bo kokosz zaslanial owsianke :)
			int id = grbuts.butisin(x,y,true,true);
			grbuts.eval("endsort");
			if( id )
				this.butclickon(grbuts.get(id-1));
			else {
				string s = _spocketpref+this.getmainhero();
				if( engine.varexist(s) )	<s>.itemhide;
				clwalkq.goto(x,y);
			}
			grmslclick.eval2("onmouselclick",x,y);
		}
		if(_b_rewind) this.behrewind();
		moddbg.mslclick();
	}
	advmsrclick	{
		if( !bmslock )	{
			grmsrclick.eval2("onmouserclick",mouse.getpos);
		}
	}
	advmslrel() {
		if( !bmslock )	{
			|int x, int y| = mouse.getpos();
			int id = grbuts.butisin(x,y,true,true);
			if( id )	this.butrelease(grbuts.get(id-1));
			grmslrel.eval2("onmouselrel",x,y);
		}
		moddbg.mslrel();
	}
	mousemove()	{
		if( .advstdstate ) this.advmsmove();
		this.mouse_MOVE();
	}
	mouselclick()	{
		if( .advstdstate ) this.advmsclick();
		this.mouse_LCLICK();
	}
	mouselrel()	{
		if( .advstdstate ) this.advmslrel();
		this.mouse_LREL();
	}
	mouserclick()	{
		if( .advstdstate ) .advmsrclick;
		this.mouse_RCLICK();
	}
	keydown()	{
		moddbg.dbkeydown();
		this.keyboard_KEYDOWN();
	}
	exit()	{
		modadvglob.onexit();
		if( igmsubtitle )	{
			subtitle.reset;
		}
	}
	onmusicfin	{
		_music.play;
	}
	/*******************************/
	sndplayobfin(string s, string sob, string sfun)	{
		__sndplay.load( .getsndpath + s + ".wav" );
		if( igmsubtitle )	{
			subtitle.register("__sndplay", this.getsndpath() + s + ".wav");
		}
		__sndplay.sob = (sob);
		__sndplay.sfun = (sfun);
		.cbsplay("__sndplay");
	}
	sndplayfin(string s, string sfun)	{	.sndplayobfin(s,null,sfun);	}
	sndplay(string s)	{	.sndplayobfin(s, null, null);	}
	/*****************************/
	advloadsnd(string sfile)	{
		if( !.hasvar("file_loaded") )	{
			.var2("file_loaded", 1);
		}
		if( engine.fileexist(sfile) )	{
			.load( sfile );
		} else {
			file_loaded = 0;
		}
		if( igmsubtitle )	{
			subtitle.register(.getfullname, sfile);
		}
	}
}


module moddbg : classlocker	{
	init()	{
		classlocker::init();
		
		new string sstate = "init";
		new int ilastx;
		new int ilasty;
		new text txtpos;
		txtpos.setz(5000);
		txtpos.setpos( 0, 0 );
		txtpos.setbkg(0,0,64,16, 0,0,0,192);
		
		new text txtmsg;
		txtmsg.setz(5000);
		txtmsg.setpos(120,10);
		txtmsg.setbkg(0,0,300,16, 0,0,0,192);
		txtmsg.hide;
		new timer timmsg;
		timmsg.setdelay(4000);
		timmsg.addmethod("onfinish", func { txtmsg.hide; } );

		new text txtpod;
		txtpod.setz(5000);
		txtpod.setbkg(0,0,128,16, 0,0,0,192);
		
		new img impod;
		new string slastimpod = null;
		
		this.disable();

	}
	public enable()	{
		this.unlock();
		txtpos.show();
		txtpod.show();
	}
	public disable()	{
		this.lock();
		txtpos.hide();
		txtpod.hide();
	}
	public updatetxtpos(int x, int y)	{
		if( engine.varexist("clcamera") )
			txtpos.set("" + ( x-clcamera.getposx() ) + "," + ( y-clcamera.getposy() ));
		else txtpos.set("" + x + "," + y);
		txtpos.setpos(x-txtpos.getw-advmouse.lodx,y-txtpos.geth-advmouse.lody);
		txtpod.setpos(x-txtpod.getw-advmouse.lodx,y-2*txtpod.geth-advmouse.lody);
		string s = engine.getimg(x,y,true,true,-2000,2000);
		txtpod.set( s );
		if( s==null || s=="imgbkg" ) impod.hide;
		else if( engine.varexist(s))	{
			if( s!=slastimpod || (s==slastimpod && !impod.isvisible) || <s>.getw != impod.getw || <s>.geth != impod.geth )	{
				impod.create( <s>.getw, <s>.geth, 255,255,0,64 );
				impod.show;
				impod.setz(2010);
				slastimpod = s;
			}
			impod.setpos( <s>.getpx, <s>.getpy );
		}
		y = txtpos.getey - iResY;
		if( y>0 )	{	txtpos.move(0,-y); txtpod.move(0,-y);	}
		x = txtpod.getex - iResX;
		if( x>0 )	{	txtpos.move(-x,0); txtpod.move(-x,0);	}
		x = -txtpod.getpx;
		if( x>0 )	{	txtpos.move(x,0); txtpod.move(x,0);	}
	}
	msminit(int x, int y)	{	this.updatetxtpos(x,y);	}
	msmmove(int x, int y)	{
		if( engine.varexist("clcamera") )
			clcamera.moveplans(x-ilastx, y-ilasty);
		this.updatetxtpos(x,y);
	}
	public msmove()	{
		if( this.getlock() )	{	return;	}
		int x = mouse.getpx();
		int y = mouse.getpy();
		this.<"msm"+sstate>(x,y);
		ilastx=x;
		ilasty=y;
	}
	public mslclick()	{
		if( this.getlock() )	{	return;	}
		if( keyboard.iskeydown("space") )	{
			sstate="move";
		}
	}
	public mslrel()	{
		if( this.getlock() )	{	return;	}
		sstate = "init";
	}
	msrclick()	{
		int x = mouse.getpx();
		int y = mouse.getpy();
		int id = grbuts.isin(x,y,true,true);
		if( id!=false )	{
			string s = grbuts.get(id-1);
			s.print();
		} 
//		txtpod.set( engine.getimg(x,y,true,true,-1000,1000));
	}
	msg(string s)	{
		txtmsg.show;
		txtmsg.set(s);
		timmsg.play;
	}
	dbkeydown(){
		if( !igmdebug ) return;
		if( keyboard.iskeydown("lctrl") ) {
			if( keyboard.iskey("l") )	{
				@s = "cache";
				if( keyboard.iskeydown("1") ) s+="1";
				else if (keyboard.iskeydown("2") ) s+="2";
				else if (keyboard.iskeydown("3") ) s+="3";
				else if (keyboard.iskeydown("4") ) s+="4";
				else if (keyboard.iskeydown("5") ) s+="5";
				else if (keyboard.iskeydown("6") ) s+="6";
				else if (keyboard.iskeydown("7") ) s+="7";
				else if (keyboard.iskeydown("8") ) s+="8";
				else if (keyboard.iskeydown("9") ) s+="9";
				._load_game(s);
				.msg("game loaded from "+s);
			} else if( keyboard.iskey("s") )	{
				@s = "cache";
				if( .can_save )	{
					if( keyboard.iskeydown("1") ) s+="1";
					else if (keyboard.iskeydown("2") ) s+="2";
					else if (keyboard.iskeydown("3") ) s+="3";
					else if (keyboard.iskeydown("4") ) s+="4";
					else if (keyboard.iskeydown("5") ) s+="5";
					else if (keyboard.iskeydown("6") ) s+="6";
					else if (keyboard.iskeydown("7") ) s+="7";
					else if (keyboard.iskeydown("8") ) s+="8";
					else if (keyboard.iskeydown("9") ) s+="9";
					._save_game(s);
					.msg("game saved to "+s);
				} else {
					.msg("could not save game to "+s+" , sgmstate=" + sgmstate);
				}
			} else if( keyboard.iskey("b") )	{
				<gameapi.getgamename>.cgetscreenshoot("saves/cache.bmp", 1);
				.msg("screenshoot in saves/cache.bmp");
			}
		}
		if( keyboard.iskey("d") )	{
			if(.getlock)	{
				this.enable();
				.msg("debug mode on: ^c-b: screenshoot, ^c-s: save, ^c-l: load, d: debug on/off");
			} else {
				this.disable();
				.msg("debug mode off");
			}
		}
	}
}

game Tclassmenu	{
	init()	{
		new db _dbl;
		new gmobjvec gr1;
		gr1.add("bkg");
	}
	public tload(string spath, string sbuts, string sdbfile)	{
		this.setgraphpath(spath);
		if( sdbfile!=null )	{
			_dbl.loadscript(this.getgraphpath()+sdbfile);
			for(int i=0; i<_dbl.getrowsno();i++)	{
				this.newsnd("snd"+_dbl.get(i,0), _dbl.get(i,1)+".wav");
			}
		}
		new classbutton _clb;
		_clb.build2( this.getgraphpath() + sbuts, 10, "imglobcurs", "gr1" );
		_clb.clickfunc("_gmbutclick");
		_clb.movonfunc("_gmbutmove");
		if(engine.varexist("sndintro"))	this.cbplay("sndintro");
	}
	mouselclick()	{
		this.cactsndstop(true);
	}
	_gmbutmove(string s)	{
		sndakskermovon.play();
		if( engine.varexist("sndintro") && sndintro.isplaying() )	return;
		if( engine.varexist("snd"+s) )	this.crselfplay("snd"+s);
	}
	_gmbutclick(string s)	{
		this.<s+"_BUTCLICK">();
	}
}

class TMenu 	{
	init()	{}
	tinit(string sbuts)	{
		new Buttons but1(sbuts);
	}
	mousel_click()	{
		.cactsndstop(true);
	}
	but1_moveon	{
		string s = but1.sobject;
		sndakskermovon.play;
		if( !(engine.varexist("sndintro") && sndintro.isplaying) )
			if( engine.varexist("snd"+s) )	this.cbselfplay("snd"+s);
		.<s+"_MOVEON">;
	}
	but1_moveoff	{	.<but1.sobject + "_MOVEOFF">;	}
	but1_lclick()	{
		this.<but1.sobject+"_BUTCLICK">();
	}
}

/************ template game Painter **************/
class TPainter {
	init()	{}
	tinit(string sndbase, string spath, string sfilebg, string sfilebrush, string sfile, string sfarby, @dir, string ssavefile)	{
		if( sndbase!=null )
			GameController::init(sndbase);
		this.unlock();
		if( spath!=null )
			this.setgraphpath(spath);
		
		if( sfilebg!=null )
			this.newanima("anbkg",sfilebg,0);
		this.newanima("anbrush1", sfilebrush, 3000);
		this.copyanima("anbrush1","anbrush2");
		anbrush2.setframe(0,1);
		anbrush2.setz(anbrush1.getz-1);
		anima_pack::resizemethods("anbrush1");		// galka
		anima_pack::resizemethods("anbrush2");		// pedzel
		int x, int y;
		match( dir )	{
			"ru" => { x = anbrush2.getex;
				y = anbrush2.getpy; }
			"rd" => { x = anbrush2.getex;
				y = anbrush2.getey; }
			"ld" => { x = anbrush2.getpx;
				y = anbrush2.getey; }
			? => { x = anbrush2.getpx;
				y = anbrush2.getpy; }
		}
		anbrush1.saverelpos(x, y);	// lewy dolny rog - kursor myszy
		anbrush2.saverelpos(x, y);	// lewy dolny rog - kursor myszy
		mouse.hide();
		
		this.newanima("anfg", sfile, 100);
		anfg.setframe("foreground",0);
		
		new gmimgvec grdraw;
		_ = this.newanframesgr("anfg", "andraw", anfg.actionnr("draw"), "grdraw");
		grdraw.setz(10);
		
		new gmimgvec grpaleta;
		//_ = this.newanframesgr("anfg", "anpaleta", anfg.actionnr("paleta"), "grpaleta");
		"grpaleta" ..< sfarby;
		grpaleta.setz(20);
		
		new int _ibrx = anbrush2.getpx();
		new int _ibry = anbrush2.getpy();
		while( !anbrush2.isin(_ibrx, _ibry, false, true) )	{
			_ibrx++;
			if( _ibrx==anbrush2.getex() ) {
				_ibrx = anbrush2.getpx();
				_ibry++;
			}
		}
		_ibrx-=anbrush2.getpx();
		_ibry-=anbrush2.getpy();
		TPainter::tp_mouse_move;		// ustawienie pedzla w pozycji myszy
		
		if( ssavefile!=null )	{
			new string savefile = ssavefile;
			new db dbkolory;
			@s = ssavefile;
			//if( engine.fileexist(s) )	{
			if( .saveexist(s) )	{
				dbkolory.vecload(s);
				grdraw.each( func { (@id)
					.paint( dbkolory.get(id,0), dbkolory.get(id,1), dbkolory.get(id,2), 255, 0);
					} );
			} else {
				grdraw.each( func { (@id)
					.paint(.white,255,0);
					dbkolory.dbaddstringrow("255 255 255"," ");
					} );
				.tp_savekols;
			}
		}
	}
	game_exit()	{
		mouse.show();
		GameController::game_exit();
	}
	tp_exit	{
		mouse.show;
	}
	tp_mouse_move()	{
		anbrush1.mssetrelpos();
		anbrush2.mssetrelpos();
	}
	tp_mouse_lclick()	{
		if( !this.getlock() )	{
			|int x, int y| = mouse.getpos();
			if( grdraw.isin(x,y,true,true) )	{
				<grdraw.getsfound()>.paint(
					anbrush2.getrgba(anbrush2.getpx()+_ibrx,anbrush2.getpy()+_ibry), 0 );
				.onpaint;
			} else if ( grpaleta.isin(x,y,false,true) )	{
				|@c[4]| = <grpaleta.getsfound()>.getrgba(x,y);
				c3 = 255;
				anbrush2.paint( c0, c1, c2, c3, 0 );
				.onsetbrush;
			}
		}
	}
	tp_savekols	{
		if( !<GAME>.hasvar("dbkolory") ) return;
		grdraw.each( func { (@id)
			int c[4];
			//|c0, c1| = .anfirstnontr;
			int ex = .getex , int ey = .getey;
			int x = .getpx, int y=.getpy;
			while( x!=ex && y!=ey )	{
				if( .isin(x,y,false,true) ) { c0=x; c1=y; x=ex; }
				else x++;
			}
			|c0,c1,c2,_| = .getrgba(c0,c1);
			dbkolory.set(id,0,c0);
			dbkolory.set(id,1,c1);
			dbkolory.set(id,2,c2);
			} );
		dbkolory.vecsave( savefile );
	}
	tp_default_erase	{	.tp_erase(.white,255);	}
	tp_erase(int r, int g, int b, int a)	{
		for( int i=0; i< grdraw.size; i++)	{
			<grdraw.get(i)>.paint(r,g,b,a,0);
			dbkolory.set(i,0,255);
			dbkolory.set(i,1,255);
			dbkolory.set(i,2,255);
		}
		.tp_savekols;
	}
}

class TPainterCon : TPainter, GameController	{
	init	{}
}
new int iMemoTryb=1;	// 0 - player na czas, 1 - player vs computer, 2 - player vs player
new int iMemoW;
new int iMemoH;
new int iMemoAI = 0;	// poziom trudnosci

class TMemo 	{
	init()	{}
	public tinit(string sbkg, string stafle, string snakl, int dt)	{
		
		if( sbkg.gete(0,3)=="pyz") .newanima("anbkg", sbkg, 0);
		else .newimg("anbkg", sbkg, 0);
		
		.newanima("antaf", stafle, 20);
		.newanima("annak", snakl, 20);
		
		new int ipredkosc = 25;
		new gmimgvec grtaf;
		new gmimgvec grnak;
		new vector veci	{
			.vecnewint( antaf.nofframes(0) );
			.hash;
		};
		string s, int i[3], int j;
		i0 = 0;
		for( int i=0; i<iMemoW; i++)	{
			for( j=0; j<iMemoH; j++)	{
				new anima <"antaf"+i0>(i0) {
					(int i)
					.copy("antaf");
					.setframe(0, veci.get(i/2));
					.anaddfilter;
					.unlink;
					grtaf.add( this );
				};
				new anima <"annak"+i0> (i0) { (int i)
					.copy("annak");
					.anaddfilter;
					.unlink;
					grnak.add(this);
				};
				i0++;
			}
		}
		antaf.hide;
		annak.hide;
		grtaf.hash;
		i0=0;
		i1 = antaf.getw + dt;
		i2 = antaf.geth + dt;
		for( i=0; i<iMemoW; i++)	{
			for( j=0; j<iMemoH; j++)	{
				s = grtaf.get(i0);
				<s>.ansetbpos( i1*i, i2*j );
				<s>.ansetbpos( i1*i, i2*j );
				<s>.vars2(A, "col", i, "row", j);
				<s>.setz(10 + 2*i0-1);
				<grnak.get(i0)>.setz(10+2*i0);
				i0++;
			}
		}
		grtaf.eval("link");
		grnak.eval("link");
		i1 = (iResX-grtaf.getw())/2;
		i2 = (iResY-grtaf.geth())/2;
		grtaf.move( i1, i2 );
		grnak.move( i1, i2 );
		new int iplayer=1;
		new int icompplayer = 0;	// 1v2
		new classfadeinout clfio;
		new classfadeinout clfio2;
		new int imemostate=0;
		new string staf1;
		new string staf2;
		new string snak1;
		new string snak2;
		new int ileai = .between(1, .between(5, iMemoW*iMemoH*0.2, 10) + iMemoAI, 20);
		new string sset1;
		new string sset2;
		new vector vecai	{
			.mresize;
			.type("string");
		};
		new int iaistate = 0;
		.newtimer("timwait", 500, 1);
		timwait.mresize;
		.cnewtimerfin("timpoka", 500, 1, "endset22");
	}
	tm_start()	{
		imemostate = 1;
		if( iMemoTryb==1 )	{
			icompplayer=2;
		}
	}
	/******************************************************/
	aigo()	{
		imemostate=11;
		.tclicks( sset1 );
	}
	aigo2()	{
		.tclicks( sset2 );
	}
	int aifind1(string sob, int i,  int ile)	{
		if( sob==null )	return -1;
		int ifr = <sob>.framenr;
		string s;
		for (; i<ile; i++)	{
			s = .get(i);
			if( s!=null && s!=sob && ifr==<s>.framenr && .tstats(i))	return i;
		}
		-1;
	}
	bool tstats(int id)	{	.stats(100-id*10);	}
	startai(string sfun)	{
		if( iplayer==icompplayer )	{
			int ile = .min(vecai.size, ileai);
			if( sfun=="aigo" )	{
				imemostate = 11;
				int i[3];
				i2 = -1;
				for(i0=0; i0<ile; i0++)	{
					i2 = vecai.aifind1( vecai.get(i0), i0+1, ile );
					if( i2>=0 && .tstats(i0))	{
						i1 = i0;
						i0 = ile;
					} else
						i2=-1;
				}
				if( i2>=0 )	{		// znalazl pare
					sset1 = vecai.get(i1);
					sset2 = vecai.get(i2);
				} else {
					sset1 = grtaf.rand;
					sset2 = null;
				}
			} else {
				if( sset2 == null )	{
					int id = vecai.aifind1( sset1, 0, ile );
					if (id>=0 && .tstats(id))	sset2 = vecai.get(id);
					else 	sset2 = grtaf.randdiff( sset1 );
				}
			}
			"timwait" ..< sfun;
			timwait.play;
		}
	}
	/******************************************************/
	endset3()	{
		imemostate=1;
		if( iMemoTryb>0 )	{
			.tnextplayer;
			.startai("aigo");
		}
	}
	endset2	{	timpoka.play;	}
	endset22	{
		imemostate=3;
		<snak2>.hide;
		if( <staf1>.framenr == <staf2>.framenr )	{
			_ = "grnak" .- snak1 .- snak2;
			_ = "grtaf" .- staf1 .- staf2;
			vecai.set( vecai.find( staf1 ), null );
			vecai.set( vecai.find( staf2 ), null );
			if( grtaf.empty )	{
				imemostate = 5;
				clfio.setopacity(1, -ipredkosc, staf1, null );
				clfio2.setopacity(1, -ipredkosc, staf2, null );
				.tfinish;
			} else {
				clfio.setopacity(1, -ipredkosc, staf1, func {
						<staf1>.hide;	<staf2>.hide;
						if( iplayer!=icompplayer) imemostate=1;
						.startai("aigo");
					});
				clfio2.setopacity(1, -ipredkosc, staf2, null );
				.tpoint;
			}
		} else {
			<snak1>.show;
			<snak2>.show;
			clfio.setopacity(1, ipredkosc, snak1, "endset3");
			clfio2.setopacity(1, ipredkosc, snak2, null );
			.terror;
		}
	}
	tclicks(string sob)	{	.tclick(<sob>.getcx, <sob>.getcy);	}
	tclick(int x, int y)	{
		if( grnak.isin( x, y, true, true ) )	string s = grnak.getsfound;
		else return;
		.tchoose;
		//engine.setdebugstate(true);
		if( imemostate==1 || imemostate==11 ) {
			imemostate--;
			snak1 = s;
			staf1 = grtaf.getimg(<s>.getcx, <s>.getcy, true, true );
			vecai.vecset( staf1, null );
			vecai.addbegin( staf1 );
			vecai.veclimes(30);
			clfio.setopacity(1, -ipredkosc, s, func {
				<snak1>.hide;
				imemostate+=2;
				.startai("aigo2");
				});
		} else if (imemostate==2 || imemostate==12)	{
			imemostate-=2;
			snak2 = s;
			staf2 = grtaf.getimg(<s>.getcx, <s>.getcy, true, true );
			vecai.vecset(staf2,null);
			vecai.addbegin( staf2 );
			vecai.veclimes(30);
			clfio.setopacity(1, -ipredkosc, s, "endset2");
		}
	}
	tnextplayer	{	iplayer = iplayer==1 ? 2 : 1;	}
	tfitinsurf(int x, int y)	{
		grtaf.eval("unlink");
		grnak.eval("unlink");
		@w = x/iMemoW;
		@h = y/iMemoH;
		@dw = <grtaf.first>.getw;
		@dh = <grtaf.first>.geth;
		@dy = h - dh;
		@dx = w - dw;
		@i0 = 0;
		
		for( int i=0; i< iMemoW; i++)	{
			for( int j=0; j<iMemoH; j++)	{
				@s = grtaf.get(i0);
				<s>.ansetbpos(w*i, h*j);
				if( dx<0 && i%2 ) <s>.move(0, dy/2);
				<grnak.get(i0)>.ansetbpos( <s>.getpx, <s>.getpy );
				i0++;
			}
		}
		x = (iResX-grnak.getex)/2;
		y = (iResY-grnak.getey)/2;
		grnak.move( x, y );
		grtaf.move( x, y );
		grtaf.eval("link");
		grnak.eval("link");
	}
	/*********************/
	tm_mouselclick	{
		if( imemostate.in(A,1,2))	.tclick( mouse.getpos );
	}
	virtual tfinish	{}
	virtual tpoint		{}
	virtual terror		{}
	virtual tchoose	{}
}


class classadvstdgame : classadvcontroller	{
	init	{
		clbuts.reset;
		classadvcontroller::init;
		.advsave_game;
		
		new img _im_podbg;
		_im_podbg.create(iResX,1,.black,255);
		_im_podbg.setpos(0,iResY-1);
		_im_podbg.setz(-2000);
		new img _im_podbg2;
		_im_podbg2.create(1,iResY,.black,255);
		_im_podbg2.setpos(iResX-1,0);
		_im_podbg2.setz(-2000);
	}
	/*********************************************/
	add_helps	{
		new gmimgvec __grhelp;
		new anima __anhp;
		__anhp.load("scripts/common/aktywny.pyz");
		__anhp.hide;
		for( int i=0; i<100; i++ )	{
			string s = "__anhp"+i;
			.copyanima("__anhp", s);
			<s>.setz(2700);
			__grhelp.add(s);
		}
	}
	clbuts_help_butclick	{
		int id = 0;
		for( int i=0; i<grbuts.size; i++)	{
			string s = grbuts.get(i);
			string s2;
			string s3 = <s>.gettyp;
			if( (s3=="item" || s3=="but" || s3=="doors") && <s>.enabled && (<s>.isvisible || <s>.ismask)  )	{
				s2 = __grhelp.get(id); id++;
				<s2>.setpos(<s>.getcx, <s>.getcy);
				if( s3=="doors" )	{
					//<s2>.setz(2700);
					<s2>.play(1);
				} else  {
					//<s2>.setz(<s>.getz);
					if( <gameapi.getgamename>.hasvar(_stalkpref+s) )
						<s2>.play(2);
					else <s2>.play(0);
				}
				clcamera.removefrombgr(s2);
				s3 = clcamera.findinbgr(s);
				if( s3!=null )	{
					clcamera.addtobgr(s3, s2);
				}
			}
		}
	}
}

/*game gameadvdef : classadvstdgame	{
	init	{
		classadvstdgame::init;
	}
}*/

new string sAskerGame;
class StdGame : classadv, GameController, Localize	{
	init(string s)	{
		AdventureGame = false;
		igmstate = 0;
		sgmstate = "init";
		classadv::init;
		GameController::init(s);
		Localize::init;
		clbuts.setcursorpos(0, 0);
		claskexit.setcursorpos(0, 0);
		.path = (s);
		.setwavpath(SNDPATH);
		clmusic.play;
		clbuts.reset;
		claskexit.reset;
		advmouse.setstd;
		new Music mus;
		new Button butgame;
		
		if( PrzygodaMode )	{
			.advsaveonstart;
			.advsave_game;
		}
	}
	butenable	{	butgame.addonce(this);		}
	butdisable	{	butgame.removebut(this);	}
	//-------------- adv -------------------------------
	cutscene	{
		new CutScene ccs(igmoffsetx, igmoffsety, iResX, iResY);
		ccs.setz(2000);
	}
	stdstart	{
		ccs.enter( "advsetstdstate" );
	}
	Button_stdoff	{
		.addmethod("butmoveoff", func {
			if( .advstdstate )
				advmouse.setstd;
			} );
	}
	//-------------- helpful -------------------------------
	crect	{	new Rect rec(600,196,403,497);	}
	crect2	{	new Rect rec2(6,174,1012,530);	}
	cshowbut(string sbut, @dir)	{
		clbuts (sbut, dir) { (string sbut, @dir)
			clp.show( buts.callimgfun( sbut, "getcx"), buts.callimgfun( sbut, "getcy"), dir ); 
		};
	}
	//-------------- sys -------------------------------
	key_down	{
		if( igmdebug && keyboard.iskeydown("lctrl") && keyboard.iskey("r") )	.crestart;
	}
	public askrestart	{	claskexit.askrestart;	}
	onmusicfin      {	mus.play;	}
	exit	{
		.game_exit;
		if( igmsubtitle )	{
			subtitle.reset;
		}
	}
}



new string HiddenPath = null;
new string HiddenExclude = null;
new string HiddenEls = null;
new bool HiddenShape = false;

class Hidden	{
	init_hidden	{
		if( HiddenPath!=null )	{
			.path = (HiddenPath);
			HiddenPath = null;
		}
		new bool bhoshape = HiddenShape;
		HiddenShape = false;
		new int ihoclickdelay = dbconf.dbget("hoclick_delay:");
		new int ihoclicktimes = dbconf.dbget("hoclick_times:");
		new int ihoclickkara = dbconf.dbget("hoclick_kara:");
		
		new int ihotxtz = 507;
		
		new int ihoclicker = 0;
		.timer = ("timhoclicker", ihoclickdelay, func {
				ihoclicker=0;
			} );
		.timer = ("timhokara", ihoclickkara, func {
			imgkara.hide;
			/*if( lektorclicks.pogadal )
				igmstate = 1;*/
			igmstate = 1;
			} );
		new img imgkara;
		imgkara.create(igmappw, igmapph, .black, 128);
		imgkara.setz(2222);
		imgkara.hide;
// 		.debug = (1);
		
		.sfxs = (A, "tolist0 70", "tolist1 70", "tolist2 50");
		
		.newgrimg("grels", "els", 10);
		
		new gmimgvec grelscopy;
		grelscopy.copy("grels");
		
		if( HiddenExclude!=null )	{
			new gmimgvec grexclude;
			.lang_db("dbexc", HiddenExclude);
			for( int i=0; i< dbexc.getrowsno; i++)	{
				@s = grels.getsac( dbexc.get(i,0) );
				<s>.hide;
				grels.remove(s);
				grexclude.add(s);
			}
			HiddenExclude = null;
		}
		.mpanel;
		
		new string sclickedho = null;
		
		int i[4], string s[4];
		new gmimgvec grtxt;
		
		if( bhoshape ) {
			for( int i=0; i< grels.size; i++)	{
				s2 = grels.get(i);
				if( <s2>.nofframes(-1) > 2 )	{
					s0 = "anshadow_"+s2;
					.copyanima(s2, s0);
					<s0>.setframe(-1, 2);	// cien
					<s0>.setz(ihotxtz);
					<s0>.show;
					
					<s2>.var2("stxtview", s0);
					
					grtxt.add(s0);
				}
			}
		} else {
			if( HiddenEls!=null )	{
				.lang_db("dbtxts", HiddenEls);
				HiddenEls=null;
			} else {
				.lang_db("dbtxts", "els_");
			}
			
			new vector vtexts; vtexts.type("string");
			new gmimgvec grtxtgrey;
			
			
			int bvirtual;
			new int itxtheight = 16;
			
			s0 = dbconf.dbget("hoguifont:");
			if( s0==null ) s0 = sgmfontitalic;
			.newfont("fnttxts", s0, itxtheight);
			
			for( int i=0; i<dbtxts.getrowsno; i++)	{
				if( dbtxts.getcolsno(i)>1 )	{
					bvirtual = false;
					s0 = dbtxts.get(i,0);
					if( s0=="<external>" )	{
						s2 = dbtxts.get(i,1);
						s1 = dbtxts.get(i,2);
						s0 = s2;
						i0 = -1;
					} else if  (s0=="<virtual>")	{
						bvirtual = true;
						s0 = dbtxts.get(i,1);
						s2 = grels.getsac(s0);
						i0 = -1;
					} else {
						s2 = grels.getsac(s0);
						s1 = dbtxts.get(i,1);
						i0 = vtexts.find(s1);
					}
					if( i0>=0 )	{
						for( i1=0; i1 < grtxt.size; i1++)	{
							s3 = grtxt.get(i1);
							if( <s3>.idvtext==i0 )	{
								<s2>.var2("stxtview", s3);
								<s3>.mupdatetxt(1);
							}
						}
					} else if ( bvirtual )	{
						<s2>.var2("stxtview", "<virtual>");
					} else {
						vtexts.add(s1);
						
						s0 = "txtel_" + s0;
						if( dbtxts.get(i,0) == "<external>" )
							.newtext(s0, s1, "fnttxts", .hoexternalcol );
						else
							.newtext(s0, s1, "fnttxts", .guifontcolor );
						<s0>.hide;
						<s0>.setz(ihotxtz);
						<s0>.vars2(A, "stekst", s1, "icnt", 1, "iidtxt", 0, "idvtext", vtexts.size-1);
						<s0>.addmethod("mupdatetxt", func { (int ile)
							icnt+=ile;
							.txtset( stekst + " 0/" + icnt );
							} );
						<s0>.addmethod("mupdatetxt2", func { (int ile)
							iidtxt+=ile;
							.txtset( stekst + " " +iidtxt+ "/" + icnt );
							} );
						grtxt.add(s0);
						
						<s2>.var2("stxtview", s0);
					}
				}
			}
			grtxt.vars2(A, "irows", 3, "icols", 4 );
			grtxt.addmethod("lastid", func {
				int id = 0;
				while( id<.size && <.get(id)>.isvisible )	{
					id++;
				}
				id;
				} );
			grtxt.addmethod("shownext", func {
				int id = .lastid;
				if( id==.size ) return;
				
				if( id < irows*icols )	{
					@s = .get(id);
					int row = id/icols;
					int col = id%icols;
					<s>.setpos( igmappw/2 - (icols.to_r/2.0 - col.to_r - 0.5)*120 - <s>.getw/2,
						guihoinventory.getpy + 50 + row * ( itxtheight + 2) );
					
					<s>.show;
				}
				} );
			for( i=0; i<12; i++)
				grtxt.shownext;
			
		}	// bhoshape
		
		new int ilehonaraz = 35;
		new classancounter ctcen;
		ctcen.set("timcenter",ilehonaraz);
		new int idtimcenter = 0;
		new real rcykcenter = 16.0;
		new string shidenmov = null;
		for (int i=0; i<ilehonaraz; i++)	{
			/*new vector <"vhox"+i>; <"vhox"+i>.type("real"); <"vhox"+i>.resize(rcykcenter+1, 0.0);
			new vector <"vhoy"+i>; <"vhoy"+i>.type("real"); <"vhoy"+i>.resize(rcykcenter+1, 0.0);*/
			@dt = 3;
			
			.cycle= ("timcenter"+i, func {
				icyk++;
				
				rdx += rpx;
				rdy += rpy;
				if( ietap==2 )	{
					<shidenmov>.ansetbpos(vhox.get(icyk), vhoy.get(icyk));
					grgwiazdki1.setpos( vhox.get(icyk), vhoy.get(icyk) );
				} else {
					<shidenmov>.move(rdx, rdy);
				}
				rdx -= rdx->to_i;
				rdy -= rdy->to_i;
				
				@sdym = ctdym.get;
				<sdym>.setpos( <shidenmov>.getcx, <shidenmov>.getcy );
				<sdym>.setz( <shidenmov>.getz-1 );
				
				if( icyk>=rcykcenter )	{
					if( ietap==1 )	{
						idestx = idestx2;
						idesty = idesty2;
						ietap = 2;
						
						grgwiazdki1.setpos( <shidenmov>.getcx, <shidenmov>.getcy );
						grgwiazdki1.setz( <shidenmov>.getz-1 );
						grgwiazdki1.nplay(-1);
						
						anbable2.setpos( <shidenmov>.getcx, <shidenmov>.getcy );
						anbable2.setz( <shidenmov>.getz-1 );
						anbable2.play(0);
						
						fxtolist2.playif;
						
						.mstart;
						<"timcenterb"+myid>.play;
					} else {
						ctcen.retf(this);
						if( ctcen.allfree )	{
							.advsetstdstate;
							igmstate = 1;
						}
						<shidenmov>.hide;
						grels.remove( shidenmov );
						
						if( bhoshape )	{
							.mputshadow(sclickedho);
						} else {
							@ile = grtxt.irows * grtxt.icols;
							@s2 = <shidenmov>.actionname;
							if( <sclickedho>.icnt > <sclickedho>.iidtxt + 1 )	{
								<sclickedho>.mupdatetxt2(1);
							} else {
								if( <sclickedho>.icnt > 1 )
									<sclickedho>.mupdatetxt2(1);
								grtxt.remove( sclickedho );
								grtxtgrey.add( sclickedho );
								<sclickedho>.createtxt( .grey(128) );
								if( grtxtgrey.size == ile && grtxt.size>0 )	{
									grtxtgrey.hide;
									grtxtgrey.free;
									int i = 0;
									while( i<ile && grtxt.size>0 )	{
										grtxt.shownext;
										i++;
									}
								}
							}
						}
						<sdym>.setpos( <sclickedho>.getpx + <sclickedho>.getw/2,
							<sclickedho>.getpy + <sclickedho>.geth/2 );
						<sdym>.play("end");
						.<s2 + "_put">;
						.hiddenobj_put;
					}
				} else {
					/*if( (ietap==1 && icyk%2) || ietap==2 )
						<sdym>.play("go");*/
					if( ietap==1 || ietap==2 )	{
						<sdym>.play("go");
					}
					.play;
				}
				} );
			<"timcenter"+i>.addmethod("mstart", func {
				@x = <shidenmov>.getcx;
				@y = <shidenmov>.getcy;
				rpx = (idestx - x)->to_r/rcykcenter;
				rpy = (idesty - y)->to_r/rcykcenter;
				rdx = 0.0;
				rdy = 0.0;
				icyk = 0;
				if( ietap==2 )	{
					
					vhox.set(0, x - (x-<shidenmov>.getpx));
					vhoy.set(0, y - (y-<shidenmov>.getpy));
					
					if( rpx<0 )	{
						for( int i=1; i<=rcykcenter; i++)	{
							vhox.set( i, rpx + vhox.get(i-1) - (i-rcykcenter.to_i/2)*5 );
							vhoy.set( i, rpy + vhoy.get(i-1) - (i-rcykcenter.to_i/2)*5 );
						}
					} else {
						for( int i=1; i<=rcykcenter; i++)	{
							vhox.set( i, rpx + vhox.get(i-1) + (i-rcykcenter.to_i/2)*5 );
							vhoy.set( i, rpy + vhoy.get(i-1) - (i-rcykcenter.to_i/2)*5 );
						}
					}
					
					real r[4];
					r0 = idesty - y;
					r1 = vhoy.get( rcykcenter-1 )  - vhoy.get( 0 );
					r2 = r0/r1;
					for( i=1; i<=rcykcenter; i++)
						vhoy.set( i, vhoy.get(i)*r2 );
					
				}
				} );
			<"timcenter"+i> (i) { (@id)
				new vector vhox; vhox.type("real"); vhox.resize(rcykcenter+1, 0.0);
				new vector vhoy; vhoy.type("real"); vhoy.resize(rcykcenter+1, 0.0);
				.vars(A, "rdx", "rdy", "rpx", "rpy", "icyk", "idestx", "idesty", "idestx2", "idesty2",
				"ietap", "shidenmov", "myid", "sclickedho");
				myid = id;
				shidenmov=null;
				sclickedho=null;
			};
			.timer = ("timcenterb"+i, 500, func {
				<"timcenter"+myid>.mstart;
				fxtolist1.playif;
				<"timcenter"+myid>.play;
				} );
			<"timcenterb"+i>.vars2(A, "myid", i);
		}
		
		@s = .getgraphpath;
		.path = ("common");
		@iledymu = 60;
		.newanima("anhodym", "dymki.pyz", 600);
		anhodym.hide;
		new gmimgvec grdym;
		grdym.ancopies("anhodym", iledymu);
		new classancounter ctdym;
		ctdym.set("anhodym_",iledymu);
		.imgs = (A, "gwiazdkif.pyzH", "gwiazdki1.pyzGH", "bable.pyzH");
		.copyanima("anbable", "anbable2");
		new gmimgvec grgwiazdkif;
		for( int i=0; i<4; i++ )	{
			.copyanima("angwiazdkif", "angwiazdkif"+i);
			grgwiazdkif.add("angwiazdkif"+i);
		}
		
		.setgraphpath(s);
		
		new int izels = 10;
		grelscopy.each( func { (@id)
			.setz(izels + id*5);
			} );
		grels.each( func { (@id)
			//.setz(izels + id*5);
			.setframe(-1,1);
			.mhobut;
			} );
		/*grtxt.eval( func {
			if( .nofframes(-1) < 2 )
				.hide;
			} );*/
		if( igmdebug )	{
			new string smovedfont = .stdfont(14);
			.newtext("txtmovedho", "", smovedfont, .grey(240) );
			txtmovedho.setz(1500);
			.newtext("txtmovedho2", "", smovedfont, .grey(2) );
			txtmovedho2.setz(1499);
		}
	}
	/************ hidden ******************/
	hoexternalcol	{	return 255,220,0;	}
	mhobutmask	{	._mhobut(0);	}
	mhobut		{	._mhobut(1);	}
	_mhobut(bool bvis)      {
		if( bvis )	{
			.addmethod("isbutin", func { (@x, @y)
				if( .nofframes(-1)>1 )	{
					.setframe(-1,0);
					.isin(x,y,1,1);
					.setframe(-1,1);
				} else .isin(x,y,1,1);
				} );
		} else   {
			.addmethod("isbutin", func { (@x, @y)
				if( .nofframes(-1)>1 )	{
					.setframe(-1,0);
					.isin(x,y,0,1);
					.setframe(-1,1);
				} else .isin(x,y,1,0);
				} );
		}
		
		.addmethod("butmoveon", func {
			if( igmdebug )	{
				@s = .actionname;
				if( txtmovedho.get != s )	{
					txtmovedho.txtset(s);
					txtmovedho2.txtset(s);
				}
				txtmovedho.setpos( mouse.getpx, mouse.getpy - txtmovedho.geth - 1 );
				txtmovedho2.setpos( mouse.getpx + 1, mouse.getpy - txtmovedho.geth );
				txtmovedho.show;
				txtmovedho2.show;
			}
			} );
		.addmethod("butmoveoff", func {
			if( igmdebug )	{
				txtmovedho.hide;
				txtmovedho2.hide;
			}
			} );
		.var2("myz", .getz);
		.addmethod("butclick", func {
			@s = .actionname;
			if( <GAME>.hasmet( s + "_preclick") )	{
				.<s+"_preclick">;
			} else if( igmstate==1 || sgmstate=="hoout" ) {
				.mho_click;
				.<s + "_click">;
				butgame.onmousemove;
			}
			} );
		butgame.add(this);
	}
	mmasks	{
		if( engine.fileexist(.getgraphpath + "masks.pyz") )	{
			.newgrimg("grmasks", "masks", 0);
			grmasks.eval( func {
				.mmask( .actionname );
				if( .nofframes(-1)>1 )
					.play(-1);
				} );
		} else {
			new gmimgvec grmasks;
		}
	}
	mmask(string s)	{
		if( s.getb(0,5)=="_prev" )	{
			@id = grmasks.find(this);
			if( id>0 )
				.setz( <grmasks.get( id-1 )>.getz );
			else .setz( 2 );
		} else {
			string sob;
			//@id = grels.findsac(s);
			@id = grelscopy.findsac(s);
			if( id<0 )	{
				sob = grexclude.getsac(s);
			} else	{
				//sob = grels.get(id);
				sob = grelscopy.get(id);
			}
			.setz( <sob>.getz + 2 );
		}
	}
	mhider(string s)	{
		@sob = grels.getsac(s);
		.setz( <sob>.getz - 2 );
		<sob>.hide;
		.var2("maskedobj", sob);
		.addmethod("hidemask", func {
			if( grels.contains(maskedobj) )
				<maskedobj>.hide;
			} );
		.addmethod("showmask", func {
			if( grels.contains(maskedobj) )
				<maskedobj>.show;
			} );
	}
	mhiderclick	{
		if( .actionnr(-1)==0 )	{
			.setframe(1,0);
			.showmask;
		} else {
			.setframe(0,0);
			.hidemask;
		}
	}
	mho_click	{
		//@id = grtxt.findsac(.actionname);
		/*@s = .actionname;
		sclickedho = null;
		for( int i=0; i<grtxt.size; i++)	{
			if( grtxt.get(i)->strsubbs("txtel_")==s && <grtxt.get(i)>.isvisible )
				sclickedho = grtxt.get(i);
		}*/
		
		if( .hasvar("stxtview") && <stxtview>.isvisible )
			sclickedho = stxtview;
		else sclickedho = null;
		
		//if( id>=0 )	{
		if( sclickedho!=null && (igmstate==1 || sgmstate=="hoout") )	{
			@s = ctcen.getf;
			if( s!=null )	{
				ihoclicker = 0;
				butgame.removebut(this);
				//angwiazdkif.anhide;
				grgwiazdkif.eval("anhide");
				
				shidenmov = this;
				<s>.shidenmov = (this);
				.setframe(-1,0);
				.setz(600);
				igmstate = 2;
				
				if( <GAME>.hasmet( .actionname+"_put" ) )
					.advsetstdstate;
				else sgmstate="hoout";
				<s>.idestx = ( igmappw/2 );
				<s>.idesty = ( igmapph/2 );
				<s>.idestx2 = ( <sclickedho>.getpx + <sclickedho>.getw/2 );
				<s>.idesty2 = ( <sclickedho>.getpy + <sclickedho>.geth/2 );
				<s>.ietap = (1);
				<s>.sclickedho = (sclickedho);
				<s>.mstart;
				
				@sdym = ctdym.get;
				<sdym>.setpos( <shidenmov>.getcx, <shidenmov>.getcy );
				<sdym>.play("start");
				
				/*angwiazdkif.setpos( <shidenmov>.getcx, <shidenmov>.getcy );
				angwiazdkif.setz( <shidenmov>.getz-1 );
				angwiazdkif.play(0);*/
				/*anbable.setpos( <shidenmov>.getcx, <shidenmov>.getcy );
				anbable.setz( <shidenmov>.getz-1 );
				anbable.play(0);*/
				
				fxtolist0.playif;
				<s>.play;
			} else sclickedho=null;
		}
	}
	butgame_lclick	{
		if( igmstate==1 && !grtxt.empty )	{
			if( timhoclicker.isplaying ) {
				ihoclicker++;
			}
			if( ihoclicker==ihoclicktimes )	{
				ihoclicker=0;
				timhoclicker.stop(false);
				sobject = null;
				igmstate = 12345;
				imgkara.show;
				timhokara.play;
				if( !clsave.bis("ho_ukarany") )	{
					clsave.bset("ho_ukarany");
					//.txtplay("lektorclicks");
				}
			} else {
				timhoclicker.play;
			}
		} else ihoclicker=0;
	}
	HINT_CLICK	{
// 		fxshowhint.playif;
		new gmobjvec _grtmp;
		string s;
		for( int i=0; i<grels.size; i++)	{
			s = grels.get(i);
			if( <s>.hasvar("stxtview") && <s>.stxtview->getb(0,1)!="<" && < <s>.stxtview >.isvisible )
				_grtmp.add(s);
		}
		.mhintonobj(_grtmp.rand);
		delete _grtmp;
	}
	mgetfirsthint	{
		string s2 = grgwiazdkif.first;
		int i=1;
		while( <s2>.isplaying(-1)!=false && i<grgwiazdkif.size )	{
			s2 = grgwiazdkif.get(i);
			i++;
		}
		if( i==grgwiazdkif.size ) grgwiazdkif.first;
		else s2;
	}
	mishintplaying	{
		for( int i=0; i<grgwiazdkif.size; i++ )
			if( <grgwiazdkif.get(i)>.isplaying(-1) )
				return true;
		false;
	}
	mhintonobj(string s)	{
		if( s==null ) return;
		@actfr = <s>.framenr;
		<s>.setframe(-1,0);
		string s2 = .mgetfirsthint;
		<s2>.setpos( <s>.getcx, <s>.getcy );
		<s>.setframe(-1,actfr);
		<s2>.setz( 600 );
		<s2>.play(0);
	}
	mgetel(string s)	{
		@id = grels.findsac(s);
		if( id>=0 ) grels.get(id);
		else null;
	}
	mouse_move	{
		StdGame::mouse_move;
		/*if( igmdebug )	{
			if( igmstate==1 )	{
				if( grels.isin(mouse.getpos,1,1) )	{
					@s = <grels.getsfound>.actionname;
					if( txtmovedho.get != s )	{
						txtmovedho.txtset(s);
						txtmovedho2.txtset(s);
					}
					txtmovedho.setpos( mouse.getpx, mouse.getpy - txtmovedho.geth - 1 );
					txtmovedho2.setpos( mouse.getpx + 1, mouse.getpy - txtmovedho.geth );
					txtmovedho.show;
					txtmovedho2.show;
				} else {
					txtmovedho.hide;
					txtmovedho2.hide;
				}
			} else {
				txtmovedho.hide;
				txtmovedho2.hide;
			}
		}*/
	}
	public mputshadow(string s)	{
		grtxt.remove( s );
		<s>.setframe(-1, 3);
	}
	public advstdstate	{	igmstate==1;	}
}


new real rBehPopupStep = dbconf.dbget("popup_speed:");
if( rBehPopupStep<=0 ) rBehPopupStep = 0.1;

class advbanbeh : classbehhero 	{
	init	{
		classbehhero::init;
	}
	_evalpopup	{
		if( _icol>=0 )	{
			int id = _icol;
			@s = <_sdb>.get(_irow,id);
			while( s!=")" )	{
				if( s.contains(".pyz") )	{
					int iac = 0;
					if( s.contains("@") )	{
						iac = s.strgetfrom("@");
						s = s.strgetto("@");
					}
					.newanima("antmpanim", s, iPopupZ);
					s = "antmpanim";
					<s>.setframe(iac,0);
					<s>.hide;
				}
				if( id==_icol )	{
					imgpopup.clone(s);
				} else {
					imgpopup.blit(s);
				}
				if( .hasvar("antmpanim") )
					delete antmpanim;
				id++;
				s = <_sdb>.get(_irow,id);
			}
			imgpopup.hide;
			if( id>_icol ) {
				ftpopup.link("imgpopup");
				ftpopup.setpivottype(0);
				timpopup.setstart;
				timpopup.play;
			} else .reteval;
		} else .reteval;
	}
	setaspopup(string sdb, int irow, int icol, string sord)	{
		.settype("popup");
		new string _spoptype = sord;
		new string _sdb = sdb;
		new int _irow = irow;
		new int _icol = icol;
		.cycle = ("timpopup", func {
			if( (idir>0 && rzoom > 1.0) || (idir<0 && rzoom<=rBehPopupStep) )	{
				ftpopup.unlink;
				if( idir>0 )	{
					imglastpopup.clone("imgpopup");
					imglastpopup.setz( iPopupZ );
				}
				imgpopup.create(2,2,.transparent);
				imgpopup.hide;
				<sbehaviour>.reteval;
				engine.redraw;
			} else {
				ftpopup.setzoom( rzoom );
				imgpopup.show;
				rzoom += rBehPopupStep*idir;
				.play;
			}
			} );
		timpopup.vars2(A, "rzoom", rBehPopupStep, "sbehaviour", this, "idir", (sord=="popin" ? 1 : -1));
		timpopup.addmethod("setstart", func {
			rzoom = ( idir > 0  ? rBehPopupStep : 1.0 );
			});
		
		new img imgpopup;
		imgpopup.setz( iPopupZ );
		new filter ftpopup;
	}
	_evalopenbook	{
		ansysbook.sbehaviour = (this);
		if( schapter!="-last" )	{
			clsave.set("guibook_lastchapter", schapter);
			clsave.bset("guibook_enabled_"+schapter);
		}
		.gui_openbook;
	}
	_evalclosebook	{
		ansysbook.sbehaviour = (this);
		.gui_closebook;
	}
	setasopenbook(string s)	{
		.settype("openbook");
		new string schapter = s;
	}
	setasclosebook	{	.settype("closebook");	}
}



class classbanadvmouse : classadvmouse	{
	init	{
		classadvmouse::init;
	}
	set(string sac)	{
		if( PrzygodaMode && <gameapi.getgamename>.hasvar("guiloupe") && guiloupe.isvisible )	{
			classadvmouse::set( sac=="normal" ? "glass" : "glassac" );
		} else classadvmouse::set(sac);
	}
}

delete advmouse;
new classbanadvmouse advmouse;
advmouse.stdload;

new gmimgvec grguipck;

new int iSzkielkoZ	= 1340;
new int iHintStarZ	= iSzkielkoZ - 5;
new int iTakeZ		= iSzkielkoZ - 10;	// items
new int iPopupZ		= iSzkielkoZ - 20;
new int iGuiBookZ	= iSzkielkoZ - 35;
new int iGuiZ		= iSzkielkoZ - 40;
new int iBookZ		= iSzkielkoZ - 50;
new int iSlotZ		= iSzkielkoZ - 70;
new int iTxtButtonZ	= iSzkielkoZ - 80;
new int iSzkielkoPodZ	= iSzkielkoZ - 90;

new int iRotoIleRot = 20;
new int iRotoIleObrotow = 2;

new bool bHOInventory;
new int ishowpouptime = dbconf.dbget("showpopup_time:");
ccs.delay( ishowpouptime.to_r*1000.0/igmdelay.to_r / 255.0 );
new img imglastpopup;

new db dbgame;
dbgame.load( LANGDIR + "gametxts.db" );
new db dbobject;
dbobject.load( LANGDIR + "objectives.db" );

public 	def guifontcolor	{	.grey(240);	}

public globsfx(string sfile, int vol)	{
	string sfx = "sfx" + sfile;
	new snd <sfx>;
	<sfx>.load( SFXPATH + sfile + ".ogg" );
	<sfx>.setvol(vol);
}

.globsfx("magic1", 60);
.globsfx("hint1", 25);
.globsfx("hint2", 50);
.globsfx("popitem", 80);
.globsfx("retitem", 30);
.globsfx("openpopup", 30);
.globsfx("closepopup", 30);
.globsfx("butclick2", 50);
.globsfx("wysun2", 100);

class BanGuiSrc{
	init	{
		new anima guihint;
		guihint.load( "scripts/sys_gui/hint.pyz" );
		guihint.hide;
		guihint.setz(iGuiZ);
		new anima guirose;
		guirose.load( "scripts/sys_gui/roza.pyz" );
		guirose.setz(iGuiZ);
		guirose.hide;
		new anima gguimenu;
		gguimenu.load( "scripts/sys_gui/menu.pyz" );
		gguimenu.setz(iGuiZ);
		gguimenu.hide;
		new anima gguishowhint;
		gguishowhint.load( "scripts/sys_gui/showhintb.pyz" );
		gguishowhint.setz(iHintStarZ);
		gguishowhint.hide;
		new anima guiloupe;
		new anima anpopexit;
		anpopexit.load( "scripts/sys_gui/popexit.pyz" );
		anpopexit.hide;
		new anima guipiorko;
		guipiorko.load( "scripts/sys_gui/piorko.pyz" );
		guipiorko.hide;
		guipiorko.setz(iGuiBookZ+2);

		new anima gguiglass;
		gguiglass.load( "scripts/sys_gui/szkielko.pyz" );
		gguiglass.setz(iSzkielkoZ);
		gguiglass.hide;
		
		new anima gguipopup;
		gguipopup.load("scripts/sys_gui/popup.pyz");
		gguipopup.setz(iPopupZ);
		gguipopup.hide;
		
		.with(A, "guihint", "guirose", "gguiglass",
			"movoffsetl");
		.with(A, "gguimenu", "guipiorko",
			"movoffsetr");
		
		new db dbitems;
		dbitems.load( LANGDIR + "popup_items.db" );
		
		new font fnthogui;
		fnthogui.load( dbconf.dbget("hoguifont:"), dbconf.dbget("item_txtname_size:") );
		
		new anima guimigot;
		guimigot.load("scripts/sys_gui/migot.pyz");
		guimigot.rle;
		guimigot.setz( iSzkielkoPodZ + 2 );
		guimigot.hide;
		
		new text gtxtskipitem;
		gtxtskipitem.setfont("fnthogui");
		gtxtskipitem.txtsetcol( dbgame.dbget("skipdialog"), .guifontcolor );
		gtxtskipitem.hide;
		
		new img imgobjective;
		imgobjective.load("scripts/sys_gui/podobjective.png");
		imgobjective.hide;
	}
	load	{
		dbitems.addtogamevars("dbitems");
		guihint.addtogamevars("globalhint");
		guirose.addtogamevars("globalrose");
		gguimenu.addtogamevars("globalmenu");
		gguishowhint.addtogamevars("globalshowhint");
		guiloupe.addtogamevars("globalloupe");
		anpopexit.addtogamevars("globalpopexit");
		guipiorko.addtogamevars("globalpiorko");
		gguipopup.addtogamevars("globalpopup");
		gguiglass.addtogamevars("globalglass");
		fnthogui.addtogamevars("fnthogui");
		guimigot.addtogamevars("globalmigot");
		gtxtskipitem.addtogamevars("gtxtskipitem");
		imgobjective.addtogamevars("imgobjective");
		.loadguiloupe;
	}
	loadguiloupe	{
		if( clsave.bis("e1_mg09_szkielko_finished") )	{
			guiloupe.load( "scripts/sys_gui/reka2.pyz" );
		} else {
			guiloupe.load( "scripts/sys_gui/reka.pyz" );
		}
		guiloupe.hide;
	}
}

new BanGuiSrc banguisrc;

class BanGui	{
	init	{
		new gmimgvec grguiloupe;
		imglastpopup.create(2,2,.transparent);
		imglastpopup.hide;
		imglastpopup.setz( iPopupZ );
	}
	isadvclass	{	<gameapi.getgamename>.hasvar("clcamera");	}
	initgui	{
		@sactpath = .getgraphpath;
		
		new bool gui_skipclick = false;
		//-------------- gui -------------------------------
		.path = ("sys_gui");
		
		new int iItemSlots = 8;
		
		.newanima("guinventory", "inventory.pyz", iGuiZ);
		.newanima("guitemslot", "items.pyz", iGuiZ);
		.newanima("guileft", "itemleft.pyz", iGuiZ);
		.newanima("guiright", "itemright.pyz", iGuiZ);
		guileft.hide;
		guiright.hide;
		
		.copyanima("globalhint", "guihint");
		guihint.show; guihint.setz(iGuiZ);
		.copyanima("guihint", "guihinsub");
		guihinsub.play(1);
		.copyanima("globalrose", "guirose");
		guirose.show;
		.copyanima("globalmenu", "guimenu");
		guimenu.show;
		
		
		//.newanima("guishowhint", "showhintb.pyz", iHintStarZ);
		.copyanima("globalshowhint", "guishowhint");
		guishowhint.hide;
		.copyanima("guishowhint", "guishowhint2");
		.copyanima("guishowhint", "guishowhint3");
		
		.copyanima("globalglass", "guiglass");
		guiglass.setz(iGuiZ);
		guiglass.show;
		.copyanima("globalloupe", "guiloupe");
		guiloupe.var2("enabled", true);
		guiloupe.addmethod("disable", func { enabled=false; });
		guiloupe.addmethod("enable", func { enabled = true; });
		guiloupe.setz(iSzkielkoZ);
		guiloupe.hide;
		.copyanima("guiloupe", "guiloupemask");
		guiloupemask.setframe(1,0);
		guiloupemask.setz(iSzkielkoPodZ);
		new filter ftguiloupe;
		
		new gmimgvec grgotopckstack;
		new gmimgvec grguitemslots;
		@dx = 3;
		guitemslot.hide;
		guinventory.vars2(A, "bdokuj", clsave.bis("guinventory_dokuj") );
		if( bHOInventory )	{
			.newanima("guihoinventory", "hoinventory.pyz", 505);
			guinventory.setz(505);
			guinventory.hide;
		} else {
			for( int i=0; i<iItemSlots; i++ )	{
				.additemslot;
			}
			guinventory.vars2(A, "blockout", false, "sitemshow", null);
			guinventory.show;
			
			/*new ImgRect recslot;
			recslot.set( <grguitemslots.first>.getpx,0, <grguitemslots>.getex,igmapph );*/
		}
		
		.copyanima("guinventory", "guinventorydok");
		.inventory_dock;
		
		string sfun;
		if( .isadvclass )	{
			sfun = "clickon";
			classadvbut::setasbutton2("guinventory", "guinventory", "guinventory");
			guinventory.bautohint = (false);
			guinventory.addmethod("butisin", func { (int x, int y, bool bv, bool ba)
				x >= .getpx && x < .getex && y >= .getpy;
				} );
			
			classadvbut::setasbutton2("guileft", "guileft", "guileft");
			guileft.bautohint = (false);
			classadvbut::setasbutton2("guiright", "guiright", "guiright");
			guiright.bautohint = (false);
		} else if( !bHOInventory) {
			guinventory {
				.Button_isin;
				.addmethod("butmoveon", func {
					if( !.advstdstate ) return;
					advmouse.setact;
					} );
				.addmethod("butmoveoff", func {
					if( !.advstdstate ) return;
					advmouse.setstd;
					} );
				butgame.add(this);
			};
			guileft.Button_stdms;
			guiright.Button_stdms;
			butgame.add("guileft");
			butgame.add("guiright");
			sfun = "butclick";
		}
		guinventory.addmethod( sfun, func {
			//.advmslock;
			//.inventory_check;
			//if( !grguitems.isin(mouse.getpos,1,0) )	{
			if( guinventorydok.isin(mouse.getpos,1,0) )	{
				bdokuj = !bdokuj;
				clsave.set("guinventory_dokuj", bdokuj);
				.inventory_dock;
				sfxbutclick2.play;
				if( bdokuj==false )
					.inventory_check;
			}
			} );
		.cycle = ("_timrevinv", func {
			.moveslots(actspeed);
			.play;
			} );
		_timrevinv.vars2(A, "speed", 20, "actspeed", 0);
		_timrevinv.addmethod("startrew", func { (int dir)
			actspeed = dir * speed;
			.stop(true);
			} );
		guileft.addmethod( sfun, func {
			if( !.advstdstate ) return;
			_timrevinv.startrew(1);
			} );
		guiright.addmethod( sfun, func {
			if( !.advstdstate ) return;
			_timrevinv.startrew(-1);
			} );
		guileft.addmethod("butlrel", "stoprewinventory");
		guiright.addmethod("butlrel", "stoprewinventory");
		.cycle = ("_timinv", func {
			@dy = dir*speed;
			if( dir>0 )	{
				if( .inventory_hidden )	{
					//.advsetstdstate;
					//.advmsunlock;
				} else {
					.inventory_move(dy);
					.play;
				}
			} else {
				if( .inventory_showed )	{
					/*@s = grguitemslots.first;
					.inventory_move( <s>.getpy - <s>.lody );*/
					for (int i=0; i<grgotopckstack.size; i++)
						<grgotopckstack.get(i)>._item_gotopck2;
					if( .isretitemstate )	{
						.item_gotopck;
					} else {
						//.advmsunlock;
						if( guinventory.sitemshow!=null )	{
							.showhint( .getanitem(guinventory.sitemshow) );
							guinventory.sitem = (null);
						}
					}
				} else {
					.inventory_move(dy);
					_ = .inventory_showed;
					.play;
				}
			}
			} );
		_timinv.vars2(A, "dir",-1, "speed", 15);
		
		.timer = ("timunblockinventory", 2000, func { guinventory.blockout = (false); } );
		
		if( .isadvclass )	{
			sfun = "clickon";
			classadvbut::setasbutton2("guihint", "guihint", "guihint");
			classadvbut::setasbutton2("guiglass", "guiglass", "guiglass");
			guiglass.smousecursor = ("loupe");
			guiglass.bautohint = (false);
			guihint.bautohint = (false);
		} else {
			guinventory {
				.Button_isinalpha;
				.addmethod("butmoveon", func {
					if( !.advstdstate ) return;
					advmouse.setact;
					} );
				.addmethod("butmoveoff", func {
					if( !.advstdstate ) return;
					advmouse.setstd;
					} );
				butgame.add(this);
			};
			guiglass {
				.Button_isinalpha;
				.addmethod("butmoveon", func {
					if( !.advstdstate ) return;
					advmouse.setact;
					} );
				.addmethod("butmoveoff", func {
					if( !.advstdstate ) return;
					advmouse.setstd;
					} );
				butgame.add(this);
			};
			guihint {
				.Button_isinalpha;
				.addmethod("butmoveon", func {
					if( !.advstdstate ) return;
					advmouse.setact;
					} );
				.addmethod("butmoveoff", func {
					if( !.advstdstate ) return;
					advmouse.setstd;
					} );
				butgame.add(this);
			};
			sfun = "butclick";
		}
		guiglass.addmethod( sfun, func {
			.LOUPE_CLICK;
			if( .isadvclass )	{
				_ = .playbehif("beh_LOUPE_CLICK");
			}
			//if( .isadvclass )	{
				if( .actionnr(-1)==0 )	{
					.show_loupe;
					sfxmagic1.playif;
				} else if (.actionnr(-1)==1 )	{
					.hide_loupe;
				}
			/*} else {
				if( !.advstdstate ) return;
				.LOUPE_CLICK;
			}*/
			} );
		guihint.addmethod( sfun, func {
			if( .isadvclass )	{
				if( .actionname=="hint" )	{
					guihinsub.anhide;
					guirose.anhide;
					.play("click");
					_ = .playbehif("beh_HINT_CLICK");
				}
			} else {
				if( !.advstdstate ) return;
				<gameapi.getgamename>.HINT_CLICK;
			}
			} );
		guihint.addmethod("onfinish", func {
			match(.actionname)	{
				"click" => {
					.play("grow");
				}
				"grow" => {
					.play("hint");
					guihinsub.play(1);
					guirose.play(0);
				}
				? => ;
			}
			} );
		
		.copyanima("globalmigot", "guimigot");
		
		.newanima("anguibook", "$scripts/sys_book/guibook.pyz", iGuiBookZ );
		if( !clsave.bis("guibook_taken") )
			anguibook.hide;
		
		if( .isadvclass )	{
			sfun = "clickon";
			classadvbut::setasbutton2("anguibook", "guibook", "book");
			anguibook.bautohint = (false);
		} else {
			anguibook {
				.addmethod("isbutin", func { (@x, @y)
					@iac = .actionnr(-1);
					@ifr = .framenr;
					.setframe(0,0);
					.isin(x,y,1,1);
					.setframe(iac,ifr);
					} );
				.addmethod("butmoveon", func {
					if( !.advstdstate ) return;
					advmouse.setact;
					} );
				.addmethod("butmoveoff", func {
					if( !.advstdstate ) return;
					advmouse.setstd;
					} );
				butgame.add(this);
			};
			sfun = "butclick";
		}
		anguibook.addmethod( sfun, func {
			if( .advstdstate )	{
				ccs.buildfromscreen;
				gameapi.play("mgBook");
			}
			} );
		
		.setgraphpath(sactpath);
		
		
		//-------------- pck items -------------------------------
		new string _clicked_guiitem;
		.freeactitem;
		if( .isadvclass )	{
			new advDelayMover guimov;
		} else {
			new DelayMover guimov;
			guimov.b2clicks = (true);
		}
		//guimov.setclickrel(false);
		guimov.unlock;
		
		new gmimgvec grguitems;
		
		new string sanitemprefix = "anitem_";
		
		//------------- schowaj inventory na init
		if( !bHOInventory )	{
			for( int i = 0; i<grguipck.size; i++ )
				._addtopck( grguipck.get(i) );
			.inventory_show;
			new Rect invhide(0,0,0,0);
			invhide.setborders(0,guinventory.getpy,igmappw,igmapph);
			bool b =  guinventory.bdokuj;
			guinventory.bdokuj = (0);
			.inventory_hide;
			new Rect invshow(0,0,0,0);
			invshow.setborders(guileft.getex, guinventory.getpy, guiright.getpx, igmapph);
			guinventory.bdokuj = (b);
			if( b )
				.inventory_show;
		}
		
		//------------ auto hint ------------------------
		
		new gmimgvec grhints;
		if( .isadvclass )	{
			sfun = func {
				grhints.free;
				for( int i=0; i<grbuts.size; i++)	{
					if( <grbuts.get(i)>.ishintablebut )
						grhints.add( grbuts.get(i) );
				}
				if( grhints.size )	{
					@s = grhints.rand;
					guimigot.setpos( <s>.getcx, <s>.getcy );
					guimigot.play(0);
				}
				.play;
				};
			.timplay("_tim_autohint", dbconf.dbget("autohintdelay:"), sfun );
		}
		// ------- texty-buttony ---------------
		if( .isadvclass )	{
			new img imgskipdialog;
			imgskipdialog.create( gtxtskipitem.getw, gtxtskipitem.geth, .transparent );
			imgskipdialog.blit("gtxtskipitem");
			imgskipdialog.setz( iTxtButtonZ );
			imgskipdialog.hide;
			imgskipdialog.Button_isin;
			imgskipdialog.Button_moveonms;
			imgskipdialog.Button_moveoffms;
			imgskipdialog.addmethod("butclick", func { .skipactbeh; });
			butgame.add("imgskipdialog");
		}
		
		new img imgobject;
		imgobject {
			.vars2(A, "sobject", null);
			.timer=("timfinobj", 5000, func { imgobject.anzoomfadeout(ishowpouptime,null); } );
		};
		.newtext("txtobject1", "", "fntsubtitle", subtitle.getcolor );
		.newtext("txtobject2", "", "fntsubtitle", subtitle.getcolor );
		.newtext("txtobject3", "", "fntsubtitle", subtitle.getcolor );
		new gmimgvec grobjectives;
		grobjectives.addlist(A, "imgobject", "txtobject1", "txtobject2", "txtobject3");
		grobjectives.hide;
		new vector _vecobjective;
		_vecobjective.type("string");
		
		//--------------
		.save_game;
	}
	int behstarteropt(string sbeh, string sdb,int irow,int iordcol, string sord)	{
		match(sord)	{
			"-skip" => {
			}
			? => iordcol++;
		}
		iordcol;
	}
	//-------------- lupa------------------
	loupe_visible	{	guiloupe.isvisible;	}
	update_loupepos	{
		if( .loupe_visible && guiloupe.enabled )	{
			.setpos_loupe(mouse.getpos);
		}
	}
	setpos_loupe(int x, int y)	{
		guiloupe.setpos(x, y);
		guiloupemask.setpos(x, y);
	}
	show_loupe	{
		guiglass.setframe(1,0);
		guiloupe.show;
		if( grguiloupe.size )	{
			guiloupemask.show;
			ftguiloupe.link( "guiloupemask" );
			for( int i=0; i<grguiloupe.size; i++)	{
				@s = grguiloupe.get(i);
				if( <s>.mtype == "loupe" )	{
					ftguiloupe.loupe( s );
				} else if (<s>.mtype == "umask" )	{
					<s>.startumask;
				}
			}
			//ftguiloupe.lineardodge( "guiloupemask" );
		}
		.update_loupepos;
	}
	hide_loupe	{
		ftguiloupe.removeallblend;
		ftguiloupe.unlink;
		guiloupe.hide;
		guiloupemask.hide;
		grguiloupe.eval( func { if( mtype=="umask" ) .stopumask; } );
		guiglass.setframe(0,0);
		advmouse.setstd;
	}
	//--------------hint -------------------
	showhint(string sob)			{	.showhintdxdy(sob,0,0);	}
	showhintdxdy(string sob, int x, int y)	{	.showhintxy(<sob>.getcx + x, <sob>.getcy + y);	}
	showhintxy(int x, int y)	{
		if( guishowhint.isplaying(-1) )	{
			if( guishowhint2.isplaying(-1) )	{
				if( guishowhint3.isplaying(-1) )	{
					guishowhint._showhint(x,y);
				} else guishowhint3._showhint(x,y);
			} else guishowhint2._showhint(x,y);
		} else guishowhint._showhint(x,y);
	}
	_showhint(int x, int y)	{
		.setpos(x,y);
		.play(-1);
	}
	showhintitem(string sitem)	{
		guinventory.blockout = (true);
		guinventory.sitemshow = (sitem);
		if( .inventory_playing || .inventory_hidden )	{
			.inventory_in;
		} else
			.showhint( .getanitem(sitem) );
	}
	showhintitemif(string sitem)	{	if(clsave.bis("ma_"+sitem) ) .showhintitem(sitem);	}
	gui_toloupe(string san)	{
		<san>.var2("mtype", "loupe");
		grguiloupe.add(san);
		grguiloupe.sortimgs;
		.gui_refreshloupe;
	}
	gui_removefromloupe(string san)	{
		grguiloupe.remove(san);
		.gui_refreshloupe;
	}
	gui_refreshloupe	{
		if( <gameapi.getgamename>.hasvar("guiloupe") && .loupe_visible )	{
			.hide_loupe;
			.show_loupe;
		}
	}
	//------------------------------------------------
	int subanalizeaninstr(string san, string sdb, int irow, int icol, string sord)	{
		bool banalize = ( san!=null );
		int i[2];
		match( sord )	{
			"-toloupe" => {
				if( banalize ) {
					.gui_toloupe(san);
				}
			}
			"-loupeumask" => {
				if( banalize )	{
					<san> {
						.var2("mtype", "umask");
						new filter ftumask;
						.addmethod("startumask", func {
							ftumask.link(this);
							ftumask.umask("guiloupemask");
							} );
						.addmethod("stopumask", func {
							ftumask.removeallblend;
							ftumask.unlink;
							} );
					};
					grguiloupe.add(san);
				}
			}
			"-popz" => {
				i0 = <sdb>.get(irow,icol);	icol++;
				if( banalize )	{
					<san>.setz(iPopupZ+i0);
				}
			}
			"-loupez" => {
				i0 = <sdb>.get(irow,icol);	icol++;
				if( banalize )	{
					<san>.setz(iSzkielkoPodZ+i0);
				}
			}
			? => icol--;
		}
		icol;
	}
	//-------------- but item -------------------------------
	int subanalizebut(string sbut, string sdb, int irow, int icol, string sord)	{
		match( sord )	{
			"-inloupe" => {
				<sbut>.bshownonvis = (true);
				<sbut>.addmethod("butisin", func { (int x, int y, bool bv, bool ba)
					if( guiloupe.isvisible )	{
						.isin(x,y,false, (balpha==-1 ? ba : balpha) );
					} else 0;
					} );
			}
			"-rotopck" => {
				.setasitemtopck(sbut);
			}
			"-topck" => {
				.setasitemtopck(sbut);
				<sbut>.sitemtopck = ( <sdb>.get(irow,icol) );
				icol++;
			}
			"-popup" => {
				.copyanima("globalpopexit", sbut+"popexit" );
				<sbut> {
					smousecursor = "loupe";
					bshownonvis = true;
					.vars2(A, "state", "hidden", "spopexit", this+"popexit", "spopwnd", this+"_window");
					.hide;
					<spopwnd>.hide;
					<spopwnd>.setz( iPopupZ );
					<spopexit>.setz( iPopupZ+100 );
					.addmethod("butisin", func { (int x, int y, bool bigv, bool biga)
						if( state=="hidden" ) .isin(x,y,0,biga);
						else <spopexit>.isin(x,y,1,0) || !<spopwnd>.isin(x,y,1,0);
						} );
					.addmethod("moveon", func {
						if( state=="shown" )	{
							advmouse.setbut;
							<spopexit>.setframe(0,1);
						} else advmouse.set(smousecursor);
						} );
					.addmethod("moveoff", func {
						advmouse.setstd;
						if( state=="shown" )	{
							<spopexit>.setframe(0,0);
						}
						} );
					.addmethod("clickon", func {
						if( state=="shown" )	{
							_ = .playbehif( "beh_"+.getbutname+"_QUIT" );
						}
						} );
					.addmethod("hidepopup", func {
						<spopexit>.hide;
						<spopwnd>.hide;
						state = "hidden";
						} );
					.addmethod("showpopup", func {
						<spopexit>.show;
						<spopwnd>.show;
						<spopexit>.setpos( <spopwnd>.getex-2, <spopwnd>.getpy );
						imglastpopup.hide;
						state = "shown";
						} );
				};
			}
			? => ;
		}
		icol;
	}
	setasitemtopck(string sbut)	{
		GuiItem::setasrototaker(sbut, iRotoIleRot, iRotoIleObrotow);
		<sbut>.vars2(A, "styperoto", "init", "sbehstate", "behstate_playbeh", "sitemtopck", null);
		<sbut>.addmethod("rototaker_endroto", func {
			if( styperoto=="startroto" )	{
				if( .isadvclass )	{
					if( sbehstate=="behstate_nobeh" )	{
						._item_gotopck;
					} else {
						@sbeh = "beh_"+.getbutname+"_TAKEN";
						if( .behexist( sbeh ) )	{
							.playbeh( sbeh );
						} else {
							if( sgmstate=="state_itemgotocenter" )
								.advsetstate("state_itemgotopck");
							._item_gotopck;
						}
					}
				} else ._item_gotopck;
			} else if( styperoto=="endroto") {
				.freeactitem;
				styperoto = "inpck";
				.hide;
				
				if( .isadvclass )	{
					if( sbehstate!="behstate_nobeh" )	{
						.advinitial;
						@s = .getbutname;
						@sbeh = "beh_"+ s +"_INPCK";
						if( .behexist(sbeh) )	{
							.playbeh(sbeh);
						} else {
							sbeh = "beh_"+ this +"_INPCK";
							if( .behexist(sbeh) )
								.playbeh(sbeh);
						}
					}
					if( sitemtopck!=null )	{
						.addtopck(sitemtopck);
					}
					grgotopckstack.remove(this);
				} else {
					.advinitial;
					<GAME>.<this+"_INPCK">;
				}
			}
			} );
		<sbut>.addmethod("clickpopup", func {
			.hide_itempopup(sitemtopck);
			.item_gotocenterobj(this);
			gui_skipclick = true;
			.advbutrefresh;
			} );
		if( .isadvclass )	{
			<sbut>.addmethod("clickon", func {
				if (styperoto=="init")	{
					@s = "beh_"+.getbutname+"_TAKE";
					if( .behexist(s) )	{
						sbehstate = "behstate_playbeh";
						.playbeh(s);
					} else {
						sbehstate = "behstate_nobeh";
						if( sitemtopck!=null )
							.saveitemtopck(sitemtopck);
						._item_gotocenter;
					}
				} else if (styperoto=="readytogo")	{
					.clickpopup;
				} else if (styperoto=="inpck")	{
				}
				} );
		} else {
			<sbut> {
				.vars2(A, "gettyp", "itemtotake", "disable", 0, "bignoralpha", 0);
				.Button_isinalpha;
				.addmethod("isbutin", func { (@x, @y)
					!disable && .isin(x,y,1,bignoralpha);
					} );
				.addmethod("butmoveon", func {
					if( !.advstdstate ) return;
					advmouse.set("take");
					} );
				.addmethod("butmoveoff", func {
					if( !.advstdstate ) return;
					advmouse.setstd;
					} );
				.addmethod("butclick", func {
					if( !.advstdstate ) return;
					if( styperoto=="readytogo" )	{
						.clickpopup;
					} else {
						if( <GAME>.hasmet( this+"_TAKE" ) )	{
							<GAME>.<this+"_TAKE">;
						} else .item_gotocenter;
					}
					} );
			};
			butgame.add(sbut);
		}
	}
	setactitem(string s)	{	_clicked_guiitem=s;	}
	getactitem		{	_clicked_guiitem;	}
	freeactitem		{	.setactitem(null);	}
	item_gotocenter	{
		.advmslock;
		.advsetstate("state_itemgotocenter");
		._item_gotocenter;
	}
	getitempopexit(string sitem)	{	"anpopup_"+sitem+"_exit";	}
	popitem_gotocenter(string sitem)	{	.popitem_gotocenterobj(sitem, .getclickedbut);	}
	popitem_gotocenterobj(string sitem, string sobj)	{
		if( sobj!=null )	{
			//.advsetstate("state_popitemopen");
			<sobj>.styperoto = ("readytogo");
			<sobj>.sitemtopck = (sitem);
			<sobj>.setframe("rotostart",0);
			.show_itempopup(sitem, sobj);
			@s = .getitempopexit(sitem);
			<s>.var2("sanitemtopck", sobj);
			<s>.addmethod("clickexit", func {
				if( .isadvclass )	<sanitemtopck>.clickon;
				else <sanitemtopck>.butclick;
				} );
		}
	}
	item_gotocenterobj(string sobj)	{
		.advmslock;
		.advsetstate("state_itemgotocenter");
		._obj_gotocenter(sobj);
	}
	item_takecenter(string sitem)	{
		.saveitemtopck(sitem);
		.item_gotocenter;
	}
	saveitemtostack(string sitem)	{
		@s = "ile_item_"+sitem;
		int ile = clsave.get(s);
		if( ile>0 )	{
			.saveitemoutpck(sitem+"_"+ile);
		}
		ile++;
		clsave.set(s,ile);
		.saveitemtopck(sitem+"_"+ile);
	}
	stackitemobj_topck(string sitem, string sobj)	{
		.saveitemtostack(sitem);
		int ile = clsave.get("ile_item_" + sitem);
		if( ile == 1 )	{
			.popitem_gotocenterobj(sitem + "_1",sobj);
		} else	{
			.item_takecenterobj( sitem+"_"+ile, sobj);
		}
	}
	stackitem_topck(string sitem)	{	.stackitemobj_topck(sitem,.getclickedbut);	}
	additemtostack(string sitem)	{	// uwaga! najpierw trzeba wykonac recznie saveitemtostack
		int ile = clsave.get("ile_item_"+sitem);
		if( ile>1 )	{
			.removefrompck(sitem+"_"+(ile-1));
		}
		.addtopck(sitem+"_"+ile);
	}
	item_takecenterobj(string sitem, string sobj)	{
		.saveitemtopck(sitem);
		.item_gotocenterobj(sobj);
	}
	getclickedbut	{	.isadvclass ? grbuts.getsfound : butgame.sclicked;	}
	_item_gotocenter	{
		@s = .getclickedbut;
		if( s!=null )
			._obj_gotocenter(s);
	}
	_obj_gotocenter(string s)	{
		if( sgmstate=="state_itemgotocenter" )	{
			<s>.sbehstate = ("behstate_playbeh");
			.setactitem(s);
		}
		if( grguiloupe.contains(s) )	{
			<s>.show;
			.remove_from_loupe(s);
		}
		<s>.setframe("rotostart", 0);
		<s>.styperoto = ("startroto");
		<s>.setz( iTakeZ );
		<s>.rototaker_startact(.getappcenter, "rotocenter");
	}
	item_gotopck	{
		@s = .getactitem;
		if( s!=null )	{
			<s>._item_gotopck2;
		}
	}
	_item_gotopck2	{
		if( .gettyp=="pckitem" ) ._pckitem_gotopck;
		else ._item_gotopck;
	}
	_item_gotopck	{
		if( .isretitemstate )	{
			.advmslock;
			.advsetstate("state_itemgotopck");
		} else
			grgotopckstack.addonce(this);
		
		if( !bHOInventory && (.inventory_playing || .inventory_hidden) )	{
			.inventory_in;
		} else {
			if( bHOInventory )	{
				@s = "guihoinventory";
			} else {
				/*if( grguitems.size+1 > grguitemslots.size )
					.additemslot;*/
				@s = .lastemptyslot;
			}
			
			styperoto = "endroto";
			@sac = .actionname;
			.setframe("rotopck",0);
			@w = .getw; @h = .geth;
			.setframe(sac,0);
			//.rototaker_startact( <s>.getcx, <s>.getcy, "rotopck");
			if( <s>.getpx >= guileft.getex && <s>.getex < guiright.getpx )
				.rototaker_startwh( <s>.getcx, <s>.getcy, .getw, .geth, w, h);
			else .rototaker_startwh( guinventory.getcx, guinventory.getcy, .getw, .geth, w, h);
		}
	}
	item_returntopck(string sitem)	{	<.getanitem(sitem)>._pckitem_gotopck;	}
	_pckitem_gotopck	{
		if( .isretitemstate )	{
			.advmslock;
			.advsetstate("state_pckitemgotopck");
		} else
			grgotopckstack.addonce(this);
		if( .inventory_playing || .inventory_hidden )	{
			.inventory_in;
		} else {
			sfxretitem.play;
			.saveitemtolastslot;
			grguitems.addonce(this);
			
			.setframe(0,0);
			@w = .getw; @h = .geth;
			.setframe(1,0);
			.rototaker_startwh( <myslot>.getcx, <myslot>.getcy, .getw, .geth, w, h);
		}
	}
	saveitemtolastslot	{	.saveitemtoslot(.lastemptyslot);	}
	saveitemtoslot(string sslot)	{
		if( sslot == null )	{
			"sslot = null!"->print;
		} else {
			myslot = sslot;
			<myslot>.myitem = (this);
		}
	}
	//-------------- pocket -------------------------------
	guimov_GET	{
		if( .advstdstate && !.advgetlock && grguitems.isinfunc(mouse.getpos, func { (int x, int y)
				.withincut(x,y) && (.isin(x,y,1,1) || x.length(x-.getcx, y-.getcy)<=30);
			}) )	{
			sfxpopitem.play;
			@s = grguitems.getsfound;
			grguitems.remove(s);
			< <s>.myslot >.myitem = (null);
			<s>.myslot = (null);
			<s>.play(1);
			<s>.anclipscreen;
			.setactitem(s);
			.mssetobj(s);
			if( !.isadvclass )	{
				.advsetstate("getitem");
			}
		}
	}
	guimov_PUT	{
		@s = .getfree;
		if( !.advgetlock )	{
			if( .isadvclass )	{
				@sbut = .advfocusedbut;
				@sbeh = "beh_USE_" + <s>.getbutname;
				if( sbut!=null && .playbehif( sbeh + "_ON_" + <sbut>.getbutname ) ) {
					// nie robimy 'freeactitem'
				} else if( !.playbehif( sbeh ) )	{
					<s>.sbehstate = ("behstate_nobeh");
					.freeactitem;
					<s>._pckitem_gotopck;
				}
			} else {
				@smet = "USE_" + <s>.getbutname;
				if( <GAME>.hasmet( smet ) )	{
					<GAME>.<smet>;
				} else {
					.advsetstdstate;
					.item_gotopck;
				}
				//.freeactitem;
			}
		}
	}
	getanitem(string sitem)	{	sanitemprefix+sitem;	}
	addtopck(string sitem)		{	<gameapi.getgamename>._addtopck(sitem);	}
	isaniteminpck(string sitem)	{	<gameapi.getgamename>.hasvar(.getanitem(sitem));	}
	isiteminpck(string sitem)	{	clsave.bis("ma_"+sitem);	}
	_addtopck(string sitem)	{
		@s = .getanitem(sitem);
		if( !grguitems.contains(s) )	{
			if( !bHOInventory )	{
				.newanima(s, "$scripts/adv_items/"+sitem+".pyz", iTakeZ);
				GuiItem::setasrototaker(s, iRotoIleRot, iRotoIleObrotow);
				<s>.vars2(A, "getbutname", sitem, "myslot", null, "gettyp", "pckitem", "sbehstate", "behstate_nobeh");
				<s>.saveitemtolastslot;
				
				<s>.addmethod("rototaker_endroto", func {
					if( sgmstate=="state_pckitemgotopck" || sbehstate=="behstate_nobeh" )	{
						grgotopckstack.remove(this);
						.freeactitem;
						.setposonmyslot;
						if( sgmstate=="state_pckitemgotopck" )	{
							.advinitial;
						}
					}
					} );
				<s>.setposonmyslot;
				grguitems.add(s);
			}
		}
		.saveitemtopck(sitem);
	}
	setposonmyslot	{
		.setpos( <myslot>.getcx, <myslot>.getcy );
		.cliptoguislot;
		.play(0);
	}
	saveitemtopck(string sitem)	{
		clsave.set("ma_"+sitem,1);
		clsave.set("taken_"+sitem,1);
		grguipck.addonce(sitem);
	}
	saveitemoutpck(string sitem)	{
		grguipck.remove(sitem);
		clsave.set("ma_"+sitem,0);
	}
	isretitemstate	{	sgmstate=="state_pckitemgotopck" || sgmstate=="state_itemgotopck";	}
	removefrompck(string sitem)	{
		@s = sanitemprefix + sitem;
		if( !bHOInventory && <GAME>.hasvar(s) )	{
			@sitm = .getactitem;
			if( s==sitm ) .freeactitem;
			<s>.anhide;
			if( <s>.myslot != null && < <s>.myslot>.myitem==s )	{
				< <s>.myslot>.myitem = (null);
				<s>.myslot = (null);
			}
		}
		grguitems.remove(s);
		.saveitemoutpck(sitem);
	}
	additemslot	{
		@id = grguitemslots.size;
		@s = "guitemslot"+id;
		.copyanima("guitemslot", s);
		//<s>.show;
		<s>.setslotpos;
		<s>.var2("myitem",null);
		if( .isadvclass )	{
			classadvbut::setasbutton2(s, "guislot"+id, "guislot");
			<s>.addmethod("butisin", func { (int x, int y, bool bv, bool ba)
				.withincut(x,y) && .isin(x,y,bv,ba);
				} );
			<s>.smousecursor = ("normal");
			//setasbutton2(string san, string sname, string styp)
		}
		grguitemslots.add(s);
	}
	setslotpos	{
		.cliptoguislot;
		if( grguitemslots.size>=1 )	{
			@dx = 0;
			.ansetbpos( <grguitemslots.last>.getex+dx, .getpy );
		}
	}
	stoprewinventory	{	_timrevinv.stop(false);	}
	moveslots(int dx)	{
		._moveslots(dx);
		if( <grguitemslots.first>.getpx > guileft.getex )
			._moveslots( guileft.getex - <grguitemslots.first>.getpx );
		if( <grguitemslots.last>.getex < guiright.getpx )
			._moveslots( guiright.getpx - <grguitemslots.last>.getex );
	}
	_moveslots(int dx)	{
		grguitems.move(dx, 0);
		grguitemslots.move(dx, 0);
	}
	cliptoguislot	{
		@dx = 3;
		.clip( guileft.getex+dx, 0, guiright.getpx - dx, igmapph );
	}
	lastemptyslot	{
		for( int i=0; i<grguitemslots.size; i++)	{
			@s = grguitemslots.get(i);
			if( <s>.myitem == null ) return s;
		}
		<GAME>.additemslot;
		guileft.show;
		guiright.show;
		grguitemslots.last;
	}
	load_pocket(string sfile)	{	grguipck.vecload( sfile+"_banguipck.db" );	}
	save_pocket(string sfile)	{	grguipck.vecsave( sfile+"_banguipck.db" );	}
	inventory_check	{
		if( .inventory_hidden )	.inventory_in;
		else .inventory_out;
	}
	inventory_dock	{
		if( clsave.bis("guinventory_dokuj") )	guinventorydok.setframe("locked_gui",0);
		else guinventorydok.setframe("unlocked_gui",0);
	}
	inventory_out	{	.inventory_start(1);	}
	inventory_in	{	.inventory_start(-1);	}
	inventory_start(int dir)	{
		if( _timinv.isplaying )	{
			if( _timinv.dir == dir ) return;
			_timinv.stop(false);
		}
		_timinv.dir=(dir);
		_timinv.play;
		sfxwysun2.play;
	}
	inventory_playing	{	_timinv.isplaying;	}
	inventory_move(int y)	{
		grguitemslots.move(0, y);
		guinventory.move(0, y);
		guinventorydok.move(0, y);
		guileft.move(0,y);
		guiright.move(0,y);
		grguitems.move(0,y);
	}
	inventory_hidden	{
		int dy = <grguitemslots.first>.getpy - igmapph;
		if( dy>0 )	{
			.inventory_move(-dy);
			true;
		} else dy==0;
	}
	inventory_showed	{
		//<grguitemslots.first>.getpy <= <grguitemslots.first>.lody;
		if( guinventory.getposy < 0 )	{
			.inventory_move( -guinventory.getposy );
			true;
		} else guinventory.getposy == 0;
	}
	inventory_hide	{
		if( !guinventory.bdokuj )	{
			while( !.inventory_hidden )
				.inventory_move(1);
		}
	}
	inventory_show	{
		while( !.inventory_showed )	{
			.inventory_move(-1);
		}
	}
	gui_mousemove	{
		if( !bHOInventory && .advstdstate && grgotopckstack.empty && !.inventory_playing )	{
			|int x, int y| = mouse.getpos;
			if( .inventory_hidden && invshow.isin(x,y) )
				.inventory_in;
			else if ( !guinventory.bdokuj && .inventory_showed && !invhide.isin(x,y) && .inventory_unblocked )
				.inventory_out;
		}
		.update_loupepos;
	}
	inventory_unblocked	{	guinventory.blockout == false;	}
	unblock_inventory(int delay)	{
		if( delay<=0 ) guinventory.blockout=(false);
		else {
			timunblockinventory.setdelay(delay);
			timunblockinventory.play;
		}
	}
	bool gui_mouselclick	{
		if( guimov.moving )	{
			.isadvclass ? guimov.onmouselclick(0,0) :  guimov.onmouselclick;
			false;
		} else true;
	}
	bool gui_mouserclick	{
		if( .loupe_visible )	{
			.hide_loupe;
			false;
		} else {
			.show_loupe;
			sfxmagic1.playif;
			true;
		}
	}
	advinitial	{
		.advmsunlock;
		.advsetstdstate;
	}
	int subloadadventure(string sdb, int irow, int icol, string sord)	{
		match(sord)	{
			"hodoors:" => {
			
			}
			? => ;
		}
		icol;
	}
	remove_from_loupe(string san)	{
		ftguiloupe.removeblend(san);
		grguiloupe.remove(san);
		if( grguiloupe.empty )
			guiloupemask.hide;
	}
	show_itempopup(string sitem, string san)	{ <gameapi.getgamename> (sitem,san) {
		(string sitem, string san)
		
		.saveitemtopck(sitem);
		@s = "anpopup_"+sitem;
		@s2 = s+"_blysk";
		@sim = "_img"+sitem;
		@stxtnew = "_txtnewitem"+sitem;
		@stxtitem = "_txtitem"+sitem;
		@sgr = "_gr_"+sitem;
		@spopex = s + "_exit";
		@sgrall = "_gr2_"+sitem;
		
		if( !.hasvar(s) )	{
			.copyanima("globalpopup", s);
			<s>.Button_isin;
			butgame.add(s);
			.copyanima("globalpopup", s2);
			<s2>.setframe(1,0);
			new img <sim>;
			<sim>.vars2(A, "swnd", s, "sblysk", s2, "sanima", san, "sgr", sgr, "sitem", sitem, "spopexit", spopex);
			
			.newtext(stxtnew, dbgame.dbget("newitem"), "fnthogui", .guifontcolor);
			.newtext(stxtitem, dbitems.dbget(sitem), "fnthogui", .guifontcolor);
			new gmimgvec <sgr>;
			<sgr>.addlist(A, s, s2, stxtnew, stxtitem);
			new gmimgvec <sgrall>;
			<sgrall>.addlist(A, sgr, spopex, san);
			
			.copyanima("globalpopup", spopex);
			<spopex>.setframe(2,0);
			<spopex>.hide;
			<spopex> (s, sitem) { (@swnd, @sitem)
				.vars2(A, "swnd", swnd, "sitem", sitem); 
				.addmethod("isbutin", func { (@x, @y)
					//.isin(x,y,1,1) || ( <swnd>.isvisible && !<swnd>.isin(x,y,1,0) );
					.isin(x,y,1,1) || <swnd>.isvisible;
					} );
				.addmethod("butmoveon", func {
					advmouse.setact;
					.setframe(-1,1);
					} );
				.addmethod("butmoveoff", func {
					advmouse.setstd;
					.setframe(-1,0);
					} );
				.addmethod("butclick", func {
					advmouse.setstd;
					@s = "popup_"+sitem+"_clickexit";
					if( <gameapi.getgamename>.hasmet(s) )	<gameapi.getgamename>.<s>;
					else if ( .hasaddedmet("clickexit") )	.clickexit;
					else	.hide_itempopup(sitem);
					} );
				butgame.add(this);
			};
		}
		int x = <san>.getcx - <s>.getw/2;
		int y = <san>.getcy - <s>.geth/2;
		<s>.setpos(x,y);
		<s2>.setpos(x,y);
		<spopex>.setpos(x,y);
		@dh = 0.12;
		<stxtnew>.setpos( <s>.getcx - <stxtnew>.getw/2, <s>.getpy + dh*<s>.geth );
		<stxtitem>.setpos( <s>.getcx - <stxtitem>.getw/2, <s>.getey - dh*<s>.geth - <stxtitem>.geth );
		@z = <s2>.getz + 5;
		<san>.setz( z );
		<sim>.setz( z );
		<stxtnew>.setz( z );
		<stxtitem>.setz( z );
		<spopex>.setz( z );
		butgame.sort;
		<sgr>.show;
		
		if( <s>.getpx < igmoffsetx ) <sgrall>.move( igmoffsetx-<s>.getpx , 0 );
		if( <s>.getex > (iResX+igmoffsetx) ) <sgrall>.move( (iResX+igmoffsetx)-<s>.getex , 0 );
		if( <s>.getpy < igmoffsety ) <sgrall>.move( 0, igmoffsety-<s>.getpy );
		if( <s>.getey > (iResY+igmoffsety) ) <sgrall>.move( 0, (iResY+igmoffsety)-<s>.getey );
		
		<sim>.imgbuildfromlist(A, s, s2, stxtnew, stxtitem, san);
		//<sim>.imgbuildfromvec(sgr);
		<sgr>.hide;
		<san>.hide;
		
		sfxopenpopup.play;
		<sim>.anzoomfadeinout(ishowpouptime,1,1, func {
			.hide;
			<sgr>.show;
			<sanima>.show;
			<spopexit>.show;
			butgame.onmousemove;
			<gameapi.getgamename>.<"popup_"+sitem+"_in">;
			} );
	}; }
	hide_itempopup(string sitem) { <gameapi.getgamename> (sitem) {
		(string sitem)
		
		@s = "anpopup_"+sitem;
		@s2 = s+"_blysk";
		@sim = "_img"+sitem;
		@stxtnew = "_txtnewitem"+sitem;
		@stxtitem = "_txtitem"+sitem;
		@sgr = "_gr_"+sitem;
		@spopex = s + "_exit";
		
		if( clsave.bis("taken_"+sitem) )
			<sim>.imgbuildfromlist(A, s, stxtnew, stxtitem);
		else	{
			<sim>.imgbuildfromlist(A, s, s2, stxtnew, stxtitem, <sim>.sanima);
			< <sim>.sanima>.hide;
		}
		<sgr>.hide;
		<spopex>.hide;
		
		sfxclosepopup.play;
		<sim>.anzoomfadeinout(ishowpouptime,-1,-1, func {
			.hide;
			<gameapi.getgamename>.<"popup_"+sitem+"_out">;
			} );
	}; }
	isvisible_itempopup(string sitem)	{
		<gameapi.getgamename>.hasvar("anpopup_"+sitem) && (<"anpopup_"+sitem>.isvisible || <"_img"+sitem>.isvisible);
	}
	getitempopupshadow(string sitem)	{	"anpopup_"+sitem+"_blysk";		}
	hideitempopupshadow(string sitem)	{	<.getitempopupshadow(sitem)>.hide;	}
	show_objective(string sid)	{
		int id = dbobject.findbyrow(sid);
		if( id<0 ) return;
		int ile = dbobject.getcolsno(id);
		if( ile<2 ) return;
		//imgobject.clone("imgobjective");
		//imgobject.show;
		_vecobjective.free;
		_vecobjective.add("imgobjective");
		for (int i=1; i<ile; i++)	{
			@s = "txtobject" + i;
			<s>.txtsetcol(dbobject.get(id,i), subtitle.getcolor);
			<s>.setpos( imgobjective.getcx - <s>.getw/2, imgobjective.getcy - (2-i)*(<s>.geth+2) );
			//imgobject.blit(s);
			_vecobjective.add(s);
		}
		imgobject.imgbuildfromvec("_vecobjective");
		imgobjective.hide;
		imgobject.show;
		imgobject.setz( iGuiZ );
		imgobject.setpos( anguibook.getex + 10, anguibook.getpy - 10 - imgobject.geth );
		imgobject.anzoomfadein( ishowpouptime, func { timfinobj.play;	} );
	}
	//------------------------ 2nd view -----------------
	load_2nd_view(string sfile)	{	<gameapi.getgamename> (sfile)	{ (@sfile)
		
		//an: czachy2w.pyz -bgr bgr1 -hide -hideonstart  -nplay 0 -toloupe
		if( !.hasvar("anczachy2w") )	{
			.newanima("anczachy2w", "$scripts/ad02_brama/czachy2w.pyz", 0);
			bgr1.add("anczachy2w");
			anczachy2w.anhideonsetframe;
			anczachy2w.play(0);
			.gui_toloupe("anczachy2w");
		}
	}; }
	watch_film(string sfilmpath, string snextgametype, string snextgamepath)	{
		clsave.set("filmpath", sfilmpath);
		clsave.set("filmdb","film");
		clsave.set("nextgame_type",snextgametype);
		clsave.set("nextgame_path",snextgamepath);
		if( snextgametype == "-def" || snextgametype == "-adv" )	{
			clsave.set("nextgame", "game" + clsave.get("nextgame_path") + "0");
		} else {
			clsave.set( "nextgame", clsave.get("nextgame_path") );
		}
		gameapi.play("BanFilm");
	}
	// --------------- specjalne do gier -----------
	znaklclick(string san)	{
		if(clsave.bis("guibook_taken"))	{
			.gui_removefromloupe(san);
			.gui_removefromloupe(san+"b");
			<san>.anhide;
			<san+"b">.anhide;
			<san>.disable;
			clsave.bset("e1_"+san+"_wziety");
			.gui_toloupe("anznakout");
			anznakout.setpos( <san>.getcx, <san>.getcy );
			anznakout.anplayfin( 0, func { .hide; .gui_removefromloupe(this); } );
			anznakout.hide;
			if( !<GAME>.hasvar("fxfounditem2") )
				<GAME>.sfx = ("founditem2 50");
			fxfounditem2.play;
		}
	}
	loadznakout	{
		.img = ("$scripts/sys_gui/znakout.pyzH");
		anznakout.setpos(-1000,-1000);
	}
	setasznakbut(string san)	{
		if (clsave.bis("e1_" + san + "_wziety"))	{
			<san>.hide;
			<san+"b">.hide;
		} else {
			<san>.setz(10);
			.gui_toloupe(san);
			.gui_toloupe(san+"b");
			<san+"b">.anhideonsetframe;
			<san+"b">.play(0);
			<san>.hide;
			<san>.Button_moveonms;
			<san>.Button_moveoffms;
			<san>.addmethod("isbutin", func { (@x, @y)
				if( .loupe_visible && .isin(x,y,0,0) ) true;
				else false;
				} );
			<san>.addmethod("butclick", func {
				if( !.advstdstate ) return;
				.znaklclick(this);
				.setadvstdstate;
				} );
			butgame.add(san);
		}
	}
	keydown	{
		.gmcontrol_keydown;
		if( igmdebug )	{
			moddbg.dbkeydown();
			if( keyboard.iskeydown("f") )	{
				ifullscreen=!ifullscreen;
				engine.setfullscreen(ifullscreen);
			}
		}
	}
	//------------------ SAVE -------------------------
	_save_game(string sfile)	{
		.save_pocket(sfile);
		classadv::advautosave;
		classadv::_advsave(sfile);
	}
	_load_game(string sfile)	{
		.load_pocket(sfile);
		classadv::_advload(sfile);
	}
	save_game	{	._save_game(.getsavename);	}
	load_game	{	._load_game(.getsavename);	}
	can_save	{	PrzygodaMode && .advstdstate;	}
	autosave_game	{
		if( .can_save )
			.save_game;
	}
	autoload_game	{
		if( .can_save )
			.load_game;
	}
	/*virtual subaddbehs(string sdb)	{
		<sdb>.dbaddstringrow("behinit_FROM_mgBook|enter:", "|");
	}*/
}

class classadvstdgame2 : ClassGameController, classadvstdgame, BanGui	{
	init	{
		bHOInventory = false;
		ClassGameController::init;
		new Button butgame;
		BanGui::init;
		banguisrc.load;
		
		classadvstdgame::init;
		
		.initadventure;
		.initgui;
		
		new Film film1;
		film1.addmethod("onfinish", func {
			.advsetstdstate;
			.free;
			_ = .playbehif("beh_END_FILM");
			} );
		
		.playbehoninit;
	}
	//playbehoninit	{}
	playfilm(string spath, string sfilm, int x, int y)	{
		.advsetstate("state_playfilm");
		clsave.set("film", spath);
		film1.setpos(x,y);
		film1.playfilm("scripts/"+spath+"/", sfilm);
	}
	playfilmob(string spath, string sfilm, string sob)	{
		.playfilm(spath, sfilm, <sob>.getpx, <sob>.getpy);
	}
	setasbanbeh(string smet)	{	advbanbeh::<"setas"+smet>;	}
	int subloadbeh(string sord, string sbeh, string sdb, int irow, int icol)	{
		string s[2];
		int i[2];
		sord = sord.strsubes(":");
		match( sord )	{
			"popin", "popout" => {
				s1 = <sdb>.get(irow,icol); icol++;
				if( s1=="(" )	{
					i0=icol;
					s1 = <sdb>.get(irow,icol);
					while( s1!=")" )	{
						s1 = <sdb>.get(irow,icol);
						icol++;
					}
				} else "beh popin: no ( error"->print;
				<sbeh>.setasbanbeh(sdb, irow, i0, sord, "popup");
			}
			"openbook" =>	{
				s1 = <sdb>.get(irow,icol); icol++;
				<sbeh>.setasbanbeh(s1, sord);
			}
			"closebook" => {
				<sbeh>.setasbanbeh(sord);
			}
			? => icol--;
		}
		icol;
	}
	public classbehhero_preeval	{
		//("preeval: " + .gettyp + ":" +this)->print;
	}
	public classbehhero_posteval	{
		//("posteval: " + .gettyp + ":"+this)->print;
		@s = .gettyp;
		if( bskip && (s=="talk"||s=="sndplay") )	{
			imgskipdialog.show;
			imgskipdialog.setpos( iResX+igmoffsetx-imgskipdialog.getw, igmoffsety+subtitle.geth );
		} else imgskipdialog.hide;
	}
	mousemove	{
		ClassGameController::mousemove;
		.gui_mousemove;
		classadvstdgame::mousemove;
	}
	mouselclick	{
		__grobj.eval("onmouselclick");
		if( gui_skipclick )	{
			gui_skipclick = false;
		} else if( .advstdstate && .gui_mouselclick )	{
			.advmsclick;
		}
		.mouse_LCLICK;
	}
	mouserclick	{
		__grobj.eval("onmouselclick");
		if( .advstdstate && .gui_mouserclick )	{
			.advmsrclick;
		}
		.mouse_RCLICK();
	}
	mouselrel	{
		__grobj.eval("onmouselrel");
		classadvcontroller::mouselrel;
	}
}




class BansheeStd : StdGame, BanGui	{
	init(string s)	{
		StdGame::init(s);
		if( PrzygodaMode )	{
			BanGui::init;
			banguisrc.load;
			.initgui;
			if(!bHOInventory) .inventory_show;
			
			new string save_prefix = clsave.get("epizod")->getb(0,2) + "_" + GAME + "_";
		}
	}
	//---------------- button exit popup
	butpopexit	{
		anpopexit {
			.Button_isinalpha;
			.vars2(A, "bholdon", false);
			.addmethod("butmoveon", func {
				//if( !.advstdstate ) return;
				advmouse.setbut;
				.setframe(-1,1);
				} );
			.addmethod("butmoveoff", func {
				//if( !.advstdstate ) return;
				advmouse.setstd;
				.setframe(-1,0);
				} );
			.addmethod("butclick", func {
				if( !.advstdstate || bholdon ) return;
				sfxbutclick2.play;
				.mend;
				} );
			butgame.add(this);
		};
	}
	butpopexitisinramka	{
		anpopexit.addmethod("isbutin", func { (int x, int y)
			.isin(x,y,1,1) || !anramka.isin(x,y,1,0);
			} );
	}
	loadimgexitbut	{
		imgbkg.Button_isin;
		imgbkg.addmethod("butclick", func {
			if( .advstdstate )
				.mend;
			} );
		butgame.add("imgbkg");
	}
	loadhoexit	{
		.newanima("anhoexit", "$scripts/sys_gui/popexit.pyz", 1000);
		anhoexit.ansetbpos( igmoffsetx + iResX - anhoexit.getw, igmoffsety );
		anhoexit.Button_stdalpha;
		anhoexit.addmethod("butclick", func {
			if( .advstdstate )	{
				if( <GAME>.hasmet("mexit_hidden") ) .mexit_hidden;
				else {
					@s = clsave.get("GAME_sgmlastscene");
					.stdexitdefadv(s->strsubbs("game")->strsubes("0"), s);
				}
			}
			} );
		butgame.add("anhoexit");
	}
	get_mg_save	{	save_prefix + "finished";	}
	set_mg_finished	{	clsave.bset( .get_mg_save );	}
	is_mg_finished	{	clsave.bis( .get_mg_save );	}
	returntomenu	{
		gameapi.play("MainMenu");
		ccs.buildfromscreen;
	}
	mousemove	{
		.gmcontrol_mousemove;
		if( PrzygodaMode )	{
			.gui_mousemove;
		}
		moddbg.msmove;
	}
	mouserclick	{
		.gmcontrol_mouserclick;
		if( PrzygodaMode && .advstdstate )	{
			_ = .gui_mouserclick;
		}
	}
}

class Banshee : BansheeStd	{
	init(string s)	{
		bHOInventory = false;
		BansheeStd::init(s);
	}
}

class HOBanshee : Hidden, BansheeStd	{
	init(string s)	{
		bHOInventory = true;
		BansheeStd::init(s);
		.init_hidden;
		.loadhoexit;
	}
	mtoloupe(string sname)	{
		string s;
		if( <GAME>.hasvar(sname) ) s = sname;
		else s = .mgetel(sname);
		.gui_toloupe(s);
		guiloupemask.setz( <grguiloupe.last>.getz );
		<s>.hide;
		<s>.var2("myz",<s>.getz);
		< <s>.stxtview>.createtxt( .holoupecol );
		<s>.addmethod("isbutin", func { (@x, @y)
			if( .loupe_visible )	{
				.setframe(-1,0);
				.isin(x,y,0,1);
				.setframe(-1,1);
			} else 0;
			} );
		<s>.addmethod("butmoveon", func {
			//guiloupemask.setz(.getz);
			//.setz(guiloupemask.getz);
			;
			} );
		<s>.addmethod("butmoveoff", func {
			//guiloupemask.setz(guiloupe.getz-1);
			//.setz(myz);
			;
			} );
	}
	holoupecol	{	return 0,202,1;	}
}

game BanFilm : StdGame	{
	init	{
		StdGame::init("film");
		advmouse.set("empty");
		if( PrzygodaMode )	{
			BanGui::save_pocket(.getsavename);
		}
		
		//.showfps;
		
		new Film film1;
		film1.bcenter = (true);
		film1.bborders = (true);
		film1.musicclass = ("mus");
		film1.addmethod("onfinish", func {
			//ccs.buildfromfile("scripts/" + clsave.get("filmpath") + "/" + slastframe);
			ccs.buildfromscreen;
			string s = gameapi.getgamename;
			match( clsave.get("nextgame_type") )	{
				"-def" => {
					.gotoadv(clsave.get("nextgame_path"), clsave.get("nextgame"));
				}
				"-adv" => {
					.gotoadv2(clsave.get("nextgame_path"), clsave.get("nextgame"));
				}
				? => gameapi.play(clsave.get("nextgame"));
			}
			} );
		new string slastframe;
		film1 {
			.playfilm( "scripts/"+clsave.get("filmpath") + "/", clsave.get("filmdb") );
			slastframe = sprefilm + iendklatka + ".jpg";
		};
	}
	mouse_lclick	{
		if( film1.isplaying ) film1.stop(true);
	}
	showfps	{
		if( !.hasvar("cfps") )	{
			new CalcFPS cfps;
			cfps.stdset(14, 10, 10);
		}
		cfps.play;
	}
}

game StartBanshee : StdGame	{
	init	{
		StdGame::init("startbanshee");
		
		/*clsave.set("filmpath","cs02_kinnatbook");
		clsave.set("filmdb","film");
		clsave.set("nextgame_type","-def");
		clsave.set("nextgame_path","ad00_endintro");
		clsave.set("nextgame","gamead00_endintro0");
		gameapi.play("BanFilm");*/
		
		.gotoadv("ad001_kszew", "gamead001_kszew0" );
	}
}


new classgamepause clpause;
new classgamemusic clmusic;
clmusic.sndbgrpath("sounds/bgr/");
clmusic.musicpath("sounds/music/");
clmusic.load("sounds/music.db");

new snd sndakskermovon;
sndakskermovon.load("sounds/sfx/butmoveon.ogg");
sndakskermovon.setvol(50);

class classasker2 : classasker	{
	init()	{
		classasker::init();
		
		new snd sndaskexit;		sndaskexit.setstartstopflag(false,true);
		new snd sndaskexitgame;	sndaskexitgame.setstartstopflag(false,true);
		new snd sndyes;			sndyes.setstartstopflag(false,true);
		new snd sndno;			sndno.setstartstopflag(false,true);
		new snd sndaskrestart;	sndaskrestart.setstartstopflag(false,true);
		new snd sndaskrestart2;	sndaskrestart2.setstartstopflag(false,true);

		.reload;
		this.load( "scripts/common/asker.pyz", 12000 );
		this.fxonmovon("sndakskermovon");
	}
	reload	{
		this.setwavpath(SNDPATH);
		@s = .getsndpath;
		sndaskexit.load( s + "narexit.wav");
		sndaskexitgame.load( s + "narexitgame.wav");
		sndyes.load( s + "naryes.wav");
		sndno.load( s + "narno.wav");
		sndaskrestart.load( s + "narrestart.wav");
		sndaskrestart2.load( s + "narrestart.wav");
	}
	askexittomenu()	{
		this.ask( "sndaskexit", "sndyes", "sndno", "myestomenu", "mnotomenu");
	}
	askexitgame	{	.ask( "sndaskexitgame", "sndyes", "sndno", "myestomenu", "mnotomenu");	}
	askrestart()	{
		this.ask( "sndaskrestart", "sndyes", "sndno", "myesrestart", "mnorestart");
	}
	askrestart2()	{
		this.ask( "sndaskrestart2", "sndyes", "sndno", "myesrestart", "mnorestart");
	}
	mnotomenu()	{}
	myestomenu()	{
		if( <GAME>.hasvar("clsave") )
			clsave.free;
		match( gameapi.getgamename() )	{
			"MainMenu" => "exit";
			? => "MainMenu";
		}
		gameapi.play;
	}
	mnorestart()	{
		match(gameapi.getgamename)	{
			"SubMenu" => "MenuGry";
			? => "MainMenu";
		}
		gameapi.play;
	}
	myesrestart()	{	this.crestart();	}
	/*****************************************************************/
	ask( string sask, string syes, string sno, string sf1, string sf2 )	{
		if( !ccs.isplaying )	classasker::ask( sask, syes, sno, sf1, sf2 );
	}
}

new classasker2 claskexit;

public LANG=(@s)	{
	LANG = s;
	SNDPATH = "sounds/";
	if( LANG=="pl" ) LANG="";
	if( LANG.length > 0 ) SNDPATH += LANG + "/";
	
	claskexit.reload;
}

new img imglobcurs;		// globalny kursor aktywnosci
module clbuts	{
	init()	{}
	load()	{
		new classbutton buts;
		buts.build("scripts/common/buttons.pyz", 4000, "imglobcurs");
		buts.transclickfunc( engine.actclassname(), "butclick");
		buts.transmovonfunc( engine.actclassname(), "butmovon");
		buts.transmovofffunc( engine.actclassname(), "butmovoff");
		buts.disableall();
		new db dbb;
		dbb.load("scripts/common/buts.db");
		new snd sndfxglobon;
		sndfxglobon.load("sounds/sfx/globbutmovon.wav");
		sndfxglobon.setvol(50);
		new @bvisible = true;
	}
	reset()	{
		buts.disableall();	
		@sgame = gameapi.getgamename;
		int pos = dbb.findbyrow( sgame );
		if( pos>=0 )	{
			int ile = dbb.getcolsno( pos );
			for( int i=1; i<ile; i++)	{
				buts.enable( dbb.get( pos, i ) );
			}
		}
	}
	setcursorpos(int x, int y)	{	buts.setcursorpos(x,y);	}
	enable(string sbu)	{
		buts.enable( sbu );
	}
	/*****************************************/
	butmovon(string sc)	{
		sndfxglobon.play();
		bvisible = mouse.isvisible;
		mouse.show;
		.<this + "_" + sc + "_butmoveon">;
	}
	butmovoff(string sc)	{
		if( !bvisible ) mouse.hide;
		.<this + "_" + sc + "_butmoveoff">;
	}
	butclick(string sc)	{
		if( sc=="pause" )	{
			clpause.pause();
		} else if( sc=="menu" )	{
			match( gameapi.getgamename )	{
				"MainMenu" => claskexit.askexitgame;
				? => {
					claskexit.askexittomenu();
				}
			}
		} else if (sc=="restart")	{
			claskexit.askrestart();
		}
		.<this + "_" + sc + "_butclick">;
	}
}

class classplacepointer2 : classplacepointer    {
	init()  {
		classplacepointer::init();
		this.load("scripts/common/strzalka.pyz");
	}
}

//clnextgm.load("scripts/common/games.db");
clbuts.load;

gameapi.play("MainLoader");
game MainLoader : StdGame       {
	init    {
		StdGame::init("mainloader");
		
		//_fxtakeitem.load( .getsndpath + "getitem" );
		
		// ADV
		modadv.load("scripts/scripts/defaults.adv");
		modadv.loadsounds("scripts/scripts/sounds.db");
		modadv.settalktype("snd");
		modadv.loadscript("scripts/scripts/initscript.dsc");
		clsave.load("saves/global.txt");
		sgmlastscene = this;
		
		gameapi.play( dbconf.dbget("startgame:") );
	}
}


game gameadvdef : classadvstdgame2	{
	init	{
		classadvstdgame2::init;
		new int ifullscreen=0;
	}
	e1_load_loupe_brama	{	<gameapi.getgamename>	{
		//an: czachy2w.pyz -bgr bgr1 -hide -hideonstart  -nplay 0 -toloupe
		if( !.hasvar("anczachy2w") )	{
			.newanima("anczachy2w", "$scripts/ad02_brama/czachy2w.pyz", 0);
			bgr1.add("anczachy2w");
			anczachy2w.anhideonsetframe;
			anczachy2w.play(0);
			.gui_toloupe("anczachy2w");
		}
	}; }
}


game gamead00_endintro0 : classadvstdgame2	{
	init	{
		classadvstdgame2::init;
		
		.imgs = (A, "e1rekator.pyzH", "e1rekaset.pyzGH 20");
		gre1rekaset.each( func { (int id)
			.var2("myid", (id+1));
			.addmethod("onsetframe", func {
				ane1rekator.setframe( myid-1, <"ane1reka"+myid>.framenr );
				.setpos( ane1rekator.getcx, ane1rekator.getcy );
				} );
			} );
		for( int i=0; i<4; i++) {
			if( clsave.bis("e1_reka_"+i+"_play") )
				.rekaplay(i);
		}
	}
	int e1_getrekaid(string s)	{
		match( s )	{
			"zolty" => 0;
			"red" => 1;
			"blue" => 2;
			"miedz" => 3;
			? => -1;
		}
	}
	e1_dymki_loadhint	{
		new int iddymekhint = 1;
		andymki2.addmethod("onendframe", func {
			int id = .e1_getrekaid(.framename) + 1;
			if( id>0 ) iddymekhint = id;
			} );
		andymki2.onendframe;
	}
	e1_click_dzwon	{
		string s = clsave.get("e1_click_dzwon");
		int id = clsave.get("e1_dzwonki");
		clsave.set("e1_dzwon"+id, s);
		
		if( id == 4 )	{
			id = 1;
			.recehide;
		} else {
			/*
			but: rekazolta ane1reka1
			but: rekared ane1reka2
			but: rekablue ane1reka3
			but: rekamiedz ane1reka4
			*/
			.e1_getrekaid(s);
			int iac = _;
			.rekaplay(iac);
			clsave.bset("e1_reka_"+iac+"_play");
			id++;
		}
		clsave.set("e1_dzwonki", id);
		@s1 = clsave.get("e1_dzwon1");
		@s2 = clsave.get("e1_dzwon2");
		@s3 = clsave.get("e1_dzwon3");
		@s4 = clsave.get("e1_dzwon4");
		//blue, miedz, red, zolty
		if( (s1=="blue" && s2=="miedz" && s3=="red" && s4=="zolty") ||
			(s4=="blue" && s1=="miedz" && s2=="red" && s3=="zolty") ||
			(s3=="blue" && s4=="miedz" && s1=="red" && s2=="zolty") ||
			(s2=="blue" && s3=="miedz" && s4=="red" && s1=="zolty") )	{
			clsave.bset("e1_zgadla_dzwonki");
			.recehide;
		}
	}
	rekaplay(int iac)	{
		<gre1rekaset.get(iac)>.play( -1 );
	}
	recehide	{
		gre1rekaset.eval("anhide");
		for( int i=0; i<4; i++)	{
			clsave.set("e1_reka_"+i+"_play",0);
		}
	}
	e1_hint_rece	{
		.showhint("andymki2");
		.showhint("ane1reka"+iddymekhint);
	}
}

game gamead004_kspok0 : classadvstdgame2	{
	init	{
		classadvstdgame2::init;
	}
	mousemove {
		classadvstdgame2::mousemove;
		if( .advstdstate && anksiega.isin(mouse.getpos,0,1) && !clsave.bis("e1_ad004_najechana_ksiega") ) {
			_ = .playbehif("beh_ksiega_FOCUS");
		}
	}
}

game mapTmp : Banshee	{
	init	{
		Banshee::init("mapTmp");
		.imgs = (A,"bkg.jpg 1", "map_r1.pyz 2", "popexit.pyz 3" );  
   
    .butpopexit;
		.stdstart;
  } //koniec init
  
  mend	{
    .stdexitdefadv("ad00_endintro", "gamead00_endintro0");
	} 
}


game MainMenu : StdGame	{
	init	{
		StdGame::init("mainmenu");
		
		mus.playstr("carmillas_masque.ogg -l");
		.sfxs = (A, "bgrwiatrN 50", "bgrlas2N 30", "medalionleft 30", "medalionright 30");
		
		.imgs = (A, "bkg.jpg", "szkielko.pyz 100", "sciezka.pyz", "buts.pyzG 50", "maska.pyz 5");
		
		ansciezka.anhideonsetframe;
		
		new filter ftmaska;
		ftmaska.link("anmaska");
		
		.animaloader_load("animy.adv");
		
		@s = grbuts.getsac("bonus");
		<s>.hide;
		ftmaska.loupe(s);
		s = grbuts.getsac("credits");
		<s>.hide;
		ftmaska.loupe(s);
		
		grbuts.eval( func {
			.addmethod("isbutin", func { (@x, @y)
				@s = .actionname;
				if( s=="bonus" || s=="credits" )
					anmaska.isin(x,y,0,1) && .isin(x,y,0,0);
				else .isin(x,y,1,0);
				} );
			.Button_moveon;
			.Button_moveoff;
			butgame.add(this);
			} );
		<grbuts.getsac("play")>.addmethod("butclick", func {
			if( .advstdstate )
				ccs.close( func { gameapi.play("StartBanshee"); } );
			} );
		<grbuts.getsac("quit")>.addmethod("butclick", func {
			if( .advstdstate )
				ccs.close( func { gameapi.exit; } );
			} );
		
		ansciezka.addmethod("onendframe", func {
			anszkielko.ansetbpos( .getcx - anszkielko.getw/2, .getcy-anszkielko.geth/2 );
			anmaska.setpos(anszkielko.getposx, anszkielko.getposy);
			butgame.onmousemove;
			} );
		
		ansciezka.addmethod("onfinish", func {
			.play( (.actionnr(-1) + 1)%.nofactions );
			} );
		//ansciezka.play(0);
		
		new CalcFPS cfps;
		cfps.stdset(14, 10, 10);
		//cfps.play;
		
		new int istep = 0;
		.cycle = ("timstep", func {
			int x = ansciezka.getcx;
			int y = ansciezka.getcy;
			if( istep%2 )	{
				ansciezka.ansetnextfr;
				x = (x+ansciezka.getcx)/2;
				y = (y+ansciezka.getcy)/2;
			}
			anszkielko.ansetbpos( x - anszkielko.getw/2, y-anszkielko.geth/2 );
			anmaska.setpos(anszkielko.getposx, anszkielko.getposy);
			butgame.onmousemove;
			istep++;
			
			.play;
			} );
		timstep.play;
		
		ccs.enter( "advsetstdstate" );
	}
	public animaloader_an(string san, string sdb, int row, int col)	{
		match( <sdb>.get(row,col) )	{
			"-toloupe" => {
				ftmaska.loupe(san);
			}
			? => ;
		}
		col;
	}
}



game mgBook : Banshee	{
	init	{
		Banshee::init("sys_mgbook");
		
		.imgs = (A, "bkg.jpg", "nextp.pyzH 50", "prevp.pyzH 50", "nakladki.pyzG 20", "zak.pyzGH 10", "pageleft.pyzH", "pageright.pyzH",
			"popexit.pyz 150");
		.butpopexit;
		
		@sfun = func {
			.Button_isinvisalpha;
			.addmethod("butmoveon", func {
				.anfadein(200,null);
				advmouse.setact;
				} );
			.addmethod("butmoveoff", func {
				.anfadeout(200,null);
				advmouse.setstd;
				} );
			butgame.add(this);
		};
		annextp.<sfun>;
		anprevp.<sfun>;
		
		grzak.eval( func {
			.Button_isinvis;
			.addmethod("butmoveon", func {
				.show;
				advmouse.setact;
				} );
			.addmethod("butmoveoff", func {
				.hide;
				advmouse.setstd;
				} );
			.addmethod("butclick", func {
				if( !.advstdstate ) return;
				grnakladki.show;
				.hidenak(.actionname);
				} );
			butgame.add(this);
			} );
		
		.stdstart;
	}
	hidenak(string s)	{	<grnakladki.getsac(s)>.hide;	}
	mend	{
		.stdexitgame;
	}
}


game BanTest : StdGame	{
	init	{
		StdGame::init("bantest");
		.imgs = (A, "niebo.pyz", "slonce.pyz 1", "chmury.pyzG 3", "drzewo.pyzP 10", "wdali1.pyz 12",
			"wod1.pyzP 15", "wod2.pyzP 20", "wod3.pyzP 25", "wod4.pyzP 30", "wod5.pyzP 35", "wod6.pyzP 40",
			"wzgorze.pyz 45", "wdali2.pyz 50", "fog1.pyz 55", "ogrodzenie.pyz 60",
			"fire1.pyzP 65", "fire2.pyzP 70",
			"woda.pyzP 75", "krople.pyzP 80",
			"fogslow.pyzH 85",
			"krzak1.pyzP 90", "drzewo1.pyzP 95", "altana.pyz 100", "cien1.pyzP 105",
			"galaz.pyzP 110", "mglagora.pyz 115", "liscie2.pyzG 116",
			"lupamask.pyz 20", "lupa.pyz 125");
		
		//.copyanima("anfog1", "anmgla3"); anmgla3.move(-anmgla3.getw,0);
		.sfxs = (A, "bgrlas2N", "bgrdeszczN 0", "bgrrzeka1N 0", "ogien2N 0", "bgrwiatrN 0");
		
		//grliscie.move( iResX-<grliscie.get(1)>.getex, 0 );
		//grliscie2.nplay(-1);
		grliscie2.hide;
		
		anslonce.move(0,-50);
		
		.newsfx("fxogien1", "ogien2.ogg");
		fxogien1.setvol(0);
		fxogien1.playloop;
		
		/*new filter ftwzgorze;
		ftwzgorze.link("angalaz");
		//ftwzgorze.setopacity(87);
		<grchmury.first>.hide;
// 		anniebo.hide;
// 		ftwzgorze.lineardodge(grchmury.get(4));
// 		anslonce.hide;
		ftwzgorze.lineardodge("anslonce");*/
		
		new filter ftlupa;
		ftlupa.link( "anlupamask" );
		ftlupa.loupe(grchmury.get(4));
		<grchmury.get(4)>.hide;
		ftlupa.loupe( "anwzgorze" );
		anwzgorze.hide;
		ftlupa.loupe( "angalaz" );
		angalaz.hide;
		angalaz.addmethod("onfinish", func { .play(-1); .hide; } );
		ftlupa.loupe( "andrzewo" );
		andrzewo.hide;
		
		.ustaw_dzwieki;
		
		SetAnMover::setas( grchmury.get(1), 0.25, 0);
		SetAnMover::setas( grchmury.get(3), 0.5, 0);
		SetAnMover::setas( grchmury.get(4), 1, 0);
		SetAnMover::setas( grchmury.get(5), 1.5, 0);
		grchmury.sortz(1);
		<grchmury.get(1)>.sam_copy;
		<grchmury.get(3)>.sam_copy;
		<grchmury.get(4)>.sam_copy;
		
		SetAnMover::setas( "anfog1", 0.55, 0);
		anfog1.sam_copy;
		
		.cycle = ("timgla", func {
			anfog1.sam_move;
			grchmury.eval("sam_move");
			
			.ustaw_dzwieki;
			
			.play;
			} );
		timgla.play;
		
		advmouse.setstd;
	}
	sam_move	{}
	ustaw_dzwieki	{
		SoundSource::setvol("fxbgrdeszcz", 70, 22, 550, 0->length(mouse.getposx-andrzewo.getcx,
			mouse.getposy - (andrzewo.getcy - andrzewo.geth/4)));
		SoundSource::setvol("fxbgrrzeka1", 70, 12, 350, 0->length(mouse.getposx-343, mouse.getposy-574 ));
		SoundSource::setvol("fxogien1", 40, 2, 200, 0->length(mouse.getposx-anfire1.getcx, mouse.getposy-anfire1.getcy));
		SoundSource::setvol("fxogien2", 40, 2, 200, 0->length(mouse.getposx-anfire2.getcx, mouse.getposy-anfire2.getcy));
		SoundSource::setvol("fxbgrwiatr", 80, 12, 600, 0->length(mouse.getposx-iResX, mouse.getposy-0.2*iResY));
	}
	key_down	{
		if( keyboard.iskey("space") )	{
			@s = .getgraphpath + "chmura1/";
			<grchmury.srcanima>.saveimages(s);
		}
	}
	mouse_move	{
		//anslon.setpos(mouse.getpx-anslon.ilodx, mouse.getpy-anslon.ilody);
		anlupa.setpos(mouse.getpos);
		anlupamask.setpos(mouse.getpos);
	}
	mouse_lclick	{
		//if( igmdebug ) engine.getimg(mouse.getpos, 1,1,-1000,1000)->print;
	}
}

game TmpGame : StdGame	{
	init(string styp, string spath, string sgame)	{
		sNextGame = sgame;
		sNextGamePath = spath;
		sNextGameType = styp;
		StdGame::init("bantest");
		.img = ("$scripts/bantest/minigame.png");
		
		.timplay("timfin", 2000, "_stdexit" );
	}
}

game MojTest : StdGame	{
	init{
		StdGame::init("bantest");
		new img imgbg;
		imgbg.create(igmappw, igmapph, .black, 255);
		@x = 5;
		x = "dupa";
		@sfont = .stdfont(20);
		.newtext("txt1", x, sfont, .white);
		txt1.setpos(igmoffsetx,igmoffsety);
		@x = "dupa";
		.newtext("txt2", x, sfont, .white);
		txt2.setpos(igmoffsetx, igmoffsety + txt1.geth);
	}
}


game HO07_Gruz : HOBanshee	{
	init	{
		new anima ankrasy;
		ankrasy.load("scripts/ho07_gruz/krasy.pyz");
		ankrasy.hide;
		
		HOBanshee::init("ho07_gruz");
		
		mus.playstr("banshee2.ogg -v 70 -l");
		
		.imgs = (A, "bkg.jpg", "puszka.pyzH 600");
	 
   .setasitemtopck("anpuszka");
		
		.mmasks;
		
		new DelayMover cmov; cmov.unlock;
		new string scmov = null;
		new bool bignoremsclick = false;
		
		ankrasy.addmethod("onfinish", func {
			.setframe(0,0);
			igmstate = 1;
			.mho_click;
			} );
		
		.mtoloupe("ho_shovel"); 
		
		ccs.enter( func {
			igmstate = 1;
			.advsetstdstate;
			} );
	}
	ho_shovel_click	{
		.show;
		.remove_from_loupe(this);
	}
	ho_dwarf_preclick	{	.dwarfcrown_preclick;	}
	ho_crown_preclick	{	.dwarfcrown_preclick;	}
	dwarfcrown_preclick	{
		@s = cmov.getfree;
		if( s!=null )	{
			scmov = null;
			.hide;
			<s>.hide;
			butgame.removebut(this);
			ankrasy.play(1);
			ankrasy.setz(610);
			ankrasy.ansetbpos(.getpx, .getpy);
		} else {
			scmov = this;
			bignoremsclick = true;
			igmstate = 6;
			.setz(600);
			.setframe(-1,0);
			cmov.mssetobj( scmov );
			butgame.removebut( scmov );
		}
	}
	hiddenobj_put	{
		if( grtxt.empty )	{
			igmstate = 20;
		  if( !.isvisible_itempopup("puszka") ) {
        .show_itempopup("puszka", "anpuszka");
      }
		}
	}
	mend	{
	 .set_mg_finished(); 
   .stdexitdefadv("ad03_placglowny", "gamead03_placglowny0"); 
	}
	mouse_lclick	{
		 if( bignoremsclick )	{
			bignoremsclick = false;
		} else if( scmov!=null )	{
			// tu trzeba zrobic jakis efekt powrotu na miejsce
			_ = cmov.getfree;
			igmstate = 1;
			<scmov>.setpos(0,0);
			<scmov>.setframe(-1,1);
			<scmov>.setz(<scmov>.myz);
			butgame.add(scmov);
			scmov = null;
		}
	}
 
  anpuszka_TAKE {
    .hide_itempopup("puszka");  
    .item_gotocenter;
    /* if (clsave.bis("taken_lopatka"))
      { 
        .removefrompck("lopatka");
        .removefrompck("puszka");
        .saveitemtopck("puszka_lopatka");
      }
      else   */
        .saveitemtopck("puszka");
    .timer = ("tim1", 1500, "mend" ); 
   tim1.play();
  }
  
     
  popup_puszka_clickexit {
    butgame.sclicked = ("anpuszka");
    .anpuszka_TAKE;
  }
  
  
  HINT_CLICK	{
		Hidden::HINT_CLICK;
		if( !.mishintplaying )	{
			.mhintonobj( .mgetel( "ho_dwarf" ) );
			.mhintonobj( .mgetel( "ho_crown" ) );
		}
	}
}


game HO01_Altana :HOBanshee	{
	init	{
	   new anima ankonewka;
		 ankonewka.load("scripts/ho01_altana/water_can.pyz");
      
		 HOBanshee::init("ho01_altana");
		 .imgs = (A, "bkg.jpg", "popup1_bkg.pyzH 300" , "popup1_ramka.pyzH 301","popup1_cube_back.pyzH 302", "poison.pyzH 303", "popup1_cube_front.pyzH 304",  "popup1_ring.pyzH 305", "popup1_key.pyzH 306","popup1_cube_open.pyzH 307", "kawalek_rzezby3.pyzH 308" );
		.setasitemtopck("anpoison");    
    anpoison.disable = (true); 
    .setasitemtopck("ankawalek_rzezby3"); 
    .setasitemtopck("ankonewka");
    ankonewka.mhobut;
    ankonewka.setz(10);
    .removefrompck("kostka"); 
    .mmasks; 
    new bool keyflying = false;
    new bool ringflying = false;
    new bool popup_opened =  false;
    ccs.enter( func {
     igmstate = 1;
     .advsetstdstate;
    } ); 
    .mtoloupe("ankonewka");
    new img imgg; 
      
      anpopup1_bkg
      { 
        .addmethod("isbutin", func { (@x, @y)
  				  .isin(x,y,1,0);
  			} );
        
        .addmethod("butclick", func {  
  				  return;
  			} ); 
        butgame.add(this);   
      }; 
       
      anpopup1_key.addmethod("onfinish", func {
        if (.actionname == "fadeout")
              .hide();
        else 
          if (.actionname == "insert")
          { 
             
            clsave.bset("e1_box_key_inserted");
            if (clsave.bis("e1_box_ring_inserted"))
            { 
              if (!ringflying)
                .open_box();
            }
            else
              .hide_popup(); 
            keyflying =  false;
          }
      });   
      anpopup1_ring.addmethod("onfinish", func {
        if (.actionname == "fadeout")  
          .hide(); 
        else 
          if (.actionname == "insert")
          { 
            ringflying =  false;
            clsave.bset("e1_box_ring_inserted");
            if (clsave.bis("e1_box_key_inserted"))
            {
              if (!keyflying)
                .open_box();
            }
             else
              .hide_popup(); 
            ringflying =  false;  
          }
      });
      @s = <.mgetel("ho_key")>.stxtview;
      <s>.createtxt( .hoexternalcol );
      s = <.mgetel("ho_ring")>.stxtview;
      <s>.createtxt( .hoexternalcol );
     
      if (clsave.bis("e1_magic_box_opened") && !clsave.bis("taken_poison") )
      { 
         anpoison.disable = (false); 
        .show_itempopup("poison", "anpoison");
      }
	}
  
  konewka_preclick {
   if( !.isvisible_itempopup("konewka") ) {
        .setframe(-1,0);
        .show_itempopup("konewka", "ankonewka");
        .remove_from_loupe("ankonewka");
        ankonewka.Button_stdms;
        butgame.sort;
      } else {
        .hide_itempopup("konewka");  
        igmstate = 1;
        ankonewka.mho_click;
        advmouse.setstd;
     }
  }
    
  popup_konewka_clickexit {
    butgame.sclicked = ("ankonewka");
    .konewka_preclick;
   }
   
   
  anpoison_TAKE {
    if (!clsave.bis("e1_magic_box_opened"))
      return; 
    if( !.isvisible_itempopup("poison") ) {
      .hide_popup();
      .show_itempopup("poison", "anpoison");
    } else {
        .hide_itempopup("poison"); 
        .item_gotocenter;  
        if( grtxt.empty )
        { 
          .timer = ("tim1", 1500, "show_sculpture_part" ); 
           tim1.play();
        }
        butgame.onmousemove;
      }
   }
    
  popup_poison_clickexit {
    butgame.sclicked = ("anpoison");
    .anpoison_TAKE;
  }
 
  show_sculpture_part()
  {
    if( !.isvisible_itempopup("kawalek_rzezby3") ) {
      .show_itempopup("kawalek_rzezby3", "ankawalek_rzezby3");
    }  
  }
   
  ankawalek_rzezby3_TAKE {
    .item_gotocenter; 
    .hide_itempopup("kawalek_rzezby3"); 
    .timer = ("tim2", 1500, "mend" ); 
    tim2.play();
  }
    
   popup_kawalek_rzezby3_clickexit {
      butgame.sclicked = ("ankawalek_rzezby3");
      .ankawalek_rzezby3_TAKE;
   }
   
   ankonewka_TAKE {
    .item_gotocenter; 
    .hide_itempopup("konewka"); 
    .timer = ("tim2", 1500, "mend" ); 
    tim2.play();
  }
 
  ho_key_click	{
		keyflying =  true;
    .anfadeout(800,null); 
    .show_popup("key");
	} 
  
  ho_ring_click	{
		ringflying =  true;
    .anfadeout(800,null); 
    .show_popup("ring");
	}
  
  hiddenobj_put	{
		if( grtxt.empty )	{
			igmstate = 20;
		  if (clsave.bis("taken_poison"))
      { 
        if( !.isvisible_itempopup("kawalek_rzezby3") ) 
          .show_itempopup("kawalek_rzezby3", "ankawalek_rzezby3");  
      }
    }
	} 
  
  show_popup(string item)	{
     if(!popup_opened)
     { 
       imgg.setz(300); 
       imgg.imgbuildfromlist(A,"anpopup1_bkg","anpopup1_cube_back","anpoison", "anpopup1_cube_front", "anpopup1_ramka");
       imgg.anzoomfadein(500, func{.hide;.show_popup_elements;});
      }
 
   
    if(item == "key"   ){
       anpopup1_key.anfadein(800,null);
       if (!clsave.bis("e1_box_key_inserted"))
       {  
        anpopup1_key.play("insert");
        clsave.bset("e1_box_key_inserted");
       }
        if (clsave.bis("e1_box_ring_inserted"))
           anpopup1_ring.anfadein(800,null);
    }
    if(item == "ring" ){ 
       anpopup1_ring.anfadein(800,null);
       if (!clsave.bis("e1_box_ring_inserted"))
       {  
        anpopup1_ring.play("insert");
        clsave.bset("e1_box_ring_inserted");
       }
       if (clsave.bis("e1_box_key_inserted"))
           anpopup1_key.anfadein(800,null);
     }
     
    popup_opened =  true;
  } 
  show_popup_elements{
    if (popup_opened)
    {  
      anpoison.show();
      anpopup1_cube_back.show(); 
      anpopup1_cube_front.show(); 
      anpopup1_bkg.show();
      anpopup1_ramka.show(); 
    }
  }  
  
  hide_popup()
  {
    new img img;
    img.imgbuildfromlist(A,"anpopup1_bkg", "anpopup1_ramka", "anpopup1_cube_back");
    img.anzoomfadeout(500, null);
    img.setz(300); 
    anpopup1_key.hide();
    anpopup1_ring.hide();
    anpopup1_cube_back.hide(); 
    anpopup1_cube_front.hide();
    anpopup1_bkg.hide();
    anpopup1_ramka.hide();
    anpopup1_cube_open.hide();
    anpoison.hide(); 
    popup_opened =  false; 
  } 
  
  open_box(){ 
    if (! clsave.bis("e1_magic_box_opened") )
    { 
      clsave.bset("e1_magic_box_opened");   
      anpopup1_cube_open.anfadein(800,null); 
      anpopup1_cube_back.anfadeout(800,null);
      anpopup1_cube_front.anfadeout(500,null);
      anpoison.disable = (false); 
    } 
  } 
  mend{
    .set_mg_finished(); 
    .stdexitdefadv("ad11_altana", "gamead11_altana0");
  }
    
  HINT_CLICK	{
    
		Hidden::HINT_CLICK;
	 
    if( !.mishintplaying )	{
      if ( anpoison.isvisible() && clsave.bis("e1_magic_box_opened")  )
      { 
    		.showhint("anpoison");
      }
      else if ( grtxt.contains("txtel_ankonewka") ) 
      {
  				.mhintonobj("ankonewka");
      }
  		else if (ankawalek_rzezby3.isvisible())  
      { 
  		  .showhint("ankawalek_rzezby3");
      }
    }
  } 
}


 

game HO09_Brzegjeziora : HOBanshee	{
	init	{
	  new anima bottle_anim;
		bottle_anim.load("scripts/ho09_brzegjeziora/bottle_anim.pyz");
		bottle_anim.hide;
		new anima andluto;
		andluto.load("scripts/ho09_brzegjeziora/dluto.pyz");
   
		HOBanshee::init("ho09_brzegjeziora");
	  .imgs = (A, "bkg.png", "ser.pyzH","swiatlo.pyz 12");
    //.setasitemtopck("andluto");
	 answiatlo.anopacityframe;
	 answiatlo.play("new");
    andluto.mhobut;
    andluto.setz(1000);
    .setasitemtopck("anser");  
    
        
		.mmasks;
    new DelayMover cmov; cmov.unlock;
		new string scmov = null;
		new bool bignoremsclick = false;
    
  	bottle_anim.addmethod("onfinish", func {
		.setframe(0,0);
		igmstate = 1;
		.mho_click;
		} );
   
		.mtoloupe("andluto");  
   
   <.mgetel("ho_letter")>.hide();
   <.mgetel("maska_bag_open")>.hide();
   <.mgetel("bag_open")>.hide();
  
	ccs.enter( func {
		igmstate = 1;
		.advsetstdstate;
		} );
	  
	}
  
  ho_bag_preclick	{
	 <.mgetel("ho_letter")>.show();
   <.mgetel("maska_bag_open")>.show();
   <.mgetel("bag_open")>.show();
   butgame.removebut(.mgetel("ho_bag"));
	}
  
  
  dluto_preclick {
  	if( !.isvisible_itempopup("dluto") ) {
        //.saveitemtopck("dluto");
        .show_itempopup("dluto", "andluto");
        .remove_from_loupe("andluto");
        clsave.bset("ma_dluto");
       // .e1_check_mlotek_dluto;
        andluto.Button_stdms;
        butgame.sort;
      } else {
        .hide_itempopup("dluto");  
        igmstate = 1;
        andluto.mho_click;
        advmouse.setstd;
     }
  }
    
  popup_dluto_clickexit {
    butgame.sclicked = ("andluto");
    .dluto_preclick;
   }
   
   anser_TAKE {
    .hide_itempopup("ser");  
    .item_gotocenter;
    .timer = ("tim1", 1500, "mend" ); 
     tim1.play();
  }
    
  popup_ser_clickexit {
    butgame.sclicked = ("anser");
    .anser_TAKE;
   }
  
  hiddenobj_put	{
		if( grtxt.empty )	{
			igmstate = 20;
			if( !.isvisible_itempopup("ser") ) {
        .show_itempopup("ser", "anser");
      }
    }
	}
	 
	mend	{
	  .set_mg_finished(); 
    .stdexitdefadv("ad04_brzegjeziora", "gamead04_brzegjeziora0");  
	}
  
 
  ho_bottle_preclick	{	.bottleletter_preclick;	}
	ho_letter_preclick	{	.bottleletter_preclick;	}
	bottleletter_preclick	{
		@s = cmov.getfree;
		if( s!=null )	{
			scmov = null;
			.hide;
			<s>.hide;
			butgame.removebut(this);
		 	bottle_anim.play(1);
		 	bottle_anim.setz(610);
		 	bottle_anim.ansetbpos(.getpx, .getpy);
		} else {
			scmov = this;
			bignoremsclick = true;
			igmstate = 6;
			.setz(600);
			.setframe(-1,0);
			cmov.mssetobj( scmov );
			butgame.removebut( scmov );
		}
	}
  
  mouse_lclick	{
		//.printstate;
		if( bignoremsclick )	{
			bignoremsclick = false;
		} else if( scmov!=null )	{
			// tu trzeba zrobic jakis efekt powrotu na miejsce
			_ = cmov.getfree;
			igmstate = 1;
			<scmov>.setpos(0,0);
			<scmov>.setframe(-1,1);
			<scmov>.setz(<scmov>.myz);
			butgame.add(scmov);
			scmov = null;
		}
	}
  
  HINT_CLICK	{
		Hidden::HINT_CLICK;
		if( !.mishintplaying )	{
			if( grtxt.contains("txtel_bottle_anim") )	{
        
    			.mhintonobj( .mgetel( "ho_letter" ) );
    			.mhintonobj( .mgetel( "ho_bottle" ) );
    		 
			} else if ( grtxt.contains("txtel_andluto") ) {
				.mhintonobj("andluto");
			}
		}
	}
 
}

game HO04_Wodospad : HOBanshee	{
  init	{
    new anima bag_anim;
		bag_anim.load("scripts/ho04_wodospad/bag_anim.pyz");
		bag_anim.hide;
    
    new anima ankostka;
		ankostka.load("scripts/ho04_wodospad/kostka.pyz");
    
    new anima ankawalek_rzezby2;
		ankawalek_rzezby2.load("scripts/ho04_wodospad/kawalek_rzezby2.pyz");
    
   	HOBanshee::init("ho04_wodospad");
    ankostka.mhobut;
    ankostka.setz(1); 
    
    ankawalek_rzezby2.mhobut;
    ankawalek_rzezby2.setz(1);
    
    .imgs = (A, "bkg.jpg", "lewy_bok.pyz 100","prawy_bok.pyz 110", "kawalek_lwa4.pyzH 120"); 
    .mmasks;
    new DelayMover cmov; cmov.unlock;
		new string scmov = null;
		new bool bignoremsclick = false;
    .mtoloupe("ankostka"); 
    .setasitemtopck("ankawalek_lwa4");
    ccs.enter( func {
		 igmstate = 1;
		 .advsetstdstate;
		} ); 
    
    bag_anim.addmethod("onfinish", func {
		.setframe(0,0);
		igmstate = 1;
		.mho_click;
		} );
    <ankawalek_rzezby2.stxtview>.createtxt( .guifontcolor );
  }
  
 hiddenobj_put	{
		if( grtxt.empty )	{
			igmstate = 20;
			if( !.isvisible_itempopup("kawalek_lwa4") ) {
        .show_itempopup("kawalek_lwa4", "ankawalek_lwa4");
      }
    }
	}
    
  mend	{
   .set_mg_finished(); 
   .stdexitdefadv("ad08_latajacecospod", "gamead08_latajacecospod0"); 
  }
  
  ho_bag_preclick	{	.bag_preclick;	}
	ho_coins_preclick	{	.bag_preclick;	}
	bag_preclick	{
		@s = cmov.getfree;
		if( s!=null )	{
			scmov = null;
			.hide;
			<s>.hide;
			butgame.removebut(this);
		 	bag_anim.play(1);
		 	bag_anim.setz(610);
		 	bag_anim.ansetbpos(.getpx, .getpy);
		} else {
			scmov = this;
			bignoremsclick = true;
			igmstate = 6;
			.setz(600);
			.setframe(-1,0);
			cmov.mssetobj( scmov );
			butgame.removebut( scmov );
		}
	}
 	mouse_lclick	{
		 if( bignoremsclick )	{
			bignoremsclick = false;
		} else if( scmov!=null )	{
			// tu trzeba zrobic jakis efekt powrotu na miejsce
			_ = cmov.getfree;
			igmstate = 1;
			<scmov>.setpos(0,0);
			<scmov>.setframe(-1,1);
			<scmov>.setz(<scmov>.myz);
			butgame.add(scmov);
			scmov = null;
		}
	}
  
  kostka_preclick {
    if( !.isvisible_itempopup("kostka") ) {
      .show_itempopup("kostka", "ankostka");
      ankostka.setframe(-1,2);
      .remove_from_loupe("ankostka");
      ankostka.Button_stdms;
      butgame.sort;
    } else {
      .hide_itempopup("kostka");  
      igmstate = 1;
      ankostka.mho_click;
      advmouse.setstd;
    }
  }
    
  popup_kostka_clickexit {
    butgame.sclicked = ("ankostka");
    .kostka_preclick;
  }
   
  kawalek_rzezby2_preclick {
    if( !.isvisible_itempopup("kawalek_rzezby2") ) {
        .show_itempopup("kawalek_rzezby2", "ankawalek_rzezby2");
        ankawalek_rzezby2.Button_stdms;
        butgame.sort;
      } else {
        .hide_itempopup("kawalek_rzezby2");  
        igmstate = 1;
        ankawalek_rzezby2.mho_click;
        advmouse.setstd;
    }
  }
    
  popup_kawalek_rzezby2_clickexit {
    butgame.sclicked = ("ankawalek_rzezby2");
    .kawalek_rzezby2_preclick;
   }
   
   ankawalek_lwa4_TAKE {
    .hide_itempopup("kawalek_lwa4");  
    .item_gotocenter;
    .timer = ("tim1", 1500, "mend" ); 
    tim1.play();
  }
  
     
  popup_kawalek_lwa4_clickexit {
    butgame.sclicked = ("ankawalek_lwa4");
    .ankawalek_lwa4_TAKE;
  }
   
  HINT_CLICK	{
		Hidden::HINT_CLICK;
		if( !.mishintplaying )	{
			if( grtxt.contains("txtel_bag_anim") )	{
			 .mhintonobj( .mgetel( "ho_bag" ) );
    	 .mhintonobj( .mgetel( "ho_coins" ) );
    	} else if ( grtxt.contains("txtel_ankostka") ) {
				.mhintonobj("ankostka");
			} else if ( grtxt.contains("txtel_ankawalek_rzezby2") ) {
				.mhintonobj("ankawalek_rzezby2");
			}
		}
	}
}

game HO06_Ogrodrozany : HOBanshee	{
    
   init	{
    new anima playmusic_anim;
		playmusic_anim.load("scripts/ho06_ogrodrozany/playmusic_anim.pyz");
		playmusic_anim.hide;
    
     
    new anima ankawalek_rzezby1;
		ankawalek_rzezby1.load("scripts/ho06_ogrodrozany/sculpture_part1.pyz");
    
    new anima annote;
    annote.load("scripts/ho06_ogrodrozany/note.pyz");
		 
     
    HOBanshee::init("ho06_ogrodrozany");
    .imgs = (A, "bkg.jpg" , "elixir.pyzH"); 
    
    ankawalek_rzezby1.mhobut;
     
    ankawalek_rzezby1.setz(1);
    annote.hide;
    
    .mmasks;
    
    new DelayMover cmov; cmov.unlock;
		new string scmov = null;
		new bool bignoremsclick = false;
    
    .mtoloupe("ho_iron");  
     ccs.enter( func {
		 igmstate = 1;
		 .advsetstdstate;
		} );
    <ankawalek_rzezby1.stxtview>.createtxt( .guifontcolor ); 
  }
  
  ho_iron_click	{
		.show;
		.remove_from_loupe(this);
	}
  
  hiddenobj_put	{
		if( grtxt.empty )	{
			igmstate = 20;
			if( !.isvisible_itempopup("elixir") ) {
        .setasitemtopck("anelixir");
        .saveitemtopck("elixir");
        .show_itempopup("elixir", "anelixir");
      }
    }
	}
  
  anelixir_TAKE {
    .hide_itempopup("elixir");  
    .item_gotocenter;
    .timer = ("tim1", 1500, "mend" ); 
     tim1.play();
  }
    
  popup_elixir_clickexit {
    butgame.sclicked = ("anelixir");
    .anelixir_TAKE;
  }
  
  ho_gramophone_preclick	{	.gramophone_preclick;	}
	ho_plyta_preclick	{	.plyta_preclick;	}
	plyta_preclick	{
		@s = cmov.getfree;
		if( s==null )	{
		  scmov = this;
			bignoremsclick = true;
			igmstate = 6;
			.setz(600);
			.setframe(-1,0);
			cmov.mssetobj( scmov );
			butgame.removebut( scmov );
      
		}
	}
  gramophone_preclick	{
		@s = cmov.getfree;
		if( s!=null )	{
		  scmov = null;
			<s>.hide;
			butgame.removebut(this);
		 	playmusic_anim.play(1);
		  playmusic_anim.setz(180);
      igmstate = 1; 
      annote.mhobut;
      annote.show;
		  annote.mho_click;
    }  
	}
  
  mouse_lclick	{
		//.printstate;
		if( bignoremsclick )	{
			bignoremsclick = false;
		} else if( scmov!=null )	{
			// tu trzeba zrobic jakis efekt powrotu na miejsce
			_ = cmov.getfree;
			igmstate = 1;
			<scmov>.setpos(0,0);
			<scmov>.setframe(-1,1);
			<scmov>.setz(<scmov>.myz);
			butgame.add(scmov);
			scmov = null;
		}
	}
  

   
  sculpture_part_preclick  {
    if( !.isvisible_itempopup("kawalek_rzezby1") ) {
        .show_itempopup("kawalek_rzezby1", "ankawalek_rzezby1"); 
        ankawalek_rzezby1.Button_stdms; 
        .play("sculpture_part_rotostart"); 
        .ansetbpos(.getpx, .getpy +100);        
        butgame.sort;
      } else {
        .hide_itempopup("kawalek_rzezby1");  
        igmstate = 1;
        ankawalek_rzezby1.play(0);
        ankawalek_rzezby1.mho_click;
        advmouse.setstd;
    }
  }
  
  sculpture_part_rotostart_preclick{
    .hide_itempopup("kawalek_rzezby1");  
    igmstate = 1;
    ankawalek_rzezby1.play(0);
    ankawalek_rzezby1.mho_click;
    advmouse.setstd; 
  }
 
    
  popup_kawalek_rzezby1_clickexit {
    butgame.sclicked = ("ankawalek_rzezby1");
    .sculpture_part_preclick;
   }
  
    
  mend	{
   .set_mg_finished(); 
   .stdexitdefadv("ad10_ogrodrozany", "gamead10_ogrodrozany0"); 
  }
 
  HINT_CLICK	{
		Hidden::HINT_CLICK;
    if( !.mishintplaying )	{ 
			if( grtxt.contains("txtel_annote") ){
			 .mhintonobj( .mgetel( "ho_plyta" ) );
    	 .mhintonobj( .mgetel( "ho_gramophone" ) );
    	} else if ( anelixir.isvisible() ) {
				.showhint("anelixir");
			} else if (ankawalek_rzezby1.isvisible() ){  
				.showhint("ankawalek_rzezby1");
      }
    }
	}
}

 
game HO12_Brama : HOBanshee	{
  init	{
    new anima padlock_anim;
		padlock_anim.load("scripts/ho12_brama/padlock_anim.pyz");
		padlock_anim.hide;
    
    new anima anserce_part2;
		anserce_part2.load("scripts/ho12_brama/serce_part2.pyz");
    
    
    HOBanshee::init("ho12_brama");
    .imgs = (A, "bkg.jpg","rune1.pyzH 600" ); 
    
    .setasitemtopck("anrune1");
    
    anserce_part2.mhobut;
    anserce_part2.setz(2);
    
    .mmasks;
    
    new DelayMover cmov; cmov.unlock;
		new string scmov = null;
		new bool bignoremsclick = false;
    
    ccs.enter( func {
		 igmstate = 1;
		 .advsetstdstate;
		} ); 
    .mtoloupe("anserce_part2"); 
    
    padlock_anim.addmethod("onfinish", func {
  		.setframe(0,0);
  		igmstate = 1;
  		.mho_click;
		} );
    
     
  }//koniec init 
  hiddenobj_put	{
		if( grtxt.empty )	{
			igmstate = 20;
      if( !.isvisible_itempopup("rune1") ) 
        .show_itempopup("rune1", "anrune1");
      }
	}
 
	ho_key_preclick	{	.key_preclick;	}
 	ho_padlock_preclick	{	.padlock_preclick;	}
	key_preclick	{
	 	@s = cmov.getfree;
		if( s!=null )	{
			scmov = null;
			.hide;
			<s>.hide;
			butgame.removebut(this);
		 	padlock_anim.play(1);
		 	padlock_anim.setz(610);
		 	padlock_anim.ansetbpos(.getpx, .getpy);
		} else {
			scmov = this;
			bignoremsclick = true;
			igmstate = 6;
			.setz(600);
			.setframe(-1,0);
			cmov.mssetobj( scmov );
			butgame.removebut( scmov );
		}    
	}
  padlock_preclick	{
		@s = cmov.getfree;
		if( s!=null )	{
			scmov = null;
			.hide;
			<s>.hide;
			butgame.removebut(this);
		 	padlock_anim.play(1);
		 	padlock_anim.setz(610);
		 	padlock_anim.ansetbpos(.getpx, .getpy);
		} 
	}
  
  
  mouse_lclick	{
		//.printstate;
		if( bignoremsclick )	{
			bignoremsclick = false;
		} else if( scmov!=null )	{
			// tu trzeba zrobic jakis efekt powrotu na miejsce
			_ = cmov.getfree;
			igmstate = 1;
			<scmov>.setpos(0,0);
			<scmov>.setframe(-1,1);
			<scmov>.setz(<scmov>.myz);
			butgame.add(scmov);
			scmov = null;
		}
	}
  
   serce_part2_preclick {
  	if( !.isvisible_itempopup("serce_part2") ) {
        .show_itempopup("serce_part2", "anserce_part2");
        .remove_from_loupe("anserce_part2");
        anserce_part2.setframe("serce_part2_rotostart", 0);
        anserce_part2.Button_stdms;
        butgame.sort;
      } else {
        .hide_itempopup("serce_part2");  
        igmstate = 1;
        anserce_part2.mho_click;
        advmouse.setstd;
     }
  }
  serce_part2_rotostart_preclick{
    .serce_part2_preclick;  
  }
     
  popup_serce_part2_clickexit {
    butgame.sclicked = ("anserce_part2");
    .serce_part2_preclick;
  }
  
   
  anrune1_TAKE {
    .hide_itempopup("rune1");  
    .item_gotocenter;
    .timer = ("tim1", 1500, "mend" ); 
    tim1.play();
  }
  
     
  popup_rune1_clickexit {
    butgame.sclicked = ("anrune1");
    .anrune1_TAKE;
  }
  
  mend	{
   .set_mg_finished(); 
   .stdexitdefadv("ad12_latajacecosna", "gamead12_latajacecosna0"); 
  }
 
  HINT_CLICK	{
		Hidden::HINT_CLICK;
    if(!.mishintplaying )	{
      if( grtxt.contains("txtel_padlock_anim") )
      { 
			  .mhintonobj( .mgetel( "ho_key") );
        .mhintonobj( .mgetel( "ho_padlock") );
      }
      else if ( grtxt.contains("txtel_anserce_part2") )  
				.mhintonobj("anserce_part2");
    } 
	}
}
game HO13_Wiszacymost : HOBanshee	{
     
  init	{
    new anima fire_anim;
		fire_anim.load("scripts/ho13_wiszacymost/fire_anim.pyz");
		fire_anim.hide;  
    
    new anima anrekawica_1;
		anrekawica_1.load("scripts/ho13_wiszacymost/rekawica_1.pyz");
    
    new anima anpan_bottom;
		anpan_bottom.load("scripts/ho13_wiszacymost/pan_bottom.pyz");
    
    HOBanshee::init("ho13_wiszacymost");
    .imgs = (A, "bkg.jpg");
     
    .setasitemtopck("anpan_bottom");
    anpan_bottom.disable = (true); 
    anrekawica_1.mhobut;
    anrekawica_1.setz(20);
    
    .mmasks;
    
    new DelayMover cmov; cmov.unlock;
		new string scmov = null;
		new bool bignoremsclick = false;
     
    ccs.enter( func {
		 igmstate = 1;
		 .advsetstdstate;
		} ); 
     .mtoloupe("anrekawica_1");   
    
     fire_anim.addmethod("onfinish", func {
  		.setframe(0,0);
  		igmstate = 1;
  		.mho_click;
		} );
    
     
  }//koniec init 
  hiddenobj_put	{
		if( grtxt.empty )	{
			igmstate = 20;
     // .mend();
      if( !.isvisible_itempopup("pan_bottom") ) 
          anpan_bottom.disable = (false); 
         .show_itempopup("pan_bottom", "anpan_bottom");
    }
	}
 
 	ho_lighter_preclick	{	.lighter_preclick;	}
 	ho_nest_preclick	{	.nest_preclick;	}
	lighter_preclick	{
	 	@s = cmov.getfree;
		if( s!=null )	{
			scmov = null;
			.hide;
			<s>.hide;
			butgame.removebut(this);
		 	fire_anim.play(1);
		 	fire_anim.setz(610);
		 	fire_anim.ansetbpos(.getpx, .getpy);
		} else {
			scmov = this;
			bignoremsclick = true;
			igmstate = 6;
			.setz(600);
			.setframe(-1,0);
			cmov.mssetobj( scmov );
			butgame.removebut( scmov );
		}    
	}
  nest_preclick	{
		@s = cmov.getfree;
		if( s!=null )	{
			scmov = null;
			.hide;
			<s>.hide;
			butgame.removebut(this);
		 	fire_anim.play(1);
		 	fire_anim.setz(610);
		 	fire_anim.ansetbpos(.getpx, .getpy);
		} 
	}
  
  
  mouse_lclick	{
		//.printstate;
		if( bignoremsclick )	{
			bignoremsclick = false;
		} else if( scmov!=null )	{
			// tu trzeba zrobic jakis efekt powrotu na miejsce
			_ = cmov.getfree;
			igmstate = 1;
			<scmov>.setpos(0,0);
			<scmov>.setframe(-1,1);
			<scmov>.setz(<scmov>.myz);
			butgame.add(scmov);
			scmov = null;
		}
	}
  
    
  rekawica_1_preclick {
  	if(!.isvisible_itempopup("rekawica_1") ) {
        anrekawica_1.setframe("rekawica_1_rotostart", 0);
        .show_itempopup("rekawica_1", "anrekawica_1");
        .remove_from_loupe("anrekawica_1");
        anrekawica_1.Button_stdms;
        butgame.sort;   
      } else {
        .hide_itempopup("rekawica_1");  
        igmstate = 1;
        anrekawica_1.mho_click;
        advmouse.setstd;
     }
  }   
  
  rekawica_1_rotostart_preclick{
    .rekawica_1_preclick;  
  }
  
  popup_rekawica_1_clickexit {
    butgame.sclicked = ("anrekawica_1");
    .rekawica_1_preclick;
  }
  
   
  anpan_bottom_TAKE {
    .hide_itempopup("pan_bottom");  
    .item_gotocenter;
     if (clsave.bis("taken_rondel_bez_dna"))
      { 
        .removefrompck("rondel_bez_dna");
        .removefrompck("pan_bottom");
        .saveitemtopck("rondel");
      }
      else
        .saveitemtopck("pan_bottom");
      .timer = ("tim1", 1500, "mend" ); 
      tim1.play();
  }
  
     
  popup_pan_bottom_clickexit {
    butgame.sclicked = ("anpan_bottom");
    .anpan_bottom_TAKE;
  }
   
  
  mend	{
   .set_mg_finished(); 
   .stdexitdefadv("ad13_wiszacymost", "gamead13_wiszacymost0"); 
  }
 
  HINT_CLICK	{
		Hidden::HINT_CLICK;
    if(!.mishintplaying )	{ 
      if( grtxt.contains("txtel_fire_anim") ) 
      { 
				.mhintonobj( .mgetel( "ho_lighter") );
        .mhintonobj( .mgetel( "ho_nest") ); 
      }
      else if ( grtxt.contains("txtel_anrekawica_1") ) {
				.mhintonobj("anrekawica_1");
			}  
    } 
	}   
}

game HO19_Szopa : HOBanshee	{
     
  init	{
    new anima tea_anim;
		tea_anim.load("scripts/ho19_szopa/tea_anim.pyz");
		tea_anim.hide;  
    
    new anima anrune7;
		anrune7.load("scripts/ho19_szopa/rune7.pyz");
    
    HOBanshee::init("ho19_szopa");
    .imgs = (A, "bkg.jpg", "rune8.pyzH 600");
    .setasitemtopck("anrune8");
   
     
    .mmasks;
    
    anrune7.mhobut;
    anrune7.setz(20);
    
    new DelayMover cmov; cmov.unlock;
		new string scmov = null;
		new bool bignoremsclick = false;
    
    ccs.enter( func {
		 igmstate = 1;
		 .advsetstdstate;
		} ); 
    .mtoloupe("HO_hat");  
    .close_drawer();
    
    tea_anim.addmethod("onfinish", func {
  		.setframe(0,0);
  		igmstate = 1;
  		.mho_click;
		} );
    <anrune7.stxtview>.createtxt( .guifontcolor );    
  
  }//koniec init 
  
  
  hiddenobj_put	{
		if( grtxt.empty )	{
			igmstate = 20;
      if( !.isvisible_itempopup("rune8")) 
         .show_itempopup("rune8", "anrune8");
    }
	}
 
  anrune8_TAKE {
    .item_gotocenter; 
    .hide_itempopup("rune8"); 
    .timer = ("tim2", 1500, "mend" ); 
    tim2.play();
  }
    
   popup_rune8_clickexit {
      butgame.sclicked = ("anrune8");
      .anrune8_TAKE;
   }  
    
    
 	HO_hat_click()
  {
    .show;
		.remove_from_loupe(this);
	}
  
  close_drawer(){
    anrune7.hide;
    for( int i=0; i<grels.size; i++)	{
      @s = grels.get(i);
      if( <s>.actionname->contains("sz") )
     	  <s>.hide();
    	} 
  }
  
  open_drawer()
  {
    anrune7.show;
    <.mgetel("drawer")>.setframe(-1,0);
    for( int i=0; i<grels.size; i++)	{
      @s = grels.get(i);
      if( <s>.actionname->contains("sz") )
   	  <s>.show();
  	} 
    butgame.removebut(.mgetel("drawer")); 
  }
  
  drawer_preclick()
  {
    .open_drawer();
  }
  
  
  HO_herbs_preclick	{	.herbs_preclick;	}
 	HO_kettle_preclick	{	.kettle_preclick;	}
	herbs_preclick	{
	 	@s = cmov.getfree;
		if( s!=null )	{
			scmov = null;
			.hide;
			<s>.hide;
			butgame.removebut(this);
		 	tea_anim.play(1);
		 	tea_anim.setz(610);
		 	tea_anim.ansetbpos(.getpx, .getpy);
		} else {
			scmov = this;
			bignoremsclick = true;
			igmstate = 6;
			.setz(600);
			.setframe(-1,0);
			cmov.mssetobj( scmov );
			butgame.removebut( scmov );
		}    
	}
  kettle_preclick	{
		@s = cmov.getfree;
		if( s!=null )	{
			scmov = null;
			.hide;
			<s>.hide;
			butgame.removebut(this);
		 	tea_anim.play(1);
		 	tea_anim.setz(610);
		 	tea_anim.ansetbpos(.getpx, .getpy);
		} 
	}
  
  
  mouse_lclick	{
		//.printstate;
		if( bignoremsclick )	{
			bignoremsclick = false;
		} else if( scmov!=null )	{
			// tu trzeba zrobic jakis efekt powrotu na miejsce
			_ = cmov.getfree;
			igmstate = 1;
			<scmov>.setpos(0,0);
			<scmov>.setframe(-1,1);
			<scmov>.setz(<scmov>.myz);
			butgame.add(scmov);
			scmov = null;
		}
	}
  
  rune7_preclick {
  	if( !.isvisible_itempopup("rune7") ) {
        .show_itempopup("rune7", "anrune7");
        anrune7.setframe("rune7_rotostart", 0);
        anrune7.Button_stdms;
        butgame.sort;   
      } else {
        .hide_itempopup("rune7");  
        igmstate = 1;
        anrune7.mho_click;
        advmouse.setstd;
     }
  }   
  
  rune7_rotostart_preclick{
    .rune7_preclick;  
  }
  
  popup_rune7_clickexit {
    butgame.sclicked = ("anrune7");
    .rune7_preclick;
  }
 
  mend	{
   .set_mg_finished(); 
   .stdexitdefadv("ad12_latajacecosna", "gamead12_latajacecosna0"); 
  }
 
  HINT_CLICK	{
		Hidden::HINT_CLICK;
    if( !.mishintplaying )	{
			if ( grtxt.contains("txtel_anrune7") ) {
				.mhintonobj("anrune7");
			}
      else
      { 
        .mhintonobj( .mgetel( "HO_herbs" ) );
        .mhintonobj( .mgetel( "HO_kettle" ) );
      }
		}
    
	}   
}


game HO17_Fontanna : HOBanshee	{
     
  init	{
    
    new anima anrekawica_2;
	 	anrekawica_2.load("scripts/ho17_fontanna/rekawica_2.pyz");
    new anima ankielich;
	 	ankielich.load("scripts/ho17_fontanna/kielich.pyz");  
     
    HOBanshee::init("ho17_fontanna");
    .imgs = (A, "bkg.jpg","rune6.pyzH 600" ); 
    
    .setasitemtopck("anrune6");
    anrekawica_2.mhobut;
    anrekawica_2.setz(20); 
    ankielich.mhobut;
    ankielich.setz(20); 
    .mmasks;
    
    <.mgetel("klatka_open")>.hide;
    .mtoloupe("anrekawica_2");  
    ccs.enter( func {
		 igmstate = 1;
		 .advsetstdstate;
		} ); 
    
    @s = <.mgetel("HO_ring")>.stxtview;
      <s>.createtxt( .hoexternalcol );
    
  }//koniec init 
  
  rekawica_2_preclick {
  	if( !.isvisible_itempopup("rekawica_2") ) {
        anrekawica_2.setframe("rekawica_2_rotostart", 0);
        .show_itempopup("rekawica_2", "anrekawica_2");
        .remove_from_loupe("anrekawica_2");
        anrekawica_2.Button_stdms;
        butgame.sort;   
      } else {
        .hide_itempopup("rekawica_2");  
        igmstate = 1;
        anrekawica_2.mho_click;
        advmouse.setstd;
     }
  }   
  
  rekawica_2_rotostart_preclick{
    .rekawica_2_preclick;  
  }
  
  popup_rekawica_2_clickexit {
    butgame.sclicked = ("anrekawica_2");
    .rekawica_2_preclick;
  }
  
  kielich_preclick {
  	if( !.isvisible_itempopup("kielich") ) {
        ankielich.setframe("kielich_rotostart", 0);
        .show_itempopup("kielich", "ankielich");
        ankielich.Button_stdms;
        butgame.sort;   
      } else {
        .hide_itempopup("kielich");  
        igmstate = 1;
        ankielich.mho_click;
        advmouse.setstd;
     }
  }   
  
  kielich_rotostart_preclick{
    .kielich_preclick;  
  }
  
  popup_kielich_clickexit {
    butgame.sclicked = ("ankielich");
    .kielich_preclick;
  }
  
  klatka_closed_click	{
  		.hide();
  		<.mgetel("klatka_open")>.show();
  }
  
  hiddenobj_put	{
		if( grtxt.empty )	{
			igmstate = 20;
      if( !.isvisible_itempopup("rune6")) 
         .show_itempopup("rune6", "anrune6"); 
    }
	} 
  anrune6_TAKE {
    .hide_itempopup("rune6");  
    .item_gotocenter;
    .timer = ("tim1", 1500, "mend" ); 
    tim1.play();
  }
  
     
  popup_rune6_clickexit {
    butgame.sclicked = ("anrune6");
    .anrune6_TAKE;
  } 
  
  mend	{
   .set_mg_finished(); 
   .stdexitdefadv("ad17_fontanna", "gamead17_fontanna0"); 
  }
 
  HINT_CLICK	{
		Hidden::HINT_CLICK;
    
    if( !.mishintplaying )	{
  	 if (ankielich.isvisible)
        .showhint("ankielich");
     else
      .showhint("anrekawica_2");
    }
  }   
}
 
 
game HO01a_ksmala : HOBanshee	{
	init	{
		HiddenShape = true;
		
		HOBanshee::init("ho01a_ksmala");
		.imgs = (A, "anim_coord.pyzH", "bkg.jpg","popup_bkg.pyz 4","herb.pyzH 5", /*"znak10.pyz","znak10b.pyz", "znak11.pyz", "znak11b.pyz", "znak12.pyz","znak12b.pyz",*/ "ramka.pyzG 400", "popexit.pyz 410");
		.butpopexit;
    anhoexit.hide ; 
 //   .loadznakout;
 //   .setasznakbut("anznak10"); 
//    .setasznakbut("anznak11");
//    .setasznakbut("anznak12");

    .mtoloupe("part1");
    .mtoloupe("part2");
    .mtoloupe("part3");
    .mtoloupe("part4");
    .mtoloupe("part5"); 
    .mtoloupe("part6");
    
    .setasitemtopck("anherb");  
		.mmasks;
		anpopup_bkg {
  		.Button_isinalpha;
  		butgame.add(this);
  	};
    imgbkg {
		.Button_isinalpha;
		.addmethod("butclick", func {
			if( !.advstdstate ) return;
			.mend;
			} );
  		butgame.add(this);
  	};   
		ccs.enter( func {
		  igmstate = 1;
		  .advsetstdstate;
		} ); 
      
    .newsnd("sndstart", "kinnat_c0d65b");
    sndstart.addmethod("onfinish", "advsetstdstate"); 
    .cbplay("sndstart"); 
   
	} 
  part1_click	{
		.show;
		.remove_from_loupe(this);
	}
  part2_click	{
		.show;
		.remove_from_loupe(this);
	}
  part3_click	{
		.show;
		.remove_from_loupe(this);
	}
  part4_click	{
		.show;
		.remove_from_loupe(this);
	}
  part5_click	{
		.show;
		.remove_from_loupe(this);
	}
  part6_click	{
		.show;
		.remove_from_loupe(this);
	}
	
	hiddenobj_put	{
		if( grtxt.empty )	{
			igmstate = 20;
      .set_mg_finished(); 
			//.mend();
      .show_itempopup("herb", "anherb"); 
    }
	}
  
  anherb_TAKE {
    .hide_itempopup("herb"); 
    .item_gotocenter;
  }
  anherb_INPCK {
    .set_mg_finished; 
     .mend();
  } 
  popup_herb_clickexit {
    butgame.sclicked = ("anherb");
    .anherb_TAKE;  
    
   }   
	mend	{
	 //	ccs.close(null);
  .stdexitdefadv("ad002a_kdoors", "gamead002a_kdoors0"); 
  }
}


game mg00Dzban : Banshee	{
	init	{
		Banshee::init("mg00_dzban");
		
		.imgsgr = (A, "bgdzban.jpg" , "elsc.pyzG 30", "maski.pyzH 40",
			"korek.pyz 5", "dzbanspod.pyz 7", "ksiezyc.pyzH 10", "dzban.pyz 15", "zlozone.pyzH 12", "animopen.pyzH 14",
			"blink.pyzH 35", "dymek.pyzH 50",
			"grall"
			);
		.loadhoexit;
		
		//grall.move(171,0);
		imgbgdzban.setpos(0,0);
		.copyanima("andymek", "andymek2");
		.copyanima("ananimopen", "animopen2");
		ananimopen.show;
		ananimopen.setz(40);
		animopen2.addmethod("onfinish", "mopen_dzban");
		
		.setasitemtopck("anksiezyc");
		
		.copyanima("anmaski", "anmaski2");
		anmaski.addtogamevars("anmaski1");
		
		new int iilekat = 4;
		.copyanima(grelsc.first, "anrot1");
		.copyanima(grelsc.first, "anrot2");
		anrot1.hide; anrot2.hide;
		new filter ftrot1; new filter ftrot2;
		new real robrot;
		new int ilesteps;
		anrot1.setpos(anzlozone.getcx, anzlozone.getcy);
		anrot2.setpos(anzlozone.getcx, anzlozone.getcy);
		
		new vector vpos;
		grelsc.eval( func {
			.setframe(-1, .actionnr(-1) );
			vpos.add( vpos.size ); 
			.setpos( anzlozone.getcx, anzlozone.getcy );
			} );
		if( clsave.bis("e1_mg00dzban_hash" ) )	{
			for( int i=0; i<vpos.size; i++ ) {
				vpos.set( i, clsave.get("e1_mg00dzban_pos_"+i) );
				<grelsc.get(i)>.setframe( -1, vpos.get(i) );
			}
		} else	{
			vpos.hash;
			for( int i=0; i<vpos.size; i++ )
				clsave.set("e1_mg00dzban_pos_"+i, vpos.get(i) );
			clsave.bset("e1_mg00dzban_hash" );
			grelsc.each( func { (@id) .mchange(id, vpos.get(id) ); } );
		}
		
		new int idclick = 0;
		new string sclicked1;
		new string sclicked2;
		grelsc.eval( func {
			.Button_isinalpha;
			.addmethod("butmoveon", func {
				if( .advstdstate )	{
					//advmouse.setbut;
					anblink.setframe(-1, .framenr);
					anblink.setpos(.getposx, .getposy);
					anblink.show;
				}
				} );
			.addmethod("butmoveoff", func {
				//advmouse.setstd;
				anblink.hide;
				} );
			.addmethod("butclick", func {
				if( .advstdstate )	{
					if( idclick==0 )	{
						idclick++;
						.mmask(this);
					} else if (idclick==1)	{
						if( sclicked1!=this )	{
							idclick++;
							.mmask(this);
							sgmstate = "check";
							timcheck.play;
						}
					}
				}
				} );
			butgame.add(this);
			} );
		.timer = ("timcheck", 500, func {
			idclick = 0;
			//.advsetstdstate;
			//.mchange( <sclicked1>.actionnr(-1), <sclicked2>.actionnr(-1) );
			.mrot( <sclicked1>.actionnr(-1), <sclicked2>.actionnr(-1) );
			anmaski1.hide;
			anmaski2.hide;
			} );
		.timer = ("timrot", 50, func {
			if( ilesteps>0 )	{
				ftrot1.rotate( -robrot );
				ftrot2.rotate( robrot );
				anrot1.setpos(anzlozone.getcx, anzlozone.getcy);
				anrot2.setpos(anzlozone.getcx, anzlozone.getcy);
				ilesteps--;
				.play;
			} else {
				ftrot1.unlink; ftrot2.unlink;
				anrot1.hide; anrot2.hide;
				<sclicked1>.show; <sclicked2>.show;
				.mchange( <sclicked1>.actionnr(-1), <sclicked2>.actionnr(-1) );
				.mcheckend;
			}
			} );
		if( clsave.bis("e1_mg00dzban_ulozony") )	{
			.mshowmoon;
		}
		.stdstart;
	}
	mcheckend	{
		bool b = 1;
		for( int i=0; i<grelsc.size; i++)	{
			@s = grelsc.get(i);
			if( <s>.framenr!=i ) b=0;
		}
		if( b )	{
			clsave.bset("e1_mg00dzban_ulozony");
			.mshowmoon;
			sgmstate="state_open";
			animopen2.play(1);
		} else .advsetstdstate;
	}
	mshowmoon	{
		butgame.remove("grelsc");
		grelsc.hide;
		anksiezyc.show;
		animopen2.setframe(1, animopen2.nofframes(1)-1 );
	}
	mchange(int idsrc, int idest)	{
		if( idsrc==idest ) return;
		@s = grelsc.get(idsrc);
		@s2 = grelsc.get(idest);
		@ifr = <s>.framenr;
		<s>.setframe( -1, <s2>.framenr );
		<s2>.setframe( -1, ifr );
		clsave.set("e1_mg00dzban_pos_"+ <s2>.actionnr(-1), ifr );
		clsave.set("e1_mg00dzban_pos_"+ <s>.actionnr(-1), <s>.framenr );
	}
	mrot(int idsrc, int idest)	{
		@s = grelsc.get(idsrc);
		@s2 = grelsc.get(idest);
		<s>.hide;
		<s2>.hide;
		
		anrot1.show;
		anrot2.show;
		@f1 = <sclicked1>.framenr;
		@f2 = <sclicked2>.framenr;
		anrot1.setframe( <s>.actionnr(-1), f1 );
		anrot2.setframe( <s2>.actionnr(-1), f2 );
		ftrot1.link("anrot1");
		ftrot2.link("anrot2");
		ftrot1.setpivottype(2);
		ftrot2.setpivottype(2);
		//anrot1.setpos(anzlozone.getcx, anzlozone.getcy);
		//anrot2.setpos(anzlozone.getcx, anzlozone.getcy);
		@ile = anrot1.nofframes(-1);
		if( f1>f2 )	{
			@steps1 = f1-f2;
			@steps2 = f2 + (ile-f1);
			if( steps1 < steps2 )	{
				.mupdate(steps1, -1);
			} else {
				.mupdate(steps2, 1);
			}
		} else {
			@steps1 = f2-f1;
			@steps2 = f1 + (ile-f2);
			if( steps1 < steps2 )	{
				.mupdate(steps1, 1);
			} else {
				.mupdate(steps2, -1);
			}
		}
		timrot.play;
	}
	mupdate(int steps, int isgn)	{
		ilesteps = steps * iilekat;
		robrot = ( isgn*360/(anrot1.nofframes(-1)*iilekat) );
	}
	mmask(string s)	{
		|int x, int y| = mouse.getpos;
		if( idclick==1 )	{
			andymek.setpos(x,y);
			andymek.play(0);
		} else {
			andymek2.setpos(x,y);
			andymek2.play(0);
		}
		<"sclicked"+idclick>.set(s);
		@s2 = "anmaski"+idclick;
		<s2>.setframe(0, <s>.framenr);
		<s2>.show;
	}
	mopen_dzban	{
		.advsetstdstate;
	}
	anksiezyc_TAKE	{	.popitem_gotocenter("kolatka");	}
	anksiezyc_INPCK	{
		.addtopck("kolatka");
		clsave.bset("e1_wyciagnela_kolatke");
		sgmstate = "end";
		.timplay("timend", 1000, func {
				.gotoadv("ad00_endintro", "gamead00_endintro0");
				ccs.buildfromscreen;
			} );
	}
	mend	{
		.gotoadv("ad00_endintro", "gamead00_endintro0");
	}
	/*mouse_rclick	{
		if( igmdebug )	{
			anksiezyc.show;
			anksiezyc.setz(200);
		}
	}*/
}


game TestFilm2 : StdGame	{
	init	{
		StdGame::init("film");
		advmouse.set("empty");
		
		new Film film1;
		film1.bcenter = (true);
		film1.bborders = (true);
		film1.musicclass = ("mus");
		
		film1.playfilm( "scripts/cs01_barghest/", "film" );
	}
	mouse_lclick	{
		if( film1.isplaying ) film1.stop(true);
	}
}

game TestFilm : StdGame	{
	init	{
		StdGame::init("testfilm2");
		
		new Film film1;
		film1.addmethod("onfinish", "film1_filmend");
		
		//film1.setpos(200, 100);
		.showfps;
		
		new TicksCounter tc1;
		
		//ccs.enter( func { .playfilm; } );
		/*.newtext("txtinfo", "print: 1-film1, 2-film2, 3-repeat film", .stdfont(24), .white);
		txtinfo.setpos( iResX - txtinfo.getw - 10, 0 );
		txtinfo.setz(20);*/
		new img imgbg;
		imgbg.create( iResX, iResY, .black, 255 );
		imgbg.setz(-1);
	}
	key_down	{
		if( keyboard.iskey("1") )	{
			film1.setcycle(2);
			//imgbg.hide;
			tc1.start;
			film1.playfilm("scripts/testfilm/", "film");
		} else if (keyboard.iskey("2") ) {
			film1.setcycle(2);
			//imgbg.hide;
			tc1.start;
			film1.playfilm("scripts/testfilm2/", "film");
		} else if  (keyboard.iskey("3")) film1.play;
	}
	showfps	{
		if( !.hasvar("cfps") )	{
			new CalcFPS cfps;
			cfps.stdset(14, 10, 10);
		}
		cfps.play;
	}
	film1_filmend	{
		.free;
		tc1.print("film time: ");
	}
}


game mg01Fontanna : Banshee	{
	init	{
		Banshee::init("mg01_fontanna");
		
		.imgs = (A, "bkg.jpg", "woda.pyzP 5", "wodamask.pyz 10", "dzwonekblue.pyz 60",
			"oczy.pyzG 25", "czachy.pyzGH 30", "bluszcz.pyz 35", "medalfontanna.pyz 40",
			"popexit.pyz 45", "ramka.pyz 42");
		
		if( clsave.bis("e1_dzwonekblue_taken") )
			andzwonekblue.hide;
		else
			.setasitemtopck("andzwonekblue");
		
		if( clsave.bis("e1_medalfontanna_taken") )
			anmedalfontanna.hide;
		else
			.setasitemtopck("anmedalfontanna");
		
		// 
		/*if( !clsave.bis("e1_czaszka1_put") )
			.addtopck("czaszka1");
		if( !clsave.bis("e1_czaszka2_put") )
			.addtopck("czaszka2");
		if( !clsave.bis("e1_czaszka3_put") )
			.addtopck("czaszka3");*/
		//
		
		.sfxs = (A, "woda2PL 10");
		
		.butpopexit;
		.butpopexitisinramka;
		
		new int idclick = 0;
		
		<grczachy.first>.show;
		<grczachy.first>.setz(31);
		grczachy.eval( func {
			.addmethod("isbutin", func { (@x, @y)
				.isin(x,y,0,0);
				} );
			.addmethod("butmoveon", func {
				if( !.advstdstate && sgmstate!="getitem" ) return;
				advmouse.set("take");
				} );
			.addmethod("butmoveoff", func {
				if( !.advstdstate && sgmstate!="getitem" ) return;
				advmouse.setstd;
				} );
			.addmethod("butclick", func {
				if( !.advstdstate || !.isvisible ) return;
				@idf = (.framenr+1)%.nofframes(-1);
				@id = .actionnr(-1);
				.setframe(-1, idf );
				<groczy.get(id)>.setframe(-1,idf);
				@s = ""+id+"_"+idclick;
				match( s )	{
					"2_0" => .mgoclick(1);
					"1_1" => .mgoclick(2);
					"3_2" => .mgoclick(3);
					"0_3" =>  {
						anwoda.anhide;
						idclick++;
						anmedalfontanna.setframe(0, idclick);
					}
					? => {
						anwoda.play(0);
						idclick = 0;
						anmedalfontanna.setframe(0, idclick);
					}
				}
				} );
			butgame.add(this);
			} );
		grczachy.removeat(0);
		
		for( int i=1; i<=3; i++) {
			if( clsave.bis("e1_czaszka"+i+"_put") )
				.wstaw_czaszke(i, clsave.get("e1_czaszka"+i+"_putplace") );
		}
		
		mus.playstr("banshee1.ogg -v 30 -l");
		.stdstart;
	}
	mgoclick(int id)	{
		if( .framenr==1 )	{
			anwoda.play(id);
			idclick++;
		} else {
			anwoda.play(0);
			idclick=0;
		}
		anmedalfontanna.setframe(0, idclick);
	}
	USE_czaszka1	{	._check_use(1);	}
	USE_czaszka2	{	._check_use(2);	}
	USE_czaszka3	{	._check_use(3);	}
	_check_use(int id)	{
		.advsetstdstate;
		if( grczachy.isin(mouse.getpos,0,0) )	{
			.removefrompck("czaszka"+id);
			.wstaw_czaszke(id, grczachy.getsfound);
		} else
			.item_gotopck;
	}
	wstaw_czaszke(int idczacha, string sczachaput)	{
		grczachy.remove(sczachaput);
		<sczachaput>.show;
		clsave.bset("e1_czaszka"+idczacha+"_put");
		clsave.set("e1_czaszka"+idczacha+"_putplace",sczachaput);
	}
	anmedalfontanna_TAKE	{
		if( anmedalfontanna.framenr==4 ) {
			.popitem_gotocenter("medalfontanna");
		}
	}
	anmedalfontanna_INPCK	{
		clsave.bset("e1_medalfontanna_taken");
		.addtopck("medalfontanna");
	}
	andzwonekblue_TAKE	{	.popitem_gotocenter("dzwonekblue");	}
	andzwonekblue_INPCK	{
		clsave.bset("e1_dzwonekblue_taken");
		.addtopck("dzwonekblue");
	}
	mend	{
		.stdexitdefadv("ad01_widokogolny", "gamead01_widokogolny0");
	}
	HINT_CLICK	{
		if( !clsave.bis("e1_wyciagnela_kolatke") )	{
			if( !clsave.bis("e1_dzwonekblue_taken") )
				.showhint("andzwonekblue");
			else .showhint("anpopexit");
		} else {
			if( clsave.bis("e1_medalfontanna_taken") )
				.showhint("anpopexit");
			else .showhint("anmedalfontanna");
		}
	}
}



game mg01Schody : Banshee	{
	init	{
		Banshee::init("mg01_schody");
		
 /*    if (!clsave.bis("medal_fontanna_dodany_test"))
     { 
        .addtopck("medalfontanna");
        clsave.bset("medal_fontanna_dodany_test");
    }   */
		.imgs = (A, "bkg.jpg", "jezyk.pyzP 5", "jaszczur.pyz 10",
			"przycisk.pyz 20", "klucz.pyz 25",
			"dolcien.pyz 30", "klapa.pyz 35", "klapamask.pyz 40",
			"dolekputmedal.pyz 45", "medalput.pyzH 50", "medalpck.pyzH 55",
			"lisc1.pyz 60", "lisc2.pyz 60", "lisc3.pyz 60", "lisc4.pyz 60",
			"cienmask.pyz 70", "motyl.pyzP 115", "ramka.pyz 80", "popexit.pyz 90");
		.butpopexit;
		//.loadimgexitbut;
		.butpopexitisinramka;
    if (!clsave.bis("taken_kluczschodek"))
    { 
      new filter ftklucz;
  		ftklucz.link("anklucz");
  		ftklucz.rotate(90);
  		.setasitemtopck("anklucz");
    }
    else
    {
      anklucz.hide(); 
    }
        
    
		if( !clsave.bis("e1_mg01_klucz_odkryty") )
    {
			anklucz.disable = (true);
      if (clsave.bis("e1_medalfontanna_is_put") || clsave.bis("e1_mg01_klucz_przycisk_nacisniety")) 
          anklapa.move(0, -70);
    }
		else anklapa.hide;
		
		anmotyl.ansetbpos( igmappw/2+250,igmapph/2);
		new filter ftmotyl;
		ftmotyl.link("anmotyl");
		new int ilicz = 0;
		anmotyl.addmethod("onendframe", func {
			ilicz++;
			if( ilicz==1 )	{
				ilicz=0;
				real kat = 12-21->rand;
				real dt = 5;
				real kat2 = ftmotyl.getangle;
				real x = kat2->sin * dt;
				real y = kat2->cos * dt;
				ftmotyl.rotate(kat);
				.move(-x,-y);
			}
			} );
		
		if( !clsave.bis("e1_zabrana_czaszka3") )	{
			.imgs = (A, "czaszka3.pyz 75");
			.setasitemtopck("anczaszka3");
		}
		for( int i=1; i<=4; i++)	{
			if( clsave.bis("e1_mg01_lisc_"+i+"_odsuniety") ) {
				<"anlisc"+i>.ansetlastframe(1);
			} else {
				<"anlisc"+i> {
					.Button_isinalpha;
					.addmethod("butmoveon", func {
						if( !.advstdstate ) return;
						advmouse.setact;
						} );
					.addmethod("butmoveoff", func {
						if( !.advstdstate ) return;
						advmouse.setstd;
						} );
					.addmethod("butclick", func {
						if( !.advstdstate ) return;
						if( .actionnr(-1)==0 )	{
							butgame.removebut(this);
							butgame.onmousemove;
							clsave.bset("e1_mg01_lisc_"+ this->gete(0,1) +"_odsuniety");
							.play(1);
						}
						} );
					butgame.add(this);
				};
			}
		}
		andolekputmedal {
			.addmethod("isbutin", func { (@x, @y)
				anlisc1.actionnr(-1)==1 && .isin(x,y,0,0);
				} );
			.addmethod("butmoveon", func {
				if( !.advstdstate && sgmstate!="getitem" ) return;
				  if( !clsave.bis("e1_medalfontanna_is_put") ) 
            advmouse.set("use");
				} );
			.addmethod("butmoveoff", func {
				if( !.advstdstate && sgmstate!="getitem" ) return;
				advmouse.setstd;
				} );
			butgame.add(this);
		};
		if( clsave.bis("e1_medalfontanna_is_put") )	{
			anmedalput.show;
		} 
		if( !clsave.bis("e1_mg01_klucz_odkryty") )	{
			anprzycisk	{
				.addmethod("isbutin", func { (@x, @y)
					.przyciskodkryty && .isin(x,y,0,0);
					} );
				.addmethod("butmoveon", func {
					if( !.advstdstate ) return;
					 if (!clsave.bis("e1_mg01_klucz_przycisk_nacisniety")) 
              advmouse.set("take");
           else
              advmouse.setstd;  
					} );
				.addmethod("butmoveoff", func {
					if( !.advstdstate ) return;
					advmouse.setstd;
					} );
				.addmethod("butclick", func {
					if( !.advstdstate ) return;
					if( .actionnr(-1) ) .setframe(0,0);
					else .setframe(1,0);
					if(!clsave.bis("e1_mg01_klucz_przycisk_nacisniety") && .actionnr(-1) )	{
						butgame.removebut("anprzycisk");
            clsave.bset("e1_mg01_klucz_przycisk_nacisniety");
						.butmoveon;
            sgmstate = "odsun";
						timzasuwa.play;
					}
					} );
				butgame.add(this);
			};
		}
		.cycle = ("timzasuwa", func {
			anklapa.move(0, -10);
			@final = 140;
      if (clsave.bis("e1_medalfontanna_is_put") &&  clsave.bis("e1_mg01_klucz_przycisk_nacisniety"))
        final = 0;
      if( anklapa.getpy < final)	{
				.advsetstdstate;
		 	  if (final == 0)
        { 
          anklucz.disable=(false);
				  clsave.bset("e1_mg01_klucz_odkryty");
        }
			} else .play;
			} ); 
    
		.stdstart;
    
    
      
	}
	anklucz_TAKE	{	ftklucz.rotate(-90); .popitem_gotocenter("kluczschodek");	}
	anklucz_INPCK	{
		.addtopck("kluczschodek");
		clsave.bset("e1_end_schody");
    if (clsave.bis("e1_zabrana_czaszka3"))
      .mend();
	}
	mend	{
		.stdexitdefadv("ad01_widokogolny", "gamead01_widokogolny0");
	}
	przyciskodkryty	{	anlisc2.actionnr(-1) && anlisc3.actionnr(-1) && anlisc4.actionnr(-1);	}
	anczaszka3_TAKE	{	.popitem_gotocenter("czaszka3");}
	anczaszka3_INPCK	{
		.addtopck("czaszka3");
		clsave.bset("e1_zabrana_czaszka3");
    if (clsave.bis("e1_end_schody"))
      .mend();
	}
	USE_medalfontanna	{
		.advsetstdstate;
		if( andolekputmedal.isbutin(mouse.getpos) )	{
			butgame.removebut("andolekputmedal");
			.removefrompck("medalfontanna");
			anmedalput.show;
      clsave.bset("e1_medalfontanna_is_put");  
      advmouse.setstd;
      .butmoveon;
      sgmstate = "odsun";
			timzasuwa.play; 
           
		} else .item_gotopck;
	}
	HINT_CLICK	{
		if( !clsave.bis("e1_wyciagnela_kolatke") )	{
			.showhint("anpopexit");
		} else {
			if( !clsave.bis("e1_medalfontanna_taken") )	{
				if( clsave.bis("e1_zabrana_czaszka3") )
					.showhint("anpopexit");
				else .showhint("anczaszka3");
			} else if( !clsave.bis("e1_mg01_lisc_1_odsuniety") )	{
				.showhint("anlisc1");
			} else if( !clsave.bis("e1_mg01_lisc_2_odsuniety") )	{
				.showhint("anlisc2");
			} else if( !clsave.bis("e1_mg01_lisc_3_odsuniety") )	{
				.showhint("anlisc3");
			} else if( !clsave.bis("e1_mg01_lisc_4_odsuniety") )	{
				.showhint("anlisc4");
			} else if ( !clsave.bis("e1_medalfontanna_is_put") )	{
				.showhint("andolekputmedal");
				.showhintitem("medalfontanna");
			} else if(!clsave.bis("e1_mg01_klucz_odkryty"))	{
				.showhint("anprzycisk");
			} else if ( !clsave.bis("e1_end_schody") )	{
				.showhint("anklucz");
			} else .showhint("anpopexit");
		}
	}
}



game mg02Klodkabrama : Banshee	{
	init	{
		Banshee::init("mg02_klodkabrama");
		.imgs = (A, "bkg.jpg", "lew.pyz 30", "oczy.pyzH 40",
			"box.pyzH 5", "els.pyzGH 10", "forklucz.pyzH 15", "kolatka.pyzH 40", "klucz.pyzH 20",
			"popexit.pyz 50");
		
		.butpopexit;
		 anlew {
  		.Button_isinalpha;
  		butgame.add(this);
  	};
    imgbkg {
		.addmethod("isbutin", func { (@x, @y)
			!anbox.isin(x,y,0,0);
			} );
		.addmethod("butclick", func {
			if( !.advstdstate ) return;
			.mend;
			} );
  		butgame.add(this);
  	};     
    
		if( !clsave.bis("e1_lew_losuj") )	{
			clsave.bset("e1_lew_losuj");
			for( int i=0; i<grels.size; i++)	{
				@s = grels.get(i);
				<s>.setframe(i, 1 + (<s>.nofframes(-1)-1)->rand );
				clsave.set("e1_lew_els_"+i, <s>.framenr );
			}
		} else {
			for( int i=0; i<grels.size; i++)	{
				<grels.get(i)>.setframe( i , clsave.get("e1_lew_els_"+i) );
			}
		}
		
		.sfxs = (A, "odklucza2");
		new bool bkoniecmech;
		.mcheckels;
		
		anklucz.addmethod("onfinish", func {
			clsave.bset("e1_lew_otworzony");
			.mend;
			} );
		ankolatka {
			.Button_isin;
			.Button_moveonms;
			.Button_moveoffms;
			.addmethod("butclick", func {
				if( !.advstdstate ) return;
				sgmstate = "lewopen";
				.play(0);
				} );
			.addmethod("onfinish", func {
				.hide;
				clsave.bset("e1_lew_mech");
				.mlewmech;
				anlew.playsmooth("open");
				} );
			butgame.add(this);
		};
		anlew {
			.addmethod("isbutin", func { (int x, int y)
				.isin(x,y,1,1) && (.actionname=="normal" || (.actionname=="sleep" && !ankolatka.isvisible));
				} );
			.Button_moveonms;
			.Button_moveoffms;
			.addmethod("butclick", func {
				if( !.advstdstate ) return;
				if( .actionname=="normal" )	{
					sgmstate = "angrylew";
					.playsmooth("angry");
					anoczy.play("angry");
				}
				} );
			.addmethod("onfinish", func {
				.setsmooth(0);
				if (.actionname=="angry")	{
					.play("angry2");
				} else if (.actionname=="angry2")	{
					.playsmooth("angry3");
				} else if (.actionname=="angry3")	{
					.advsetstdstate;
					.play("normal");
					anoczy.play("normal");
				} else if ( .actionname=="open" )	{
					.advsetstdstate;
					.setframe("opened", 0);
				} else if (.actionname=="sleep")	{
					.advsetstdstate;
				}
				} );
			butgame.add(this);
		};
		grels.eval( func {
			.addmethod("isbutin", func { (int x, int y)
				!bkoniecmech && .isin(x,y,1,1);
				} );
			.Button_moveonms;
			.Button_moveoffms;
			.addmethod("butclick", func {
				if( !.advstdstate || bkoniecmech ) return;
				.ansetnextfr;
				clsave.set("e1_lew_els_" + .actionnr(-1), .framenr);
				.mcheckels;
				if( bkoniecmech )	{
					fxodklucza2.play;
				}
				} );
			butgame.add(this);
			} );
		
		anforklucz	{
			.addmethod("isbutin", func { (int x, int y)
				bkoniecmech && .isin(x,y,1,0);
				} );
			.Button_moveonms;
			.Button_moveoffms;
			butgame.add(this);
		};
		
		//lew: normal angry sleep open opened
		if( clsave.bis("e1_lew_mech") )	{
			anlew.setframe("opened",0);
			.mlewmech;
		} else if ( clsave.bis("e1_lew_kolatka") )	{
			anlew.setframe("sleep", 0);
			ankolatka.show;
		} else {
			anoczy.play(0);
		}
		.stdstart;
		/*if( clsave.bis("e1_lew_mech") )	{
			.stdstart;
		} else
			.advsetstdstate;*/
	}
	mlewmech	{
		anbox.show;
		grels.show;
		anforklucz.show;
	}
	mcheckels	{
		for( int i=0 ; i<grels.size; i++) {
			if( !<grels.get(i)>.framename->contains("ok") ) {
				bkoniecmech = false;
				return;
			}
		}
		bkoniecmech = true;
	}
	USE_kolatka	{
		if( anlew.isin(mouse.getpos,1,1) )	{
			.removefrompck("kolatka");
			anlew.play("sleep");
			anoczy.anhide;
			ankolatka.show;
			clsave.bset("e1_lew_kolatka");
		} else {
			.advsetstdstate;
			.item_gotopck;
		}
	}
	USE_kluczschodek	{
		if( bkoniecmech && anforklucz.isin(mouse.getpos,1,0) )	{
			.removefrompck("kluczschodek");
			sgmstate = "kluczotwiera";
			anklucz.play(0);
		} else {
			.advsetstdstate;
			.item_gotopck;
		}
	}
	mend	{
		.stdexitdefadv("ad02_brama", "gamead02_brama0");
	}
}



game mg01_barghest :Banshee {
	init{
		Banshee::init("mg01_barghest");
		
		.imgs = (A, "bkg.jpg",  "anim_pos.pyz H", "ramka.pyz 20");
		
		new Film filmb;
		filmb.musicclass = ("mus");
		filmb.addmethod("onfinish", "mend");
		filmb.load("scripts/cs01_barghest/", "film");
		filmb.showfirstframe;
		filmb.setpos( ananim_pos.getpx, ananim_pos.getpy );
		ccs.enter( func {
			filmb.play;
			} );
	}
	mend	{ 
		.stdexitdefadv("ad01_widokogolny", "gamead01_widokogolny0");
   
	}
}



game mg02Gniazdo : Banshee	{
	init	{
		Banshee::init("mg02_gniazdo");
	 //  .addtopck("jajo"); // do testow 
    .imgs = (A, "bkg.jpg", "ptak.pyzH 20", "ptak2.pyzH 10",
			"tlo.pyz 5", "jajko.pyzH 15", "ziarno.pyzH 15", "popexit.pyz 50");
		
		 antlo {
  		.Button_isinalpha;
  		butgame.add(this);
  	};
	.loadimgexitbut;   
    
    if( !clsave.bis("e1_jajko_taken") )	{
			anjajko.show;
		}
		if( !clsave.bis("taken_ziarno") )	{
			anziarno.show;
			.setasitemtopck("anziarno");
		}
		
		//ptak.pyz tlo.pyz popexit.pyz ptak2.pyz 
		if( clsave.bis("e1_ptok_odslonil_jajco") )	{
			.copyanima("anptak2", "anptakcorp");
			anptak2.play(1);
		//	anptakcorp.setz(9);
			anptakcorp.show;
		} else {
			anptak.play(0);
			anptak.addmethod("onfinish", func { .play(0); });
		}
		
		.butpopexit;
		
		.stdstart;  
	}
 
	anziarno_TAKE	{
		if( clsave.bis("e1_ptok_odslonil_jajco") ) {
			.popitem_gotocenter("ziarno");
		} else if( !anptak.isplaying(1) ) {
			anptak.play(1);
		}
	}
	anziarno_INPCK	{
		.addtopck("ziarno");
    .mend;        
	}
 
   
  USE_jajo	{
		.advsetstdstate;
    advmouse.setstd;
    if( anptak.isin(mouse.getpos,1,1) || anjajko.isin(mouse.getpos,1,1) || anziarno.isin(mouse.getpos,1,1) )	{
			  .removefrompck("jajo");
        .copyanima("anptak2", "anptakcorp");
  			anptak.anhide();
        anptak2.play(1);
  		//	anptakcorp.setz(9);
  			anptakcorp.show; 
        clsave.bset("e1_ptok_odslonil_jajco");
    } else .item_gotopck;   
	} 
  
	mend	{
		.stdexitdefadv("ad02_brama", "gamead02_brama0");
	}
}




public e1_check_mlotek_dluto	{
	if( clsave.bis("ma_mlotek") && clsave.bis("ma_dluto") )	{
		.removefrompck("mlotek");
		.removefrompck("dluto");
		.addtopck("mlotek_dluto");
	}
}

game mg02SkrytkaL : Banshee	{
	init	{
		Banshee::init("mg02_skrytkal");
	//	.addtopck("gzyms1"); 
  //  .addtopck("gzyms2"); 
		.imgs = (A, "$scripts/mg02_gniazdo/bkg.jpg", "bgpop.pyz 5", "sciana.pyz 15", "mlotek.pyz 10",
			"podgzyms1.pyz 20", "podgzyms2.pyz 20", "maskabg.pyz 30", "popexit.pyz 40");
		.butpopexit;
		anmaskabg.addtogamevars("anramka");
		.butpopexitisinramka;
		
		// e1_ad02_skrytka_otwarta, e1_ad02_gzyms1put
		
		if( clsave.bis("taken_mlotek") )	anmlotek.hide;
		else .setasitemtopck("anmlotek");
		
		if( clsave.bis("e1_ad02_gzyms1put") )	{
			anpodgzyms1.hide;
		} else {
			anpodgzyms1.Button_stdms;
      anpodgzyms1.addmethod("butmoveon", func {
				if( !.advstdstate) return;
				  if (!clsave.bis("e1_ad02_gzyms1put"))
            advmouse.set("use");   
        } );
			anpodgzyms1.addmethod("butmoveoff", func {
				if( !.advstdstate ) return;
				  advmouse.setstd;
				} );    
			butgame.add("anpodgzyms1");
		}
		if( clsave.bis("e1_ad02_gzyms2put") )	{
			anpodgzyms2.hide;
		} else {
			anpodgzyms2.Button_stdms;
      anpodgzyms2.addmethod("butmoveon", func {
				if( !.advstdstate) return;
				  if (!clsave.bis("e1_ad02_gzyms2put"))
            advmouse.set("use");   
        } );
			anpodgzyms2.addmethod("butmoveoff", func {
				if( !.advstdstate ) return;
				  advmouse.setstd;
				} );    
			butgame.add("anpodgzyms2");
		}
		
		if( clsave.bis("e1_ad02_skrytka_otwarta") )	{
			ansciana.setframe("opened",0);
		} else {
			anmlotek.hide;
			ansciana.addmethod("isbutin", func { (@x, @y)
				.isin(x,y,1,1) && !anpodgzyms1.isvisible && !anpodgzyms2.isvisible;
				} );
			ansciana.Button_moveonms;
			ansciana.Button_moveoffms;
			ansciana.addmethod("butclick", func {
				if( !.advstdstate ) return;
				butgame.removebut(this);
				butgame.onmousemove;
				clsave.bset("e1_ad02_skrytka_otwarta");
				sgmstate = "state_opensciana";
				anmlotek.show;
				.anplaysmoothfin( "open", func {
					.advsetstdstate;
					} );
				} );
			butgame.add("ansciana");
		}
		
		.stdstart;
	}
	anmlotek_TAKE	{
		//.saveitemtopck("mlotek");
		.popitem_gotocenter("mlotek");
	}
	anmlotek_INPCK	{
		.addtopck("mlotek");
	//	.e1_check_mlotek_dluto;
	}
	USE_gzyms1	{
		.advsetstdstate;
		if( anpodgzyms1.isin(mouse.getpos,1,0) )	{
			clsave.bset("e1_ad02_gzyms1put");
			anpodgzyms1.hide;
			.removefrompck("gzyms1");
       advmouse.setstd;
		} else .item_gotopck;
	}
	USE_gzyms2	{
		.advsetstdstate;
		if( anpodgzyms2.isin(mouse.getpos,1,0) )	{
			clsave.bset("e1_ad02_gzyms2put");
			anpodgzyms2.hide;
			.removefrompck("gzyms2");
       advmouse.setstd;
		} else .item_gotopck;
	}
	mend	{
		.stdexitdefadv("ad02_brama", "gamead02_brama0");
	}
}




game mg03_pnacza :Banshee {
	init{
    Banshee::init("mg03_pnacza");
    .imgs = (A, "bkg.jpg 0", "base.pyz 1","rama_win.pyzH 2", "cegla_1.pyzH 3","cegla_2.pyzH 3","cegla_3.pyzH 3","cegla_1_fall.pyzH 3","cegla_2_fall.pyzH 3","cegla_3_fall.pyzH 3", "diamond_1.pyzH 4", "diamond_2.pyzH 5", 
              "diamond_3.pyzH 5","1.pyzH 6","2.pyzH 6","3.pyzH 6","4.pyzH 6","5.pyzH 6","6.pyzH 6","7.pyzH 6","8.pyzH 6","9.pyzH 6" , "rama.pyz 7", "cut_1.pyz 8", "cut_2.pyz 9","cut_3.pyz 10", "cut_4.pyz 11", "cut_5.pyz 12",  "cut_6.pyz 13", "frame.pyz 14", "popexit.pyz 15" );
    .butpopexit; 
    
  //  .addtopck("sekator"); 
    
    imgbkg {
  		.addmethod("isbutin", func { (@x, @y)
  			!anbase.isin(x,y,0,0);
  			} );
  		.addmethod("butclick", func {
  			if( !.advstdstate ) return;
  			 .mend;
  			} );
    		butgame.add(this);
  	 };      
    
    new bool computer_turn = true;     
    new int shake1 = 0;
    new int shake2 = 0;
    new int shake3 = 0;  
    
    for( int i=1; i<=6; i++)	{  
       <"ancut_"+i> {
        .Button_isin;
        .addmethod("butmoveon", func {
    			if( !.advstdstate) return;
    			  advmouse.set("use");   
          } );
    		.addmethod("butmoveoff", func {
    			if( !.advstdstate ) return;
    			  advmouse.setstd;
    			} );
          butgame.add(this); 
        };
     }; 
    // buttony 
    
     for( int i=1; i<=9; i++)	{ 
      <"an"+i> {
  			.Button_isin;
      			.Button_moveonms;
      			.Button_moveoffms;
  					.addmethod("butclick", func {
  					  if( !.advstdstate ) return;
                
                if (.actionnr(-1)== 0){ 
                  .play(1);
                  
                  if (.check_won() == 0)
                  {
                    if (!.table_full())
                      .computer_move();
                      
                    if (.check_won()> 0)
                    {
                        //someone win   
                        if (.check_won() == 1)  //player won
                        {
                          .player_won(); 
                        }
                        else //computer won
                        {
                          .start_game();
                        }
                    }
                    else{
                      if (.table_full()){  //table full  - restart
                           .start_game();
                      }
                    }
                  }
                  else 
                  { 
                    
                    //someone win   
                    if (.check_won() == 1)  //player won
                    {
                       
                      .player_won();
                      return;
                    }
                    else     //computer won
                    {
                        
                      .start_game();
                      return;
                    }
                    
                    if (.table_full()){          //table full  - restart
                        
                       .start_game();
                    }
                     
                  }
              }
  					 } );
             butgame.add(this);
  				};
      }
    
    
    for( int i=1; i<=6; i++)	{ 	
        <"ancut_"+i> {
          .clip( anrama_win.getpx, anrama_win.getpy, anrama_win.getex, anrama_win.getey ); 
			 };
      }
      
      ancegla_1{
          .Button_isin;
    			.Button_moveonms;
    			.Button_moveoffms; 
					.addmethod("butclick", func {
					if( !.advstdstate ) return;
              if (shake1 < 2)
              {
                shake1 = shake1 +1;
                .play("shake");
              }
              else
              {  
                .play("push");
                ancegla_1_fall.show();
                ancegla_1_fall.play("fall");
                andiamond_1.anfadein(300,null);  
                clsave.bset("bn03pnacza_cegla_1_pushed"); 
                advmouse.setstd;
                butgame.removebut(this);
  							butgame.onmousemove; 
                
              }
          } );
					//butgame.add(this);
      }; 
      ancegla_2{
           .Button_isin;
    			.Button_moveonms;
    			.Button_moveoffms;
					.addmethod("butclick", func {
					if( !.advstdstate ) return;
            if (shake2 < 2)
            {
              shake2 = shake2 +1;
              .play("shake");
            }
            else
            {  
              ancegla_2_fall.show();
              ancegla_2_fall.play("fall");
              .play("push");
              andiamond_2.anfadein(300,null);  
              clsave.bset("bn03pnacza_cegla_2_pushed");
              advmouse.setstd;
              butgame.removebut(this);
  						butgame.onmousemove; 
               
            }
          } );
					//butgame.add(this);
      }; 
      ancegla_3{
          .Button_isin;
    			.Button_moveonms;
    			.Button_moveoffms; 
					.addmethod("butclick", func {
					if( !.advstdstate ) return;
            if (shake3 < 2)
            {
              shake3 = shake3 +1;
              .play("shake");
            }
            else
            {  
              .play("push");
              ancegla_3_fall.show();
              ancegla_3_fall.play("fall");
              andiamond_3.anfadein(300,null);  
              clsave.bset("bn03pnacza_cegla_3_pushed");
              advmouse.setstd;
              butgame.removebut(this);
  						butgame.onmousemove;
                
            }
          } );
					//butgame.add(this);
      }; 
  
      .setasitemtopck("andiamond_1");
      .setasitemtopck("andiamond_2");
      .setasitemtopck("andiamond_3");
     
   
    //flagi 
    for( int i=1; i<=6; i++)
    {
       if (clsave.bis("e1_bn03pnacza_cuted_"+ i))
       {
         <"ancut_"+i>.hide();
       }
    } 
    
   
    if (clsave.bis("bn03pnacza_player_won"))
    {
      anrama.hide();
      anrama_win.show();
      anrama_win.play("burned");
      
      if (clsave.bis("bn03pnacza_cegla_1_pushed"))
      {
        ancegla_1.show();
        ancegla_1.play("pushed");
        if ( !clsave.bis("taken_krysztal_red_1"))
        {
          andiamond_1.show();
        }
      }
      else
      {
         ancegla_1.show(); 
         butgame.add("ancegla_1"); 
      }
      
      if (clsave.bis("bn03pnacza_cegla_2_pushed"))
      {
        ancegla_2.show();  
        ancegla_2.play("pushed");
        if ( !clsave.bis("taken_krysztal_red_2"))
        {
          andiamond_2.show();
        }
      }  
      else
      {
         ancegla_2.show();
         butgame.add("ancegla_2");   
      }
      if (clsave.bis("bn03pnacza_cegla_3_pushed"))
      {
        ancegla_3.show();
        ancegla_3.play("pushed");
        if ( !clsave.bis("taken_krysztal_blue_1"))
        {
          andiamond_3.show();
        }
      }
      else
      {
         ancegla_3.show();
         butgame.add("ancegla_3");   
      }
    }
    else
    { 
      if (.check_game_can_start())
      {
         .start_game();
      }
    }
    .stdstart;   
	 } // koniec init
   
   mend	{ 
   .dprint("mend");
    .stdexitdefadv("ad03_placglowny", "gamead03_placglowny0");
	}
   
   check_game_can_start()
   {
       for( int i=1; i<=6; i++)
       {
         if (!clsave.bis("e1_bn03pnacza_cuted_"+ i))
            return false;
       }
       return true;  
   }
   
     start_game()
     {
        for( int i=1; i<=9; i++)
        {   
          <"an"+i>.show();
          <"an"+i>.play("empty");
          
        } 
        int count = 7;
        if (computer_turn){ 
          <"an"+(count->rand +1)>.play("x");  
          computer_turn = false;
        }
        else
        {
          computer_turn =  true;
        }
        
    } 
    
    act_anim(int id)
    {
        return <"an"+id>.actionnr(-1);
    }
     
     check_won() {
        if (.act_anim(1) == .act_anim(2) && .act_anim(2) == .act_anim(3) && .act_anim(1) > 0)
      		return .act_anim(1);
       	if (.act_anim(4) == .act_anim(5) && .act_anim(5) == .act_anim(6) && .act_anim(4) > 0)
      		return .act_anim(4);
      	if (.act_anim(7) == .act_anim(8) && .act_anim(8) == .act_anim(9) && .act_anim(7) > 0)
      		return .act_anim(7);
       	if (.act_anim(1) == .act_anim(4) && .act_anim(4) == .act_anim(7) && .act_anim(1) > 0)
      		return .act_anim(1);
        if (.act_anim(2) == .act_anim(5) && .act_anim(5) == .act_anim(8) && .act_anim(2) > 0)
      		return .act_anim(2);
        	if (.act_anim(3) == .act_anim(6) && .act_anim(6) == .act_anim(9) && .act_anim(3) > 0)
      		return .act_anim(3);
       	if (.act_anim(1) == .act_anim(5) && .act_anim(5) == .act_anim(9) && .act_anim(1) > 0)
      		return .act_anim(1);
      	if (.act_anim(3) == .act_anim(5) && .act_anim(5) == .act_anim(7) && .act_anim(3) > 0)
      		return .act_anim(3);    
        return 0;  
     }
     
     computer_move(){
         
        //check horizontal
          
        if (9->rand >4){
            if (.act_anim(1) == 1 && .act_anim(2) == 0 && .act_anim(3) == 1)
            {
        		     <"an2">.play("x");
                 return;
            }
            if (.act_anim(4) == 1 && .act_anim(5) == 0 && .act_anim(6) == 1)
            {
        		     <"an5">.play("x");
                 return;
            }
            if (.act_anim(7) == 1 && .act_anim(8) == 0 && .act_anim(9) == 1)
            {
        		     <"an8">.play("x");
                 return;
            }
          //check vertical
            if (.act_anim(1) == 1 && .act_anim(4) == 0 && .act_anim(7) == 1)
            {
        		     <"an4">.play("x");
                 return;
            }
            if (.act_anim(2) == 1 && .act_anim(5) == 0 && .act_anim(8) == 1)
            {
        		     <"an5">.play("x");
                 return;
            }
            if (.act_anim(3) == 1 && .act_anim(6) == 0 && .act_anim(9) == 1)
            {
        		     <"an6">.play("x");
                 return;
            } 
            
             //check crosses
            if (.act_anim(1) == 1 && .act_anim(5) == 0 && .act_anim(9) == 1)
            {
        		     <"an5">.play("x");
                 return;
            }
            if (.act_anim(1) == 1 && .act_anim(5) == 1 && .act_anim(9) == 0)
            {
        		     <"an9">.play("x");
                 return;
            }
            
            if (.act_anim(1) == 0 && .act_anim(5) == 1 && .act_anim(9) == 1)
            {
        		     <"an1">.play("x");
                 return;
            }
            
            
            if (.act_anim(3) == 1 && .act_anim(5) == 0 && .act_anim(7) == 1)
            {
        		     <"an5">.play("x");
                 return;
            }
            
            if (.act_anim(3) == 1 && .act_anim(5) == 1 && .act_anim(7) == 0)
            {
        		     <"an7">.play("x");
                 return;
            }
            
            if (.act_anim(3) == 0 && .act_anim(5) == 1 && .act_anim(7) == 1)
            {
        		     <"an3">.play("x");
                 return;
            }
             //check horizontal again
            
          
            if (.act_anim(1) == 1 && .act_anim(2) == 1 && .act_anim(3) == 0)
            {
        		     <"an3">.play("x");
                 return;
            }
            if (.act_anim(1) == 0 && .act_anim(2) == 1 && .act_anim(3) == 1)
            {
        		     <"an1">.play("x");
                 return;
            }
            
            if (.act_anim(4) == 1 && .act_anim(5) == 1 && .act_anim(6) == 0)
            {
        		     <"an6">.play("x");
                 return;
            }
            if (.act_anim(4) == 0 && .act_anim(5) == 1 && .act_anim(6) == 1)
            {
        		     <"an4">.play("x");
                 return;
            }
            
            if (.act_anim(7) == 1 && .act_anim(8) == 1 && .act_anim(9) == 0)
            {
        		     <"an9">.play("x");
                 return;
            }
            if (.act_anim(7) == 0 && .act_anim(8) == 1 && .act_anim(9) == 1)
            {
        		     <"an7">.play("x");
                 return;
            }
            
             //check vertical again
            
          
            if (.act_anim(1) == 1 && .act_anim(4) == 1 && .act_anim(7) == 0)
            {
        		     <"an7">.play("x");
                 return;
            }
            if (.act_anim(1) == 0 && .act_anim(4) == 1 && .act_anim(7) == 1)
            {
        		     <"an1">.play("x");
                 return;
            }
            
            if (.act_anim(2) == 1 && .act_anim(5) == 1 && .act_anim(8) == 0)
            {
        		     <"an8">.play("x");
                 return;
            }
            if (.act_anim(2) == 0 && .act_anim(5) == 1 && .act_anim(8) == 1)
            {
        		     <"an2">.play("x");
                 return;
            }
            
            if (.act_anim(3) == 1 && .act_anim(6) == 1 && .act_anim(9) == 0)
            {
        		     <"an9">.play("x");
                 return;
            }
            if (.act_anim(3) == 0 && .act_anim(6) == 1 && .act_anim(9) == 1)
            {
        		     <"an3">.play("x");
                 return;
            }  
            
            for( int i=1; i<=9; i++){   
              if ( <"an"+i>.actionnr(-1)== 0){
                   <"an"+i>.play("x");
                  return;
              } 
            } 
          }
          else 
          {   
            bool found = false;
            while( !found)	{
    				    int pos = 9->rand +1; 
                if ( <"an"+pos>.actionnr(-1)== 0){
                    <"an"+pos>.play("x");
                    found =  true;
                } 
  					} 
          }
      }
     
      table_full(){
        for( int i=1; i<=9; i++){   
          if ( <"an"+i>.actionnr(-1)== 0){
            return false;
          } 
        } 
        return true;  
      }
      
      player_won(){
          .clear_table();
          anrama.hide();
          anrama_win.show(); 
          anrama_win.play(0);
          .show_bricks(); 
          clsave.bset("bn03pnacza_player_won");   
      }
      
      clear_table()
      {
        advmouse.setstd;
        for( int i=1; i<=9; i++)
        {   
          <"an"+i>.hide(); 
           butgame.removebut("an"+i);
        }
        butgame.onmousemove;   
      }
      
      show_bricks()
      {
        advmouse.setstd;
        ancegla_1.show();   
        ancegla_1.play("start");
        ancegla_2.show();  
        ancegla_2.play("start");
        ancegla_3.show();   
        ancegla_3.play("start");
        butgame.add("ancegla_1");
        butgame.add("ancegla_2");
        butgame.add("ancegla_3"); 
        butgame.onmousemove;   
      }
      
      andiamond_1_TAKE	{.check_finished();	.item_gotocenter("krysztal_red_1");	}
    	andiamond_1_INPCK	{
    	   .addtopck("krysztal_red_1");
    	} 
      
      
      //-------------------------------------------------------------
     
      andiamond_2_TAKE	{.check_finished();	.item_gotocenter("krysztal_red_2");	}
    	andiamond_2_INPCK	{
    		 .addtopck("krysztal_red_2");
    	} 
      
      //-------------------------------------------------------------
     
      andiamond_3_TAKE	{.check_finished();	.item_gotocenter("krysztal_blue_1");	}
    	andiamond_3_INPCK	{
    		  .addtopck("krysztal_blue_1");
    	} 
      
      
      check_finished()
      { 
         if (clsave.bis("taken_krysztal_blue_1")  &&  clsave.bis("taken_krysztal_red_1") &&  clsave.bis("taken_krysztal_red_2"))
            .set_mg_finished(); 
      } 
      
      get_ancut()
      {
        for( int i=1; i<=6; i++)	{ 	
          if (<"ancut_"+i>.isin(mouse.getpos,1,1)&& <"ancut_"+i>.isvisible )
          {
            return i;   
          }
        }
        return -1; 
      }
      
      USE_sekator	{
        .advsetstdstate;   
        if( anbase.isin(mouse.getpos,1,0) )	{
          int index = .get_ancut();
          if (index >-1)
          {
            <"ancut_"+index>.hide();
            clsave.bset("e1_bn03pnacza_cuted_"+ index);
            if (.check_game_can_start()){
                .copyanima("anitem_sekator","fake_anitem_sekator");
                fake_anitem_sekator.play("cut");
                fake_anitem_sekator.anfadeout(300,null);
                .removefrompck("sekator"); 
                .start_game(); 
            }
            else
            {
               // tu ma zostac pod kursorem.
              //.item_gotopck;  
             anitem_sekator.play("cut");
             .advsetstate("getitem");
             guimov.setmoved("anitem_sekator"); 
              
            }      
          }
          else
            .item_gotopck;  
        }
        else
        {
           // .advsetstate("getitem");
           // guimov.mssetobj("anitem_sekator");
              .item_gotopck; 
        }    
      } 
      
       
      
      HINT_CLICK {
       
        for( int i=1; i<=6; i++)
        {
           if (!clsave.bis("e1_bn03pnacza_cuted_"+ i))
           {
              .showhint("ancut_"+i);
              return;
           }
        } 
        
        if (!clsave.bis("bn03pnacza_player_won"))
        {
          .showhint("anbase");
        }
        else
        {
            if (!clsave.bis("taken_krysztal_red_1"))
            {
              .showhint("andiamond_1");
              return;
            }
            
           if ( !clsave.bis("taken_krysztal_red_2"))
            {
              .showhint("andiamond_2");
              return;
            }
            
            if (!clsave.bis("taken_krysztal_blue_1"))
            {
              .showhint("andiamond_3");
              return;
            }
            .showhint("anpopexit"); 
        }
    }           
}
 


game mg04_glowa1 :Banshee {
	init{
    Banshee::init("mg04_glowa1");
      .newsnd("snd_brak_krysztalow", "kinnat_28a");
      snd_brak_krysztalow.addmethod("onfinish", "advsetstdstate");  
      
      .imgs = (A,"bkg.jpg ", "bkg.pyz 0", "wnetrze_czaszki.pyz 1", "baza.pyz 2",   "grom_normal_g.pyzH 4", "oko_l.pyz 5", "oko_p.pyz 6",  "czaszka_l.pyz 7", "czaszka_p.pyz 7", "ramka.pyz 8" , "grom_normal_l.pyzH 10", "grom_normal_p.pyzH 11", "grom_normal_d.pyzH 12", "krysztal.pyzH 13","krysztal_mask.pyzH 14","glowa1_element.pyzH 15", "popexit.pyz 50" );
      
      imgbkg {
  		.addmethod("isbutin", func { (@x, @y)
  			!anbkg.isin(x,y,0,0);
  			} );
  		.addmethod("butclick", func {
  			if( !.advstdstate ) return;
  			 .mend;
  			} );
    		butgame.add(this);
  	 };       
          
     	.butpopexit;
      .setasitemtopck("anglowa1_element");
        
      new vector crystal_states;
      crystal_states.type("string");
      crystal_states.beginadd("begin", "redblue", "empty", "blue", "red", "empty", "blue", "blue", "blue");
      
      new vector crystal_states_2;
      crystal_states_2.type("string");
      crystal_states_2.beginadd("begin", "red", "empty", "empty", "blue", "red", "red", "red"); 
     
      new int click_counter = -1;
     .init_crystals(); 
      
      if (clsave.bis("mg04_glowa1_saved")) 
       .load_ring();
      
    
    //flagi 
    
      
      // do testow
     /*   if (!clsave.bis("bn_04_glowa_1_krysztaly_dodane"))
      {
        .addtopck("krysztal_blue_1");
        .addtopck("krysztal_red_1");
        .addtopck("krysztal_red_2"); 
        .addtopck("krysztal_blue_2");
        clsave.bset("bn_04_glowa_1_krysztaly_dodane"); 
      }     
      */   
      if (clsave.bis("bn_04_glowa_1_lewe_oko_zamkniete"))
          anoko_l.hide();
      if (clsave.bis("bn_04_glowa_1_prawe_oko_zamkniete"))
          anoko_p.hide();
      if(clsave.bis("bn_04_glowa_1_czaszka_otwarta")&& !clsave.bis("taken_glowa1_element"))
      {
          angrom_normal_g.show(); 
          angrom_normal_d.show();
          anczaszka_l.show();
          anczaszka_l.setframe("opened", 0); 
          anczaszka_p.show();
          anczaszka_p.setframe("opened", 0);
          anglowa1_element.anfadein(500,null);
      }
      else
      {
          angrom_normal_g.hide(); 
          angrom_normal_d.hide();
      }
    
    
    // buttony 
    
    anoko_l {
			.Button_isin;
			.Button_moveonms;
			.Button_moveoffms;
			.addmethod("butclick", func {
		 	if( !.advstdstate  ) return;
		 	    if (clsave.bis("bn_04_glowa_1_lewe_oko_zamkniete")) return;
          
          .nokrystal_warning; 
          if (!clsave.bis("bn_04_glowa_1_kregi_rozwiazane"))
          { 
            .rotate_circle_1();  
          }
          else
          {
            anoko_l.play("push");
          }
              
			} );
      .addmethod("onfinish", func {
				.hide;
			  clsave.bset("bn_04_glowa_1_lewe_oko_zamkniete");
        if (clsave.bis("bn_04_glowa_1_prawe_oko_zamkniete") && !clsave.bis("bn_04_glowa_1_czaszka_otwarta")) 
        { 
            .open_skull();
        }        
			 } );
			 
			butgame.add(this);
		};
    
    anoko_p {
			.Button_isin;
			.Button_moveonms;
			.Button_moveoffms;
			.addmethod("butclick", func {
		 	if( !.advstdstate ) return;
		 	    if (clsave.bis("bn_04_glowa_1_prawe_oko_zamkniete")) return;
          
          .nokrystal_warning; 
          if (!clsave.bis("bn_04_glowa_1_kregi_rozwiazane"))
          { 
            .rotate_circle_2();  
          }
          else
          {
            anoko_p.play("push");
          }
      } );
      .addmethod("onfinish", func {
  			.hide; 
  		  clsave.bset("bn_04_glowa_1_prawe_oko_zamkniete"); 
        if (clsave.bis("bn_04_glowa_1_lewe_oko_zamkniete") && !clsave.bis("bn_04_glowa_1_czaszka_otwarta")) 
        { 
            .open_skull();
        }
		  } );
		 
		  butgame.add(this);
		}; 
    
     
    .stdstart;
	 
    
    
  } // koniec init
  
  nokrystal_warning()
  {
    click_counter++;
    if (.find_empty_slot > 0 && (click_counter == 0 || click_counter%6 == 0) && .advstdstate)
    {
      .cbplay("snd_brak_krysztalow");    
    }
  }

  //krysztaly  
  init_crystals{  
    .init_crystal("ankrysztal_0", 665, 278);
    .init_crystal("ankrysztal_1", 636, 348);
    .init_crystal("ankrysztal_2", 571, 376);
    .init_crystal("ankrysztal_3", 500, 347);
    .init_crystal("ankrysztal_4", 473, 279);
    .init_crystal("ankrysztal_5", 502, 212);
    .init_crystal("ankrysztal_6", 569, 184);
    .init_crystal("ankrysztal_7", 637, 210);
    
    .init_crystal("ankrysztal_8", 694, 212);
    .init_crystal("ankrysztal_9", 761, 186);
    .init_crystal("ankrysztal_10", 829, 212);
    .init_crystal("ankrysztal_11", 857, 282);
    .init_crystal("ankrysztal_12", 830, 351);
    .init_crystal("ankrysztal_13", 761, 377);
    .init_crystal("ankrysztal_14",695, 351);
    
    .update_crystals();
  }
  
  update_crystals(){
    for( int i=0; i<crystal_states.size; i++)	{ 
      string s = crystal_states.get(i);  
      <"ankrysztal_"+i>.play(s);
    } 
    for( int i=0; i<crystal_states_2.size; i++)	{ 
      string s = crystal_states_2.get(i);  
      int index = i + 8;
      <"ankrysztal_"+index>.play(s);
    }
     .check_rings();     
  }
  
  init_crystal(string name, int x, int y){
    .copyanima("ankrysztal", name);
    .copyanima("ankrysztal_mask", name+"_mask");
    <name>.setpos(x,y);
    <name>.play("empty");
    <name+"_mask">.setpos(x + 8,y +5);
    
  }
   
  // koniec krysztalow 
  
  // obracanie 
  rotate_circle_1(){
      string last = crystal_states.get(crystal_states.size-1);
      for(int i=crystal_states.size-1; i > 0; i--)	{ 
          crystal_states.set(i,crystal_states.get(i-1));  
      }
       crystal_states.set(0,last); 
      .update_crystals();
             
  } 
   rotate_circle_2(){
      string first = crystal_states.get(0);
      string last = crystal_states_2.get(crystal_states_2.size-1);
       
      for(int i=crystal_states_2.size-1; i > 0; i--)	{ 
          crystal_states_2.set(i,crystal_states_2.get(i -1));  
      }
      crystal_states.set(0,last);
      crystal_states_2.set(0,first);
       
      .update_crystals(); 
           
  } 
  
  check_rings(){
    if (clsave.bis("bn_04_glowa_1_kregi_rozwiazane")) return;
      for( int i=1; i<crystal_states.size; i++)	{ 
        if(!(crystal_states.get(i) == "red"))
        { 
          return;
        }
    }
     
    for( int i=0; i<crystal_states_2.size; i++)	{ 
      if( !(crystal_states_2.get(i) == "blue") )
      {
        return;
      }    
    }   
   sgmstate = "animacja_oczu";  
   angrom_normal_l.anfadein(1500,func{angrom_normal_l.anfadeout(1500,func{.advsetstdstate;});});
   angrom_normal_p.anfadein(1500,func{angrom_normal_p.anfadeout(1500,null);});
    clsave.bset("bn_04_glowa_1_kregi_rozwiazane");
  }
  
  open_skull()
  {
    anglowa1_element.anfadein(700,null); 
    angrom_normal_g.anfadein(700,null); 
    angrom_normal_d.anfadein(700,null); 
    anczaszka_l.play("open"); 
    anczaszka_p.play("open");
    clsave.bset("bn_04_glowa_1_czaszka_otwarta");
  } 
    
  USE_krysztal_blue_1	{
    .advsetstdstate();
		.click_on_empty("krysztal_blue_1", "blue");
  }
  
  USE_krysztal_blue_2	{
    .advsetstdstate();
		.click_on_empty("krysztal_blue_2", "blue");
  }
  
  USE_krysztal_red_1	{
    .advsetstdstate();
		.click_on_empty("krysztal_red_1", "red");
  }
  
  USE_krysztal_red_2	{
    .advsetstdstate();
		.click_on_empty("krysztal_red_2", "red");
  }
  
  click_on_empty(string item, string color)  {
      int index = -1;
      for( int i=0; i<15; i++)	{ 
          @name = "ankrysztal_"+i+"_mask";
          if (<name>.isin(mouse.getpos,0,1))
          {
            index = i;
          }
       }     
       
       if (index>-1)
       {
          if  (<"ankrysztal_"+index>.actionnr(-1)== 3 )
            .put_crystal(index,item, color);
          else 
              .item_gotopck;
      }
       else
       {
          .item_gotopck;
       }     
       
  }
  
  put_crystal(int index, string item, string color)
  {
    <"ankrysztal_"+index>.play(color);
    .removefrompck(item); 
    if (index < 8)
    {
        crystal_states.set(index,color);
    }
    else
    {
      crystal_states_2.set(index-8,color); 
    }
    
    .check_rings(); 
  }
  
  save_ring()
  {
     for( int i=0; i<15; i++)	{ 
      if (i < 8)
      { 
          clsave.set("ankrysztal_"+i,crystal_states.get(i)); 
      }
       else
       {
          clsave.set("ankrysztal_"+i,crystal_states_2.get(i-8));
       }
    }
    clsave.bset("mg04_glowa1_saved");     
  }
  load_ring()
  {
      for( int i=0; i<8; i++)	{ 
          crystal_states.set(i,clsave.get("ankrysztal_"+i));
      }
      crystal_states_2.set(0,clsave.get("ankrysztal_0"));
      for( int i=8; i<15; i++)	{ 
        crystal_states_2.set(i-8,clsave.get("ankrysztal_"+i));
      }   
      .update_crystals(); 
  }
  
  find_empty_slot()
  {
      int index = -1;
      for( int i=0; i<15; i++)	{ 
          if  (<"ankrysztal_"+i>.actionnr(-1)== 3 )
          {
            return i;
          }
       }     
      return -1; 
  }   
    
  mend	{
    .save_ring();  
    .stdexitdefadv("ad04_brzegjeziora", "gamead04_brzegjeziora0");
	}   
 
  anglowa1_element_TAKE {
      if( !.isvisible_itempopup("glowa1_element") ) {
          .show_itempopup("glowa1_element", "anglowa1_element");
          anglowa1_element.setframe("rotostart", 0); 
          .set_mg_finished;   
      } else {
          .hide_itempopup("glowa1_element");  
          .item_gotocenter;
          butgame.onmousemove;
           angrom_normal_g.anfadeout(700,null);
          angrom_normal_d.anfadeout(700,null);
          anczaszka_l.play("close"); 
          anczaszka_p.play("close"); 
        }
      }
       
    popup_glowa1_element_clickexit {
      .setactitem("anglowa1_element");
      butgame.sclicked = ("anglowa1_element");
      .anglowa1_element_TAKE;
     }
   anglowa1_element_INPCK {
    .addtopck("glowa1_element"); 
    .mend();
  } 

  
  HINT_CLICK {
      int empty_slot = .find_empty_slot();
      if (empty_slot > -1)
      {
        .showhint("ankrysztal_"+empty_slot+"_mask");
      }
      else
      {
          if (!clsave.bis("bn_04_glowa_1_lewe_oko_zamkniete"))
          { 
              .showhint("anoko_l");
              return;
          }
          else if (!clsave.bis("bn_04_glowa_1_prawe_oko_zamkniete"))
          { 
              .showhint("anoko_p");
              return;
          }
          
          if (!clsave.bis("taken_glowa1_element"))
          {
              .showhint("anglowa1_element");  
          }
          else
            .showhint("anpopexit"); 
          
          
      }
    } 
   
}
 


game mg04_glowa2 :Banshee {
	init{
    Banshee::init("mg04_glowa2");
    .newsnd("snd_brak_elementu", "kinnat_28b");
    snd_brak_elementu.addmethod("onfinish", "advsetstdstate"); 
     
    
    .imgs = (A,"bkg.jpg ", "bkg_game.pyz 1","base.pyz 2","diamenty.pyz 3", "wnetrze_czaszki.pyz 4","grom_normal_g.pyz 5", "oko.pyz 6","oko_l.pyz 7", "oko_p.pyz 8", "czaszka_l.pyz 9", "czaszka_p.pyz 10", "element.pyzH 11" ,"grom_normal_l.pyzH 12", "grom_normal_p.pyzH 13","grom_normal_d.pyzH 14", "ramka.pyz 18", "popexit.pyz 50" );
      .butpopexit;
     imgbkg {
  		.addmethod("isbutin", func { (@x, @y)
  			!anbkg_game.isin(x,y,0,0);
  			} );
  		.addmethod("butclick", func {
  			if( !.advstdstate ) return;
  			 .mend;
  			} );
    		butgame.add(this);
  	};       
     
      
    //     .addtopck("glowa1_element"); // do testow
      .setasitemtopck("anoko");
       anoko.disable = (true); 
       
       anelement{
        .Button_isinvis;
        .addmethod("butmoveon", func {
  				if( !.advstdstate) return;
  				  if (!clsave.bis("bn_04_glowa_2_element_on"))
              advmouse.set("use");   
            else
              advmouse.setstd;
            
  				} );
  			.addmethod("butmoveoff", func {
  				if( !.advstdstate ) return;
  				  advmouse.setstd;
  				} ); 
          butgame.add(this);
        };  
       
       
       //animacje
     
    //flagi  
      
      if (clsave.bis("bn_04_glowa_2_element_on"))
      {
         anelement.show(); 
      }
      
      if (clsave.bis("bn_04_glowa_2_lewe_oko_zamkniete"))
          anoko_l.hide();
      if (clsave.bis("bn_04_glowa_2_prawe_oko_zamkniete"))
          anoko_p.hide();
          
      if(clsave.bis("bn_04_glowa2_czaszka_otwarta")&& !clsave.bis("taken_oko"))
      {
          angrom_normal_d.show();
          anczaszka_l.show();
          anczaszka_l.play("opened"); 
          anczaszka_p.show();
          anczaszka_p.play("opened");
          angrom_normal_g.show();
           
			    anoko.disable = (false); 
          
      }
      else
      {
          angrom_normal_g.hide(); 
          angrom_normal_d.hide();
          
      }
    
    // buttony 
    anoko_l {
			.Button_isin;
			.Button_moveonms;
			.Button_moveoffms;
			.addmethod("butclick", func {
		 	    if( !.advstdstate  ) return;
		 	    if (clsave.bis("bn_04_glowa_2_element_on") && !clsave.bis("bn_04_glowa_2_lewe_oko_zamkniete") )
          { 
            anoko_l.play("push");
            clsave.bset("bn_04_glowa_2_lewe_oko_zamkniete");
          }
          else  
          {
            .cbplay("snd_brak_elementu");
          }
             
      } );
      .addmethod("onfinish", func {
				.hide;
			  
        if (clsave.bis("bn_04_glowa_2_prawe_oko_zamkniete") && !clsave.bis("bn_04_glowa_2_czaszka_otwarta")) 
        { 
            .open_skull();
        }        
			 } );
			 
			butgame.add(this);
		};
    
    anoko_p {
			.Button_isin;
			.Button_moveonms;
			.Button_moveoffms;
			.addmethod("butclick", func {
		 	if( !.advstdstate ) return;
		 	    if (clsave.bis("bn_04_glowa_2_element_on") &&!clsave.bis("bn_04_glowa_2_prawe_oko_zamkniete")) 
          { 
            clsave.bset("bn_04_glowa_2_prawe_oko_zamkniete");
            anoko_p.play("push");
          } 
          else 
          {
            .cbplay("snd_brak_elementu");
          }
           
              
			} );
        .addmethod("onfinish", func {
				.hide; 
			   
        if (clsave.bis("bn_04_glowa_2_lewe_oko_zamkniete") && !clsave.bis("bn_04_glowa_2_czaszka_otwarta")) 
        { 
            .open_skull();
        }
			 } );
			 
			butgame.add(this);
		};
   
    .stdstart;
  } //koniec init 
  
  open_skull()
  {
    angrom_normal_g.anfadein(800,null);
    anoko.anfadein(300,null);;
    anczaszka_l.play("open"); 
    anczaszka_p.play("open");
    angrom_normal_d.anfadein(800,null);
    anoko.disable = (false);
    clsave.bset("bn_04_glowa_2_czaszka_otwarta");
  } 
  
  mend	{
    .stdexitdefadv("ad04_brzegjeziora", "gamead04_brzegjeziora0");
	}
  
  anoko_TAKE {
      if( !.isvisible_itempopup("oko") ) {
        anoko.setframe("rotostart", 0);
        .show_itempopup("oko", "anoko");
        .set_mg_finished;  
      } else {
        .hide_itempopup("oko");
        anczaszka_l.play("close"); 
        anczaszka_p.play("close");
        angrom_normal_g.anfadeout(800,null);
        angrom_normal_d.anfadeout(800,null);   
        .item_gotocenter;
        butgame.onmousemove;
      }
    }
       
    popup_oko_clickexit {
      .setactitem("oko");
      butgame.sclicked = ("anoko");
      .anoko_TAKE;
     }
    anoko_INPCK {
      .addtopck("oko");
      .mend();
    } 
  
   
  USE_glowa1_element	{
		.advsetstdstate();
    if(anbase.isin(mouse.getpos,1,1) )	{
			sgmstate = "animacja_oczu"; 
      .removefrompck("glowa1_element");
		  anelement.anfadein(500,null);  
      angrom_normal_l.anfadein(1500,func{angrom_normal_l.anfadeout(1500,func{.advsetstdstate;});});
      angrom_normal_p.anfadein(1500,func{angrom_normal_p.anfadeout(1500,null);});
      clsave.bset("bn_04_glowa_2_element_on"); 
		} else {
			.advsetstdstate;
			.item_gotopck;
		}
	} 
  HINT_CLICK {
       
      if (!clsave.bis("bn_04_glowa_2_element_on"))
      {
        .showhint("anelement");
      }
      else
      {
          if (!clsave.bis("bn_04_glowa_2_lewe_oko_zamkniete"))
          { 
              .showhint("anoko_l");
              return;
          }
          else if (!clsave.bis("bn_04_glowa_2_prawe_oko_zamkniete"))
          { 
              .showhint("anoko_p");
              return;
          }
          
          if (!clsave.bis("taken_oko"))
          {
              .showhint("anoko");  
          }
          else
            .showhint("anpopexit"); 
      }
    } 
}
 

game mg04_glowa3 :Banshee {
	init{
    Banshee::init("mg04_glowa3");
        .newsnd("snd_brak_oka", "kinnat_28c");
        snd_brak_oka.addmethod("onfinish", "advsetstdstate"); 
       
       .imgs = (A,"bkg.jpg","bkg_game.pyz 1","wnetrze_czaszki.pyz 2", "baza.pyz 3","oko_l.pyz 4","oko_p.pyzH 4","szczeka_break.pyz 5", "grom_normal_d.pyzH 6","grom_normal_g.pyzH 6", "grom_normal_p.pyzH 7", "grom_normal_l.pyzH 8","lopatka.pyzH 9", "czaszka_l.pyz  10","czaszka_p.pyz 11", "krysztaly.pyz 12", "ramka.pyz 18", "popexit.pyz 20" );
     .butpopexit;
     //  .addtopck("oko"); // do testow
      .setasitemtopck("anlopatka");
    imgbkg {
  		.addmethod("isbutin", func { (@x, @y)
  			!anbkg_game.isin(x,y,0,0);
  			} );
  		.addmethod("butclick", func {
  			if( !.advstdstate ) return;
  			 .mend;
  			} );
    		butgame.add(this);
  	};       
      
     
      //flagi    
      if(clsave.bis("bn_04_glowa3_czaszka_otwarta")&& !clsave.bis("taken_lopatka"))
      {
          angrom_normal_d.show();
          anczaszka_l.show();
          anczaszka_l.play("opened"); 
          anczaszka_p.show();
          anczaszka_p.play("opened");
          angrom_normal_g.show();
          anlopatka.show();
      }
      else
      {
          angrom_normal_g.hide(); 
          angrom_normal_d.hide();
      }  
      
      if (clsave.bis("bn_04_glowa_3_oko_on") && !clsave.bis("bn_04_glowa_3_prawe_oko_zamkniete")){
        anoko_p.show();
      }        
      else
      {       
        anoko_p.hide();
      } 
      
      if ( clsave.bis("bn_04_glowa_3_lewe_oko_zamkniete")){
        anoko_l.hide();
      }  
      
      if (clsave.bis("bn_04_glowa3_szczeka_faza")) 
      {
          int faza =  clsave.get("bn_04_glowa3_szczeka_faza");
          anszczeka_break.play("faza"+ faza); 
      }      
      
                   
      // buttony 
      anoko_l {
  			.Button_isin;
  			.Button_moveonms;
  			.Button_moveoffms;
  			.addmethod("butclick", func {
  		 	    if( !.advstdstate  ) return;
  		 	    if (clsave.bis("bn_04_glowa_3_oko_on") && !clsave.bis("bn_04_glowa_3_lewe_oko_zamkniete") )
            { 
              anoko_l.play("push");
              clsave.bset("bn_04_glowa_3_lewe_oko_zamkniete");
            }
            else
            {
              .cbplay("snd_brak_oka");
            }
               
        } );
        .addmethod("onfinish", func {
  				.hide;
  			  
          if (clsave.bis("bn_04_glowa_3_prawe_oko_zamkniete") && !clsave.bis("bn_04_glowa_3_czaszka_otwarta")) 
          { 
              .open_skull();
          }        
  			 } );
  			 butgame.add(this);
		};
    
    anoko_p {
			.Button_isinvis;
		 .addmethod("butmoveon", func {
				if( !.advstdstate) return;
				  if (!clsave.bis("bn_04_glowa_3_oko_on"))
            advmouse.set("use");   
          else
            if (!clsave.bis("bn_04_glowa_3_prawe_oko_zamkniete"))
              advmouse.set("take"); 
            else
              advmouse.setstd;
          
				} );
			.addmethod("butmoveoff", func {
				if( !.advstdstate ) return;
				  advmouse.setstd;
				} ); 
			.addmethod("butclick", func {
		 	if( !.advstdstate ) return;
		 	    if ( !clsave.bis("bn_04_glowa_3_prawe_oko_zamkniete")) 
          { 
            clsave.bset("bn_04_glowa_3_prawe_oko_zamkniete");
            anoko_p.play("push");
          }  
              
			} );
        .addmethod("onfinish", func {
				.hide; 
			   
        if (clsave.bis("bn_04_glowa_3_lewe_oko_zamkniete") && !clsave.bis("bn_04_glowa_3_czaszka_otwarta")) 
        { 
            .open_skull();
        }
			 } );
			 
			butgame.add(this);
		};
    
    anszczeka_break{
      .Button_isin;
			.Button_moveonms;
			.Button_moveoffms;
      .addmethod("butclick", func {
		 	      if( !.advstdstate ) return;
		 	     //if (clsave.bis("bn_04_glowa3_szczeka_urwana")) return;
            
            int faza;
            if (clsave.bis("bn_04_glowa3_szczeka_faza")) 
            {
                faza =  clsave.get("bn_04_glowa3_szczeka_faza");
            }
            else
            {
              faza = 1;
            }
              
            if (!clsave.bis("bn_04_glowa3_szczeka_urwana") )
             {  
              faza = faza +1;
               if (faza >2)
                {
                  clsave.bset("bn_04_glowa3_szczeka_urwana"); 
                  faza = 3; 
                  butgame.removebut(this); 
                  advmouse.setstd;  
                }
                anszczeka_break.play("break"+ faza);  
                clsave.set("bn_04_glowa3_szczeka_faza",faza); 
                 
            }
      } );
      .addmethod("onfinish", func {
			if (clsave.bis("bn_04_glowa3_szczeka_faza")) 
        {
          int faza =  clsave.get("bn_04_glowa3_szczeka_faza");
          anszczeka_break.play("faza"+ faza); 
            
        }
      } );  
      if (!clsave.bis("bn_04_glowa3_szczeka_urwana")) 
        butgame.add(this);  
    };
    
           
      .stdstart;
  }// koniec init
  open_skull()
  {
    angrom_normal_g.anfadein(500,null);  
    anlopatka.show();  
   // anlopatka.disable = (false); 
    anczaszka_l.play("open"); 
    anczaszka_p.play("open");
    angrom_normal_d.anfadein(800,null); 
    clsave.bset("bn_04_glowa3_czaszka_otwarta");
  } 
  mend	{
    .stdexitdefadv("ad04_brzegjeziora", "gamead04_brzegjeziora0");
	} 
  USE_oko	{
		.advsetstdstate();
    if(anoko_p.isin(mouse.getpos,0,0) )	{
			.removefrompck("oko");
		  anoko_p.show();
      sgmstate = "animacja_oczu"; 
      angrom_normal_l.anfadein(1500,func{angrom_normal_l.anfadeout(1500,func{.advsetstdstate;});});
      angrom_normal_p.anfadein(1500,func{angrom_normal_p.anfadeout(1500,null);});
      clsave.bset("bn_04_glowa_3_oko_on"); 
      advmouse.set("take"); 
		} else {
			.advsetstdstate;
			.item_gotopck;
		}
	}
  anlopatka_TAKE {
        if (!clsave.bis("bn_04_glowa3_szczeka_urwana")) 
        { 
          anczaszka_l.play("closeopen"); 
          anczaszka_p.play("closeopen");
          anszczeka_break.play("smile");
          return;
        }
        
        if( !.isvisible_itempopup("lopatka") ) {
         .show_itempopup("lopatka", "anlopatka");
         .set_mg_finished; 
         anlopatka.play("rotostart");   
        } else {
          .hide_itempopup("lopatka"); 
          anczaszka_l.play("close"); 
          anczaszka_p.play("close");
          angrom_normal_d.anfadeout(800,null); 
          .item_gotocenter;
          butgame.onmousemove;
        }
        
       }
       
    popup_lopatka_clickexit {
      .setactitem("lopatka");
      butgame.sclicked = ("anlopatka");
      .anlopatka_TAKE;
     }
    anlopatka_INPCK {
   /*   if (clsave.bis("taken_puszka"))
      { 
        .removefrompck("puszka");
	.removefrompck("lopatka");
        .addtopck("puszka_lopatka");
      }
      else
      { */
        .addtopck("lopatka");
   //   }
      .mend();   
    } 
     
   
  
  HINT_CLICK {
       
      if (!clsave.bis("bn_04_glowa_3_oko_on"))
      {
        .showhint("anoko_p");
      }
      else
      {
          if (!clsave.bis("bn_04_glowa_3_lewe_oko_zamkniete"))
          { 
              .showhint("anoko_l");
              return;
          }
          else if (!clsave.bis("bn_04_glowa_3_prawe_oko_zamkniete"))
          { 
              .showhint("anoko_p");
              return;
          }
          if (!clsave.bis("bn_04_glowa3_szczeka_urwana"))
          {
              .showhint("anszczeka_break"); 
              return; 
          }
          
          if (!clsave.bis("taken_lopatka"))
          {
              .showhint("anlopatka");  
          }
          else
            .showhint("anpopexit"); 
          
          
      }
    }          
}
 

game mg04_tarcza :Banshee {
	 
  init{
    Banshee::init("mg04_tarcza");
    .imgs = (A, "bkg.jpg 0", "base.pyz 1", "kopanie_obszar.pyzH 2", "tarcza.pyz 3", "robaki.pyz 4","kopanie.pyzH 5", "puszka_robakiH.pyz 6", "maska.pyz 7", "ramka.pyz 8", "popexit.pyz 9");
    
    imgbkg {
  		.addmethod("isbutin", func { (@x, @y)
  			!anbase.isin(x,y,0,0);
  			} );
  		.addmethod("butclick", func {
  			if( !.advstdstate ) return;
  			 .mend;
  			} );
    		butgame.add(this);
  	 };      
      
     .butpopexit; 
  /*  if (!clsave.bis("e1_puszka_lopatka_dodana"))
    {
        .addtopck("puszka"); 
        .addtopck("lopatka");  
         clsave.bset("e1_puszka_lopatka_dodana");
    }  */  
        
    // buttony 
     .setasitemtopck("antarcza");
      antarcza.disable = (true);
      anpuszka_robaki.anopacityframe;  
      
     .setasitemtopck("anpuszka_robaki");
      anpuszka_robaki.disable = (true); 
     
    //animacje
      new int ilicz = 0;
   
     
     ankopanie{
       .addmethod("onfinish", func {
  			  .move(30,0); 
          ilicz = 0;
          antarcza.disable = (false);  
          .anfadeout(300, null);
          ankopanie_obszar.butmoveon;
          
        } );
        .addmethod("onendframe", func {
  				ilicz++;
    			if(ilicz == 15 || ilicz == 28) 
          { 
            .move(-10,0);
          }
        } );
    };    
   
    //flagi 
    if(clsave.bis("e1_robaki_wykopane")){
        if (!clsave.bis("taken_puszka_robaki")){
          anpuszka_robaki.disable = (false); 
          anpuszka_robaki.show();
        }
      }
     if(clsave.bis("e1_tarcza_wykopana"))
     { 
       if(clsave.bis("taken_tarcza") )
   			  antarcza.hide;
   		 else
          antarcza.disable = (false);  
      }
    
    if(clsave.bis("e1_robaki_wykopane")){ 
      if(!clsave.bis("e1_tarcza_wykopana"))
   	 		   anrobaki.play(3);
   	 	 else
           anrobaki.play(4);
    }      
     
    .stdstart;
    .newsnd("snd_init", "kinnat_28d");
    snd_init.addmethod("onfinish", "advsetstdstate"); 
    
    .newsnd("snd_robaki", "kinnat_28e");
    snd_robaki.addmethod("onfinish", "advsetstdstate"); 
  
    if (!clsave.bis("e1_tarcza_wykopana"))
    {    
      ankopanie_obszar{
        .Button_isinvis;
        .addmethod("butmoveon", func {
      			if( !.advstdstate) return;
      			  if (!clsave.bis("e1_tarcza_wykopana"))
                advmouse.set("use");
              else
                 advmouse.setstd;
            } );
      	 .addmethod("butmoveoff", func {
      			if( !.advstdstate ) return;
      			  advmouse.setstd;
      			} );
            butgame.add(this); 
      };
       
       
    }
    if(!clsave.bis("e1_robaki_snd_intro_done")){  
      .timplay("timeintro", 1000, func {
			  .cbplay("snd_init"); 
        clsave.bset("e1_robaki_snd_intro_done");
			} );
    }  
     
    } // koniec init
   
  mend	{
    .stdexitdefadv("ad04_brzegjeziora", "gamead04_brzegjeziora0"); 
	}
  
  USE_puszka	{
     if( ankopanie_obszar.isin(mouse.getpos,0,0) )	{
      .advsetstdstate;
      advmouse.setstd;
      .removefrompck("puszka");
      clsave.bset("e1_robaki_wykopane");
      anrobaki.play(1); 
      anpuszka_robaki.disable = (false);  
      anpuszka_robaki.anfadein(200,null);
    
      } 
    else .item_gotopck;   
	}  
  
  USE_lopatka	{
		.advsetstdstate;
     advmouse.setstd;
    if( ankopanie_obszar.isin(mouse.getpos,0,0) )	{
			 if (clsave.bis("e1_robaki_wykopane"))
       { 
          .removefrompck("lopatka");
          clsave.bset("e1_tarcza_wykopana");
          advmouse.setstd;
          ankopanie.play(0);
          anrobaki.play(2);                  
           
      }
      else .item_gotopck;   
    } 
    else .item_gotopck;   
	}
  
  anpuszka_robaki_TAKE {
      .popitem_gotocenter("puszka_robaki");
         
  }
  anpuszka_robaki_INPCK {
    .addtopck("puszka_robaki"); 
     
  }   
  
 
  antarcza_TAKE {
    antarcza.setframe("rotostart",0);
    .popitem_gotocenter("tarcza");
    .set_mg_finished;   
  }
  antarcza_INPCK {
      .addtopck("tarcza"); 
      if (clsave.bis("taken_puszka_robaki") )
        .mend();
  }
   
  HINT_CLICK {
     
    if (!clsave.bis("taken_tarcza"))
    {     
        if (clsave.bis("e1_robaki_wykopane") && !clsave.bis("taken_puszka_robaki"))
          .showhint("anpuszka_robaki"); 
        else if (clsave.bis("ma_puszka"))
        { 
          .showhint("anrobaki");
          .showhintitem("puszka");
        }
        else if (clsave.bis("ma_lopatka") && clsave.bis("e1_robaki_wykopane") )
        { 
          .showhint("anrobaki");
          .showhintitem("lopatka"); 
        }
        else if (clsave.bis("e1_tarcza_wykopana"))
          .showhint("antarcza");
        else
          .showhint("anpopexit");
    }         
    else
     {
        .showhint("anpopexit");
     }
      
   }   
}
 


game mg04_lodz :Banshee {
	init{
    Banshee::init("mg04_lodz");
    .imgs = (A, "$scripts/mg04_glowa1/bkg.jpg 1", "base.pyz 2", "krysztal_blue.pyzH 3", "medalion.pyzH 4",  "ramka.pyz 5", "popexit.pyz 6", 
	"medalion_wlozony.pyzH 7",  "kruk_idle.pyzH 8", "flight.pyzH 9", "medalion_w_dziobie.pyzH 10" );
    .butpopexit; 
    if (!clsave.bis("e1_kruk_odlecial"))	{
      ankruk_idle.play("loop");   
      .newsndfree("sndkrukodlecial", "kinnat_28");
      sndkrukodlecial.addmethod("onfinish", func{.advsetstdstate; <GAME>.show_objective("OB4");} );
     }
                                                             
  //  .addtopck("kluczlodz"); 
    
    if (!clsave.bis("taken_krysztal_blue_2"))
    { 
      ankrysztal_blue.show;
      .setasitemtopck("ankrysztal_blue");  
      if (!clsave.bis("e1_kruk_odlecial"))
        ankrysztal_blue.disable = (true); 
      else
         ankrysztal_blue.disable = (false); 
    }  
    
    
    ankruk_idle {
			.Button_isin; 
			.Button_moveonms;
			.Button_moveoffms;
			.addmethod("butclick", func {
			if( !.advstdstate || clsave.bis("e1_kruk_odlecial")) return;
				  .hide();
          clsave.bset("e1_kruk_odlecial");
          ankruk_idle.stop(false);
          anflight.play(0);
          sgmstate = "state_kruk_odlatuje";
          ankrysztal_blue.disable = (false); 
      } );
			 
			butgame.add(this);
		};
    
    anflight {
      .addmethod("onfinish", func {
			  .hide(); 
			  .cbplay("sndkrukodlecial");
          
      //  .mend();   
				} );
		};   
    
	.newsndfree("sndlocked", "kinnat_56");
	//anmedalion_wlozony.Button_stdms;
   anmedalion_wlozony.addmethod("butmoveon", func {
    			if( !.advstdstate) return;
    			  if (!clsave.bis("e1_lodz_odblokowana") )
              advmouse.set("use");
            else
              advmouse.setstd;
          } );
  anmedalion_wlozony.addmethod("butmoveoff", func {
    			if( !.advstdstate ) return;
    			  advmouse.setstd;
    			} );
           
	anmedalion_wlozony.addmethod("isbutin", func { (@x, @y) .isin(x,y,0,0); } );
	anmedalion_wlozony.addmethod("butclick", func { 
		if( .advstdstate && !clsave.bis("e1_lodz_odblokowana") )
			.crplay("sndlocked");
		} );
	butgame.add("anmedalion_wlozony");
	
    if( clsave.is("GAME_sgmlastscene", "gamead04b_lodz0") )	{
	.advsetstdstate;
    } else {
	ccs.enter( func {
		if( !clsave.bis("e1_lodz_1st_click") )	{
			clsave.bset("e1_lodz_1st_click");
			
			sndlocked.addmethod("onfinish", func {
				.gotoadv("ad04b_lodz", "gamead04b_lodz0");
				} );
			.cbplay("sndlocked");
		} else	{
			anbase.addmethod("onfinish", func {
				.stdexitdefadv("ad05_lodz", "gamead05_lodz0"); 
				} );
			.advsetstdstate;
		}
		} );
	}
    } // koniec init
    
  ankrysztal_blue_TAKE	{.check_finished();	.item_gotocenter("krysztal_blue_2");	}
	ankrysztal_blue_INPCK	{
		  .addtopck("krysztal_blue_2");
      .mend;
	} 
   
  mend	{
    .stdexitdefadv("ad04_brzegjeziora", "gamead04_brzegjeziora0"); 
	}
  
  HINT_CLICK {
    if (!clsave.bis("e1_kruk_odlecial"))
      {
        .showhint("ankruk_idle");
        return; 
      }
      .showhint("anpopexit"); 
  }            
	USE_kluczlodz	{
		if( anmedalion_wlozony.isin(mouse.getpos,0,0) )	{
			clsave.bset("e1_lodz_odblokowana");
			butgame.removebut("anmedalion_wlozony");
			butgame.onmousemove;
			.removefrompck("kluczlodz");
			sgmstate = "state_openlodz";
			anbase.playsmooth("open");
			anmedalion_wlozony.playsmooth("open");
		} else {
			.advsetstdstate;
			.item_gotopck;
		}
	}
}
 

game ho09intro :Banshee {
	init{
    Banshee::init("ho09_intro");
    .imgs = (A,"bkg.pyz 1","robak1.pyzH 2","robak2.pyzH 3","robak3.pyzH 4","robak4.pyzH 5", "robak5.pyzH 6", "robak6.pyzH 7", "robak7.pyz 8", "idle.pyz 9", "fight.pyzH 10", "flight.pyzH 11","swiatlo.pyz 12");
    anidle.play("loop");
 //    .addtopck("puszka_robaki");
    answiatlo.anopacityframe;
	 answiatlo.play("new");
    anbkg {
			.Button_isin; 
			.addmethod("butmoveon", func {
				if( !.advstdstate) return;
				  if (!clsave.bis("e1_robaki_zjedzone"))
            advmouse.set("use"); 
          else
             advmouse.setstd;  
      } );
			.addmethod("butmoveoff", func {
				if( !.advstdstate ) return;
				  advmouse.setstd;
				} );  
			.addmethod("butclick", func {
			if( !.advstdstate ) return;
				if (anfight.isvisible || clsave.bis("e1_robaki_zjedzone")) return;
          anidle.hide();
          anidle.stop(false);
          anfight.play(0);
      } );
			 
			butgame.add(this);
		}; 
    
    anfight {
      .addmethod("onfinish", func {
			  .hide(); 
        if (!clsave.bis("e1_robaki_zjedzone"))
          anidle.play(0);
				} );
		};  
    
    anflight {
    .addmethod("onfinish", func {
			  .mend;
				} );
        
     .addmethod("onendframe", func {
        int id = .framenr;
        int numfr = .nofframes(-1); 
        if (id == 35)
          anrobak1.hide();
        if (id == 55)
          anrobak2.hide(); 
        if (id == 72)
          anrobak3.hide(); 
        if (id == 82)
          anrobak4.hide();
        if (id == 94)
          anrobak5.hide();
        if (id == 110)
          anrobak6.hide(); 
        if (id == 125)
          anrobak7.hide();     
      
		});  
    
		}; 
    
    new ImgRect recexit {
      .Button_isin;
      .Button_moveoffms;
      .addmethod("butmoveon", func { advmouse.set("godd"); });
      .setrect( 0, 0.8 * igmapph, igmappw, igmapph );
      .setz(300); 
       butgame.add(this);
      .addmethod("butclick", func {
  			if( !.advstdstate ) return;
  				   .stdexitdefadv("ad04_brzegjeziora", "gamead04_brzegjeziora0");  
        });
    }; 
    
    advmouse.set("use");
    .stdstart;  
  }  
  
  USE_puszka_robaki	{
		.advsetstdstate();
     clsave.bset("e1_HO09_Brzegjeziora_after_intro");
    if(anbkg.isin(mouse.getpos,1,1) )	{
      if (anfight.isvisible) 
      { 
          .advsetstdstate;
			    .item_gotopck;
          return;
      }
			.removefrompck("puszka_robaki");
		  clsave.bset("e1_robaki_zjedzone"); 
      anidle.hide();
      anidle.stop(false);
      anflight.play(0);
      for (int i = 1;i<8;i++)
          <"anrobak"+i>.anfadein(100 *i,null); 
    } else {
			.advsetstdstate;
			.item_gotopck;
		}
	}     
  mend	{
     .stdexit("HO09_Brzegjeziora");  
	} 
  
  HINT_CLICK {
    if (!clsave.bis("e1_HO09_Brzegjeziora_after_intro"))
    {
      .showhint("anidle");
      return; 
    }
      .showhint("recexit"); 
  }       
  
   
}
 


game mg06krople :Banshee {
	init{
    Banshee::init("mg06_krople");
    .imgs = (A,"bkg.jpg 1", "podklad.pyz 2", "tor_4.pyz 3", "tor_3.pyz 5","tor_2.pyz 6","tor_1.pyz 7", "tor1_btn.pyz 8", "tor2_btn.pyz 9" , "tor3_btn.pyz 10" , "tor4_btn.pyz 11", "final_glow.pyzH 12" , "ramka.pyz 13" , "popexit.pyz 14");
    .butpopexit; 
    anfinal_glow.setdrawmode(1);
    new vector right_sequence; 
    new bool good_sequence =  false;
    right_sequence.beginadd("begin",0,2200,1050,1975);

    new vector sequence; 
    .timer = ("tim1", right_sequence.get(0), func { antor_1.play(0);antor1_btn.hide();} ); 
    .timer = ("tim2",  right_sequence.get(1),func { antor_2.play(0);antor2_btn.hide();} ); 
    .timer = ("tim3",  right_sequence.get(2), func { antor_3.play(0);antor3_btn.hide();}); 
    .timer = ("tim4",  right_sequence.get(3), func { antor_4.play(0);antor4_btn.hide();} ); 
  
		anpodklad {
  		.Button_isinalpha;
  		butgame.add(this);
  	}; 
     imgbkg {
  		.Button_isinalpha;
  		.addmethod("butclick", func {
  			if( !.advstdstate ) return;
  			.mend;
  			} );
    		butgame.add(this);
    	};       
     
    
    antor1_btn {
			.Button_isinalpha;
		  .vars2(A, "selected", false);
			.addmethod("butmoveon", func {
			 advmouse.setbut; 
				.setframe(-1,1);
				} );
			.addmethod("butmoveoff", func {
				advmouse.setstd;
        if (selected)
				  .setframe(-1,2);
        else
          .setframe(-1,0); 
				} );
			.addmethod("butclick", func {
				if( !.advstdstate || good_sequence) return;
				  if (!selected)
          { 
            selected = true;
            .setframe(-1,2);
            .add_to_sequence(1);
          }
          .play_all_selected();
				} );
			butgame.add(this);
		};
    
    antor2_btn {
			.Button_isinalpha;
		  .vars2(A, "selected", false);
			.addmethod("butmoveon", func {
			 advmouse.setbut; 
				.setframe(-1,1);
				} );
			.addmethod("butmoveoff", func {
				advmouse.setstd;
        if (selected)
				  .setframe(-1,2);
        else
          .setframe(-1,0); 
				} );
			.addmethod("butclick", func {
				if( !.advstdstate || good_sequence) return;
				  if (!selected)
          { 
            selected = true;
            .setframe(-1,2);
            .add_to_sequence(4);
          }
          .play_all_selected();
				} );
			butgame.add(this);
		};
    
    antor3_btn {
			.Button_isinalpha;
		  .vars2(A, "selected", false);
			.addmethod("butmoveon", func {
			 advmouse.setbut; 
				.setframe(-1,1);
				} );
			.addmethod("butmoveoff", func {
				advmouse.setstd;
        if (selected)
				  .setframe(-1,2);
        else
          .setframe(-1,0); 
				} );
			.addmethod("butclick", func {
				if( !.advstdstate || good_sequence) return;
				  if (!selected)
          { 
            selected = true;
            .setframe(-1,2);
            .add_to_sequence(2);
          }
          .play_all_selected();
				} );
			butgame.add(this);
		};
    
    antor4_btn {
			.Button_isinalpha;
		  .vars2(A, "selected", false);
			.addmethod("butmoveon", func {
			 advmouse.setbut; 
				.setframe(-1,1);
				} );
			.addmethod("butmoveoff", func {
				advmouse.setstd;
        if (selected)
				  .setframe(-1,2);
        else
          .setframe(-1,0); 
				} );
			.addmethod("butclick", func {
				if( !.advstdstate || good_sequence) return;
				  if (!selected)
          { 
            selected = true;
            .setframe(-1,2);
            .add_to_sequence(3);
          }
          .play_all_selected();
				} );
			butgame.add(this);
		};
	  antor_1{ 
      .addmethod("onfinish", func {
    			 .setframe(-1,0);
           antor1_btn.show(); antor1_btn.setframe(-1,0);
  		  } );
    };
    antor_2{ 
      .addmethod("onfinish", func {
    			 .setframe(-1,0);
           antor2_btn.show(); antor2_btn.setframe(-1,0);
  		  } );
    };
    antor_3{ 
      .addmethod("onfinish", func {
    			 .setframe(-1,0);
           antor3_btn.show(); antor3_btn.setframe(-1,0);
  		  } );
    };
    antor_4{ 
      .addmethod("onfinish", func {
    			 .setframe(-1,0);
           antor4_btn.show(); antor4_btn.setframe(-1,0);
  		  } );
    };
    .stdstart;
  } // koniec init   
      
  mend	{
     .stdexitdefadv("ad06_posagmamy", "gamead06_posagmamy0");  
  } 
  
  play_all_selected {
      if (antor1_btn.selected && antor2_btn.selected && antor3_btn.selected && antor4_btn.selected )
      {
        good_sequence = true;
        for( int i=1; i<=4; i++)
        {
           if (!(i-1 == sequence.get(i-1)) )
             good_sequence = false;    
          
          <"antor"+i+"_btn">.selected = (false);
          <"antor"+i+"_btn">.setframe(-1,0);
          int sequence_pos = sequence.get(i-1); 
          int delay = right_sequence.get(sequence_pos);
          @s = "tim" + i;
          <s>.delay(delay);
          <s>.play();
        }
          
        if (good_sequence)
        {
          .timer = ("timfinish", 4000, func { anfinal_glow.anfadein(500,func{
		clsave.bset("e1_krople_rozwiazane"); 
		/*open_popup*/
    anfinal_glow.hide();
		mouse.hide;
		engine.redrawnoblit;
		clsave.set("e1_mg06_krople_adv",0);
    .set_mg_finished(); 
		.stdexit("mg06_huby");
		mouse.show;
		}); 
		}); 
	sgmstate = "state_finish";
          timfinish.play();
        }
        sequence.free();   
      }
       
	} 
  
  add_to_sequence(int i)
  {
    sequence.add(i-1);
  }
  HINT_CLICK {
    if (!clsave.bis("e1_krople_rozwiazane"))
    {
      int i = 4->rand + 1;
      .showhint("antor"+i+"_btn");
      return; 
    }
    if (!clsave.bis("taken_sekator"))
    { 
        .showhint("anpopexit"); 
    }
  }     
   
}
 


game mg06_huby :Banshee {
	init{
    Banshee::init("mg06_huby");
	
	.img = ("popexit.pyz 7");
	if( clsave.bis("e1_mg06_krople_adv") )	{
		.img = ("bkg.jpg 1");
	} else {
		new img imgbkg;
		ccs.cloneto("imgbkg");
		imgbkg.setz(1);
		imgbkg.transparency(255);
		imgbkg.show;
	}

    .butpopexit; 
       
       .load_mg(null);
    .setasitemtopck("ansekator");   
	
    
    anwypalanie.addmethod("onfinish", func {
      clsave.bset("e1_huby_wypalone");
      .hide();
      anwypalone.show();
      ansekator.show();
          
    });    
    .stdstart;
  } // koniec init 
	load_mg(string simg)	{
	.switch_path("scripts/mg06_huby/");
	.imgs = (A, "przed_wypaleniem.pyz 2",  "wypalanie.pyzH 3","wypalone.pyzH 4", "sekator.pyzH 5", "ramka.pyz 6");
	if( simg!=null)	{
		<gameapi.getgamename>.varnew("img", simg);
		<simg>.clone("anprzed_wypaleniem");
		anprzed_wypaleniem.hide;
		anramka.hide;
	}
	
    if (clsave.bis("taken_sekator"))
    {
      //ansekator.hide();
      
    } else {
	ansekator.show;
	if( simg!=null ) {
		<simg>.blit("ansekator");
		ansekator.hide;
	}
	}
    if (clsave.bis("e1_krople_rozwiazane") && !clsave.bis("e1_huby_wypalone")) 
    {
        anprzed_wypaleniem.hide();
        if( simg!=null ) {
		<simg>.blit("anwypalanie");
        } else {
		anwypalanie.play("wypalanie");
		clsave.bset("e1_huby_wypalone");
	}
    }  
    else 
      if (clsave.bis("e1_huby_wypalone"))
      {
        anprzed_wypaleniem.hide();
        anwypalanie.hide();
        if( simg!=null ) <simg>.blit("anwypalone");
        else anwypalone.show();
      }
      if( simg!=null ) {
	<simg>.blit("anramka");
	anramka.hide;
	<simg>.hide;
	}
      .restore_path;
	}
	
   ansekator_TAKE	{
    if (!clsave.bis("e1_huby_wypalone"))
    {
        return;
    }    
    if( !.isvisible_itempopup("sekator") ) {
      ansekator.play("rotostart");
      .show_itempopup("sekator", "ansekator");
      .set_mg_finished(); 
    }
    else   
     {  
      .item_gotocenter;
      .hide_itempopup("sekator"); 
     }
  }
  popup_sekator_clickexit {
    butgame.sclicked = ("ansekator");
    .ansekator_TAKE;
    
   }
    ansekator_INPCK	{
    .addtopck("sekator");
	}    
   
  mend	{
     .stdexitdefadv("ad06_posagmamy", "gamead06_posagmamy0");  
  } 
  
  HINT_CLICK {
    if (!clsave.bis("taken_sekator") && clsave.bis("e1_krople_rozwiazane") )
    {   
        .showhint("ansekator");
        return; 
    }
    .showhint("anpopexit"); 
  }      
}
 


game mg07_gargulec :Banshee {
	init{
    Banshee::init("mg07_gargulec");
    .imgs = (A,"bkg.jpg 1", "background.pyz 2","items_mask.pyzH 3", "swiatelko.pyz 3", "kawalek_rzezby_3.pyzH 4", "kawalek_rzezby_2.pyzH 5" , "kawalek_rzezby_1.pyzH 6", "efekt.pyzH 7", "ramka.pyz 8", "popexit.pyz 9" );
    anefekt.setdrawmode(1);      
    .butpopexit;
    //  .addtopck("kawalek_rzezby1"); // do testow 
    //  .addtopck("kawalek_rzezby2"); // do testow 
    //  .addtopck("kawalek_rzezby3"); // do testow    
    
    answiatelko.anopacityframe;
	  answiatelko.play(1);  
    
    imgbkg {
  		.addmethod("isbutin", func { (@x, @y)
  			!anbackground.isin(x,y,0,0);
  			} );
  		.addmethod("butclick", func {
  			if( !.advstdstate ) return;
  			 .mend;
  			} );
    		butgame.add(this);
  	 }; 
     
     
     anitems_mask{
      .Button_isinvis;
      .addmethod("butmoveon", func {
				if( !.advstdstate) return;
				  if (!clsave.bis("e1_ad07_maska_naprawiona"))
            advmouse.set("use"); 
          else
             advmouse.setstd;  
      } );
			.addmethod("butmoveoff", func {
				if( !.advstdstate ) return;
				  advmouse.setstd;
				} ); 
        butgame.add(this);
     };     
           
             
     .stdstart;
    
    if (clsave.bis("e1_ankawalek_rzezby_1_on"))
    {
      ankawalek_rzezby_1.show(); 
    }
    if (clsave.bis("e1_ankawalek_rzezby_2_on"))
    {
      ankawalek_rzezby_2.show(); 
    }
    if (clsave.bis("e1_ankawalek_rzezby_3_on"))
    {
      ankawalek_rzezby_3.show(); 
    }
    
     
	 
  } // koniec init
  
  USE_kawalek_rzezby1	{
		.advsetstdstate();
    if(anitems_mask.isin(mouse.getpos,0,1) )	{
			.removefrompck("kawalek_rzezby1");
		  ankawalek_rzezby_1.anfadein(800,null);  
      clsave.bset("e1_ankawalek_rzezby_1_on");
      if (.check_all_done())
      { 
        .all_done(); 
      }
       
		} else {
		  .item_gotopck;
		}
    anitems_mask.butmoveon; 
	}  

  USE_kawalek_rzezby2	{
		.advsetstdstate();
    if(anitems_mask.isin(mouse.getpos,0,1) )	{
			.removefrompck("kawalek_rzezby2");
		  ankawalek_rzezby_2.anfadein(800,null);  
      clsave.bset("e1_ankawalek_rzezby_2_on");
      
      if (.check_all_done())
      { 
        .all_done(); 
      }
       
		} else {
			 .item_gotopck;
		}
    anitems_mask.butmoveon; 
	}  
  
  USE_kawalek_rzezby3	{
		.advsetstdstate();
    if(anitems_mask.isin(mouse.getpos,0,1) )	{
			.removefrompck("kawalek_rzezby3");
		  ankawalek_rzezby_3.anfadein(800,null);  
      clsave.bset("e1_ankawalek_rzezby_3_on"); 
       
      if (.check_all_done())
      { 
        .all_done();
      }
      anitems_mask.butmoveon;
    } else {
		  .item_gotopck;
		}
    anitems_mask.butmoveon;
   
	} 
  
  check_all_done()
  {
     if (clsave.bis("e1_ankawalek_rzezby_1_on") && clsave.bis("e1_ankawalek_rzezby_2_on") && clsave.bis("e1_ankawalek_rzezby_3_on"))	{
	     return true;
     } else
        return false;
  } 
  
  all_done()
  {
    clsave.bset("e1_ad07_maska_naprawiona");
    anefekt.anfadein(1600,"efekt_fadout");  
    .set_mg_finished();  
  }
  efekt_fadout()
  {
    anefekt.anfadeout(1000,"mend");    
  }
  
  HINT_CLICK {
    if (!ankawalek_rzezby_1.isvisible)
    {
        .showhint("ankawalek_rzezby_1");
        return;
    }
    if (!ankawalek_rzezby_2.isvisible)
    {
        .showhint("ankawalek_rzezby_2");
        return;
    }
    if (!ankawalek_rzezby_3.isvisible)
    {
        .showhint("ankawalek_rzezby_3");
        return;
    }
    .showhint("anpopexit"); 
  }
  mend	{
	.stdexitdefadv("ad07_alejadrzew", "gamead07_alejadrzew0");
  }
}
 


game mg07_gargulecjajo :Banshee {
	init{
    Banshee::init("mg07_gargulecjajo");
    .imgs = (A,"bkg.jpg 1", "base.pyz 2", "oczy.pyzH 3", "base2.pyzH 4", /*"animacja.pyzH 5",*/ "jajo.pyzH 6","ramka.pyz 6", "popexit.pyz 7" );
    anoczy.setdrawmode(1);  
    .butpopexit;     
    .stdstart; 
    anbase {
  		.Button_isinalpha;
  		butgame.add(this);
  	}; 
     imgbkg {
  		.Button_isinalpha;
  		.addmethod("butclick", func {
  			if( !.advstdstate ) return;
  			.mend;
  			} );
    		butgame.add(this);
    	};       
     .butpopexit;     
     .stdstart; 
       
     anjajo {
			.addmethod("isbutin", func { (@x, @y)
				.isin(x,y,0,0);
				} ); 
			.Button_moveonms;
			.Button_moveoffms;
			.addmethod("butclick", func {
		 	  if( !.advstdstate ) return;
        sgmstate = "eye_anim" ;
		 	  anoczy.anfadein(700,"oczy_fadeout");     
       }); 
       butgame.add(this);     
	  };
    
    /*ananimacja{
      .addmethod("onfinish", func {
		if( !.isvisible_itempopup("jajo") ) 
		.hide();
		anbase2.show();
		.show_itempopup("jajo", "anjajo");     
			} );  
				 
    } ;*/
	new Film filmb;
	filmb.musicclass = ("mus");
	filmb.addmethod("onfinish", func {
		if( !.isvisible_itempopup("jajo") ) 
			.hide;
		anbase2.show();
		.show_itempopup("jajo", "anjajo");     
		} );
	filmb.load("scripts/cs09_gargijajo/", "film");
	filmb.showfirstframe;
	filmb.setz(5);
	filmb.setpos( anbase.getpx, anbase.getpy );
	filmb.hide;
    
   // clsave.bset(clsave.get("epizod") + "_mg07_gargulec_finished"); 
    if (!clsave.bis("taken_jajo") && clsave.bis("e1_mg07_gargulec_finished"))
    { 
        sgmstate = "state_finish";
      .setasitemtopck("anjajo"); 
      butgame.removebut("anjajo");
      .animacja; 
      .set_mg_finished();  
    };   
        
  } // koniec init 
  
  oczy_fadeout{
    anoczy.anfadeout(700,func{.advsetstdstate;});    
  } 
  
  animacja{
     anjajo.hide();
    .timplay("tim1", 1000, func {
	//ananimacja.play(1); 
	filmb.play;
	}); 
  }
   
  anjajo_TAKE	{ 
    .item_gotocenter;
    .hide_itempopup("jajo");  
  }
  popup_jajo_clickexit {
    butgame.sclicked = ("anjajo");
    .anjajo_TAKE;  
    
   }
  anjajo_INPCK	{
    .addtopck("jajo");
    .mend;
	}   
  
  
  HINT_CLICK {
    if ( !clsave.bis("taken_jajo"))
    {
      .showhint("anjajo");
      return;
    } 
    .showhint("anpopexit"); 
  }
  mend	{
	.stdexitdefadv("ad07_alejadrzew", "gamead07_alejadrzew0");
  }
}
 


game mg07_skrzynia :Banshee {
	init{
    Banshee::init("mg07_skrzynia");
    .imgs = (A,"bkg.jpg 1","popup_bkg.pyz 2", "zasuwa1_open.pyzH 3", "zasuwa2_open.pyzH 4", "ramka.pyz 5","popexit.pyz 6" , "skrzynia_open.pyzH 7", "kilof.pyzH 8");
    .setasitemtopck("ankilof");  
    anpopup_bkg {
  		.Button_isinalpha;
  		butgame.add(this);
  	}; 
     imgbkg {
  		.Button_isinalpha;
  		.addmethod("butclick", func {
  			if( !.advstdstate ) return;
  			.mend;
  			} );
    		butgame.add(this);
    	};       
     .butpopexit;     
     .stdstart; 
    
     anzasuwa1_open {
  			.addmethod("isbutin", func { (@x, @y)
				.isin(x,y,0,1);
				} ); 
  			.Button_moveonms;
  			.Button_moveoffms;
  			.addmethod("butclick", func {
    		 	if( !.advstdstate  ) return;
     	    if (!clsave.bis("e1_mg07_skrzynia_zasuwa_1_opened"))
          { 
             .show();
             clsave.bset("e1_mg07_skrzynia_zasuwa_1_opened");
            .disable = (true);
            
          }else if (clsave.bis("e1_mg07_skrzynia_zasuwa_1_opened") && clsave.bis("e1_mg07_skrzynia_zasuwa_2_opened"))
            {
              clsave.bset("e1_mg07_skrzynia_opened"); 
               .skrzynia_open();
            }  
          }); 
        butgame.add(this);  
      };
      
      anzasuwa2_open {
  			.addmethod("isbutin", func { (@x, @y)
				.isin(x,y,0,1);
				} ); 
  			.Button_moveonms;
  			.Button_moveoffms;
  			.addmethod("butclick", func {
    		 	if( !.advstdstate  ) return;
     	    if (!clsave.bis("e1_mg07_skrzynia_zasuwa_2_opened"))
          { 
             .show();
             clsave.bset("e1_mg07_skrzynia_zasuwa_2_opened");
            .disable = (true);
             
          }
          else if (clsave.bis("e1_mg07_skrzynia_zasuwa_1_opened") && clsave.bis("e1_mg07_skrzynia_zasuwa_2_opened"))
            {
              clsave.bset("e1_mg07_skrzynia_opened"); 
               .skrzynia_open();
            } 
          }); 
        butgame.add(this);  
      };
      
       
      
      if (clsave.bis("e1_mg07_skrzynia_opened"))
      {
        anzasuwa1_open.disable = (true);
        anzasuwa2_open.disable = (true);
        anskrzynia_open.show();
        if (!clsave.bis("taken_kilof"))
        {
          ankilof.show();
          ankilof.enabled = (true);
        }
        
      }
      else
      {
         if (clsave.bis("e1_mg07_skrzynia_zasuwa_1_opened"))
        {
          anzasuwa1_open.show(); 
          anzasuwa1_open.disable = (true);
        }
        
        if (clsave.bis("e1_mg07_skrzynia_zasuwa_2_opened"))
        {
          anzasuwa2_open.show(); 
          anzasuwa2_open.disable = (true);
        }
      
      }
      
      
      
      
  } // koniec init 
  
  ankilof_TAKE {
     // anpuszka_robaki.setframe("rotostart",0); 
       .popitem_gotocenter("kilof");
      .set_mg_finished;   
  }
   ankilof_INPCK {
    .addtopck("kilof"); 
    .mend();
  }  
  
  skrzynia_open()
  {
    anzasuwa1_open.hide();
    anzasuwa2_open.hide(); 
    anskrzynia_open.show();
    ankilof.show();
  }
  
  HINT_CLICK {
    .showhint("anpopexit"); 
  }
  mend	{
	 .stdexitdefadv("ad07_alejadrzew", "gamead07_alejadrzew0");
  }
}
 


game mg08_doniczki :Banshee {
	init{
    Banshee::init("mg08_doniczki");
    .imgs = (A,"bkg.jpg 1","popup_bkg.pyz 2", "doniczka1.pyz 3", "doniczka2.pyz 4", "doniczka3.pyz 5", "ziarenko1.pyzH 5", "ziarenko2.pyzH 6", "ziarenko3.pyzH 7", "elixir1.pyzH 8", "roslinka1.pyzH 9", "elixir2.pyzH 10", "roslinka2.pyzH 11", "elixir3.pyzH 12", "roslinka3.pyzH 13", "ramka.pyz 14", "konewka1.pyzH 15","konewka2.pyzH 16","konewka3.pyzH 16", "popexit.pyz 25");
 //    .addtopck("ziarno"); 
//     .addtopck("elixir");
//     .addtopck("konewka");  
    anpopup_bkg {
  		.Button_isinalpha;
  		butgame.add(this);
  	};
    
    anelixir1.addmethod("onfinish",func{ .hide; .advsetstdstate;}); 
    anelixir2.addmethod("onfinish",func{ .hide; .advsetstdstate;}); 
    anelixir3.addmethod("onfinish",func{ .hide; .advsetstdstate;}); 
    
    ankonewka1.addmethod("onfinish",func{ .hide; .advsetstdstate;}); 
    ankonewka2.addmethod("onfinish",func{ .hide; .advsetstdstate;}); 
    ankonewka3.addmethod("onfinish",func{ .hide; .advsetstdstate;}); 
  
     imgbkg {
  		.Button_isinalpha;
  		.addmethod("butclick", func {
  			if( !.advstdstate || sgmstate == "getitem" || sgmstate == "anim" ) return;
  			.mend;
  			} );
    		butgame.add(this);
    	};       
      .butpopexit;     
     .stdstart; 
     
     if (clsave.bis("e1_ad08_doniczka1_ziarno_in"))
     {
        anziarenko1.show();
     }
     
     if (clsave.bis("e1_ad08_doniczka2_ziarno_in"))
     {
        anziarenko2.show();
     }
     
     if (clsave.bis("e1_ad08_doniczka3_ziarno_in"))
     {
        anziarenko3.show();
     }
     
      if (clsave.bis("e1_ad08_doniczka1_elixir_in"))
     {
        anziarenko1.hide;
     }
     
     if (clsave.bis("e1_ad08_doniczka2_elixi_in"))
     {
        anziarenko2.hide();
     }
     
     if (clsave.bis("e1_ad08_doniczka3_elixi_in"))
     {
        anziarenko3.hide();
     }
     
     if (!clsave.bis("e1_ad08_doniczka1_elixi_in"))
        andoniczka1{
        .Button_isinvis;
        .addmethod("butmoveon", func {
  				if( !.advstdstate) return;
  				  if (!clsave.bis("e1_ad08_doniczka1_elixi_in"))
              advmouse.set("use"); 
            else
               advmouse.setstd;  
        } );
  			.addmethod("butmoveoff", func {
  				if( !.advstdstate ) return;
  				  advmouse.setstd;
  				} ); 
          butgame.add(this);
      }; 
      
      if (!clsave.bis("e1_ad08_doniczka2_elixi_in"))
        andoniczka2{
        .Button_isinvis;
        .addmethod("butmoveon", func {
  				if( !.advstdstate) return;
  				  if (!clsave.bis("e1_ad08_doniczka2_elixi_in"))
              advmouse.set("use"); 
            else
               advmouse.setstd;  
        } );
  			.addmethod("butmoveoff", func {
  				if( !.advstdstate ) return;
  				  advmouse.setstd;
  				} ); 
          butgame.add(this);
      };
      if (!clsave.bis("e1_ad08_doniczka3_elixi_in"))
        andoniczka3{
        .Button_isinvis;
        .addmethod("butmoveon", func {
  				if( !.advstdstate) return;
  				  if (!clsave.bis("e1_ad08_doniczka3_elixi_in"))
              advmouse.set("use"); 
            else
               advmouse.setstd;  
        } );
  			.addmethod("butmoveoff", func {
  				if( !.advstdstate ) return;
  				  advmouse.setstd;
  				} ); 
          butgame.add(this);
      };                
      
     
  } // koniec init 
   
   
  
  ziarno_completed()
  {
   if (clsave.bis("e1_ad08_doniczka1_ziarno_in") && clsave.bis("e1_ad08_doniczka3_ziarno_in") && clsave.bis("e1_ad08_doniczka3_ziarno_in"))
      return true;
    else
      return false;
  }
  
  elixir_completed()
  {
   if (clsave.bis("e1_ad08_doniczka1_elixir_in") && clsave.bis("e1_ad08_doniczka3_elixir_in") && clsave.bis("e1_ad08_doniczka3_elixir_in"))
      return true;
    else
      return false;
  }
  konewka_completed()
  {
   if (clsave.bis("e1_ad08_doniczka1_water_in") && clsave.bis("e1_ad08_doniczka3_water_in") && clsave.bis("e1_ad08_doniczka3_water_in"))
      return true;
    else
      return false;
  }
  
  
   USE_ziarno {
        .advsetstdstate; 
        if( andoniczka1.isin(mouse.getpos,1,0) && !clsave.bis("e1_ad08_doniczka1_ziarno_in") )	{
          clsave.bset("e1_ad08_doniczka1_ziarno_in");
          anziarenko1.play(1);
          .advsetstate("getitem");
          guimov.setmoved("anitem_ziarno");
          if(.ziarno_completed)
          { 
            .removefrompck("ziarno");
            .advsetstdstate; 
          }
          else
              anitem_ziarno.anfadeout(200,func{anitem_ziarno.anfadein(800,func{.advsetstdstate;} );}); 
              
        } else if( andoniczka2.isin(mouse.getpos,1,0) && !clsave.bis("e1_ad08_doniczka2_ziarno_in") )	{
    			clsave.bset("e1_ad08_doniczka2_ziarno_in");
    		    anziarenko2.play(1);
            .advsetstate("getitem");
            guimov.setmoved("anitem_ziarno");
          if(.ziarno_completed)
          { 
            .removefrompck("ziarno");
            .advsetstdstate; 
          }
          else
              anitem_ziarno.anfadeout(200,func{anitem_ziarno.anfadein(800,func{.advsetstdstate;} );}); 
              
        } else if( andoniczka3.isin(mouse.getpos,1,0) && !clsave.bis("e1_ad08_doniczka3_ziarno_in") )	{
    			 clsave.bset("e1_ad08_doniczka3_ziarno_in");
           anziarenko3.play(1);
           .advsetstate("getitem");
           guimov.setmoved("anitem_ziarno");
           if(.ziarno_completed)
           { 
            .removefrompck("ziarno");
            .advsetstdstate; 
            }
            else
              anitem_ziarno.anfadeout(200,func{anitem_ziarno.anfadein(800,func{.advsetstdstate;} );}); 
            
        }  else .item_gotopck; 
         
    } 
    
    USE_konewka {
        .advsetstdstate; 
        if( andoniczka1.isin(mouse.getpos,1,0) && clsave.bis("e1_ad08_doniczka1_ziarno_in") && !clsave.bis("e1_ad08_doniczka1_water_in"))	{
          clsave.bset("e1_ad08_doniczka1_water_in");
          ankonewka1.play(1);
          .advsetstate("getitem");
          guimov.setmoved("anitem_konewka");
          if(.konewka_completed)
          { 
            .removefrompck("konewka");
            .advsetstdstate;
             
          }
          else
              anitem_konewka.anfadeout(200,func{anitem_konewka.anfadein(800,func{.advsetstdstate;} );}); 
              
        } else if( andoniczka2.isin(mouse.getpos,1,0) && clsave.bis("e1_ad08_doniczka2_ziarno_in") && !clsave.bis("e1_ad08_doniczka2_water_in") )	{
          clsave.bset("e1_ad08_doniczka2_water_in");
          ankonewka2.play(1);
          .advsetstate("getitem");
          guimov.setmoved("anitem_konewka");
          if(.konewka_completed)
          { 
            .removefrompck("konewka");
            .advsetstdstate;
            
          }
          else
              anitem_konewka.anfadeout(200,func{anitem_konewka.anfadein(800,func{.advsetstdstate;} );}); 
              
        } else if( andoniczka3.isin(mouse.getpos,1,0) && clsave.bis("e1_ad08_doniczka3_ziarno_in")&& !clsave.bis("e1_ad08_doniczka3_water_in") )	{
          clsave.bset("e1_ad08_doniczka3_water_in");
          ankonewka3.play(1);
          .advsetstate("getitem");
          guimov.setmoved("anitem_konewka");
          if(.konewka_completed)
           { 
            .removefrompck("konewka");
            .advsetstdstate;
             
            }
            else
              anitem_konewka.anfadeout(200,func{anitem_konewka.anfadein(800,func{.advsetstdstate;} );}); 
            
        }  else .item_gotopck; 
         
    } 
    
    go_to_next_location{
      .timplay("timend", 400, func {
      .stdexitdefadv("ad12_latajacecosna", "gamead12_latajacecosna0");});
    }
    
    USE_elixir {
        .advsetstdstate; 
        if( andoniczka1.isin(mouse.getpos,1,0) && clsave.bis("e1_ad08_doniczka1_water_in") && !clsave.bis("e1_ad08_doniczka1_elixir_in"))	{
          clsave.bset("e1_ad08_doniczka1_elixir_in");
          anelixir1.play(1);
          anroslinka1.play(1);
          .advsetstate("getitem");
          guimov.setmoved("anitem_elixir");
          butgame.removebut("andoniczka1");
          if(.elixir_completed)
          { 
            .removefrompck("elixir");
            .advsetstdstate;
            .set_mg_finished();
            .go_to_next_location();  
          }
          else
              anitem_elixir.anfadeout(200,func{anitem_elixir.anfadein(800,func{.advsetstdstate;advmouse.setstd;} );}); 
              
        } else if( andoniczka2.isin(mouse.getpos,1,0) && clsave.bis("e1_ad08_doniczka2_ziarno_in") && !clsave.bis("e1_ad08_doniczka2_elixir_in") )	{
    			clsave.bset("e1_ad08_doniczka2_elixir_in");
    		    anelixir2.play(1);
            anroslinka2.play(1);
           .advsetstate("getitem");
            guimov.setmoved("anitem_elixir");
            butgame.removebut("andoniczka2");
          if(.elixir_completed)
          { 
            .removefrompck("elixir");
            .advsetstdstate;
            .set_mg_finished(); 
            .go_to_next_location(); 
          }
          else
              anitem_elixir.anfadeout(200,func{anitem_elixir.anfadein(800,func{.advsetstdstate; advmouse.setstd; } );}); 
              
        } else if( andoniczka3.isin(mouse.getpos,1,0) && clsave.bis("e1_ad08_doniczka3_ziarno_in")&& !clsave.bis("e1_ad08_doniczka3_elixir_in") )	{
    			 anelixir3.play(1);
           anroslinka3.play(1);
          .advsetstate("getitem");
           guimov.setmoved("anitem_elixir");
          butgame.removebut("andoniczka3");
          clsave.bset("e1_ad08_doniczka3_elixir_in");
    		   if(.elixir_completed)
           { 
              .removefrompck("elixir");
              .advsetstdstate; 
              .set_mg_finished();
              .go_to_next_location(); 
            }
            else
              anitem_elixir.anfadeout(200,func{anitem_elixir.anfadein(800,func{.advsetstdstate; advmouse.setstd; } );}); 
            
        }  else .item_gotopck; 
         
    }     
  
  
  mend	{
    if (.is_mg_finished)
      .stdexitdefadv("ad12_latajacecosna", "gamead12_latajacecosna0");
    else
      .stdexitdefadv("ad08_latajacecospod", "gamead08_latajacecospod0");
  }
  
  HINT_CLICK {
    if (!clsave.bis("e1_ad08_doniczka3_elixi_in") ) 
    {  
       
      .showhint("andoniczka1");
    }
    else
    if (!clsave.bis("e1_ad08_doniczka1_elixi_in") ) 
    {  
      //.showhintitem("klamka");
      .showhint("andoniczka2");
    }
     else
    if (!clsave.bis("e1_ad08_doniczka3_elixi_in") ) 
    {  
      //.showhintitem("klamka");
      .showhint("andoniczka3");
    }
    else
      .showhint("anpopexit"); 
  }       
}
 

game mg09_reka :Banshee {
	init{
		Banshee::init("mg09_reka");
		
		.imgs = (A, "bkg.jpg", "ramka.pyz 20", "klatka.pyz H");
		
		new Film filmb;
		filmb.musicclass = ("mus");
		filmb.addmethod("onfinish", "mend");
		filmb.load("scripts/cs09_reka/", "film");
		filmb.showfirstframe;
		filmb.setpos( anklatka.getpx, anklatka.getpy );
		ccs.enter( func {
			filmb.play;
			} );
	}
	mend	{ 
		.stdexitdefadv("ad09_polekoniczyny", "gamead09_polekoniczyny0");
	}
}




game mg09_szkielko :Banshee {
	init{
    new string act_id = "null";
    Banshee::init("mg09_szkielko");
    new ImgRect recmask {
      .Button_isin;
      .Button_moveoffms;
       
      .setrect( 0,0, igmappw, igmapph );
      .setz(2); 
      .hide;
      butgame.add(this);
       
    };
      
    .imgs = (A, "bkg.jpg 1","base.pyz 2","slot1.pyz 3","slot2.pyz 3","slot3.pyz 3","slot4.pyz 3","slot5.pyz 3","osmiornica.pyzH 4","pajak.pyzH 4","waz.pyzH 4","ptak.pyzH 4","kon.pyzH 4","kot.pyzH 4","ryba.pyzH 4","mis.pyzH 4","malpa.pyzH 4","slon.pyzH 4", "mask.pyz 5","glow1.pyzH 6","glow2.pyzH 6","glow3.pyzH 6","glow4.pyzH 6","glow5.pyzH 6","final_anim.pyzH  9", "popexit.pyz 10" );
     .butpopexit;
     
    imgbkg {
		.addmethod("isbutin", func { (@x, @y)
			!anbase.isin(x,y,0,0);
			} );
		.addmethod("butclick", func {
			if( !.advstdstate ) return;
			 .mend;
			} );
  		butgame.add(this);
  	};      
    
    anglow1.setpos(514,488);
    anglow1.setdrawmode(1); 
    
    anglow2.setdrawmode(1); 
    anglow2.setpos(656,482);
    
    anglow3.setdrawmode(1); 
    anglow3.setpos(792,406); 
    
    anglow4.setdrawmode(1); 
    anglow4.setpos(866,290); 
    
    anglow5.setdrawmode(1); 
    anglow5.setpos(868,160); 
  //  .addtopck("moneta_5");  
  //   clsave.bset("e1_monety_zwierzeta_zebrane");
  //    clsave.bset("ma_moneta_5");
   
    if (clsave.bis("e1_monety_zwierzeta_uzyte") )
    { 
      .init_coin("osmiornica",774 +25,306+50, 1);
      .init_coin("kot",834,248,2);
      .init_coin("waz",788,172,3);
      .init_coin("ptak",586,242,4);
      .init_coin("kon",740,258,5); 
    
    }
    else
    {
      
      .newsnd("snd_brak_monet", "kinnat_51a");
      snd_brak_monet.addmethod("onfinish", func {.advsetstdstate;  anbase.butmoveon; });
      .cbplay("snd_brak_monet");
      anbase { 
        .Button_isinvisalpha;
        .addmethod("butmoveon", func {
  				if( !.advstdstate) return;
  				  if(!clsave.bis("e1_monety_zwierzeta_uzyte"))
              advmouse.set("use"); 
                  
          } );
  			.addmethod("butmoveoff", func {
  				if( !.advstdstate ) return;
  				  advmouse.setstd;
  				} ); 
          butgame.add(this);
                 
      };
       
    } 
    .init_coin("pajak",565,366,0);
    .init_coin("ryba",624,438,0);
    .init_coin("mis",660,312,0);
    .init_coin("malpa",675,185,0);
    .init_coin("slon",720,386,0); 
    
    if (!clsave.bis("e1_monety_zwierzeta_uzyte") )
      .enable_buttons(0);
    
    anslot1{
      .Button_isin;    
      .addmethod("butmoveon", func {
				if( !.advstdstate) return;
				advmouse.set("use");
				} );
			.addmethod("butmoveoff", func {
				if( !.advstdstate ) return;
				advmouse.setstd;
				} ); 
      .vars2(A,"occupied",false, "obj_id","null");
    
    }; 
     anslot2{
      .Button_isin;    
      .addmethod("butmoveon", func {
				if( !.advstdstate) return;
				advmouse.set("use");
				} );
			.addmethod("butmoveoff", func {
				if( !.advstdstate ) return;
				advmouse.setstd;
				} ); 
      .vars2(A,"occupied",false,"obj_id","null");
    }; 
     anslot3{
       .Button_isin;    
      .addmethod("butmoveon", func {
				if( !.advstdstate) return;
				advmouse.set("use");
				} );
			.addmethod("butmoveoff", func {
				if( !.advstdstate ) return;
				advmouse.setstd;
				} ); 
       .vars2(A,"occupied",false,"obj_id","null");
    }; 
     anslot4{
      .Button_isin;    
      .addmethod("butmoveon", func {
				if( !.advstdstate) return;
				advmouse.set("use");
				} );
			.addmethod("butmoveoff", func {
				if( !.advstdstate ) return;
				advmouse.setstd;
				} ); 
      .vars2(A,"occupied",false,"obj_id","null");
    }; 
     anslot5{
      .Button_isin;    
      .addmethod("butmoveon", func {
				if( !.advstdstate) return;
				advmouse.set("use");
				} );
			.addmethod("butmoveoff", func {
				if( !.advstdstate ) return;
				advmouse.setstd;
				} ); 
      .vars2(A,"occupied",false,"obj_id","null");
    }; 
    
     anfinal_anim{
      .addmethod("onfinish", func {
      for( int i = 1;i<6;i++)
        <"anglow"+i>.anfadeout(200,null);
      .mend();
      });    
    };
    .stdstart;  
  } // koniec init
   
   
  
     
  init_coin(string name, int x,int y, int index )
  {
      <"an"+name>(name, x,y,index){(string name, int x, int y, int index)
      .show;
      .setpos(x,y);
      .vars2(A,"name", name, "start_x", x, "start_y", y, "index", index, "slot_id",0 );
      .Button_isin;    
      .Button_moveonms;
			.Button_moveoffms;
      .addmethod("butclick", func {
          if( !.advstdstate || .is_mg_finished()) return;
            if (anslot1.isin(mouse.getpos,1,0)){ 
              if(anslot1.occupied)
              {
                if (anslot1.obj_id == .name)
                { 
                 // .setpos(.start_x,.start_y);
                  act_id = this;
                  .setz(300); 
                  .play(1);
                  recmask.setz(5);
                  butgame.sort; 
                  anslot1.occupied = (false);
                  anslot1.obj_id = ("null");
                  .slot_id = (0); 
                  anglow1.hide();
                  .check_won();
                  return;  
                }
                else
                {
                  .setpos(524+37,500+38); 
                  <"an"+anslot1.obj_id>.setz(4);
                  <"an"+anslot1.obj_id>.setpos(<"an"+anslot1.obj_id>.start_x,<"an"+anslot1.obj_id>.start_y);                 
                  anslot1.obj_id = (.name);
                  .slot_id = (1);
                  if (.index == 1)
                  { 
                    anglow1.setframe("green",0); 
                    anglow1.anfadein(800,null);
                  }
              //    else if (.index >0)
              //      anglow1.play("blue");
                  else
                  { 
                    anglow1.setframe("red",0);
                    anglow1.anfadein(800,null); 
                  }    
                }
              }
              else
              {
                anslot1.occupied = (true); 
                anslot1.obj_id = (.name);
                .slot_id = (.index);  
               if (.index == 1)
                  { 
                    anglow1.setframe("green",0); 
                    anglow1.anfadein(800,null);
                  }
              //    else if (.index >0)
              //      anglow1.play("blue");
                  else
                  { 
                    anglow1.setframe("red",0);
                    anglow1.anfadein(800,null); 
                  }    
                .setpos(524+37,500+38);    
              } 
              .setz(4);
              act_id = "null"; 
              .play(0); 
              recmask.setz(2);
              .check_won();
            } 
            else if (anslot2.isin(mouse.getpos,1,0)){ 
              if(anslot2.occupied)
              {
                if (anslot2.obj_id == .name)
                { 
                 // .setpos(.start_x,.start_y);
                  act_id = this;
                  .setz(300); 
                  .play(1);
                  recmask.setz(5);
                  butgame.sort; 
                  anslot2.occupied = (false);
                  anslot2.obj_id = ("null");
                  .slot_id = (0); 
                  anglow2.hide();
                  .check_won();
                  return;  
                }
                else
                {
                  .setpos(672+32,494+38); 
                  <"an"+anslot2.obj_id>.setz(4);
                  <"an"+anslot2.obj_id>.setpos(<"an"+anslot2.obj_id>.start_x,<"an"+anslot2.obj_id>.start_y);                   
                  anslot2.obj_id = (.name);
                  .slot_id = (2);
                 if (.index == 2)
                  { 
                    anglow2.setframe("green",0); 
                    anglow2.anfadein(800,null);
                  }
              //    else if (.index >0)
              //      anglow2.play("blue");
                  else
                  { 
                    anglow2.setframe("red",0);
                    anglow2.anfadein(800,null); 
                  }    
                }
              }
              else
              {
                anslot2.occupied = (true); 
                anslot2.obj_id = (.name);
                .slot_id = (.index); 
                 if (.index == 2)
                  { 
                    anglow2.setframe("green",0); 
                    anglow2.anfadein(800,null);
                  }
              //    else if (.index >0)
              //      anglow2.play("blue");
                  else
                  { 
                    anglow2.setframe("red",0);
                    anglow2.anfadein(800,null); 
                  }    
                .setpos(672+32,494+38);     
              } 
              .setz(4);
              act_id = "null"; 
              .play(0); 
              recmask.setz(2);
              .check_won();
            }
            else if (anslot3.isin(mouse.getpos,1,0)){ 
              if(anslot3.occupied)
              {
                if (anslot3.obj_id == .name)
                { 
                  // .setpos(.start_x,.start_y);
                  act_id = this;
                  .setz(300); 
                  .play(1);
                  recmask.setz(5);
                  butgame.sort; 
                  anslot3.occupied = (false);
                  anslot3.obj_id = ("null");
                  .slot_id = (0); 
                  anglow3.hide();
                  .check_won();
                  return;  
                   
                }
                else
                {
                  .setpos(802+37,418+38);
                  <"an"+anslot3.obj_id>.setz(4);
                  <"an"+anslot3.obj_id>.setpos(<"an"+anslot3.obj_id>.start_x,<"an"+anslot3.obj_id>.start_y);                     
                  anslot3.obj_id = (.name);
                  .slot_id = (3);
                  if (.index == 3)
                  { 
                    anglow3.setframe("green",0); 
                    anglow3.anfadein(800,null);
                  }
              //    else if (.index >0)
              //      anglow3.play("blue");
                  else
                  { 
                    anglow3.setframe("red",0);
                    anglow3.anfadein(800,null); 
                  }    
                }
              }
              else
              {
                anslot3.occupied = (true); 
                anslot3.obj_id = (.name);
                .slot_id = (.index); 
                if (.index == 3)
                  { 
                    anglow3.setframe("green",0); 
                    anglow3.anfadein(800,null);
                  }
              //    else if (.index >0)
              //      anglow3.play("blue");
                  else
                  { 
                    anglow3.setframe("red",0);
                    anglow3.anfadein(800,null); 
                  }    
                .setpos(802+37,418+38);    
              }
              .setz(4);
              act_id = "null"; 
              .play(0); 
              recmask.setz(2);
              .check_won();
            }
            else if (anslot4.isin(mouse.getpos,1,0)){ 
              if(anslot4.occupied)
              {
                if (anslot4.obj_id == .name)
                { 
                  // .setpos(.start_x,.start_y);
                  act_id = this;
                  .setz(300); 
                  .play(1);
                  recmask.setz(5);
                  butgame.sort; 
                  anslot4.occupied = (false);
                  anslot4.obj_id = ("null");
                  .slot_id = (0); 
                  anglow4.hide();
                  .check_won();
                  return;  
                   
                }
                else
                {
                  .setpos(876+37,304+38); 
                  <"an"+anslot4.obj_id>.setz(4);
                  <"an"+anslot4.obj_id>.setpos(<"an"+anslot4.obj_id>.start_x,<"an"+anslot4.obj_id>.start_y);                 
                  anslot4.obj_id = (.name);
                  .slot_id = (4);
                   if (.index == 4)
                  { 
                    anglow4.setframe("green",0); 
                    anglow4.anfadein(800,null);
                  }
              //    else if (.index >0)
              //      anglow4.play("blue");
                  else
                  { 
                    anglow4.setframe("red",0);
                    anglow4.anfadein(800,null); 
                  }    
                }
              }
              else
              {
                anslot4.occupied = (true); 
                anslot4.obj_id = (.name);
                .slot_id = (.index); 
                 if (.index == 4)
                  { 
                    anglow4.setframe("green",0); 
                    anglow4.anfadein(800,null);
                  }
              //    else if (.index >0)
              //      anglow4.play("blue");
                  else
                  { 
                    anglow4.setframe("red",0);
                    anglow4.anfadein(800,null); 
                  }    
                  
                .setpos(876+37,304+38);     
              }
              .setz(4);
              act_id = "null"; 
              .play(0); 
              recmask.setz(2);
              .check_won();
            }
            else if (anslot5.isin(mouse.getpos,1,0)){ 
              if(anslot5.occupied)
              {
                if (anslot5.obj_id == .name)
                { 
                  // .setpos(.start_x,.start_y);
                  act_id = this;
                  .setz(300); 
                  .play(1);
                  recmask.setz(5);
                  butgame.sort; 
                  anslot5.occupied = (false);
                  anslot5.obj_id = ("null");
                  .slot_id = (0); 
                  anglow5.hide();
                  .check_won();
                  return;  
                   
                }
                else
                {
                  .setpos(880+37,172+38);   
                  <"an"+anslot5.obj_id>.setz(4);
                  <"an"+anslot5.obj_id>.setpos(<"an"+anslot5.obj_id>.start_x,<"an"+anslot5.obj_id>.start_y);                  
                  anslot5.obj_id = (.name);
                  .slot_id = (5);
                  if (.index == 5)
                  { 
                    anglow5.setframe("green",0); 
                    anglow5.anfadein(800,null);
                  }
              //    else if (.index >0)
              //      anglow5.play("blue");
                  else
                  { 
                    anglow5.setframe("red",0);
                    anglow5.anfadein(800,null); 
                  }    
                }
              }
              else
              {
                anslot5.occupied = (true); 
                anslot5.obj_id = (.name);
                .slot_id = (.index); 
                 if (.index == 5)
                  { 
                    anglow5.setframe("green",0); 
                    anglow5.anfadein(800,null);
                  }
              //    else if (.index >0)
              //      anglow5.play("blue");
                  else
                  { 
                    anglow5.setframe("red",0);
                    anglow5.anfadein(800,null); 
                  }    
                  
                .setpos(880+37,172+38);     
              }
              .setz(4);
              act_id = "null"; 
              .play(0); 
              recmask.setz(2);
              .check_won();
            }
            else if (act_id == "null"){ 
              act_id = this;
              .setz(300); 
              .play(1);
              recmask.setz(5);
              butgame.sort;
              .check_won(); 
              return;
            }
             
            else{ 
              .setpos(.start_x,.start_y);
              .setz(4);
              act_id = "null"; 
              .play(0); 
              recmask.setz(2);
            }  
            butgame.sort;
            
      } ); 
      butgame.add(this);   
    };
  }
   
 	mouse_move	{
	  if (act_id != "null")
        <act_id>.setpos(mouse.getpos);
	}
  
  check_all_done()
  {
    for(int i =1;i<6;i++)
    {
      if (<"anglow"+i>.actionname != "green")
        return false;
    }  
    return true;
  }
  
  check_won()
  {
    if (.check_all_done())
    {
      .set_mg_finished();
      anfinal_anim.play(1); 
        
    }
  }
  
  enable_buttons(bool bvis){
    if (bvis)
    { 
      
      butgame.add("anpajak");
      butgame.add("anryba");
      butgame.add("anmis");
      butgame.add("anmalpa");
      butgame.add("anslon");
     
      butgame.add("anslot1");
      butgame.add("anslot2");
      butgame.add("anslot3");
      butgame.add("anslot4");
      butgame.add("anslot5");
    }
    else
    {
   
      butgame.removebut("anpajak");
      butgame.removebut("anryba");
      butgame.removebut("anmis");
      butgame.removebut("anmalpa");
      butgame.removebut("anslon");   
      
      butgame.removebut("anslot1");
      butgame.removebut("anslot2");
      butgame.removebut("anslot3");
      butgame.removebut("anslot4");
      butgame.removebut("anslot5");
      
    }
  }
  
  USE_moneta_5	{
		.advsetstdstate();
    if(anbase.isin(mouse.getpos,0,1) )	{
		 	.removefrompck("moneta_5");
		  .init_coin("osmiornica",774 +25,306+50, 1);
      .init_coin("kot",834,248,2);
      .init_coin("waz",788,172,3);
      .init_coin("ptak",586,242,4);
      .init_coin("kon",740,258,5); 
       
        <"anosmiornica">.hide;
        .timplay("tim1", 150,func{<"anosmiornica">.show;});  
        <"ankot">.hide;
        .timplay("tim2", 200,func{<"ankot">.show;});  
        <"anwaz">.hide;
        .timplay("tim3", 250,func{<"anwaz">.show;});  
        <"anptak">.hide;
        .timplay("tim4", 300,func{<"anptak">.show;});  
        <"ankon">.hide;
        .timplay("tim5", 350,func{<"ankon">.show;});   
       butgame.removebut("anbase");
      
      .enable_buttons(1);
      clsave.bset("e1_monety_zwierzeta_uzyte");
    
		} else {
			 .item_gotopck;
		}
     
	}   
 
  mend	{
    .stdexitdefadv("ad09_polekoniczyny", "gamead09_polekoniczyny0"); 
	}
  
  HINT_CLICK {
    if (!anslot1.occupied)
    { 
      .showhint("anosmiornica"); 
      .showhint("anglow1"); 
      return;
    }   
    else if (!anslot2.occupied) 
    { 
      .showhint("anpajak");
      .showhint("anglow2"); 
       return;
    }
    else if (!anslot3.occupied) 
    { 
      .showhint("anwaz");
      .showhint("anglow3"); 
       return;
    }
    else if (!anslot4.occupied) 
    { 
      .showhint("anptak");
      .showhint("anglow4"); 
       return;
    }
    else if (!anslot5.occupied) 
    {
      .showhint("ankon");
      .showhint("anglow5"); 
       return;
    }
    .showhint("anpopexit");  
  } 
}
 

game mg10_poison :Banshee {
	init{
		Banshee::init("mg10_poison");
		
		.imgs = (A, "bkg.jpg", "ramka.pyz 20", "klatka.pyz H");
		
		new Film filmb;
		filmb.musicclass = ("mus");
		filmb.addmethod("onfinish", "mend");
		filmb.load("scripts/cs10_poison/", "film");
		filmb.showfirstframe;
		filmb.setpos( anklatka.getpx, anklatka.getpy );
		ccs.enter( func {
			filmb.play;
			} );
	}
	mend	{  
		.stdexitdefadv("ad10_ogrodrozany", "gamead10_ogrodrozany0");
	}
}



game mg11_lew :Banshee {
	init{
    Banshee::init("mg11_lew");
    .imgs = (A,"bkg.jpg 1", "base.pyz 2", "4.pyz 3", "3.pyz 4", "2.pyz 5", "1.pyz 6", "mask.pyz 7", "ramka.pyz 8","win.pyzH 9", "popexit.pyz 10", "2_hint_mask.pyzH 11", "3_hint_mask.pyzH 12", "4_hint_mask.pyzH 13");
    
    anbase {
  		.Button_isinalpha;
  		butgame.add(this);
  	}; 
   imgbkg {
		.Button_isinalpha;
		.addmethod("butclick", func {
			if( !.advstdstate ) return;
			.mend;
			} );
  		butgame.add(this);
  	};       
    
    .butpopexit;
  //  anwin.setdrawmode(1);
    
    .addtopck("kawalek_lwa2");
    .addtopck("kawalek_lwa3");
    .addtopck("kawalek_lwa4");
   
    new int center_x =  rgmscalex * 666;
    new int center_y =  rgmscaley * 374;
    
    new int rot1 = 0;
    new int rot2 = 0;
    new int rot3 = 0;
    new int rot4 = 0;
  
    new filter ftrot2;
    ftrot2.link("an2");
    ftrot2.setpivottype(0);
    
    new filter ftrot3;
    ftrot3.link("an3");
    ftrot3.setpivottype(0);
    
    new filter ftrot4;
    ftrot4.link("an4");
    ftrot4.setpivottype(0);  
   
    //obiekty dla hintw
    new filter frot2;
    frot2.link("an2_hint_mask");
    frot2.setpivottype(2);
    
    new filter frot3;
    frot3.link("an3_hint_mask");
    frot3.setpivottype(2);
    
    new filter frot4;
    frot4.link("an4_hint_mask");
    frot4.setpivottype(2);
    
    an2_hint_mask.move(center_x,center_y);
    an3_hint_mask.move(center_x,center_y);
    an4_hint_mask.move(center_x,center_y); 
  
    an2{
       .addmethod("isbutin", func { (@x, @y)
				  .isin(x,y,1,1);
				} ); 
  			.addmethod("butmoveon", func {
  				if( !.advstdstate) return;
    				if (!clsave.bis("e1_kawalek_lwa2_inserted"))
              advmouse.set("use");
            else
              if (.all_inserted)
                advmouse.set("take");
              else
                advmouse.set("normal");
  				} );
  			.addmethod("butmoveoff", func {
  				if( !.advstdstate ) return;
  				advmouse.setstd;
  				} ); 
				.addmethod("butclick", func {
				if( !.advstdstate || .is_mg_finished || !.all_inserted) return;
         // if (mouse.getpx <center_x)
             .rotate2(30);
        //  else
        //    .rotate2(-30); 
        } );
				butgame.add(this);
    };  
    
    an3{
       .addmethod("isbutin", func { (@x, @y)
				  .isin(x,y,1,1);
				} ); 
  			.addmethod("butmoveon", func {
  				if( !.advstdstate) return;
  				if (!clsave.bis("e1_kawalek_lwa3_inserted"))
            advmouse.set("use");
          else
              if (.all_inserted)
                advmouse.set("take");
              else
                advmouse.set("normal");
  				} );
  			.addmethod("butmoveoff", func {
  				if( !.advstdstate ) return;
  				  advmouse.setstd;
  				} ); 
				.addmethod("butclick", func {
				if( !.advstdstate ||.is_mg_finished || !.all_inserted) return;
        //  if (mouse.getpx <center_x)
             .rotate3(30);
        //  else
        //   .rotate3(-30);
        } );
				butgame.add(this);
    };    
    
     an4{
        .addmethod("isbutin", func { (@x, @y)
				  .isin(x,y,1,1);
				} ); 
  			.addmethod("butmoveon", func {
  				if( !.advstdstate) return;
  					if (!clsave.bis("e1_kawalek_lwa4_inserted"))
              advmouse.set("use");
            else
              if (.all_inserted)
                advmouse.set("take");
              else
                advmouse.set("normal");
  				} );
  			.addmethod("butmoveoff", func {
  				if( !.advstdstate ) return;
  				  advmouse.setstd;
  				} ); 
				.addmethod("butclick", func {
				if( !.advstdstate || .is_mg_finished || !.all_inserted) return;
        //  if (mouse.getpx <center_x)
             .rotate4(30);
        //  else
        //    .rotate4(-30);
        } );
				butgame.add(this);
    };
    
    if (clsave.bis("e1_kawalek_lwa2_inserted"))
      an2.play("inserted"); 
    if (clsave.bis("e1_kawalek_lwa3_inserted"))
      an3.play("inserted"); 
    if (clsave.bis("e1_kawalek_lwa4_inserted"))
      an4.play("inserted"); 
     
     
     
    .random_rings(); 
    //.check_buttons(); 
    if (!clsave.bis("e1_kawalek_lwa2_inserted") || !clsave.bis("e1_kawalek_lwa3_inserted") || !clsave.bis("e1_kawalek_lwa4_inserted"))
    { 
      .newsnd("snd_brak_kawalkow", "kinnat_54a");
      snd_brak_kawalkow.addmethod("onfinish", "advsetstdstate");
      .cbplay("snd_brak_kawalkow"); 
    };
     
	  .stdstart;
  } // koniec init
  
  all_inserted{
    if (!clsave.bis("e1_kawalek_lwa2_inserted") || !clsave.bis("e1_kawalek_lwa3_inserted") || !clsave.bis("e1_kawalek_lwa4_inserted"))
      return false;
    else
      return true;
  }
  
 /*   check_buttons()
   {
    if (clsave.bis("e1_kawalek_lwa2_inserted") && clsave.bis("e1_kawalek_lwa3_inserted") && clsave.bis("e1_kawalek_lwa4_inserted"))
         .enable_buttons(1);
    else 
      .enable_buttons(0);   
   
   }
   
   enable_buttons(bool bvis){
    if (bvis)
    { 
      
      butgame.add("an2");
      butgame.add("an3");
      butgame.add("an4");
     
    }
    else
    {
      butgame.removebut("an2");
      butgame.removebut("an3");
      butgame.removebut("an4");
    }
  } */
   
  rotate2(int angle)
  {
    ftrot2.rotate(angle);
    rot2 += angle; 
    
    if (rot2.abs() == 360)
    {
      rot2 = 0;  
    }  
    frot2.rotate(angle);
    if (.check_won())
      .finish();
  }
  
  rotate3(int angle)
  {
    ftrot3.rotate(angle);
    rot3 += angle; 
    if (rot3.abs() == 360)
    {
      rot3 = 0;  
    }  
    frot3.rotate(angle);
    if (.check_won())
      .finish();
  }
  
  rotate4(int angle)
  {
    ftrot4.rotate(angle);
    rot4 += angle; 
    if (rot4.abs() == 360)
    {
      rot4 = 0; 
    }
    frot4.rotate(angle); 
    if (.check_won())
      .finish();
  }
  
  random_rings()
  {
      int rand4 = 8->rand()+2;
      .rotate4(rand4*30);
      
      int rand3 = 8->rand()+2;
      .rotate3(-rand3*30);
      
      int rand2 = 8->rand()+2;
      .rotate2(rand2*30);
  }
  
  check_won {
    if (!clsave.bis("e1_kawalek_lwa2_inserted"))
      return false;  
    if (!clsave.bis("e1_kawalek_lwa3_inserted"))
      return false;  
    if (!clsave.bis("e1_kawalek_lwa4_inserted"))
      return false; 
    if (rot2 != 0)
      return false; 
    if (rot3 != 0)
      return false; 
    if (rot4 != 0)
      return false; 
    return true;  
  } 
  
  finish()
  {
    .set_mg_finished();
    anwin.anfadein(1200,func{anwin.anfadeout(1000,"mend");}); 
  }
  
  mend	{ 
    .stdexitdefadv("ad11_altana", "gamead11_altana0");
	}
  
  USE_kawalek_lwa2	{
    .advsetstdstate; 
    if(anbase.isin(mouse.getpos,1,1) ){
			.removefrompck("kawalek_lwa2");
      clsave.bset("e1_kawalek_lwa2_inserted"); 
		  an2.play("inserted");
      advmouse.setstd; 
      .check_buttons();
      if (.check_won())
        .finish();
    } 
    else {
		  .item_gotopck;
		}
	}  
    
  USE_kawalek_lwa3	{
    .advsetstdstate;
    if(anbase.isin(mouse.getpos,1,1) )	{
			.removefrompck("kawalek_lwa3");
      clsave.bset("e1_kawalek_lwa3_inserted"); 
		  an3.play("inserted"); 
      advmouse.setstd; 
      .check_buttons();
      if (.check_won())
        .finish();
		} 
    else {
		  .item_gotopck;
		} 
  }
  USE_kawalek_lwa4	{
    .advsetstdstate;
    if(anbase.isin(mouse.getpos,1,1) )	{
			.removefrompck("kawalek_lwa4");
      clsave.bset("e1_kawalek_lwa4_inserted"); 
		  an4.play("inserted");
      advmouse.setstd; 
      .check_buttons(); 
      if (.check_won())
        .finish();
		} 
    else {
		  .item_gotopck;
		}
     
  }
  
  HINT_CLICK {
    if (!clsave.bis("e1_kawalek_lwa2_inserted"))
    {
      .showhint("an2_hint_mask");
      return;
    }
    
    if (!clsave.bis("e1_kawalek_lwa3_inserted"))
    {
      .showhint("an3_hint_mask");
      return;
    }
    
    if (!clsave.bis("e1_kawalek_lwa4_inserted"))
    {
      .showhint("an4_hint_mask");
      return;
    }
    
    if (!.is_mg_finished)
    {
      .showhint("an1");
      return;
    }
    .showhint("anpopexit");   
  }
}
 


game mg12_aniol :Banshee {
	init{
    Banshee::init("mg12_aniol");
    .imgs = (A,"bkg.jpg 1", "base.pyz 2", "serce_part_2.pyzH 3", "serce_part_1.pyzH 4", "animacja.pyzH 5","ramka.pyz 6","popexit.pyz 7");
    .butpopexit;
    
    anbase {
  		.Button_isinalpha;
  		butgame.add(this);
  	}; 
     imgbkg {
  		.Button_isinalpha;
  		.addmethod("butclick", func {
  			if( !.advstdstate ) return;
  			.mend;
  			} );
    		butgame.add(this);
    	};       
    
 /*  if (!clsave.bis(save_prefix+"serce_part_1_added"))
    { 
      .addtopck("serce_part1"); // do testow
      .addtopck("serce_part2"); // do testow
      clsave.bset(save_prefix+"serce_part_1_added"); 
    }  */
    ananimacja.setdrawmode(1);     
    .stdstart; 
    
    // restore obiektw
    
    if (clsave.bis(save_prefix+"serce_part_1_on"))
      anserce_part_1.show();
    
    if (clsave.bis(save_prefix+"serce_part_2_on"))
      anserce_part_2.show();  
      
    if (!clsave.bis(save_prefix+"intro_spoken"))
    { 
      .newsnd("snd_intro", "kinnat_012_2");
      snd_intro.addmethod("onfinish", "advsetstdstate");     
      .cbplay("snd_intro"); 
      clsave.bset(save_prefix+"intro_spoken"); 
    }
    if(!clsave.bis(save_prefix+"serce_part_1_on"))
    
    anserce_part_1
    {
      .Button_isinvisalpha;
      .addmethod("butmoveon", func {
				if( !.advstdstate) return;
				  if(!clsave.bis(save_prefix+"serce_part_1_on"))
            advmouse.set("use"); 
                
        } );
			.addmethod("butmoveoff", func {
				if( !.advstdstate ) return;
				  advmouse.setstd;
				} ); 
        butgame.add(this);
    }; 
    anserce_part_2
    {
      .Button_isinvisalpha;
      .addmethod("butmoveon", func {
				if( !.advstdstate) return;
				  if(!clsave.bis(save_prefix+"serce_part_2_on"))
            advmouse.set("use"); 
                
        } );
			.addmethod("butmoveoff", func {
				if( !.advstdstate ) return;
				  advmouse.setstd;
				} ); 
        butgame.add(this);
    }; 
          
  
  }// koniec init 
  
  mend	{
    .stdexitdefadv("ad12_latajacecosna", "gamead12_latajacecosna0"); 
  }
  
   USE_serce_part1	{
		.advsetstdstate();
    if(anbase.isin(mouse.getpos,0,1) )	{
			.removefrompck("serce_part1");
		  anserce_part_1.anfadein(800,null);  
      clsave.bset(save_prefix+"serce_part_1_on");
      butgame.removebut("anserce_part_1");
      if (.check_all_done())
      { 
        .timplay("timend", 1000, "all_done");  
      }
		} else {
			 .item_gotopck;
		}
    advmouse.setstd;
  } 
  
  USE_serce_part2	{
		.advsetstdstate();
    if(anbase.isin(mouse.getpos,0,1) )	{
			.removefrompck("serce_part2");
		  anserce_part_2.anfadein(800,null);  
      clsave.bset(save_prefix+"serce_part_2_on");
      butgame.removebut("anserce_part_2");
      if (.check_all_done())
      { 
        .timplay("timend", 1000, "all_done"); 
      }
		} else {
			 .item_gotopck;
		}
    advmouse.setstd;
  } 
  
  check_all_done()
  {
     if (clsave.bis(save_prefix+"serce_part_1_on") && clsave.bis(save_prefix+"serce_part_2_on"))	{
	     .set_mg_finished(); 
       return true;
     } else
        return false;
  } 
  
  all_done()
  {
    ananimacja.anfadein(1600,"animacja_fadout");  
    .set_mg_finished();  
  }
  animacja_fadout()
  {
    ananimacja.anfadeout(1000,"mend");    
  }     
 
   
  HINT_CLICK {
    if (!anserce_part_1.isvisible)
    {
        .showhintitem("serce_part1");
        .showhint("anserce_part_1");
        return;
    }
    else if (!anserce_part_2.isvisible)
    {
        .showhintitem("serce_part2");
        .showhint("anserce_part_2");
        return;
    }
    else  
      .showhint("anpopexit");   
  }
}
 


game mg12_winogrona :Banshee {
	init{
    Banshee::init("mg12_winogrona");
    .imgs = (A,"bkg.jpg 1",  "ramka.pyz 6","popexit.pyz 7", "winogrona.pyz 8");
    .butpopexit;
    .setasitemtopck("anwinogrona");      
    .stdstart; 
    
    
      
  }// koniec init 
  
  anwinogrona_TAKE {
    if( !.isvisible_itempopup("winogrona") ) {
         
        .show_itempopup("winogrona", "anwinogrona");
          
    } else {
        .hide_itempopup("winogrona");  
        .item_gotocenter;
    }
   
  }
  anwinogrona_INPCK {
    .set_mg_finished; 
    .mend();  
  }  
  
  mend	{
    .stdexitdefadv("ad12_latajacecosna", "gamead12_latajacecosna0"); 
  }
  
  HINT_CLICK {
    .showhint("anpopexit");   
  }
 
}
 


game mg001_witryna : Banshee	{
	init	{
		Banshee::init("mg001_witryna");
		.imgs = (A, "bkg.jpg 1", "popup_bkg.pyz 2", "popup_ramka.pyz 3","okladka_2v.pyzH 4", "popexit.pyz 5");  
  	.butpopexit;
    clsave.bset("e1_mg001_witryna_visited"); 
         .sfxs = (A, "gwarludziN 40");
  
     imgbkg {
		.addmethod("isbutin", func { (@x, @y)
			!anpopup_bkg.isin(x,y,0,0);
			} );
		.addmethod("butclick", func {
			if( !.advstdstate ) return;
			 .mend;
			} );
  		butgame.add(this);
  	};      
    
     
    .newsndfree("sndstart", "kinnat_c0d58");
     sndstart.addmethod("onfinish", "advsetstdstate");  
  
    .gui_toloupe("anokladka_2v"); 
    anokladka_2v.anhideonsetframe;  
 
     anokladka_2v{
       .addmethod("isbutin", func { (int x, int y)
			  .advstdstate && .isin(x,y,0,0) && .loupe_visible;
				} );
      .addmethod("butclick", func {
          .cbplay("sndstart"); 
            clsave.bset("e1_mg001_witryna_okladka_2v_clicked");                
      });
      butgame.add(this);
    }; 
        
    .stdstart;
  }//koniec init
  
  mend	{
    .stdexitdefadv("ad001_kszew", "gamead001_kszew0");
	} 
  
  HINT_CLICK {
      if (!clsave.bis("e1_mg001_witryna_okladka_2v_clicked")) 
       .showhint("anokladka_2v"); 
     else  
      .showhint("anpopexit");
  }       
}

game mg002_drzwi : Banshee	{
	init	{
		Banshee::init("mg002_drzwi");
		.imgs = (A, "bkg.jpg 1", "pop_bkg.pyz 2","klamka_obszar.pyzH 3",  "ramka.pyz 4" ,"klamka.pyzH 5", "popexit.pyz 6");  
   	.butpopexit;
    .sfxs = (A, "bgrszumN 30","bgrogienN 15", "opendoor 60", "szufladaklik");
    imgbkg {
  		.addmethod("isbutin", func { (@x, @y)
  			!anpop_bkg.isin(x,y,0,0);
  			} );
  		.addmethod("butclick", func {
  			if( !.advstdstate ) return;
  			 .mend;
  			} );
    		butgame.add(this);
  	};       
    
     
    if (!clsave.bis("e1_ad002_kswew_klamka_wlozona"))
    { 
      anklamka_obszar{
        .Button_isinvis;
        .addmethod("butmoveon", func {
  				if( !.advstdstate) return;
  				  advmouse.set("use");   
          } );
  			.addmethod("butmoveoff", func {
  				if( !.advstdstate ) return;
  				  advmouse.setstd;
  				} ); 
          butgame.add(this);
        };   
     }
    
    anklamka{
			.addmethod("isbutin", func { (int x, int y)
			  .advstdstate && .isin(x,y,0,0) && anklamka.isvisible;
				} ); 
			.Button_moveonms;
			.Button_moveoffms;
			.addmethod("butclick", func {
			if( !.advstdstate  ) return;
				fxopendoor.play;
			   anklamka.play("push"); 
      } );
      butgame.add(this);
		};
    
    anklamka {
      .addmethod("onfinish", func {
			   .set_mg_finished; 
          clsave.bset("e1_ad002_drzwi_otwarte") ;
          .mend;   
          
      } );
    };
    
    if (clsave.bis("e1_ad002_kswew_klamka_wlozona"))
    { 
      anklamka.show;
      
    }
    
    
		.stdstart;
  } //koniec init
  
  USE_klamka	{
		.advsetstdstate();
    if( anklamka_obszar.isin(mouse.getpos,0,0) )	{
      .removefrompck("klamka");
      anklamka.show();
      fxszufladaklik.play;
      butgame.removebut("anklamka_obszar"); 
      clsave.bset("e1_ad002_kswew_klamka_wlozona");  
    } else {
		  .advsetstdstate; 
      .item_gotopck;
		}
	} 
  
  mend	{
    .stdexitdefadv("ad002_kswew", "gamead002_kswew0");
	} 
  
  HINT_CLICK {
    if (!clsave.bis("e1_ad002_kswew_klamka_wlozona") && clsave.bis("taken_klamka") ) 
    {  
      .showhintitem("klamka");
      .showhint("anpop_bkg");
    }
    else
      .showhint("anpopexit"); 
  }               
}

game mg003_drzwi : Banshee	{
	init	{
		Banshee::init("mg003_drzwi");
		.imgs = (A, "bkg.jpg 1", "popup_bkg.pyz 2","keyhole.pyz 3", "klamka_mask.pyzH 4", "klamka.pyz 5","herb.pyzH 6", "popup_ramka.pyz 7", "popexit.pyz 8", "popup2_bkg.pyzH 9", "popup2_herb.pyzH 10", "popup2_symbol_2v.pyzH 13", "popup2_symbol_2v_anim.pyzH 14", "popup2_ramka.pyzH 15", "popup2_popexit.pyzH 16");  
  	.butpopexit;
		.stdstart;
    .sfxs =(A, "skrzypienie_podlogiN 15", "wiatr_w_jaskiniN 50", "szufladaclose", "opendoor 60", "przekrecaklucz");
    anpopup2_symbol_2v.anhideonsetframe;
    anpopup2_symbol_2v_anim.setdrawmode(1); 
   
    .newsndfree("anpopup2_symbol_2vsnd", "kinnat_c0d65g");
    anpopup2_symbol_2vsnd.addmethod("onfinish", "advsetstdstate"); 
    
    .newsndfree("anpopup2_symbol_shown", "kinnat_c0d65j");
    anpopup2_symbol_shown.addmethod("onfinish", "advsetstdstate"); 
   
   imgbkg {
  		.addmethod("isbutin", func { (@x, @y)
  			!anpopup_bkg.isin(x,y,0,0);
  			} );
  		.addmethod("butclick", func {
  			if( !.advstdstate ) return;
  			 .mend;
  			} );
    		butgame.add(this);
  	 };
   
    new bool popup2_open;
   /*if (!clsave.bis("e1_mg003_drzwi_herb_added"))
    { 
       .addtopck("herb"); //do testow 
        clsave.bset("e1_mg003_drzwi_herb_added");
        .addtopck("klucz_biblioteka"); //do testow 
    }  */ 
    
    anpopup2_bkg{
      .addmethod("isbutin", func { (@x, @y)
				.isin(x,y,1,1) && popup2_open ;
				} );
      .addmethod("butmoveon", func {
				if( !.advstdstate) return;
				  if (!clsave.bis("e1_mg003_drzwi_herb_inserted"))
            advmouse.set("use");   
        } );
			.addmethod("butmoveoff", func {
				if( !.advstdstate ) return;
				  advmouse.setstd;
				} );    
       
      
      butgame.add(this);
    };
     
    anpopexit.addmethod("butmoveon", func {
		 	 if(popup2_open) return;
				advmouse.setbut;
				.setframe(-1,1);
				} );
    anpopup2_popexit {
			.Button_isinalpha;
			.addmethod("butmoveon", func {
		 	 if( !popup2_open) return;
				advmouse.setbut;
				.setframe(-1,1);
				} );
			.addmethod("butmoveoff", func {
				 if(!popup2_open) return;
				advmouse.setstd;
				.setframe(-1,0);
				} );
			.addmethod("butclick", func {
			 	if(!popup2_open) return;
			   .close_popup2(null);
				} );
			butgame.add(this);
		}; 
    
    anpopup2_symbol_2v{
      .addmethod("isbutin", func { (int x, int y)
			  .advstdstate && .isin(x,y,0,0) && clsave.bis("e1_mg003_drzwi_herb_inserted") && popup2_open;
				} );
			.addmethod("butmoveon", func {
		 	 if(!popup2_open) return;
			    if ( .loupe_visible && !clsave.bis("taken_klucz_biblioteka"))
            .cbplay("anpopup2_symbol_2vsnd");   
				} );
			butgame.add(this);  
    };
    
    if (!clsave.bis("e1_mg003_drzwi_klucz_inserted"))
    { 
      ankeyhole{
        .addmethod("isbutin", func { (int x, int y)
  			  .advstdstate && .isin(x,y,0,0)  ;
  				} ); 
  			.addmethod("butmoveon", func {
  		 	     if (!clsave.bis("e1_mg003_drzwi_klucz_inserted"))
                advmouse.set("use"); 
  			 } );
  			.addmethod("butmoveoff", func {
  			   advmouse.setstd;
  				 
  			 } );
  			 
  			butgame.add(this);
       };
    };
    
    anherb {
			.addmethod("isbutin", func { (int x, int y)
			  .advstdstate && .isin(x,y,0,0)  ;
				} ); 
			.addmethod("butmoveon", func {
		 	    advmouse.set("loupe"); 
			 } );
			.addmethod("butmoveoff", func {
			   advmouse.setstd;
				 
			 } );
			.addmethod("butclick", func {
				if( !.advstdstate || popup2_open || clsave.bis("e1_ad003_drzwi_otwarte")) return;
			  .open_popup2(); 
				} );
			 
			butgame.add(this);
		};
    
    
     anklamka_mask {
			.addmethod("isbutin", func { (int x, int y)
			  .advstdstate && .isin(x,y,0,0);
				} ); 
			.Button_moveonms;
			.Button_moveoffms;
			.addmethod("butclick", func {
				if( !.advstdstate || popup2_open) return;
			  anklamka.play("push"); 
			  fxopendoor.play;
        } );
         
			 
			 butgame.add(this);
		};
    
    anklamka {
      .addmethod("onfinish", func {
			   if (clsave.bis("e1_mg003_drzwi_herb_inserted") && clsave.bis("e1_mg003_drzwi_klucz_inserted")) 
         {
            .set_mg_finished; 
            clsave.bset("e1_ad003_drzwi_otwarte") ;
            .mend;   
         }
         
				} );
    };
   
    if (clsave.bis("e1_mg003_drzwi_herb_inserted"))
      anherb.show(); 
    
    if (clsave.bis("e1_mg003_drzwi_klucz_inserted")) 
      ankeyhole.setframe(1,1);
       
      
  } //koniec init
  
  open_popup2()
  {
    popup2_open =  true;
    anpopup2_bkg.anfadein(300,null);  
    anpopup2_ramka.anfadein(300,null);  
    anpopup2_popexit.anfadein(300,null);  
    if (clsave.bis("e1_mg003_drzwi_herb_inserted")) 
      anpopup2_herb.anfadein(300,null);  
      
    if (clsave.bis("e1_mg003_drzwi_herb_inserted")) 
     .gui_toloupe("anpopup2_symbol_2v");
  }
  
  close_popup2()
  {
    anpopup2_bkg.anfadeout(300,null); 
    anpopup2_ramka.anfadeout(300,null);
    anpopup2_popexit.anfadeout(300,null);
    .gui_removefromloupe("anpopup2_symbol_2v");
    if (clsave.bis("e1_mg003_drzwi_herb_inserted")) 
      anpopup2_herb.anfadeout(300,null);
     popup2_open =  false; 
    .advsetstdstate; 
  }
  
  USE_herb	{
		.advsetstdstate();
     
    if(popup2_open && anpopup2_bkg.isin(mouse.getpos,0,0) )	{
      .removefrompck("herb");
      anpopup2_herb.anfadein(800,null);
      anherb.show();
      anpopup2_symbol_2v_anim.anfadein(800,"efekt_fadout");  
      .gui_toloupe("anpopup2_symbol_2v");
      clsave.bset("e1_mg003_drzwi_herb_inserted");  
      fxszufladaclose.play;
      advmouse.setstd;
    } 
    else if (anherb.isin(mouse.getpos,0,0))
    {
      popup2_open =  true;
      anpopup2_bkg.show;  
      anpopup2_ramka.show;  
      anpopup2_popexit.anfadein(300,null);  
      .removefrompck("herb");
      anpopup2_herb.anfadein(800,null);
      anherb.show();
      anpopup2_symbol_2v_anim.anfadein(800,"efekt_fadout");  
      .gui_toloupe("anpopup2_symbol_2v");
      clsave.bset("e1_mg003_drzwi_herb_inserted"); 
       
    }
    else {
		  .advsetstdstate; 
      .item_gotopck;
		}
	}
   
  
  USE_klucz_biblioteka	{
		.advsetstdstate();
    if(!popup2_open && ankeyhole.isin(mouse.getpos,0,0) )	{
      .removefrompck("klucz_biblioteka");
      ankeyhole.anfadein(800,null);
      ankeyhole.play("open");
      fxprzekrecaklucz.play;
      butgame.removebut("ankeyhole");
      advmouse.setstd;
      clsave.bset("e1_mg003_drzwi_klucz_inserted");  
    } else {
		  .advsetstdstate; 
      .item_gotopck;
		}
	} 
  
  efekt_fadout()
  {
    anpopup2_symbol_2v_anim.anfadeout(800,func{.cbplay("anpopup2_symbol_shown");});    
  }  
  
  mend	{
    .stdexitdefadv("ad003_ksrod", "gamead003_ksrod0");
	} 
  HINT_CLICK {
    if (!clsave.bis("e1_mg003_drzwi_herb_inserted") && clsave.bis("taken_herb")) 
    {  
      if (popup2_open)
      {
        .showhintitem("herb");
        .showhint("anpopup2_herb");
      }
      else
        .showhint("anherb");
      
    }  
    else if (!popup2_open && !clsave.bis("e1_mg003_drzwi_klucz_inserted") && clsave.bis("taken_klucz_biblioteka"))
    {
      .showhintitem("klucz_biblioteka"); 
      .showhint("ankeyhole");
    }
    else if (!popup2_open && clsave.bis("e1_mg003_drzwi_klucz_inserted") && clsave.bis("e1_mg003_drzwi_herb_inserted"))
    {
       .showhint("anklamka_mask");
    }
    else
    { 
        if(popup2_open)
          .showhint("anpopup2_popexit");  
        else
          .showhint("anpopexit");
      }
  }       
}

game mg003_lustro : Banshee	{
	init	{
		Banshee::init("mg003_lustro");
		.imgs = (A, "bkg.jpg 1", "popup_bkg.pyz 2","anim.pyzH 3","blysk.pyzH 4", "popup_maska.pyz 10", "popup_ramka.pyz 11", "spinka.pyzH 12", "popexit.pyz 13");  
  /*  if (!clsave.bis("e1_mg003_szmata_added"))
     { 
        .addtopck("szmata"); //do testow 
        clsave.bset("e1_mg003_szmata_added");
      }  */ 
    anblysk.setdrawmode(1);
    .setasitemtopck("anspinka");   
    .butpopexit;
		.stdstart;
		
	.sfxs =(A, "skrzypienie_podlogiN 15", "wiatr_w_jaskiniN 50", "przetrzyj", "founditem1 30");
    anpopup_bkg {
  			.Button_isin;
  			.addmethod("butmoveon", func {
  				if( !.advstdstate) return;
  				   if (!clsave.bis("e1_mg003_lustro_szmata_used"))
                advmouse.set("use");  
             else if (!clsave.bis("e1_mg003_lustro_szmata_anim_shown"))
                advmouse.set("take");
             else
                advmouse.setstd;
          } );
  			.addmethod("butmoveoff", func {
  				if( !.advstdstate ) return;
  				  advmouse.setstd;
  				} ); 
  			.addmethod("butclick", func {
  		 	    if( !.advstdstate ||.isvisible_itempopup("spinka")|| ananim.isplaying(-1) ) return;
  		 	    if (clsave.bis("e1_mg003_lustro_szmata_used"))
            {
              advmouse.setstd;
              sgmstate = "lustro_anim" ;
              ananim.play(1); 
              clsave.bset("e1_mg003_lustro_szmata_anim_shown") ; 
            }
        } );
        butgame.add(this);
		};
    imgbkg {
		.Button_isinalpha;
		.addmethod("butclick", func {
			if( !.advstdstate ||.isvisible_itempopup("spinka")|| ananim.isplaying(-1) ) return;
			.mend;
			} );
  		butgame.add(this);
  	};   
    
    ananim.addmethod("onfinish", func {
  		if (!.isvisible_itempopup("spinka") )
        { 
          .advsetstdstate;
          anspinka.show();  
          anspinka.setframe("rotostart",0);
          .show_itempopup("spinka", "anspinka");
          fxfounditem1.play;
        }
         
    } ); 
    
    if (clsave.bis("e1_mg003_lustro_szmata_used"))
    {
      ananim.show();
       
      if (clsave.bis("e1_mg003_lustro_szmata_anim_shown") && !clsave.bis("taken_spinka"))
      {
        anspinka.show();   
        anspinka.setframe(1,0);
        .show_itempopup("spinka", "anspinka");  
        fxfounditem1.play;
      }  
    }
    
    if (!clsave.bis("e1_mg003_lustro_szmata_used")) 
    { 
      .newsnd("sndstart", "kinnat_c0d66");
      sndstart.addmethod("onfinish", "advsetstdstate"); 
      .cbplay("sndstart");
       
    }
    
  } //koniec init
  mend	{
    .stdexitdefadv("ad003_ksrod", "gamead003_ksrod0");
	} 
  HINT_CLICK {
    if (!clsave.bis("taken_spinka")&& clsave.bis("taken_szmata") )
    { 
      .showhint("ananim");
      if (!clsave.bis("e1_mg003_lustro_szmata_used"))
      { 
        .showhintitem("szmata");
      } 
    }
    else
      .showhint("anpopexit");
  }
  
  show_blink{
    sgmstate = "blink_anim" ;
    anblysk.anfadein(1000,"hide_blink");   
  }
  
  hide_blink{
    anblysk.anfadeout(1000,func{.advsetstdstate;});  
  }
  
  
  anspinka_TAKE {
    if( !.isvisible_itempopup("spinka") ) {
         anspinka.setframe("rotostart",0);
        .show_itempopup("spinka", "anspinka");
         fxfounditem1.play;
    } else {
        .hide_itempopup("spinka");  
        .item_gotocenter;
    }
   
  }
  anspinka_INPCK {
    .set_mg_finished; 
    .mend();  
  } 
  popup_spinka_clickexit {
    butgame.sclicked = ("anspinka");
    .anspinka_TAKE;  
  }  
        
  
  USE_szmata	{
		.advsetstdstate();
    if(ananim.isin(mouse.getpos,0,0) && !clsave.bis("e1_mg003_lustro_szmata_used") )	{
      .removefrompck("szmata");
      advmouse.set("take");
      ananim.anfadein(1200,"show_blink");
      clsave.bset("e1_mg003_lustro_szmata_used");
         fxprzetrzyj.play;
		} else {
			.advsetstdstate;
			.item_gotopck;
       
        
		}
	}
        
}

game mg002_witryna : Banshee	{
	init	{
		Banshee::init("mg002_witryna");
		.imgs = (A, "bkg.jpg 1", "popup_bkg.pyz 2","anim_koord.pyzH 3", "klodka.pyz 4", "ramka.pyz 20", "popexit.pyz 21");  
  	.butpopexit;
		.stdstart;
    .newsnd("sndstart", "kinnat_c0d65");
     sndstart.addmethod("onfinish", "advsetstdstate"); 
     .sfxs = (A,"bgrszumN 30", "bgrogienN 15");
    .timplay("tim1", 800,func{.cbplay("sndstart");}); 
/*     if (!clsave.bis("e1_mg002_witryna_spinka_added"))
     { 
         .addtopck("spinka"); //do testow 
        clsave.bset("e1_mg002_witryna_spinka_added");
      } 
*/     
    imgbkg {
  		.addmethod("isbutin", func { (@x, @y)
  			!anpopup_bkg.isin(x,y,0,0);
  			} );
  		.addmethod("butclick", func {
  			if( !.advstdstate ) return;
  			 .mend;
  			} );
    		butgame.add(this);
  	 };
     
     anklodka{
      .Button_isinalpha;
      .addmethod("butmoveon", func {
				if( !.advstdstate) return;
				  if (!clsave.bis("e1_mg002_witryna_spinka_used"))
            advmouse.set("use");   
        } );
			.addmethod("butmoveoff", func {
				if( !.advstdstate ) return;
				  advmouse.setstd;
				} ); 
        butgame.add(this);
      };        
    
     
    
    new Film filmb;
  	filmb.musicclass = ("mus");
  	filmb.addmethod("onfinish", func {
  		  .advsetstdstate;
        .mend(); 
         
  	} );
  	filmb.load("scripts/cs002_klodka/", "film");
  	filmb.showfirstframe;
  	filmb.setz(5);
  	filmb.setpos( ananim_koord.getpx, ananim_koord.getpy );
  	filmb.hide; 
  }
  
  USE_spinka	{
		.advsetstdstate();
    if(anklodka.isin(mouse.getpos,0,0) && !clsave.bis("e1_mg002_witryna_spinka_used") )	{
      .removefrompck("spinka");
      clsave.bset("e1_mg002_witryna_spinka_used"); 
     //filmik
      filmb.play;
      advmouse.setstd; 
    } else {
			.advsetstdstate;
			.item_gotopck;
		}
	} 
  
  HINT_CLICK {
    if (clsave.bis("taken_spinka") && !clsave.bis("e1_mg002_witryna_spinka_used"))
    { 
      .showhint("anpopup_bkg");   
     
      .showhintitem("spinka");
    }
    else
      .showhint("anpopexit");
  } 
  
  mend	{
    .stdexitdefadv("ad002a_kdoors", "gamead002a_kdoors0");
	} 
       
}

game mg002_witryna_open : Banshee	{
	init	{
		Banshee::init("mg002_witryna_open");
		.imgs = (A, "bkg.jpg ","anim_coord.pyzH", "popup_bkg.pyz 2", /*"znak10.pyz","znak10b.pyz", "znak11.pyz", "znak11b.pyz", "znak12.pyz","znak12b.pyz",*/ "symbol2v.pyzH 5", "ramka.pyzG 400", "popexit.pyz 410"); 
  	.butpopexit;
    .loadznakout;
   // .setasznakbut("anznak10"); 
   // .setasznakbut("anznak11");
   // .setasznakbut("anznak12"); 
    
    
    new Film filmb;
  	filmb.musicclass = ("mus");
    filmb.load("scripts/cs002a_popup_ksiazka/", "film");
    filmb.setpos( ananim_coord.getpx, ananim_coord.getpy );  
  	filmb.showfirstframe;
  	filmb.setz(300);
  	filmb.hide;
    filmb.addmethod("onfinish", func {
		  .mend();
		} );  
  
 
    if (!clsave.bis("e1_cs002a_popup_ksiazka_shown")) 
    {
         anpopup_bkg.hide(); 
      	.gui_toloupe("ansymbol2v"); 
        ansymbol2v.anhideonsetframe;  
     
         ansymbol2v{
           .addmethod("isbutin", func { (int x, int y)
    			  .advstdstate && .isin(x,y,0,0) && .loupe_visible;
    				} );
          .addmethod("butclick", func {
          if(!clsave.bis("e1_cs002a_popup_ksiazka_shown")){ 
            .hide();
            .gui_removefromloupe("ansymbol2v"); 
            clsave.bset("e1_cs002a_popup_ksiazka_shown");
            filmb.play();
          }       
          });
          butgame.add(this);
         };   
     }
    else
    {
      ansymbol2v.hide ;
    } 
    
    imgbkg {
		.addmethod("isbutin", func { (@x, @y)
			!anpopup_bkg.isin(x,y,0,0);
			} );
		.addmethod("butclick", func {
			if( !.advstdstate ) return;
			 .mend;
			} );
  		butgame.add(this);
  	};      
   
    
    
    
    .stdstart;
    
    
  } //koniec init
   
  HINT_CLICK {
    .showhint("anpopexit");
  } 
  
  mend	{
    .stdexitdefadv("ad002a_kdoors", "gamead002a_kdoors0");
	} 
       
}


game mg003_ksiazki : Banshee	{
	init	{
		Banshee::init("mg003_ksiazki");
		.imgs = (A, "bkg.jpg 1","popup_bkg.pyz 2", "ksiazka.pyz 3", "ramka.pyz 4", "popexit.pyz 5", "ksiazka_open.pyzH 6", "klucz_biblioteka.pyzH 7");  
  	.setasitemtopck("anklucz_biblioteka"); 
    .butpopexit;
		.stdstart;
    .sfxs =(A, "skrzypienie_podlogiN 15", "wiatr_w_jaskiniN 50", "book2");
      .newsnd("booksnd", "kinnat_c0d65h");
      booksnd.addmethod("onfinish", "advsetstdstate");
   
    imgbkg {
  		.addmethod("isbutin", func { (@x, @y)
  			!anpopup_bkg.isin(x,y,0,0);
  			} );
  		.addmethod("butclick", func {
  			if( !.advstdstate ) return;
  			 .mend;
  			} );
    		butgame.add(this);
  	 };        
      
    
     anksiazka {
  			.Button_isin;
  			.Button_moveonms;
  			.Button_moveoffms;
  			.addmethod("butclick", func {
  		 	    if( !.advstdstate  ) return;
  		 	    if (!clsave.bis("e1_mg003_ksiazki_ksiazka_open"))
            {
              anksiazka_open.anfadein(300,null); 
              anklucz_biblioteka.anfadein(300,null);
              clsave.bset("e1_mg003_ksiazki_ksiazka_open") ;
              .cbplay("booksnd");
              fxbook2.play;
            }
        } );
        butgame.add(this);
      
		};
    
    
    if (clsave.bis("e1_mg003_ksiazki_ksiazka_open"))
    {
      anksiazka_open.show(); 
      anklucz_biblioteka.show();
      
      if (!clsave.bis("taken_klucz_biblioteka"))
        anklucz_biblioteka.show();    
      else
        anklucz_biblioteka.hide();     
       
    }
    
     
  } //koniec init
  
  mend	{
    .stdexitdefadv("ad003_ksrod", "gamead003_ksrod0");
	} 
  
   anklucz_biblioteka_TAKE {
      if( !.isvisible_itempopup("klucz_biblioteka") ) {
         anklucz_biblioteka.setframe("rotostart",0);
         .show_itempopup("klucz_biblioteka", "anklucz_biblioteka");
        } else {
          .hide_itempopup("klucz_biblioteka"); 
          //.item_gotocenter;
          .item_takecenter("klucz_biblioteka");
        }
    }
       
    popup_klucz_biblioteka_clickexit {
      .setactitem("klucz_biblioteka");
      butgame.sclicked = ("anklucz_biblioteka");
      .anklucz_biblioteka_TAKE;
   }
   anklucz_biblioteka_INPCK {
      .set_mg_finished;  
      .addtopck("klucz_biblioteka");
      .mend();
    } 
  
  
  HINT_CLICK {
    if (!clsave.bis("e1_mg003_ksiazki_ksiazka_open"))
      .showhint("anksiazka");  
    else if (!clsave.bis("taken_klucz_biblioteka"))
      .showhint("anklucz_biblioteka");
    else
      .showhint("anpopexit");
  }       
}

game mg004_ksiega : Banshee	{
	
  
  init	{
		new string act_id = "null";
    Banshee::init("mg004_ksiega");
    if(!clsave.bis("e1_kspok_kawalki_zebrane"))
    { 
      .newsnd("snd_brak_kawalkow", "kinnat_c0d69");
      snd_brak_kawalkow.addmethod("onfinish", "advsetstdstate");
      .cbplay("snd_brak_kawalkow");      
    }
    .imgs = (A, "bkg.jpg 0","popup_bkg.pyz 1", "minigame_mask.pyzH 1", "popexit.pyz 2", "slot1.pyzH 3", "slot2.pyzH 2", "slot3.pyzH 3", "slot4.pyzH 4", "slot5.pyzH 5", "1.pyz 6", "2.pyz 7", "3.pyz 8", "4.pyz 9", "5.pyz 5");  
    .butpopexit; 
   // .addtopck("kawalek_ksiazki_5"); //do testow 
    imgbkg {
		.addmethod("isbutin", func { (@x, @y)
			!anminigame_mask.isin(x,y,0,0);
			} );
		.addmethod("butclick", func {
			if( !.advstdstate ) return;
			 .mend;
			} );
  		butgame.add(this);
  	};      
   
    if (!clsave.bis("e1_kspok_kawalki_uzyte"))  
    {
      for(int i=1;i<6;i++)
          <"an"+i>.hide;  
          
      anminigame_mask { 
        .Button_isinvis;
        .addmethod("butmoveon", func {
  				if( !.advstdstate) return;
  				  if(!clsave.bis("e1_kspok_kawalki_uzyte"))
              advmouse.set("use"); 
               
          } );
  			.addmethod("butmoveoff", func {
  				if( !.advstdstate ) return;
  				  advmouse.setstd;
  				} ); 
          butgame.add(this);
                 
      };
       
    }    
  
    if (clsave.bis("e1_mg004_ksiega_1_inserted") )
    { 
      anslot1.show();
      an1.hide(); 
    }  
    else
      .init_coin("1", 820,502);
       
    if (clsave.bis("e1_mg004_ksiega_2_inserted") )
    { 
      anslot2.show();
      an2.hide(); 
    }  
    else
      .init_coin("2", 780,208); 
      
    if (clsave.bis("e1_mg004_ksiega_3_inserted") )
    { 
      anslot3.show();
      an3.hide(); 
    }  
    else
      .init_coin("3", 920,500);
    
    if (clsave.bis("e1_mg004_ksiega_4_inserted") )
    { 
      anslot4.show();
      an4.hide(); 
    }  
    else
      .init_coin("4", 980,180);
    
    if (clsave.bis("e1_mg004_ksiega_5_inserted") )
    { 
      anslot5.show();
      an5.hide(); 
    }  
    else
      .init_coin("5", 930,350);
     
    .stdstart;
     
  } //koniec init
  
  init_coin(string name, int x,int y)
  {
      <"an"+name>(name, x,y){(string name, int x, int y)
        .setpos(x,y);
        .vars2(A,"name", name, "start_x", x, "start_y", y);
           
        .addmethod("isbutin", func { (@x, @y)
  				 .isin(x,y,1,1);
  				} ); 
        .addmethod("butclick", func {
          if( !.advstdstate || .is_mg_finished()) return;
          if(!clsave.bis("e1_kspok_kawalki_zebrane"))
          { 
            .cbplay("snd_brak_kawalkow"); 
            return;
          }
          
          if (act_id == "null")
          {
            act_id = this;
            .setz(300);
          }
          else if(act_id == this)
          { 
            @slot = "anslot"+.name;
            if (<slot>.isin(mouse.getpos,0,1))
            {
              <slot>.show();
              clsave.bset("e1_mg004_ksiega_"+.name+"_inserted" );
              .hide();
              .check_won();     
            }
            else
            { 
              .setpos(.start_x,.start_y) ; 
              .setz(2); 
            }
            act_id = "null";
          }
          butgame.sort; 
          .advsetstdstate;
        } );
        butgame.add(this);
      };
  }
  
  check_all_done()
  {
    for(int i=1;i<6;i++)
    {
      if (<"an"+i>.isvisible)
        return false;
    }  
    return true;
  }
  
  check_won()
  {
    if (.check_all_done())
    {
      .set_mg_finished();
      .timplay("timend", 500, func {
			 .start_film;   
			} );
        
    }
  }
  
  start_film{
    .watch_film("cs02_kinnatbook", "-def", "ad00_endintro");
  }
  
  mouse_move	{
	  if (act_id != "null")
        <act_id>.setpos(mouse.getpos);
	}
  
  go_to_next_location{
    .stdexitdefadv("ad00_endintro", "gamead00_endintro0"); 
  }
  
  USE_kawalek_ksiazki_5	{
		.advsetstdstate();
    if(anminigame_mask.isin(mouse.getpos,0,1) )	{
		 	.removefrompck("kawalek_ksiazki_5");
		   for(int i=1;i<6;i++)
          <"an"+i>.hide;  
      .timplay("time_show_parts",0, func {
			   for(int i=1;i<6;i++)
            <"an"+i>.anfadein(100 *i,null);  
        });
       
      advmouse.setstd;
      clsave.bset("e1_kspok_kawalki_uzyte");
       
		} else {
			 .item_gotopck;
		}
     
	}   
  
  mend	{ 
    .stdexitdefadv("ad004_kspok", "gamead004_kspok0");   
	} 
}
