/* 
	klasa oblugujaca postac z gry
	Dominik Dagiel 3 III 2006
*/

new string sgmlastscene = null;
new string sgmglobpath = null;	// dla gier, ktore sa w innym katalogu niz ich nazwa
new string sgmgame = null;		// jezeli .adv inaczej sie nazywa niz game
new db gdbsound;			// baza dialogow
new classfullsave clsave("saves/save.txt");

new string _slhpref = "cllh";	// prefix do obiektu classloadedhero
new string _spathpref = "pt";	// prefix do obiektu classpathf
new string _spocketpref = "pc";	// prefix do pocket
new string _sstndpref = "stnd";	// prefix do standera
new string _stalkpref = "ctlk";

new bool AdventureGame;

new CutScene ccs(0, 0, iResX, iResY);
ccs.setz(2000);

module modadv	{
	init()	{
		new db dbload;
		new string stalktype;
		this.settalktype("snd");
		new Script scrl(null);
		new string _stalk;
	}
	/********************************/
	public execute(string sfunc)		{	scrl.call(sfunc);		}
	public loadscript(string sfile)		{	scrl.load(sfile);			}
	/********************************/
	public loadsounds(string sfile)	{
		gdbsound.load(sfile);
		if( igmdebug )	{
			gdbsound.save( "exports/adv.dlg" );
		}
	}
	public string gettalktype()	{	return stalktype;	}
	public settalktype(string s)	{	stalktype=s;	}
	/********************************/
	public load(string sfile)			{
		dbload.loadscript(sfile);
		_stalk = this.get("talk:",1);
	}
	public string get(string styp, int ipos)	{
		int id = dbload.findbyrow(styp);
		if( id<0 )	{
			engine.print("modadv.dbload: can't find "+styp);
			return null;
		} else
			return  dbload.get( id, ipos );
	}
}

module modadvglob	{
	init()	{
		new gmobjvec grhero;
		new gmobjvec grfiles;
		new gmobjvec grpck;
	}
	bool addhero(string sname, string sfile, bool bpocket)	{
		clsave.set("hero_"+sname+"_active",1);
		int id = grhero.find(sname);
		if( id>=0 ) {
			if( grfiles.get(id)!=sfile )	{
				grfiles.set(id, sfile);
				<sname>.load( .getpath(sfile) );
			}
			<sname>.addtogamevars(sname);
			if( bpocket )
				<_spocketpref+sname>.addtoadv();
			return false;
		} else {
			this.newanima(sname,sfile,0);
			<sname>.addtogamevars(sname);
			grhero.add(sname);
			grfiles.add(sfile);
			if( bpocket )	{
				string s = _spocketpref+sname;
				if( !.hasvar(s) )	{
					new classadvpocket <s>(sname);
					//<s>.addtogamevars(s);
					grpck.add(s);
					<s>.addtoadv;
					//<s>.enable;
				} else	{
					<s>.addtoadv;
				}
			}
			return true;
		}
	}
	reloadhero(string sname)	{
		int id = grhero.find(sname);
		if( id>=0 )	{
			string s = grfiles.get(id);
			._delhero(sname, false);
			_ = .addhero(sname, s, false);
		}
	}
	delhero(string sname)	{	._delhero(sname, true);	}
	delheros	{	while( grhero.size )	.delhero(grhero.first);	}
	_delhero(string sname, bool bdelpck)	{
		clsave.set("hero_"+sname+"_active",0);
		int id = grhero.find(sname);
		if(id>=0)	{
			delete <sname>;
			grhero.removeat(id);
			grfiles.removeat(id);
			/*if( <gameapi.getgamename>.hasvar("clcamera") )	{
				clcamera.remove(sname);
			}*/
			sname = _spocketpref + sname;
			if( this.hasvar(sname) && bdelpck)	{
				delete <sname>;
				grpck.remove(sname);
			}
		}
	}
	savepck(string s)	{
		grpck.vecsave("saves/grpck_"+s+".txt");
		for( int i=0; i<grpck.size; i++)	{	<grpck.get(i)>.savestate(s);	}
	}
	loadpck(string sfile)	{
		@s2, @s;
// 		engine.setdebugstate(1);
		for( int i=0; i< grpck.size; i++)	{
			s2 = grpck.get(i);
			<s2>.removefromadv;
			delete <s2>;
		}
		grpck.vecload("saves/grpck_"+sfile+".txt");
		for( i=0; i<grpck.size; i++)	{
			s2 = grpck.get(i);
			new classadvpocket <s2>( s2.strsubbs(_spocketpref) );
			<s2>.loadstate(sfile);
			<s2>.removefromadv;
		}
	}
	onexit()	{
		string s;
		for( int i=0; i<grhero.size(); i++)	{
			s = grhero.get(i);
			<s>.stop(false);
			<s>.hide();
			if( .hasvar(_spocketpref+s) )	<_spocketpref+s>.exitpocket;
			s = _spathpref + s;
			<s>.unlinkanima();
		}
	}
}

class classloadedhero	{
	init()	{
		new string sanhero;
		new bool bplaystart = false;
		new bool bplaystop = false;
	}
	public setplaystart(bool b)	{	bplaystart = b;	}
	public setplaystop(bool b)	{	bplaystop = b;	}
	public getstartstop()	{	return bplaystart, bplaystop;	}
}

class classadvcontroller : classadv	{
	init()	{
// 		new TicksCounter ctc;
		AdventureGame = true;
		
		classadv::init();
		
// 		engine.setdebugstate(1);
		
		this.setwavpath( modadv.get("sndpath:", 1) );
		
		new snd __sndplay	{
			.vars2(A,"sfun", null,"sob",null);
			.setstartstopflag(false, true);
			.addmethod("onfinish", func {	.callfun(sob, sfun);	} );
		};
		
		igmstate = 0;
		
// 		new string _slhpref = "cllh";	// prefix do obiektu classloadedhero
// 		new string _spathpref = "pt";	// prefix do obiektu classpathf
// 		new string _spocketpref = "pc";	// prefix do pocket
// 		new string _sstndpref = "stnd";	// prefix do standera
// 		new string _stalkpref = "ctlk";
		
		new classstndgroup modstnd;
		new Music _music;
		
		new timer _tim_dbclk;
		_tim_dbclk.setdelay(200);
		
		new int _if_pos = -1;
		
		new classobjcounter clcbeh("_dbbh");		// prefix do bazy danych bahaviourow
		
		new string _sbeh = "clbeh";	// prefix obiektu behaviour
		new int iidbeh;		// id behavioura niedeklarowanego poprzez nazwe
		
		new classobjcounter clcadv("dbadv");	// bazy danych z przygoda
		
		new db dbmacros;
		new vector _vecarg;	// argumenty wolania makr
		_vecarg.type("string");
		
		new classadvcamera clcamera;	// kamera
		clcamera.setmetonmsmove("advmsmove");
		
		new classwalkerqueue clwalkq;	// kolejnosc chodzenia
		
		new gmadvvec grbuts;		// obiekty do analizowania (buttons)
		new gmimgvec grmsmove;		// kieszenie bohaterow i inne do move
		new gmimgvec grmslclick;
		new gmimgvec grmsrclick;
		new gmimgvec grmslrel;
		
		new string _susetool = null;
		new string _slastms = null;
		new bool bmslock = false;
		new bool _b_rewind = true;
		
		new string sactbeh = null;		// aktualny beh
		new string slastpathf;		// ostatni pathfinder to podawania pozycji buttonow
		
		new int licznik=0;
		
		new string smainhero = null;
		
		.advsaveonstart;
		
		string s, string s2;
		if( sgmgame==null )	{
			sgmgame = this.getname();
		}
		new string sprivgame = sgmgame;
		sgmgame = null;
		
		s2 = sprivgame.strsubbs("game");
		if( sgmglobpath!=null )	{
			s = sgmglobpath;
			sgmglobpath = null;
		} else {
			s = s2;
		}
		this.setgraphpath("scripts/" + s + "/" );
		this.loadadventure( s2 + ".adv");
		grbuts.sortimgs();
		
		if( smainhero==null )	{	smainhero = clcamera.getactor();	}
		
		clcamera.start();
		clcamera.setscene();
		clwalkq.start();
		clwalkq.setverlen(1);
		
		advmouse.setstd();
		
		if( .behexist("preinit") )	{
			.playbehobfin("preinit", this, "playbehinit");
		} else .playbehinit;
		
		grbuts.sortimgs();
	}
	public playbehinit	{
		if ( clsave.bis(sprivgame+"visited") ){
			if ( this.playpostinit( "behinit_FROM_" + sgmlastscene ) )	{
			} else if ( this.playpostinit( "behinit" ) )	{
			}
//			else <gameapi.getgamename()>.postinit();
		} else {
			clsave.bset(sprivgame+"visited");
			if( this.playpostinit( "behinit0_FROM_" + sgmlastscene ) )	{}
			else if ( this.playpostinit( "behinit0" ) )	{}
			else if ( this.playpostinit( "behinit_FROM_" + sgmlastscene ) )	{}
			else if ( this.playpostinit( "behinit" ) )	{}
//			else <gameapi.getgamename()>.postinit();
		}
	}
	public getmainhero()	{
		return smainhero;
	}
	public setmainhero(string s)	{
		smainhero=s;
	}
	public bool ismainhero(string s)	{	return smainhero==s;	}
	public setactbeh(string s)	{	sactbeh = s;	}
	public string getactbeh()	{	return sactbeh;	}
	public bool advgetlock()	{	return bmslock;	}
	public advmslock()	{
		bmslock=true;
		advmouse.setwait();
	}
	public advmsunlock()	{
		bmslock=false;
		advmouse.setstd();
	}
	public advmssetlock(bool block)	{
		block ? this.advmslock() : this.advmsunlock();
	}
	public setusetool(string s)	{	_susetool=s;	}
	public getusetool()	{	return _susetool;	}
	/********************************/
	bool playpostinit( string sbeh ){ 
		return this.playbehobfinif( sbeh, gameapi.getgamename(), "postinit");
	}
	public playbeh(string sname)	{
		this.playbehfin(sname,null);
	}
	public bool playbehif(string sname)	{
		if ( this.behexist( sname ) ){
			this.playbehfin(sname,null);
			return true;
		}
		return false;
	}
	public playbehfin(string sname, string sfunfin)	{
		this.playbehobfin(sname,null,sfunfin);
	}
	public bool playbehfinif(string sname, string sfunfin)	{
		if ( this.behexist( sname ) ){
			this.playbehfin(sname,sfunfin);
			return true;
		}
		return false;
	}
	public playbehobfin(string sname, string sobfin, string sfunfin)	{
		<this.getbeh(sname)>.playfin(sobfin, sfunfin);
	}
	public bool playbehobfinif(string sname, string sobfin, string sfunfin)	{
		if ( this.behexist( sname ) ){
			this.playbehobfin(sname,sobfin,sfunfin);
			return true;
		}
		return false;
	}
	public playnewgamepath(string sgame, string spath)	{
		sgmglobpath = spath;
		sgmlastscene = sprivgame;
		clsave.set("lastscene", sgmlastscene);
		gameapi.play(sgame);
	}
	public playnewgame(string sgame)	{
		this.playnewgamepath(sgame, null);
	}
	public playfromscript(string spath, string sgame)	{
		sgmgame = sgame;
		this.playnewgamepath( modadv.get("defaultadv:",1), spath );
	}
	/********************************/
	string getheroloader(string swavbase)	{
		swavbase = _slhpref + swavbase;
		engine.varexist(swavbase) ? swavbase : null;
	}
	/*********************************/
	public advanstand(string san)	{
		string s =  _spathpref + san;
		if( engine.varexist( s ) && <s>.iswalking() )	{
			<s>.stop(false);
			<s>.stand();
		}
	}
	public reloadhero(string sfile)	{
		.anreload(._getheropath(sfile));
		string sptf = _spathpref + this;
		<sptf>.linkanima(this);
		<sptf>.linkfilter;
		<sptf>.scalean;
	}
	analizeanopts(string sdb, int irow, int icol, int ilecol, string san, string sgrp, string styp)	{
		real r[2], string s1, string s2;
		bool b0 = false, bool b1 = false, int i[3], bool bfont=false;
		while( icol < ilecol )	{
			icol++;
			match(<sdb>.get(irow,icol-1))	{
				"-stt" => {	b0 = <sdb>.get(irow,icol);	icol++;	}
				"-stp"=> {	b1 = <sdb>.get(irow,icol);	icol++;	}
				"-wav"=> { s1 = _slhpref + <sdb>.get(irow,icol);	icol++;
					new classloadedhero <s1>;
					<s1>.varset( "sanhero", san );
					<sgrp>.add( s1 );
				}
				"-path" => {
					classadvanhero::buildheroframe(san);	// on end frame anputgr
					s1 = <sdb>.get(irow,icol);	icol++;	// pathfinder
					r0 = <sdb>.get(irow,icol);	icol++;	// step
					s2 = _spathpref+san;
					this.newclpathfcopy( s2, san, s1, r0);
					<s2>.prepareforhero();
					s1 = s2 + "look";	new classherolooker <s1>;	<s1>.link( san );
					s1 = s2 + "use";	new classherouser <s1>;		<s1>.link( san );
					s1 = s2 + "take";	new classherotaker <s1>;	<s1>.link( san );
				}
				"-ft"=> {	s2 = _spathpref+san;
					r0 = <sdb>.get(irow,icol);	icol++;	// z depth
					r1 = <sdb>.get(irow,icol);	icol++;	// scale power
					<s2>.linkfilter();
					<s2>.setzsize(r0);
					<s2>.setscalepower(r1);
				}
				"-stnd"=> { <_sstndpref+san>.setdelay(<sdb>.get(irow,icol)); icol++; }
				"-txt" => { i0 = <sdb>.get(irow,icol);	icol++;
					i1 = <sdb>.get(irow,icol);	icol++;
					i2 = <sdb>.get(irow,icol);	icol++;
					<_stalkpref+san>.settxtcolor(i0,i1,i2);
				}
				"-font" => {	bfont=true;
					s1 = <sdb>.get(irow,icol);	icol++;
					s2 = <sdb>.get(irow,icol);	icol++;
					if( styp=="hero:" )	{
						<_stalkpref+san>.setfont( s1, s2 );
					}
				}
				? => icol = this.analizeaninstr( sdb ,irow, icol-1, san);
			}
		}
		if( !bfont && styp=="hero:")	{
			<_stalkpref+san>.setfont( modadv.get("font:",1), modadv.get("font:",2) );
		}
		<sgrp>.eval1("setplaystart", b0 );
		<sgrp>.eval1("setplaystop", b1 );
		<sgrp>.free();
	}
	setasadvanima()	{
		classadvanhero::setashero( this.getname(), "cadvherofinish");
	}
	analizebut(string styp, string sdb, int irow, int icol)	{
		string s[3], int i[2];
		s0 = <sdb>.get(irow,icol);	icol++;	// nazwa
		s1 = <sdb>.get(irow,icol);	icol++;	// nazwa annki
		if( s1.contains(".pyz") )	{
			s2 = s1;
			s1 = "an" + s1.strsube(4);
			.newanima( s1, s2, 0);
		}
		styp = styp.strsube(1);
		//<"classadv"+styp.strsube(1)>::setasbutton(s1,s0);
		classadvbut::setasbutton2(s1, s0, styp);
		classadvbut::<"setas"+styp>(s1);
		<s1>.setadvbutpos( <s1>.getcx(), <s1>.getcy() );
		while( icol < <sdb>.getcolsno(irow) )	{
			icol++;
			match( <sdb>.get(irow,icol-1) )	{
				"-pos"=> {	s0 = <sdb>.get(irow,icol);	icol++;	// x
					s2 = <sdb>.get(irow,icol);	icol++;	// y
					if(s0=="-id" && slastpathf!=null)	{
						i0 = <slastpathf>.getbyname(s2);
						s0 = <slastpathf>.getxver(i0) - <slastpathf>.getposx();
						s2 = <slastpathf>.getyver(i0) - <slastpathf>.getposy();
					}
					<s1>.setadvbutpos(s0,s2);
				}
				"-bs1"	=> {	<s1>.setbutbase1( <sdb>.get(irow,icol) ); icol++;}
				"-bs2"	=> {	<s1>.setbutbase2( <sdb>.get(irow,icol) ); icol++;}
				"-us1" => {	<s1>.baseuse1=( <sdb>.get(irow,icol) ); icol++;}
				"-us2" => {	<s1>.baseuse2=( <sdb>.get(irow,icol) ); icol++;}
				"-useon"	=> {	<s1>.setbutbase1( modadv.get("use:",1) );
					<s1>.setbutbase2( modadv.get("use:",2) );
				}
				"-dir"	=> {	<s1>.setbutdir( <sdb>.get(irow,icol) ); icol++;}
				"-noreach"=> 	<s1>.setreach(false);
				"-nh" => <s1>.hideontake = (false);
				"-pck" =>  {	<s1>.setpocket( <sdb>.get(irow,icol) ); icol++;}
				"-mask" => { classadvbut::setasmask(s1); <s1>.hide;	}
				"-inpck" => {
					if( <s1>.hideontake )	{
						<s1>.hide();		// zabranie przedmiotu
					} else <s1>.setbuttyp("but");
					s0 = .getmainhero;
					if( s0==null ) s0 = clcamera.getactor;
					< <s0>.getpocket >.additem( <s1>.getbutname, <s1>.getpocket );
				}
				"-disable" => <s1>.disable;
				"-once" => {
					s0 = <sdb>.get(irow,icol);	icol++;
					<s1>.setonce( s0 );
					if( clsave.bis(s0) ) <s1>.disable;
				}
				? => ;
			}
		}
	}
	_getheropath(string s)	{
		string sp = .getpath(s);
		if( engine.fileexist(sp) )
			"$" + sp;
		else "$" + modadv.get("heropath:",1) + s;
	}
	public loadadventure(string sfile)	{
		string sdb = clcadv.get();
		string sgrp = "grpers"+clcadv.size();
		new db <sdb>;
		//<sdb>.loadbeh(this.getgraphpath()+sfile);
		<sdb>.loadbeh( .getpath(sfile) );
		int ile = <sdb>.getrowsno();
		int i[4], string s[3], bool b[2], bool bhero;
		real r[2];
		
		s0 = sdb + "script";
		new Script <s0>(sdb);
		
		string spath = "";
		new gmobjvec <sgrp>;
		for( int i=0; i<ile; i++)	{
			i0 =0 ;
			i1 = <sdb>.getcolsno(i);
			s0 = <sdb>.get(i,i0);	i0++;
			match(s0)	{
				"setpath:" => {
					spath = <sdb>.get(i,i0);	i0++;
					this.setgraphpath(spath);
				} "nopath:" => {
					spath = "";
					this.setgraphpath(spath);
				} "func"	=> {		// funkcja skryptu
					while( <sdb>.get(i,0)!="end" )	i++;
				} "sndpath:"	=> {
					s0 = <sdb>.get(i,i0);	i0++;
					this.setwavpath(s0);
				} "hero:", "an:"	=> {
					i2 = <sdb>.dbdelvar(i,"-global");
					i3 = <sdb>.dbdelvar(i,"-pck");
					s2 = <sdb>.get(i,i0);	i0++;	// anima
					if( s2.contains(".pyz") )	{
						s1 = s2;
						s2 = "an"+s2.strsubes(".pyz");
					} else {
						s1 = <sdb>.get(i,i0);	i0++;	// file
					}
					if( s0=="hero:" )	{
						/*if( s1.contains(".pyz") && !engine.fileexist(.getpath(s1)) )
							s1 = "$" + modadv.get("heropath:",1) + s1;*/
						if( s1.contains(".pyz") )	{
							s1 = ._getheropath(s1);
							//s1.print;
						}
					}
					if( s1.contains(".pyz") )	{
						if( i2 )	{
							if(modadvglob.addhero(s2,s1,i3))
								<s2>.setasadvanima();
							i1--;
						} else {
							this.newanima(s2, s1, 0);
							<s2>.setasadvanima();
							if( s0=="hero:" && i3)	new classadvpocket <_spocketpref + s2>(s2);
						}
					} else {
						this.copyanima(s1, s2);
						<s2>.setasadvanima();
						if( s0=="hero:" && i3)	new classadvpocket <_spocketpref + s2>(s2);
					}
					if(i3)	i1--;
					if( s0=="hero:" )	{
						new classadvstander <_sstndpref+s2>;
						//classadvanhero::buildheroframe(s2);
						
						//new classadvpocket <_spocketpref + s2>(s2);
						
						s1 = _stalkpref+s2;
						new classtalker <s1>;
						<s1>.set(s2);
						<s1>.settextdb("gdbsound");
					}
					this.analizeanopts(sdb, i, i0, i1, s2, sgrp, s0);
				} "anaac:"	=>	{
					i2 = <sdb>.dbdelvar(i,"-mask");
					i3 = 0;
					s0 = <sdb>.get(i,i0);	i0++;	// anima
					if( s0.contains(".pyz") )	{
						s1 = s0;
						s0 = "an" + s0.strsubes(".pyz");
					} else {
						s1 = <sdb>.get(i,i0);	i0++;	// z ktorej..
					}
					if( i2 )	{
						i1--;
						new gmmaskvec <s0>;
					} else {
						new gmadvvec <s0>;
					}
					if( s1.contains(".pyz") )	{
						.newanima("_" + s0, s1, 0);
						s1 = "_" + s0;
						i3 = 1;
					}
					i2 = this.newanactionsgr(s1, s0, s0);
					i0 = this.analizeaninstr( sdb ,i, i0, s0);
					if( i3 ) <s1>.hide;
				} "anaf:"	=> {
					s0 = <sdb>.get(i,i0);	i0++;	// anima
					//s1 = <sdb>.get(i,i0);	i0++;	// z ktorej..
					if( s0.contains(".pyz") )	{
						s1 = s0;
						s0 = "an" + s0.strsubes(".pyz");
					} else {
						s1 = <sdb>.get(i,i0);	i0++;	// z ktorej..
					}
					new gmimgvec <s0>;
					if( s1.contains(".pyz") )	{
						.newanima("_" + s0, s1, 0);
						s1 = "_" + s0;
					}
					i2 = this.newanfrbyactgr(s1, s0, s0);
					i0 = this.analizeaninstr( sdb ,i, i0, s0);
				} "anfac:"	=> {
					i2 = <sdb>.dbdelvar(i,"-mask");
					s0 = <sdb>.get(i,i0);	i0++;	// anima
					if( i2 )	{
						i1--;
						new gmmaskvec <s0>;
					} else {
						new gmadvvec <s0>;
					}
					s1 = <sdb>.get(i,i0);	i0++;	// z ktorej..
					s2 = <sdb>.get(i,i0);	i0++;	// akcja
					i2 = this.newanframesgr(s1, s0, <s1>.actionnr(s2), s0);
					i0 = this.analizeaninstr( sdb ,i, i0, s0);
				} "anac:"	=> {
					i2 = <sdb>.dbdelvar(i,"-adv");
					s0 = <sdb>.get(i,i0);	i0++;	// anima
					s1 = <sdb>.get(i,i0);	i0++;	// z ktorej..
					s2 = <sdb>.get(i,i0);	i0++;	// akcja
					if( StringChecker::isdigit(s2) )	s2 = <s1>.nameofaction(s2);
					this.copyanimaact(s1, s0, s2);
					if( i2 )	{
						i1--;
						<s0>.setasadvanima();
					}
					i0 = this.analizeaninstr( sdb ,i, i0, s0);
				} "anf:" => {
					i2 = <sdb>.dbdelvar(i,"-mask");
					s0 = <sdb>.get(i,i0);	i0++;	// anima
					s1 = <sdb>.get(i,i0);	i0++;	// z ktorej..
					s2 = <sdb>.get(i,i0);	i0++;	// akcja
					i3 = <sdb>.get(i,i0);	i0++;	// klatka
					this.copyanima( s1, s0 );
					<s0>.setframe(s2,i3);
					if( i2 )	{
						i1--;
						<s0>.setasadvanima();
					}
					i0 = this.analizeaninstr( sdb ,i, i0, s0);
				} "anorder:" => {
					s0 = <sdb>.get(i,i0);	i0++;	// anima
					i0 = this.analizeaninstr( sdb ,i, i0, s0);
				} "behfile:" => {
					this.loadbehaviours( <sdb>.get(i,i0) );
					i0++;
				} "include:" =>	{	// another adv specification
					this.loadadventure( <sdb>.get(i,i0) );
					i0++;
				} "walkqueue:" => {
					while( i0<i1 )	{
						clwalkq.add( _spathpref + <sdb>.get(i,i0) );
						i0++;
					}
				} "font:" => {
					s0 = <sdb>.get(i,i0);	i0++;	// nazwa
					s1 = <sdb>.get(i,i0);	i0++;	// plik
					i2 = <sdb>.get(i,i0);	i0++;	// size
					new font <s0>;
					<s0>.load( s1, i2 );
				} "bkg:" => {
					s0 = <sdb>.get(i,i0);	i0++;	// plik
					//this.csetbkg(s0);
					if( s0.contains(".pyz") )	.newanima("imgbkg", s0, 0);
					else .newimg("imgbkg",s0,0);
				
					i0 = this.analizeaninstr( sdb ,i, i0, "imgbkg");
				} "img:" => {
					s0 = <sdb>.get(i,i0);	i0++;	// nazwa
					if( s0.gete(0,4)->in(A, ".jpg", ".png") )	{
						s1 = s0;
						s0 = "img" + s0.strsube(4);
					} else {
						s1 = <sdb>.get(i,i0);	i0++;	// plik
					}
					this.newimg(s0,s1,0);
					i0 = this.analizeaninstr( sdb ,i, i0, s0);
				} "but:", "doors:", "item:" => {
					this.analizebut(s0, sdb, i, i0);
				} "camera:" => {
					r0 = <sdb>.get(i,i0);	i0++;	// xmodfifier
					r1 = <sdb>.get(i,i0);	i0++;	// ymodifier
					clcamera.scalemodifiers(r0,r1);
					while(i0<i1)	{
						s0 = <sdb>.get(i,i0);	i0++;
						if( s0=="-size")	{
							i2 = <sdb>.get(i,i0);	i0++;
							i3 = <sdb>.get(i,i0);	i0++;
							clcamera.setborders( i2, i3 );
						} else if (s0=="-center")	{
							i2 = <sdb>.get(i,i0);	i0++;
							i3 = <sdb>.get(i,i0);	i0++;
							clcamera.setcenter( i2, i3 );
						} else if (s0=="-sizebg")	{
							clcamera.setborders(imgbkg.getw(), imgbkg.geth());
						}
					}
				} "actor:" => {	clcamera.setactor(<sdb>.get(i,i0)); i0++;
				} "bgr:" => {
					s0 = <sdb>.get(i,i0);	i0++;	// plan
					r0 = <sdb>.get(i,i0);	i0++;	// scalex
					r1 = <sdb>.get(i,i0);	i0++;	// scaley
					new classbgplan <s0>;
					clcamera.addbgr(s0, r0, r1);
				} "pathfinder:" => {
					slastpathf = <sdb>.get(i,i0);	i0++;	// nazwa
					s1 = <sdb>.get(i,i0);	i0++;	// file
					if( s1.contains(".ptf") )	{	
						i2 = 20;
						i3 = 20;
					} else {// znaczy, ze wgrywany z grafiki
						i2 = <sdb>.get(i,i0);	i0++;	// dx
						i3 = <sdb>.get(i,i0);	i0++;	// dy
					}
					this.newpathf(slastpathf, s1, i2, i3);
				} "script:" =>	{
					s0 = <sdb>.get(i,i0);	i0++;	// nazwa
					s1 = <sdb>.get(i,i0);	i0++;	// file
					new Script <s0>(s1);
				} "func:" => {		// wywolanie wewnetrznej funkcji
					s1 = <sdb>.get(i,i0); i0++;
					i1--;		// usuwamy nawiasy
					for(i2=clcadv.size-1; i2 >=0; i2--)	{
						s0 = clcadv.getid(i2) + "script";
						if( <s0>.containsfun(s1) )	{
							for(i2=3; i2< i1; i2++)
								<s0>.ARG = ( i2-3, <sdb>.get(i, i2) );
							i2 = -1;
							<s0>.call(s1);
						}
					}
				}
				"IF" => {
					_if_pos++;
					i = ._found_if(sdb, i, i0, i1);
				}
				"ELSE" => i = ._goto_fi(sdb, i+1);
				"FI" => {
					_if_pos--;
					if( _if_pos<-1 )	("FI error! "+this+"."+ .methodname)->print;
				}
				"bsave:" =>{ 	clsave.bset(<sdb>.get(i,i0)); i0++;}
				"save:" => {
					s0 = <sdb>.get(i,i0); i0++;
					s1 = <sdb>.get(i,i0); i0++;
					clsave.set(s0,s1);
				}
				"stdptf:" => {	slastpathf = <sdb>.get(i,i0); i0++;	}
				"sfxs:" => {
					while(i0<i1)	{
						s0 = <sdb>.get(i,i0); i0++;
						s2 = s0 + ".wav";
						i2=1;
						i3 = 100;
						b0 = false;
						b1 = false;
						r0 = 0.0;
						while(i2 && i0<i1)	{
							s1 = <sdb>.get(i, i0);
							match(s1)	{
								"-f" => {
									i0++;
									s2 = <sdb>.get(i,i0) + ".wav";
								}
								"-v" => {
									i0++;
									i3 = <sdb>.get(i,i0);
								}
								"-l" => b0 = true;
								"-p" => b1 = true;
								"-pl" => r0 = 1.0;
								? => {
									i0--;
									i2 = 0;
								}
							}
							i0++;
						}
						.newsfx(s0, s2);
						<s0>.setvol(i3);
						if( b0 ) <s0>.addmethod("onfinish","_stdsndloop");
						//if( b0 ) <s0>.loop;
						if( b1 ) <s0>.play;
						else if (r0) <s0>.playloop;
					}
				}
				? => ;
			}
		}
		<sdb>.readonly();
	}
	int _found_if(string sdb, int row, int col, int cols)	{
		col++;		// opusc nawias
		int i2 = 0;
		bool odp = 0;
		cols--;
		string s[2];
		while( col<cols )	{
			s0 = <sdb>.get(row, col);
			s1 = <sdb>.dbchecknext(row, col);
			match(s1)	{
				")","|", "&" => {
					odp = ._check_if(i2, odp, s0.getb(0,1)=="!" ? (!clsave.bis(s0.strsubb(1))) : clsave.bis(s0) );
					if( s1=="|" ) i2 = 1;
					else if (s1=="&") i2 = 2;
				}
				"=" => {
					col+=2;
					odp = ._check_if(i2, odp, clsave.is(s0, <sdb>.get(row, col)) );
					i2 = ._check_if2( <sdb>.dbchecknext(row, col) );
				}
				"!=" => {
					col+=2;
					odp = ._check_if(i2, odp, !clsave.is(s0, <sdb>.get(row, col)) );
					i2 = ._check_if2( <sdb>.dbchecknext(row, col) );
				}
				? => ;
			}
			col+=2;
		}
		if( !odp )	{
			._goto_fi(sdb, row+1);
		} else row;
	}
	_goto_fi(string sdb, int row)	{
		int poz = _if_pos;
		while( 1 )	{
			match( <sdb>.get(row,0) )	{
				"IF" => poz++;
				"ELSE" => if( poz==_if_pos ) return row;	// for robi potem i++
					//else poz--;
				"FI" => if( poz==_if_pos ) {
						_if_pos--;
						return row;	// for robi potem i++
					} else poz--;
				? => ;
			}
			row++;
		}
	}
	int _check_if2(string s)	{
		match(s)	{
			"|" => 1;
			"&" => 2;
			? => 0;
		}
	}
	bool _check_if(int opt, bool b, bool bnew)	{
		match( opt )	{
			1 => b || bnew;
			2 => b && bnew;
			? => bnew;
		}
	}
	behrewind()	{	if( sactbeh!=null )	<sactbeh>.rewind();	}
	bool behplaying()	{	return sactbeh!=null;	}
	bool behexist(string sname)	{	return engine.varexist( this.getbeh(sname) );	}
	string getbeh(string sname)	{	return _sbeh+sname;	}
	string newbehname()	{
		string s = _sbeh + "_" + iidbeh;
		iidbeh++;
		return s;
	}
	string newbeh()	{
		string s = this.newbehname();
		new classbehhero <s>;
		return s;
	}
	def _checkvol(string sdb,int irow, int id)	{
		if( <sdb>.dbchecknext(irow, id)=="-v" )	{
			id+=2;
			return <sdb>.get(irow, id), id+1;
		} else return 100, id+1;
	}
	loadbeh(string sdb, int irow, int icol, int id, string sstarter, string sprevobj, bool brand, bool bpar)	{
		string s[4], bool bblock = <sstarter>.getblock(), bool bread;
		s0 = <sdb>.get(irow,id);	id++;
		s1 = this.newbeh();
		int i[2];
		match(s0)	{
			"IF", "ELIF" => {
				i0 = id+1;
				while( <sdb>.get(irow, id)!=")" ) id++;
				<s1>.<"setas"+s0>(sdb, irow, i0, id);
				id++;
			}
			"FI", "ELSE" => <s1>.setas(s0);
			"call:" => {	s0 = <sdb>.get(irow,id);	id++;
				<s1>.setascaller( s0, sdb+"script" );
			}
			"walk:" => {	s0 = <sdb>.get(irow,id);	id++;	// kto
				s2 = <sdb>.get(irow,id);	id++;	// destx lub "id"
				s3 = <sdb>.get(irow,id);	id++;	// desty lub idpath
				<s1>.setaswalker( _spathpref + s0, s2, s3 );
			}
			"turn:" => {	s0 = <sdb>.get(irow,id);	id++;	// kto
				s2 = <sdb>.get(irow,id);	id++;	// dir
				<s1>.setasturn( _spathpref + s0, s2 );
			}
			"setpos:" => {	s0 = <sdb>.get(irow,id);	id++;	// kto
				s2 = <sdb>.get(irow,id);	id++;	// id lub x
				i1 = <sdb>.get(irow,id);
				i0 = 0;
				s3 = <sdb>.dbchecknext(irow,id);
				if( s3=="-ssc" )	{
					i0 = 1;
					id++;
					s3 = <sdb>.dbchecknext(irow,id);
				}
				if( s3=="-dir" )	{
					id+=2;
					s3 = <sdb>.get(irow, id);
				} else {
					s3 = "auto";
				}
				id++;
				<s1>.setasposer( s0, s2, i1, i0, s3 );
			}
			"game:" => {	s0 = <sdb>.get(irow,id);	id++;	// nazwa gry
				match( s0 )	{
					"-def", "-adv" => {
						<s1>.setasnewgamer(s0, <sdb>.get(irow, id), <sdb>.get(irow, id+1) );
						id+=2;
					}
					? => <s1>.setasnewgamer(null, null, s0);
				}
			}
			"ref:" => {		id = this.buildbeh( "_" + iidbeh, sdb, irow, id );
				s0 = this.newbehname();
				<s1>.setascaller( s0.strsubbs(_sbeh), sdb+"script" );
			}
			"anplay:" => {	s0 = <sdb>.get(irow,id);	id++;
				s2 = <sdb>.get(irow,id);	id++;
				<s1>.setasanplayer(s0, s2);
			}
			"anorder:" =>	{	s2 = <sdb>.get(irow,id);	id++;
				<s1>.setasanorder(sdb, irow, id, s2);
				id = this.analizeaninstr(sdb,irow,id,null);
			}
			"sndbg:" =>	{	s0 = <sdb>.get(irow,id);
				|i0, id| = ._checkvol(sdb,irow,id);
				<s1>.setassndbg(s0, i0);
			}
			"sndplay:" =>	{	s0 = <sdb>.get(irow,id);
				|i0, id| = ._checkvol(sdb,irow,id);
				<s1>.setassndplayer(s0, i0);
			}
			"fxplay:" => 	{	s0 = <sdb>.get(irow,id);
				|i0, id| = ._checkvol(sdb,irow,id);
				<s1>.setassndplayer("sfx/"+s0, i0);
			}
			"fxbg:" => 	{	s2 = <sdb>.get(irow,id);
				|i0, id| = ._checkvol(sdb,irow,id);
				<s1>.setassndbg("sfx/"+s2, i0);
			}
			"wait:" =>	{	i0 = <sdb>.get(irow,id);	id++;
				<s1>.setaswaiter(i0);
			}
			"read:" =>	{	s0 = <sdb>.get(irow,id);	id++;	// plik
				i0 = <sdb>.get(irow,id);	id++;	// x
				i1 = <sdb>.get(irow,id);	id++;	// y
				s2 = "auto";
				if( <sdb>.getcolsno(irow)>id )	{
					s2 = <sdb>.get(irow,id);
					if( s2=="-dir" )	{
						id++;
						s2 = <sdb>.get(irow,id); id++;
					}
				}
				<s1>.setasreader(s0,i0,i1,s2);
			}
			"met:" =>	{	s0 = <sdb>.get(irow,id);	id++;
				s3 = gameapi.getgamename;
				if( s0.contains(".") )	{
					s2 = s0.strgetto(".");
					s0 = s0.strgetfrom(".");
					if( s2=="" || s2=="this" ) s2 = s3;
				} else
					s2 = s3;
				<s1>.setasmet(s2, s0);
			}
			"bsave:" =>	{	s0 = <sdb>.get(irow,id);	id++;
				<s1>.setassaver(s0,"1");
			}
			"save:" =>	{	s0 = <sdb>.get(irow,id);	id++;
				s2 = <sdb>.get(irow,id);	id++;
				<s1>.setassaver(s0,s2);
			}
			"script:" =>	{	s0 = <sdb>.get(irow,id);	id++;
				s2 = <sdb>.get(irow,id);	id++;
				<s1>.setasscript(s0,s2);
			}
			"func:" =>	{
				s2 = <sdb>.get(irow,id);
				
				for(i1=clcbeh.size-1; i1 >= 0; i1--)	{
					s0 = clcbeh.getid(i1) + "script";
					if( <s0>.containsfun(s2) )	{
						i1 = -1;
					}
				}
				//s0 = sdb + "script";
				
				if( <sdb>.dbchecknext(irow,id)=="(" )	{
					i1 = id+2;
					while( <sdb>.get(irow,id)!=")" ) id++;
				} else {
					i1 = -1;
				}
				id++;
				<s1>.setasscript(s0,s2, sdb, irow, i1);
			}
			"use:" => {	s0 = <sdb>.get(irow,id);	id++;
				<s1>.setasuse(s0);
			}
			"topck:" => {
				s2 = <sdb>.get(irow,id);	// przedmiot
				if( <sdb>.dbchecknext(irow,id)=="-pck" )	{
					id+=2;
					s3 = <sdb>.get(irow,id);
				} else s3 = s2;
				id++;
				<s1>.setastopck(s2, s3);
			}
			"enter:"	=> <s1>.setasenter;
			"close:"	=> <s1>.setasclose;
			"music:"	=> {
				i1 = id+1;
				while( <sdb>.get(irow,id)!=")" ) id++;
				<s1>.setasmusic(sdb, irow, i1, id);
				id++;
			}
			? => {		// talker
				s3 = s0.strgetto("_");
				s2 = this.getheroloader( s3 );
				if( s2==null )	{
					if( igmdebug ) engine.print(s1+": "+s0+" loadbeh error: no hero linked to "+s3);
					return s1, icol;
					//<s1>.setassndplayer(s0);
				} else {
					|bool bstart, bool bstop| = <s2>.getstartstop();
					string sdir="auto", string sbase=modadv.varget("_stalk"), int itypsort=1;
					bread = id<icol;
					while(bread)	{
						s3 = <sdb>.get(irow,id);	id++;
						match(s3)	{
							"-stt" =>	{	bstart = <sdb>.get(irow,id);	id++;}
							"-stp"=>	{	bstop = <sdb>.get(irow,id);	id++;}
							"-base"=>	{	sbase = <sdb>.get(irow,id);	id++;}
							"-r" =>	itypsort=1; 
							"-nr" =>	itypsort = 0;
							"-dir" =>	{	sdir = <sdb>.get(irow,id);	id++;}
							? => {	bread = false;	id--;	}
						}
						if( bread && id>=icol )	{
							bread = false;
						}
					}
					<s1>.setastalker( <s2>.varget("sanhero"), s0, sbase,
						itypsort, bstart, bstop, sdir );
					
				}
			}
		}
		<sstarter>.addtostarter( s1 );
		
		if( brand==false)	{
			<sprevobj>.setflags(s1);
			<s1>.addflags( sstarter, bblock, bpar );
		} else {
			<sprevobj>.setflags(null);
			<s1>.addflags( sstarter, bblock, false );
		}
		/*if( id < icol )	{
			this.loadbeh(sdb,irow,icol,id,sstarter,s1,brand, bpar);
		}*/
		return s1, id;
	}
	int buildbeh(string sname, string sdb, int irow, int icol)	{
		int id = dbmacros.findbyrow( <sdb>.get(irow, icol) );
		if( id<0 )	{
			engine.print("no such macro: "+ <sdb>.get(irow, icol) );
			return -1;	
		}	// nie ma takiego makra
		while( <sdb>.get(irow, icol) != "(" )	{	icol++;	}
		icol++;
		int id2 = <sdb>.addrow() -1;
		string s = <sdb>.get( irow, icol ); icol++;
		_vecarg.free();
		while( s!=")" )	{		// sczytanie argumentow
			_vecarg.add( s );
			s = <sdb>.get( irow, icol ); icol++;
		}
		int ile = dbmacros.getcolsno( id );
		int i1;
		<sdb>.add( id2, sname );
		for( int i=1; i<ile; i++)	{
			s = dbmacros.get( id, i );
			if( s.getb(0,1)=="$" )	{
				i1 = s.getb(1,10);
				<sdb>.add( id2, _vecarg.get( i1-1 ) );
			} else {
				<sdb>.add( id2, s );
			}
		}
		return icol;
	}
	loadbehaviours(string sfile)	{
		string sdb = clcbeh.get();
		new db <sdb>;
		//<sdb>.loadbeh(this.getgraphpath()+sfile);
		<sdb>.loadbeh( .getpath(sfile) );
		string s = sdb + "script";
		new Script <s>(sdb);
		int i[2], string s[4], bool brand, bool bread, string bonce, bool bpar, bool bblock, int ienumer;
		int iifsave, string sifsave, string sifvar;
		for( int i=0; i< <sdb>.getrowsno(); i++)	{
			i1 = 0;
			s0 = <sdb>.get(i,i1);	i1++;
			match(s0)	{
				"macro:" => { dbmacros.dbaddrowfrom( sdb, i, 1 );
				} "include:" => {	this.loadbehaviours(<sdb>.get(i,i1));
					i1++;
				} "build:" => { i1 = this.buildbeh( <sdb>.get(i,i1), sdb, i, i1+1 );
				} "func" => 	{ while( <sdb>.get(i,0)!="end" )	i++;
				} "IF" => { _if_pos++;	i = ._found_if( sdb, i, i1, <sdb>.getcolsno(i) );
				} "ELSE" => { i = ._goto_fi(sdb, i+1);
				} "FI" => {
					_if_pos--;
					if( _if_pos< -1 )	("FI error! "+this+"."+ .methodname)->print;
				}
				? => {
					i0 = <sdb>.getcolsno(i);
					s0 = this.getbeh(s0);
					new classbehhero <s0>;
					brand = false;
					bread = true;
					bonce = null;
					bpar = false;
					bblock = true;
					//bblock = false;
					sifvar = null;
					iifsave = -1;
					ienumer=0;
					while(bread)	{
						s1 = <sdb>.get(i,i1);	i1++;
						match(s1)	{
							"-nr"	=>	brand = false;
							"-once"	=>	{ bonce = <sdb>.get(i,i1);	i1++;}
							"-par"=>	bpar = true;
							"-r"	=>	brand = true;
							"-nb"=>	bblock = false;
							"-b"=>		bblock = true;
							"-en"=>	{	ienumer = <sdb>.get(i,i1);	i1++;}
							"-bif"=>	{	iifsave = 1;
								sifsave = <sdb>.get(i,i1);	i1++;
								sifvar=true;
							}
							"-bnif"=>	{	iifsave = 0;
								sifsave = <sdb>.get(i,i1);	i1++;
								sifvar=true;
							}
							"-if"	=>	{	iifsave = 1;
								sifsave = <sdb>.get(i,i1);	i1++;
								sifvar = <sdb>.get(i,i1);	i1++;
							}
							"-nif" =>	{	iifsave = 0;
								sifsave = <sdb>.get(i,i1);	i1++;
								sifvar = <sdb>.get(i,i1);	i1++;
							}
							?	=>	{	bread = false;
								<s0>.setasstarter(bonce, brand, bpar, bblock, ienumer, iifsave, sifsave, sifvar);
								//this.loadbeh(sdb, i, i0, i1-1, s0, s0, brand, bpar);
								
								// loadbeh(string sdb, int irow, int icol, int id, string sstarter, string sprevobj, bool brand, bool bpar)	{
								/*if( id < icol )	{
									this.loadbeh(sdb,irow,icol,id,sstarter,s1,brand, bpar);
								}*/
								i1--;
								s1 = s0;	// sstarter
								while( i1<i0 )	{
									|s1, i1| = .loadbeh( sdb, i, i0, i1, s0, s1, brand, bpar);
								}
							}
						}
					}
				}
			}
		}
		<sdb>.readonly();
	}
	int analizeaninstr(string sdb,int irow,  int icol, string san)	{
		bool bread = true;
		if( icol >= <sdb>.getcolsno(irow) )	{	bread=false;	}
		bool banalize = false;
		if( san!=null )	{
			banalize=true;
			this.advanstand(san);
		}
		int i[3];
		string s[2];
		while(bread)	{
			s1 = <sdb>.get(irow,icol);	icol++;
			match(s1)	{
				"-z"		=>	{
					if( banalize)	<san>.setz( <sdb>.get(irow,icol) );
					icol++;
				}
				"-pos"	=>	{	s0 = <sdb>.get(irow,icol);	icol++;
					i2 = <sdb>.get(irow,icol);	icol++;
					if( banalize)	{
						if(s0=="-id")	{
							s0 = _spathpref+san;
							i0 = <s0>.getbyname(i2);
							i1 = <s0>.getxver(i0) - <s0>.getposx;
							i2 = <s0>.getyver(i0) - <s0>.getposy;
						} else i1=s0;
						//<san>.setpos( i1+ clcamera.getposx(), i2+ clcamera.getposy() );
						<san>.setpos( i1, i2 );
					}
				}
				"-putgr"	=>	if( banalize )	<san>.anputgr();
				"-vis"	=>	{	i0 = <sdb>.get(irow,icol);	icol++;
					if( banalize )	i0==false ? <san>.hide() : <san>.show();
				}
				"-show"	=>	if( banalize )	<san>.show();
				"-hide"	=>	if( banalize )	<san>.hide();
				"-dir"	=>	{s0 = <sdb>.get(irow,icol);	icol++;
					if( banalize)	{
						s1 = <san>.actionname();
						i0 = <san>.framenr();
						<san>.setframe( s1.strsube(2) + s0, 0 );
					}
				}
				"-play"	=>	{
					if( banalize)	<san>.play( <sdb>.get(irow,icol) );
					icol++;
				}
				"-nplay"	=>	{i0 = <sdb>.get(irow,icol);	icol++;
					if( banalize)	<san>.nplay( i0 );
				}
				"-lplay"	=>	{
					if( banalize)	<san>.anloopsplay( <sdb>.get(irow,icol) );
					icol++;
				}
				"-bgr"	=>	{s1 = <sdb>.get(irow,icol);	icol++;
					if( banalize)	{
						<s1>.add(san);
						if( engine.varexist( _spathpref + san ) )	<s1>.add( _spathpref+san );
					}
				}
				"-sc"		=>
					if( banalize)	{
						s1 = _spathpref+san;
						if( engine.varexist( s1 ) )	<s1>.scalean();
					}
				"-ssc"	=>	if( banalize)	clcamera.setscene();
				"-actor"	=>	if( banalize)	clcamera.setactor(san);
				"-mhero"	=>	if( banalize)	this.setmainhero(san);
				"-puty"	=>	{s0 = <sdb>.get(irow,icol);	icol++;
					if( banalize)	s0=="resy" ? <san>.anputy( iResY-1 ) : <san>.anputy(s0);
				}
				"-stopf"	=>	if( banalize )	<san>.stop(false);
				"-stoph"	=>	if( banalize )	{
					<san>.stop(false);
					<san>.hide;
				}
				"-setaction" =>	{s0 = <sdb>.get(irow,icol);	icol++;
					if( banalize)	{
						if( StringChecker::isdigit(s0) )	<san>.setframe(s0.to_i, 0);
						else <san>.setframe(s0, 0);
						<san>.stop(false);
					}
				}
				"-setframe"	=>	{s0 = <sdb>.get(irow,icol);	icol++;
					i0 = <sdb>.get(irow,icol);	icol++;
					if( banalize)	{
						if( StringChecker::isdigit(s0) )	<san>.setframe(s0.to_i, i0);
						else <san>.setframe(s0, i0);
						<san>.stop(false);
					}
				}
				"-stand"	=>	{
					if( banalize)	<san>.setstandbase(<sdb>.get(irow,icol));
					icol++;
				}
				"-delay"	=>	{
					if( banalize)	<san>.setdelay(<sdb>.get(irow,icol));
					icol++;
				}
				"-step" => {
					if( banalize)	< _spathpref + san >.setanstep(<sdb>.get(irow,icol));
					icol++;
				}
				"-sb1" => {	if( banalize)	< san >.setbutbase1(<sdb>.get(irow,icol));	// dla buttona
					icol++;	}
				"-sb2" => {	if( banalize)	< san >.setbutbase2(<sdb>.get(irow,icol));	// dla buttona
					icol++;	}
				?	=>	{	bread = false;		// natrafil na inny string
					icol--;		// przywroc go do analizy
				}
			}
			if( bread && icol>=<sdb>.getcolsno(irow) )	bread = false;
		}
		return icol;
	}
	/*******************************/
	cadvherofinish()	{}
	/*******************************/
	butmoveoff(string sbut)	{
		<sbut>.moveoff();
		this.< <sbut>.getbutname() + "_MOVEOFF">();
	}
	butmoveon(string sbut)	{
		<sbut>.moveon();
		this.< <sbut>.getbutname() + "_MOVEON">();
	}
	advmsmove()	{
		if ( !this.advgetlock() ){
			|int x, int y| = mouse.getpos();
			int id = grbuts.butisin(x,y,true,true);
			if( id )	{
				string s = grbuts.get(id-1);
				if( s!=_slastms )	{
					if( _slastms!=null )	this.butmoveoff(_slastms);
					_slastms = s;
					this.butmoveon(s);
				}
			} else {
				if( _slastms!=null )	{
					this.butmoveoff(_slastms);
					_slastms = null;
				}
			}
			grmsmove.eval2("onmousemove", x, y);
			moddbg.msmove();
		}
	}
	butclickon(string sbut)	{
		//string s = _spocketpref+this.getmainhero();
		//if( engine.varexist(s) )	<s>.skipitem();
		<sbut>.clickon();
		//this.< <sbut>.getbutname() + "_CLICKON">();
		if( !.behplaying )
			_b_rewind = !.playbehif( "beh_"+ <sbut>.getbutname +"_LCLICK" );
	}
	butrelease(string sbut)	{
		//string s = _spocketpref+this.getmainhero();
		//if( engine.varexist(s) )	<s>.skipitem();
		<sbut>.lrel();
		//this.< <sbut>.getbutname() + "_RELEASE">();
	}
	advmsclick()	{
		if( _tim_dbclk.isplaying )	{
			clwalkq.mulspeed(2);
			return;
		} else _tim_dbclk.play;
		_b_rewind = true;
		if( !bmslock )	{
			|int x, int y| = mouse.getpos();
			int id = grbuts.butisin(x,y,true,true);
			if( id )
				this.butclickon(grbuts.get(id-1));
			else {
				string s = _spocketpref+this.getmainhero();
				if( engine.varexist(s) )	<s>.itemhide;
				clwalkq.goto(x,y);
			}
			grmslclick.eval2("onmouselclick",x,y);
		}
		if(_b_rewind) this.behrewind();
		moddbg.mslclick();
	}
	advmsrclick	{
		if( !bmslock )	{
			grmsrclick.eval2("onmouserclick",mouse.getpos);
		}
	}
	advmslrel() {
		if( !bmslock )	{
			|int x, int y| = mouse.getpos();
			int id = grbuts.butisin(x,y,true,true);
			if( id )	this.butrelease(grbuts.get(id-1));
			grmslrel.eval2("onmouselrel",x,y);
		}
		moddbg.mslrel();
	}
	mousemove()	{
		if( igmstate==0 ) this.advmsmove();
		this.mouse_MOVE();
	}
	mouselclick()	{
		if( igmstate==0 ) this.advmsclick();
		this.mouse_LCLICK();
	}
	mouselrel()	{
		if( igmstate==0 ) this.advmslrel();
		this.mouse_LREL();
	}
	mouserclick()	{
		if( igmstate==0 ) .advmsrclick;
		this.mouse_RCLICK();
	}
	keydown()	{
		moddbg.dbkeydown();
		this.keyboard_KEYDOWN();
	}
	exit()	{
		modadvglob.onexit();
		if( igmsubtitle )	{
			subtitle.reset;
		}
	}
	onmusicfin	{
		_music.play;
	}
	/*******************************/
	sndplayobfin(string s, string sob, string sfun)	{
		__sndplay.load( .getsndpath + s + ".wav" );
		if( igmsubtitle )	{
			subtitle.register("__sndplay", this.getsndpath() + s + ".wav");
		}
		__sndplay.sob = (sob);
		__sndplay.sfun = (sfun);
		.cbsplay("__sndplay");
	}
	sndplayfin(string s, string sfun)	{	.sndplayobfin(s,null,sfun);	}
	sndplay(string s)	{	.sndplayobfin(s, null, null);	}
	/*******************************/
	advsaveonstart	{
		//clsave.set("GAME_game", this);
		clsave.set("GAME_game", gameapi.getgamename);
		clsave.set("GAME_sgmgame", sgmgame);
		clsave.set("GAME_sgmglobpath", sgmglobpath);
		clsave.set("GAME_sgmlastscene", sgmlastscene);
		clsave.set("GAME_ccs", ccs.isvisible);
		.advautosave;
	}
	advautosave	{
		clsave.save("saves/autosave.txt");
		modadvglob.savepck("autosave");
	}
	advautoload	{	._advload("autosave");	}
	advcacheload	{	._advload("cache");	}
	advcachesave	{	._advsave("cache");	}
	_advload(string s)	{
		modadvglob.delheros;
		modadvglob.loadpck(s);
		
		clsave.load("saves/"+s+".txt");
		sgmgame = clsave.get("GAME_sgmgame");
		sgmglobpath = clsave.get("GAME_sgmglobpath");
		sgmlastscene = clsave.get("GAME_sgmlastscene");
		if( clsave.bis("GAME_ccs") ) ccs.show; else ccs.hide;
		gameapi.play( clsave.get("GAME_game") );
	}
	_advsave(string s)	{
		new classfullsave _saver("saves/" + s + ".txt");
		_saver.load("saves/autosave.txt");
		_saver.stdsave;
		delete _saver;
		new vector _vcsave;	_vcsave.type("string");
		new vector _vcsv2;	_vcsv2.type("string");
		_vcsave.vecload("saves/grpck_autosave.txt");
		_vcsave.vecsave("saves/grpck_"+s+".txt");
		@s2;
		for( int i=0; i<_vcsave.size; i++)	{
			s2 = _vcsave.get(i);
			_vcsv2.vecload("saves/" + s2 + "autosave_name.txt" );
			_vcsv2.vecsave("saves/" + s2 + s + "_name.txt" );
			_vcsv2.vecload("saves/" + s2 + "autosave_file.txt" );
			_vcsv2.vecsave("saves/" + s2 + s + "_file.txt" );
		}
		delete _vcsave;
		delete _vcsv2;
// 		arPocket.save( "saves/" + this+sfilepref + "_name.txt" );
// 		arPocketFile.save( "saves/" + this+sfilepref + "_file.txt" );
	}
	/*****************************/
	advloadsnd(string sfile)	{
		.load( this.getsndpath() + sfile );
		if( igmsubtitle )	{
			subtitle.register(.getfullname, this.getsndpath() + sfile);
		}
	}
}
