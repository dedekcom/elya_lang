/******** konstrukcje  ********************/
new string	A = "!!!";
new real		PI = 3.14159265358979323846;
new int		BYTE0 = "0"->getbyte(0);
new int		BYTE9 = "9"->getbyte(0);
new int		BYTEa = "a"->getbyte(0);
new int		BYTEz = "z"->getbyte(0);
new int		BYTEA = "A"->getbyte(0);
new int		BYTEZ = "Z"->getbyte(0);
new int		BYTE_ = "_"->getbyte(0);

public varget(string svar)				{	[svar];				}
public varset(string svar, def val)			{	<svar> = val;			}
public varnew(string styp, string svar)	{	new <styp> <svar>;	}
public varnewif(string styp, string svar)	{	if( !.hasvar(svar) )	.varnew(styp,svar);}
public vardel(string svar)				{	delete <svar>;		}
public reader(string sname)	{
	.varnewif("def", sname);
	.addmethod( sname, func { [.methodname]; } );
}
public writer(string sname)	{
	.varnewif("def", sname);
	.addmethod( sname+"=", func { (def val) <.methodname->strsube(1)> = val; } );
}
public var(string sname)	{
	.reader(sname);
	.writer(sname);
}
public var2(string sname, def val)	{
	.var(sname);
	<sname> = val;
}
public withlist(string sfun)	{
	@s = _;
	while( A != s )	{
		.<sfun>(s);
		@s = _;
	}
}
public vars	{	.withlist("var");}
/*****************************************************/
public bool in	{
	bool b = false;
	@x = .get;
	@y = _;
	while( A != y )	{
		if( !b )	b = x==y;
		@y=_;
	}
	b;
}
public with(string sfun)	{
	string sob = _;
	while( sob!=A )	{
		<sob>.<sfun>();
		sob=_;
	}
}
public copycall(string sfun, string sob)	{
	string s = "__call" + sfun;
	new string <s>;
	<s> = sob;
	.addmethod( sfun, func {
		string sf = .methodname;
		< [ "__call" + sf ] >.<sf>();
		});
}
public copycalls(string sobj)	{
	string s = _;
	while( s!=A )	{
		.copycall( s, sobj ); 
		s=_;
	}
}
/***********************************/
public mresize()	{	< .gettype + "_pack">::resizemethods( this );	}
/******** petle ********************/
public times(string sfun)		{	this.for_plus(0, this.get()-1, sfun );		}
public upto(int ito, string sfun)	{	this.for_plus( this.get(), ito, sfun );	}
public downto(int ito, string sfun)	{	this.for_minus( this.get(), ito, sfun );	}
public for_plus(int ifrom, int ito, string sfun)	{
	if( ito-ifrom<=0 )	return;
	for( ; ifrom<=ito; ifrom++)	this.<sfun>(ifrom);
}
public for_minus(int ifrom, int ito, string sfun)	{
	if( ifrom-ito<=0 )	return;
	for( ; ifrom>=ito; ifrom--)	this.<sfun>(ifrom);
}
public double_for(int w, int h, string sfun)	{
	int j;
	for( int i=0; i<w; i++)	{
		for( j=0; j<h; j++)	{
			this.<sfun>(i,j);
		}
	}
}
/****************************************/

// klasa do np. dynamicznego tworzenia obiektow z prefixem+id
class classobjcounter	{
	init(string sprefix)	{
		new string _sprefix=sprefix;
		new int _iile=0;
	}
	string get()	{
		_iile++;
		return _sprefix + (_iile-1);
	}
	int size()	{_iile;}
}

/*class classvsigobj	{
	init()	{
		new bool bplaying=false;
	}
	virtual play()	{	bplaying=true;	}
	virtual stop(bool bstop)	{ 
		bplaying=false;
		if( bstop )	{	this.onfinish();	}
	}
	virtual bool isplaying()	{	bplaying;	}
}*/

/***************************************************************************/

class classsignals	{
	init()	{}
	/********** std obj **********************/
	stdfinish(string sob) { <sob>.addmethod("onfinish",func { this.<this.getname()+"_FINISH">();}); }
	stdstart(string sob) { <sob>.addmethod("onstart",func { this.<this.getname()+"_START">(); }); }
	stdsigs(string sob)	{
		this.stdstart(sob);
		this.stdfinish(sob);
	}
	/********** anima **********************/
	buildanima(string san)	{
		this.stdsigs(san);
		<san>.addmethod("onendframe", func { this.<this.getname()+"_ENDFRAME">(); } );
	}
	/********** snd **********************/
	buildsnd(string ssnd)	{	this.stdsigs(ssnd);		}
	/********** timer **********************/
	buildtimer(string stimer)	{
		this.stdsigs(stimer);
		<stimer>.addmethod("ontick", func { this.<this.getname()+"_TICK">(); });
	}
	/********** button *******************/
	buildbut(string sbut)	{
		<sbut>.addmethod("onclick", func { this.<this.getname()+"_CLICK">(); });
		<sbut>.addmethod("onrel", func { this.<this.getname()+"_REL">(); });
		<sbut>.addmethod("onmoveon", func { this.<this.getname()+"_MOVEON">(); });
		<sbut>.addmethod("onmoveoff", func { this.<this.getname()+"_MOVEOFF">(); });
	}
}

/******************************************************************/

class classlocker	{
	init()	{
		new bool _block = true;
	}
	public lock()	{	_block=true;	}
	public unlock()	{	_block=false;	}
	public setlock(bool b)	{	_block=b;	}
	public bool getlock()	{	return _block;	}
	public bool unlocked	{	_block==false;	}
}

/***************************************************************************/

module classdbreader	{
	init()	{
		new db dbl;
	}
	readdb( string sfunc )	{
		int id = 0;
		int ile = dbl.getrowsno();
		while( id < ile )	{
			this.<sfunc>( id );
			id++;
		}
	}
	readrow( string srow, string sfunc )	{
		int ipos = dbl.findbyrow( srow );
		if( ipos >= 0 )	{
			this.<sfunc>( ipos );
		}
	}
}

/***************************************************************************/


/***************************************************************************/
class collection	{
	init(string styp)	{	new string stype=styp;	}
	public string type()	{	return stype;		}
}

class array : collection {
	init(string styp, int idimens, int isiz)	{
		collection::init(styp);
		new int idim = idimens;
		new int isize = isiz;
		new vector vec;
		vec.type(styp);
		if( idimens<=0 || isiz<=0 )	return;
		//vec.resize( isiz.pow(isiz,idimens), 0 );
		vec.resize( isiz.pow(idimens), 0 );
	}
	int getid()	{
		int pos=0;
		int dim=idim-1;
		while(dim>0)	{
			pos+=_;
			pos*=isize;
			dim--;
		}
		return pos+_;
	}
	public def get()	{	return vec.get( this.getid() );	}
	public set(def svar)	{	vec.set( this.getid(), svar);	}
	public int getsize()	{	return isize;			}
	public int getdim()	{	return idim;			}
}

class stack : collection	{
	init(string styp)	{
		collection::init(styp);
		new vector vec;
		vec.type(styp);
		new <styp> var;
	}
	public push(string svar){	vec.add(svar);		}
	public def top()	{	return vec.last();	}
	public def pop()	{
		var = this.top();
		vec.removeat( vec.size()-1 );
		return var;
	}
	public free	{	vec.free;	}
}

class map : collection	{
	init(string styp)	{
		collection::init(styp);
		new int isize=0;
	}
	set(string svar, def val)	{
		if( !this.hasvar(svar) )	this.add(svar);
		<"v"+svar>.set(val);
	}
	add(string svar)	{	new <stype> <"v"+svar>;		}
	def get(string svar)	{	return ["v"+svar];		}
	remove(string svar)	{	delete <"v"+svar>;		}
	bool contains(string svar){	return this.hasvar("v"+svar);	}
}
class map2 : collection	{
	init(string styp)	{
		collection::init(styp);
		new vector vn;
		vn.type("string");
		new vector vec;
		vec.type(styp);
	}
	add(string svar, def val)	{	vn.add(svar);	vec.add(val);	}
	set(string svar, def val)	{	vec.set( vn.find(svar), val );	}
	bool contains(string svar)	{	return vn.contains(svar);	}
	def get(string svar)		{	return vec.get( vn.find(svar) );}
	remove(string svar)	{
		int id = vn.find(svar);
		if( id>=0 )	{
			vec.removeat( id );
			vn.removeat(id);
		}
	}
	free()	{	vn.free();	vec.free();	}
}


/***************************************************************************/
class classgamemusic : classdbreader	{
	init()	{
		classdbreader::init();
		new string smuspath = "";
		new string sbgrpath = "";
		new snd _sndbgr;
		_sndbgr.addmethod("onfinish", "_stdsndloop");
	}
	reset()	{
		gameapi.stopmusic();
		this.stopbgr();
	}
	_stdsndloop()	{	this.play(); }
	load(string sfile)	{	dbl.loadscript( sfile );	}
	musicpath(string s)	{	smuspath = s;	}
	sndbgrpath(string s)	{	sbgrpath=s;	}
	_play(int ipos)	{
		int i[3], string s[2];
		i0 = 1;
		i1 = dbl.getcolsno( ipos );
		while( i0 < i1 )	{
			s0 = dbl.get( ipos, i0 );	i0++;
			if( s0 == "music" )	{
				s1 = smuspath + dbl.get( ipos, i0 );
				i0++;
				if( i0 < i1 )	{
					if( dbl.get( ipos, i0 )=="vol" )	{
						i0++;
						gameapi.setmusicvol( dbl.get( ipos, i0 ) );
						i0++;
					}
				} else {
					gameapi.setmusicvol( 100 );
				}
				gameapi.playmusic( s1 );
			} else if (s0 == "bgr")	{
				_sndbgr.load( sbgrpath + dbl.get( ipos, i0 ) );
				i0++;
				if( i0 < i1 )	{
					if( dbl.get( ipos, i0 )=="vol" )	{
						i0++;
						_sndbgr.setvol( dbl.get( ipos, i0 ) );
						i0++;
					}
				} else {
					_sndbgr.setvol( 100 );
				}
				this.playbgr();
			} else {	i0++;	}
		}
	}
	play()	{
		this.reset();
		this.readrow( gameapi.getgamename(), "_play" );
	}
	playbgr()		{	_sndbgr.play();	}
	stopbgr()	{	_sndbgr.stop(false);	}
}

/**************************************************************/
	// zmienne globalna - stany gry
new int igmstate;
new int igmdebug;
new int igmeasy;
new int igmdemo;
new int igmbegin;
new string sgmfontfile = "configs/fonts/ala.ttf";
new string sgmfontmono = "configs/fonts/mono.ttf";

new int iResX = 800;
new int iResY = 600;

/**************************************************************/
	// standardowa klasa do tworzenia zmiennych
class newvars		{
	init()	{
		new string _sclpath = "";
		new string _sclwavpath = "";
	}
	string _checkfont(string sfont, int isize, string sfnt)	{
		if( sfont==null )	sfont=sgmfontfile;
		if( sfont.contains(".ttf") )	{
			new font <sfnt>;
			<sfnt>.load( sfont, isize );
			sfont = sfnt;
		}
		sfont;
	}
	string checkfont(string sfont, int isize)	{
		._checkfont(sfont, isize, "_fnt");
	}
	bool begingame()	{
		igmbegin = !igmbegin;
		!igmbegin;
	}
	newarray(string styp, string sbase, int size)	{
		if( size<= 0 )	return;
		size--;
		while(size>=0)	{
			new <styp> <sbase+size>;
			size--;
		}
	}
	setgraphpath(string spath)	{	_sclpath = spath;	}
	setwavpath(string spath)	{ _sclwavpath = spath; }
	string getgraphpath()	{	return _sclpath; }
	string getsndpath()	{	return _sclwavpath; }
	newanima(string sname, string sfile, int z)	{
		new anima <sname>;
		<sname>.load(this.getgraphpath() + sfile);
		<sname>.setz(z);
	}
	newstdanima(string sname, string sfile, int z)	{
		this.newanima(sname, sfile, z);
		this.stdanaction(sname);
	}
	copyanimaactz(string ssrc, string sdest, string saction, int z)	{
		this.copyanimaact(ssrc, sdest, saction);
		<sdest>.setz(z);
	}
	copyanimaact(string ssrc, string sdest, string saction)	{
		this.copyanima(ssrc, sdest);
		<sdest>.setframe( saction, 0 );
	}
	copyanima(string ssrc, string sdest)	{
		new anima <sdest>;
		<sdest>.copy( ssrc );
	}
	copyanimas(string san, string sname, int istart, int ilosc)	{
		if (ilosc<0)	return;
		for(int i=0; i<ilosc; i++)	this.copyanima( san, sname + (istart + i)  );
	}
	newanimas(string sname, string sfile, int z, int ilosc)	{
		if(ilosc<0) return; 
		this.newanima(sname+"0", sfile, z);		// pierwsza load z zerem
		this.copyanimas(sname+"0", sname, 1, ilosc-1);		// pozostale kopiowane z niej
	}
	int newanframesgr(string san, string sname, int iaction, string sgr)	{	// tworzy animacje z klatek
		int ile = <san>.nofframes( iaction );
		this.copyanimas( san, sname, 0, ile );
		for(int i=0; i<ile; i++)	{
			<sname+i>.setframe(iaction, i);
			if( sgr!=null )	{	<sgr>.add( sname+i );	}
		}
		return ile;		// zwraca ilosc stworzonych animacji
	}
	int newanframes(string san, string sname, int iaction)	{	// tworzy animacje z klatek
		return this.newanframesgr(san,sname,iaction,null);
	}
	newcanvas(string sname, int w, int h, int r, int g, int b, int a, int z)	{
		new img <sname>;
		<sname>.create(w,h,r,g,b,a);
		<sname>.setz(z);
	}
	newimg(string sname, string sfile, int z)	{
		new img <sname>;
		<sname>.load(this.getgraphpath() + sfile);
		<sname>.setz(z);
	}
	copyimg(string ssrc, string sdest)	{
		new img <sdest>;
		<sdest>.copy(ssrc);
	}
	playmusic(string sfile)	{gameapi.playmusic( this.getsndpath() + sfile );	}
	newsndfree(string sname, string sfile)	{
		new snd <sname>;
		<sname>.setstartstopflag(false, true);
		<sname>.load( this.getsndpath() + sfile);
	}
	snewsnd(string sname, string sfile)	{
		this.newsnd(sname,sfile);
		<sname>.addmethod("onfinish","__std_finish");
	}
	newsnd(string sname, string sfile)	{
		new snd <sname>;
		<sname>.load( this.getsndpath() + sfile);
	}
	newsndloop(string sname, string sfile)	{
		this.newsnd(sname,sfile);
		this.looponfinish1( sname );
	}
	looponfinish1( string sob )	{<sob>.addmethod("onfinish","_stdsndloop");	}
	sndplayloop(string sob)	{
		this.looponfinish1( sob );
		<sob>.play();
	}
	newsnds(string sbase, int inamestart, string sfilebase, int ifilefrom, int ifileto)	{
		string s;
		int ile = ifileto-ifilefrom+1;
		for(int i=0; i<ile; i++)	{
			s = sbase + (inamestart + i);
			new snd <s>;
			<s>.load( this.getsndpath() + sfilebase + (ifilefrom+i) + ".wav" );
		}
	}
	newtimer(string sname, int idelay, int iticks)	{
		new timer <sname>;
		<sname>.settick(iticks);
		<sname>.delay(idelay);
	}
	newtimercycle(string sname, int icycle, int iticks)	{
		new timer <sname>;
		<sname>.settick(iticks);
		<sname>.setcycle(icycle);
	}
	stdanaction(string san)	{
		string s = <san>.actionname();
		if( s.contains("L")  )	this.looponfinish(san);
		else if( s.contains("H")  )	this.hideonfinish(san);
		if( s.contains("P")  )	<san>.play(-1);
	}
	int newanactionsgr(string san, string sname, string sgr)	{
		int ile = <san>.nofactions();
		this.copyanimas( san, sname, 0, ile );
		string s;
		for(int i=0; i<ile; i++)	{
			s = sname+i;
			<s>.setframe(i,0);
			this.stdanaction(s);
			if( sgr!=null )	{<sgr>.add( s );}
		}
		return ile;
	}
	int newanactions(string san, string sname)	{return this.newanactionsgr(san,sname,null);	}
	int newanfrbyactgr(string san, string sname, string sgr)	{
		int ile = <san>.nofactions();
		for( int i=0; i<ile; i++)	_ = this.newanframesgr(san, sname+i+"_", i, sgr);
		return ile;
	}
	int newanfrbyact(string san, string sname)	{return this.newanfrbyactgr(san,sname,null);	}
	int loadanfrbyact(string san, string sfile, int z)	{
		string s = "_"+san;
		this.newanima(s,sfile,z);
		int ile = this.newanfrbyact(s, san);
		<s>.hide();
		return ile;
	}
	int loadanactions(string san, string sfile, int z)	{
		string s = "_"+san;
		this.newanima(s, sfile, z);
		int ile = this.newanactions(s, san);
		<s>.hide();
		return ile;
	}
	int loadanframes(string san, string sfile, int iaction, int z)	{
		string s = "_"+san;
		this.newanima(s, sfile, z);
		int ile = this.newanframes(s, san, iaction);
		<s>.hide();
		return ile;
	}
	newbutimg(string sbut, string sstd, string smov, string sclick, string smouse)	{
		new button <sbut>;
		<sbut>.set(sstd, smov, sclick);
		<sbut>.setmouse(smouse);
	}
	newbutan(string sbut, string sanstd, string sanmov, string sanclick, string smouse)	{
		new button <sbut>;
		<sbut>.setan(sanstd, sanmov, sanclick);
		<sbut>.setmouse(smouse);
	}
	/*****************************************************/
	newdb(string sdb, string sfile)	{
		new db <sdb>;
		<sdb>.load( this.getgraphpath() + sfile );
	}
	newdbscript(string sdb, string sfile)	{
		new db <sdb>;
		<sdb>.loadscript( this.getgraphpath() + sfile );
	}
	vargmset(string svar, def val)	{
		string sg = gameapi.getgamename();
		if( !<sg>.hasvar(svar) )	<sg>.varnew( val.gettype(), svar );
		<svar> = val;
	}
}

/**************************************************************/
new img imglobcurs;		// globalny kursor aktywnosci
bsms.load("configs/kursorstd.png","configs/kursoract.png" );
	// modul obslugi standardowych kursorow myszy
module bsms {
	init()	{
		new img imgstd;
		new img imgact;
		new int msid = 0;		// 0- brak kursora 1-std lapka 2- active lapka 3- wlasny (wczytany w jakiejs grze)
	}
	load(string spath1, string spath2)	{
		imgstd.load(spath1);
		imgact.load(spath2);
		imglobcurs.copy("imgact");
		imglobcurs.hide();
		imgstd.hide();
		imgact.hide();
		this.reset();
		engine.stdbutcursor("imgstd");
	}
	setinitial()	{	mouse.stdcursor();	msid = 0;	}
	setstd()	{
		mouse.setcursor("imgstd");
		engine.stdbutcursor("imgstd");
		msid = 1;
	}
	setact()	{	mouse.setcursor("imgact");	msid = 2;	}
	setown()	{	msid=3;	}
	bool isinitial()	{	msid==0;	}
	bool isstd()	{	msid==1;	}
	bool isact()	{	msid==2;	}
	bool isown()	{	msid==3;	}
}

/***************************************************************************/

module clsurf	{
	init()	{}
	bool isin(int x, int y, int x1, int y1, int x2, int y2)	{
		x >= x1 && x<=x2 && y>=y1 && y<=y2;
	}
	bool isin2(int x, int y, int x1, int y1, int w, int h)	{
		x >= x1 && x < x1+w && y>=y1 && y<y1+h;
	}
	bool inscreen(int x, int y, int dx, int dy)	{
		this.isin( x, y, 0-dx, 0-dy, 800+dx, 600+dy );
	}
	bool insurf(int x, int y, string simg)	{
		this.isin(x,y,<simg>.getpx(), <simg>.getpy(), <simg>.getex()-1, <simg>.getey()-1);
	}
	bool issurfin(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)	{
		this.isin(x1,y1, x3,y3,x4,y4) || this.isin(x2,y1, x3,y3,x4,y4) ||
				this.isin(x1,y2, x3,y3,x4,y4) || this.isin(x2,y2, x3,y3,x4,y4);
	}
	bool commonsurface(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)	{
		this.issurfin(x1,y1,x2,y2, x3,y3,x4,y4) || 
				this.issurfin(x3,y3,x4,y4, x1,y1,x2,y2);
	}
	bool commonimgs(string simg1, string simg2)	{
		this.commonsurface(<simg1>.getpx(), <simg1>.getpy(), <simg1>.getex()-1, <simg1>.getey()-1,
				<simg2>.getpx(), <simg2>.getpy(), <simg2>.getex()-1, <simg2>.getey()-1 );
	}
	bool surfwithinsurf(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)	{
		this.isin(x1,y1, x3,y3,x4,y4) && this.isin(x2,y1, x3,y3,x4,y4) &&
				this.isin(x1,y2, x3,y3,x4,y4) && this.isin(x2,y2, x3,y3,x4,y4);
	}
	bool imgwithinimg(string simg1, string simg2)	{
		this.surfwithinsurf(<simg1>.getpx(), <simg1>.getpy(), <simg1>.getex()-1, <simg1>.getey()-1,
				<simg2>.getpx(), <simg2>.getpy(), <simg2>.getex()-1, <simg2>.getey()-1 );
	}
}

/* modul do obliczen odleglosci */

module cllen	{
	init()	{
		new int il1;
		new int ilx;
		new int ily;
	}
	int ilenx()	{ return ilx; }
	int ileny()	{ return ily; }
	int ilen4(int x1, int x2)	{	return (x1-x2)->abs();	}
	int ilen3(string simg1, string simg2)	{
		return this.ilen( <simg1>.getcx(), <simg1>.getcy(), <simg2>.getcx(), <simg2>.getcy() );
	}
	int ilen5(string simg1, string simg2)	{
		return this.ilen( <simg1>.getpx(), <simg1>.getpy(), <simg2>.getpx(), <simg2>.getpy() );
	}
	int ilen2(string simg1, int x, int y)	{return this.ilen( <simg1>.getcx(), <simg1>.getcy(), x,  y );	}
	int ilen(int x1, int y1, int x2, int y2)	{
		ilx = x1-x2;
		ily = y1-y2;
		return il1.length( ilx, ily );
	}
	int iclenx(string simg1, int x)	{	return <simg1>.getcx() - x;	}
	int iclenx2(string simg1, string simg2)	{	return <simg1>.getcx() - <simg2>.getcx();	}
	int icleny(string simg1, int y)	{	return <simg1>.getcy() - y;	}
	int icleny2(string simg1, string simg2)	{	return <simg1>.getcy() - <simg2>.getcy();	}
	int isbetween2(string simg1, string simg2, int x1, int y1, int x2, int y2)	{
		return this.isbetween(simg1, <simg2>.getcx(), <simg2>.getcy(), x1, y1, x2, y2);
	}
	int isbetween(string simg1, int xx, int yy, int x1, int y1, int x2, int y2)	{
		il1 = this.ilen( simg1, xx, yy );
		return ilx>=x1 && ilx<=x2 && ily>=y1 && ily<=y2;
	}
	int ilodlen(string s1, string s2)	{	.ilen(<s1>.lodx,<s1>.lody, <s2>.lodx, <s2>.lody);	}
	int iposlen(string simg1, string simg2)	{
		.ilen( <simg1>.getpos, <simg2>.getpos );
	}
}

/****************************************************/
class classansearcher	{
	init()	{}
	def _findnotr(string san, int x, int y, int dx, int dy)	{
		int ex = <san>.getex() , int ey = <san>.getey();
		while( x!=ex && y!=ey )	{
			if( <san>.isin(x,y,false,true) ) return x,y;
			x+=dx;	y+=dy;
		}
		return -1,-1;
	}
	def firstnotrx1y(string san)	{	return ._findnotr(san,<san>.getpx(), <san>.getpy(), 1, 0);	}
	def firstnotrexy1(string san)	{	return ._findnotr(san,<san>.getex()-1, <san>.getpy(), 0, 1);	}
	def firstnotrxy1(string san)	{	return ._findnotr(san,<san>.getpx(), <san>.getpy(), 0, 1);	}
	def firstnotrx1ey(string san)	{	return ._findnotr(san,<san>.getpx(), <san>.getey()-1, 1, 0);	}
}

class signal_pack	{
	init()	{}
	addsignals(string san)	{
		<san>.addmethod("operator<", func { (string sfun) this.addmethod("onfinish", sfun ); } );
	}
}
/***************************************************************************/
	// rozszerzenia dla animcaji
class anima_pack : signal_pack	{
	init()	{}
	public resizemethods(string san)	{
		<san>.addmethod("_clanbuildpomvars", func { new int _ixp; new int _iyp; } );
		<san>._clanbuildpomvars();
		<san>.addmethod("setbpos", func {(int x, int y) this.setpos( x-this.lodx, y-this.lody ); });
		<san>.addmethod("saverelpos", func {(int x,int y)_ixp=x-this.getpx;_iyp=y-this.getpy;} );
		<san>.addmethod("setrelpos", func{(int x, int y) this.setbpos( x - _ixp, y - _iyp );});
		<san>.addmethod("mssaverelpos", func {this.saverelpos( mouse.getpos );} );
		<san>.addmethod("mssetrelpos", func {this.setrelpos( mouse.getpos );});
		<san>.addmethod("rplay", func {(string sact)if( !this.isplaying(sact) ) this.play(sact);});
		<san>.addmethod("setcpos", func {(int x, int y)this.setbpos( x-this.getw/2, y-this.geth/2 );});
		<san>.addmethod("operator=", func { (string s) this.copy(s); } );
		<san>.addmethod("operator==", func { (string s)
			.actionnr==<s>.actionnr && .framenr==<s>.framenr; } );
		this.addsignals(san);
	}
}

class timer_pack : signal_pack	{
	init()	{}
	resizemethods(string sob)	{
		this.addsignals(sob);
	}
}
/***************************************************************************/
class vector_pack	{
	init()	{}
	each(string sfun)	{	for( int i=0; i<.size; i++) this.<sfun>(.get(i));	}
	resizemethods(string svec)	{
		<svec>.addmethod("each", "each");
		<svec>.addmethod("operator-", func { (def x) this.remove(x); this; } );
		<svec>.addmethod("operator+", func { (def x) this.add(x); this; } );
	}
}

/***************************************************************************/

class classanfilter	{
	init()	{}
	buildanfilter()	{
		new filter ft;
		ft.link( this.getname() );
		ft.setpivottype(1);
	}
	public build(string san)	{
		<san>.addmethod("buildanfilter","buildanfilter");
		<san>.buildanfilter();
		<san>.addmethod("setopacity",	func {	(int iop) ft.setopacity(iop); }		);
		<san>.addmethod("setzoom",		func {	(real r) ft.setzoom(r); }			);
		<san>.addmethod("setangle",		func {	(real r) ft.setangle(r); }			);
		<san>.addmethod("getangle",		func {	return ft.getangle; }			);
		<san>.addmethod("rotate",		func {	(real r)	ft.rotate(r); }			);
		<san>.addmethod("setpivottype",	func {	(int ityp) ft.setpivottype(ityp); }	);
		<san>.addmethod("unlink",		func {	ft.unlink(); }					);
		<san>.addmethod("link",			func {	ft.link(this); }					);
		<san>.addmethod("blend",		func {	(string s) ft.blend(s); }			);
		<san>.addmethod("mask",		func {	(string s) ft.mask(s); }			);
	}
}

/***************************************************************************/

class classancounter	{
	init()	{
		new int iile;
		new int id;
		new string _san;
		new vector _vs;
		new int _pos;
	}
	set(string sname, int ile)	{
		_san = sname;
		iile = ile;
		id = 0;
		_pos = sname.length();
		_vs.resize( ile, false );
	}
	string get()	{
		string s = _san+id;
		id = (id+1)%iile;
		return s;
	}
	string getf()	{
		for(int i=0; i<iile; i++)	{
			if( !_vs.get(i) )	{
				_vs.set(i, true);
				return _san+i;
			}
		}
		return null;	// brak wolnych
	}
	retf(string s)	{	_vs.set( s.getb( _pos, 10 ), false );	}
	isfree(int pos)	{	return _vs.get(pos);	}
	int getile()	{	return iile;	}
}

/**************************************************************/
	// operacje na obrazach, dzwiekach, timerach i animacjach
class gmobjvec {
	init()	{
		new vector lsim;
		lsim.type("string");
	}
	operator=(string sgr)	{
		if( engine.varexist(sgr) )	{
			match(<sgr>.gettype())	{
				"vector" => this.copy(sgr);
				"gmobjvec" => this.copy(sgr);
				"gmimgvec" => this.copy(sgr);
				? => {	this.free(); this.add(sgr); }
			}
		} else {
			this.free();
			this.add(sgr);
		}
	}
	operator+(string sob)	{	this.add(sob);		return this;	}
	operator-(string sob)	{	this.remove(sob);	return this;	}
	addtogr(string sgr)	{	for( int i=0; i<this.size(); i++)	<sgr>.add(this.get(i));	}
	addgr(string sgr)	{	for( int i=0; i< <sgr>.size(); i++)	this.add( <sgr>.get(i) );	}
	copy(string sgr)	{
		this.free();
		this.addgr(sgr);
	}
	free()	{ lsim.free();	}
	int size()	{ return lsim.size(); }
	bool empty()	{	return this.size()==0;	}
	hash()	{ lsim.hash(); }
	string first()	{ return lsim.get(0); }
	string last()	{ return lsim.get( lsim.size()-1 ); }
	print()	{	lsim.print();	}
	string get(int i)	{ return lsim.get(i); }
	add(string simg)	{	lsim.add(simg);	}
	additer(string s, int ifrom, int iile)	{
		while( iile>0 )	{
			.add(s+ifrom);
			ifrom++;
			iile--;
		}
	}
	buildarray(string styp, string sname, int ilosc)	{
		<gameapi.getgamename>.newarray(styp,sname,ilosc);
		.additer(sname,0,ilosc);
	}
	deleteall	{	for( int i=0; i<.size; i++)	delete <.get(i)>;	}
	addbegin(string simg)	{	lsim.addbegin(simg);	}
	swap(int i, int j)	{	lsim.swap(i,j);	}
	addonce(string simg)	{	if( !lsim.contains(simg) )	lsim.add(simg);	}
	sepadd(string separator)	{
		string s = _;
		while( s!=separator )	{
			this.addbegin(s);
			s = _;
		}
	}
	addlist	{	.sepadd(A);	}
	insertat(string sob, int pos)	{
		@ile = .size;
		if( pos<=0 )	.addbegin(sob);
		else if (pos>=ile)	.add(sob);
		else {
			.add(null);
			for( @i=ile; i>pos; i--)	.set( i, .get(i-1) );
			.set(pos, sob );
		}
	}
	remove(string simg)	{	lsim.remove(simg);	}
	removeat(int pos)		{	lsim.removeat(pos);	}
	removefirst			{	lsim.removeat(0);	}
	removelast			{	lsim.removeat(.size-1);	}
	removealloccurs(string simg)	{	while(this.contains(simg))	this.remove(simg);	}
	removeif(string sfun)	{
		for( int i=0; i<.size; i++)
			if( <.get(i)>.<sfun>() )  .removeat(i);
	}
	int find(string simg)	{ return lsim.find(simg); }
	int contains(string simg)	{ return lsim.contains(simg); }
	addgroup(string sob, int ile)	{	this.addgroup2( sob, 0, ile-1 );	}
	addgroup2(string sob, int ifrom, int ito)	{
		while( ifrom <= ito )	{
			this.add( sob+ifrom );
			ifrom++;
		}
	}
	string rand()	{
		int ile = .size;
		ile>0 ? .get(ile.rand) : null;
	}
	string randdiff(string s)	{
		int ile = .size;
		if( ile>0 )	{
			int id = ile.rand;
			int i = id;
			while( .get(id)==s )	{
				id = (id+1)%ile;
				if( id==i )	return null;
			}
			return .get(id);
		}
		null;
	}
	buildfullvars	{	.each( func { (@id) .buildfullname; } );	}
	buildvars		{	.each( func { (@id) .addtogamevars(this); } );	}
	/******************* metody na obiektach grupy *****************************/
	movefrom(string simg, int x, int y)	{
		int i = this.find(simg);
		if( i>=0 )	{
			while( i<lsim.size() )	{
				<lsim.get(i)>.move(x,y);
				i++;
			}
		}
	}
	move(int x, int y)	{	this.eval2("move",x,y);	}
	setpos(int x, int y)	{	this.eval2("setpos",x,y);	}
	show()	{	this.eval("show");	}
	hide()	{	this.eval("hide");	}
	stop(int fin)	{	this.eval1("stop",fin);	}
	play()	{	this.eval("play");	}
	setdelay(int d)	{	this.eval1("setdelay",d);	}
	graddmethod(string sdest, string ssrc)	{	this.eval2("addmethod",sdest,ssrc);	}
	string getimg(int x, int y, int bignorehidden, int bignorealpha)	{
		for( int i=lsim.size()-1; i>=0; i--)	{
			if( <lsim.get(i)>.isin( x,y,bignorehidden,bignorealpha ) )	return lsim.get(i);
		}
		return null;
	}
	int isin(int x, int y, bool bignorehidden, bool bignorealpha)	{
		for( int i=lsim.size()-1; i>=0; i--)	{
			if( <lsim.get(i)>.isin( x,y,bignorehidden,bignorealpha ) )	return i+1;
		}
		return false;
	}
	setframe(def ac, int ifr)	{	this.eval2("setframe",ac,ifr);	}
	setz(int z)	{	this.eval1("setz",z);	}
	/**************/
	eval(string sfunc)	{
		for(int i=0; i<lsim.size(); i++)	{<lsim.get(i)>.<sfunc>();	}
	}
	eval1(string sfunc, def darg)	{
		for(int i=0; i<lsim.size(); i++)	{<lsim.get(i)>.<sfunc>(darg);}
	}
	eval2(string sfunc, def darg1, def darg2)	{
		for(int i=0; i<lsim.size(); i++)	{<lsim.get(i)>.<sfunc>(darg1, darg2);}
	}
	eval3(string sfunc, def darg1, def darg2, def darg3)	{
		for(int i=0; i<lsim.size(); i++)	{<lsim.get(i)>.<sfunc>(darg1, darg2, darg3);}
	}
	int _find(string sfun, def id)	{
		for( int i=0; i<this.size; i++) if ( <this.get(i)>.<sfun>()==id ) return i;
		-1;
	}
	int _find1(string sfun, @id)	{
		for( int i=0; i<.size; i++) if ( <this.get(i)>.<sfun>(id) ) return i;
		-1;
	}
	each(string sfun)	{	for( int i=0; i<.size; i++) <.get(i)>.<sfun>(i);	}
	each1(string sfun, @d1)	{	for( int i=0; i<.size; i++) <.get(i)>.<sfun>(i, d1);	}
	each2(string sfun, @d1, @d2)	{	for( int i=0; i<.size; i++) <.get(i)>.<sfun>(i, d1, d2);	}
	bool ineach(string sfun)	{
		for( int i=0; i<.size; i++) if( !<.get(i)>.<sfun>(i) )	return false;
		true;
	}
	int find_closest(string sob, string sfun)	{
		if( .empty ) return;
		int id = 0, real il;
		real ilen = <.get(0)>.<sfun>(sob);
		for( int i=1; i<.size; i++)	{
			il = <.get(i)>.<sfun>(sob);
			if( il < ilen )	{
				id = i;
				il = ilen;
			}
		}
		id;
	}
	/**************/
	sortimgsfun(string sfun)	{	lsim.vecsort(sfun);	}
	sortimgs()	{	// sortowanie od najmniejszych
		lsim.vecsort("_scmpimg1");
	}
	bool _scmpimg1(string s0, string s1)	{
		return ( <s0>.getz() < <s1>.getz() || ( <s0>.getz()==<s1>.getz() && <s0>.getidobj() < <s1>.getidobj() ) );
	}
}

class gmimgvec : gmobjvec	{
	init()	{
		gmobjvec::init();
		new int _ix = 0;
		new int _iy = 0;
		new int _iz = 0;
		new int _ifound = -1;
	}
	_setpos(int x, int y)	{	|_ix, _iy| = x,y;	}
	int lodx()	{0;}
	int lody()	{0;}
	int getposx()	{	return _ix;	}
	int getposy()	{	return _iy;	}
	int getpos()	{	return _ix, _iy;	}
	int getpx() {	return _ix;	}
	int getpy() {	return _iy;	}
	int getw()	{	return this.getex()-this.getpx();	}
	int geth()	{	return this.getey()-this.getpy();	}
	int getcx() {	return this.getpx()+this.getw()/2;	}
	int getcy() {	return this.getpy()+this.geth()/2;	}
	int getz()	{	return _iz;	}
	int getex()	{
		int ile = this.size();
		if( ile<=0 )	{	return _ix;	}
		int x = <this.get(0)>.getex();
		int x2;
		for( int i=1; i<ile; i++)	{
			x2 = <this.get(i)>.getex();
			if( x2>x )	{	x=x2;	}
		}
		return x;
	}
	int getey()	{
		int ile = this.size();
		if( ile<=0 )	{	return _iy;	}
		int y = <this.get(0)>.getey();
		int y2;
		for( int i=1; i<ile; i++)	{
			y2 = <this.get(i)>.getey();
			if( y2>y )	{	y=y2;	}
		}
		return y;
	}
	/*minx	{	.find_closest(null, func {(@s) .getpx; } );	}
	miny	{	.find_closest(null, func {(@s) .getpy; } );	}
	countborders	{
		_ix = .minx;
		_iy = .miny;
	}*/
	setz(int z)	{
		_iz = z;
		this.eval1("setz",z);
	}
	move(int x, int y)	{
		_ix +=x;
		_iy +=y;
		this.eval2("move",x,y);
	}
	setpos(int x, int y)	{
		_ix = x;
		_iy = y;
		this.eval2("setpos",x,y);
	}
	setpos2(int x, int y)	{
		_ix = x;
		_iy = y;
		if( !.empty )	{
			x -= <.get(0)>.getpx;
			y -= <.get(0)>.getpy;
			.move(-x,-y);
		}
	}
	changeframe(int ifr) {
		string s;
		for( int i=0; i<.size; i++)	{
			s = .get(i);
			<s>.setframe( <s>.actionnr(-1), ifr );
		}
	}
	txtreset	{	for( int i=0; i<.size; i++) <.get(i)>.txtset("");	}
	anputgr()	{	this.eval("anputgr");	}
	anputy(int ypos)	{	this.eval1("anputy", ipos);	}
	int isin(int x, int y, bool bignorehidden, bool bignorealpha)	{
		for( int i=lsim.size()-1; i>=0; i--)	{
			if( <lsim.get(i)>.isin( x,y,bignorehidden,bignorealpha ) )	{
				_ifound=i;
				return i+1;
			}
		}
		_ifound = -1;
		return false;
	}
	int getfound()	{	return _ifound;	}
	string getsfound()	{	return this.get(_ifound);	}
	int findfr(int id)	{	._find("framenr", id);	}
	int findac(int id)	{	._find("actionnr", id);	}
	int findsac(string sac)	{	._find("actionname", sac);	}
	int nearest_to(string sob)	{
		//.find_closest(sob, func {(string s) 0->length( .getpx-<s>.getpx, .getpy-<s>.getpy ); } );
		.find_closest(sob, func {(string s) cllen.ilen5(this,s); } );
	}
	/*def find_min(string s)	{
		if( .empty ) return;
		int x = <s>.getpx;
		int y = <s>.getpy;
		int id = 0, int il;
		int ilen = id.length( <.get(0)>.getpx-x, <.get(0)>.getpy-y );
		for( int i=1; i<.size; i++)	{
			il = id.length( <.get(i)>.getpx-x, <.get(i)>.getpy-y );
			if( il < ilen )	{
				id = i;
				il = ilen;
			}
		}
	}*/
	/****************************/
	loadallan(string sname, string sfile, int z)	{
		string s = gameapi.getgamename();
		<s>.newanima(sname,sfile,z);
		_ = <s>.newanfrbyactgr(sname, sname, this);
		<sname>.hide();
	}
	operator*(string s)	{
		string sg = gameapi.getgamename;
		string san;
		if ( s.contains(".pyz") ) {
			san = "an" + s.strsubes(".pyz");
			<sg>.newanima(san,s,0);
		} else san = s;
		_ = <sg>.newanactionsgr(san, san, this);
		<san>.hide();
	}
	operator<(string s)	{
		string sg = gameapi.getgamename;
		string san;
		if ( s.contains(".pyz") ) {
			san = "an" + s.strsubes(".pyz");
			<sg>.newanima(san,s,0);
		} else san = s;
		_ = <sg>.newanfrbyactgr(san, san, this);
		<san>.hide();
	}
}

class gmmaskvec : gmimgvec	{
	init()	{
		gmimgvec::init();
	}
	int isin(int x, int y, bool bigvis, bool bigalpha)	{
		return gmimgvec::isin(x,y,false,bigalpha);
	}
}


class classsound {
	init()	{
		new string _csplay = null;
	}
	creset()	{ _csplay = null; }
	string cgetactsnd()	{ return _csplay; }
	crselfplay(string ssnd)	{
		if( !this.cisplaying() )	this.cbplay(ssnd);
		else if ( this.cgetactsnd()!=ssnd )	this.cbplay(ssnd);
	}
	cbplay(string ssnd)	{
		if(this.cisplaying())	<_csplay>.stop(true);
		_csplay = ssnd;
		if( ssnd!=null )	<ssnd>.play();
	}
	cbplay2(string ssnd)	{
		if(this.cisplaying())	<_csplay>.stop(false);
		_csplay = ssnd;
		if( ssnd!=null )	<ssnd>.play();
	}
	crplay(string ssnd)	{
		if(_csplay!=null && <_csplay>.isplaying() )	return;
		_csplay = ssnd;
		if( ssnd!=null )	<ssnd>.play();
	}
	crbgplay(string ssnd)	{	if( ssnd != null && !<ssnd>.isplaying() )	<ssnd>.play();	}
	crandplay(string ssnd, int irand, string styp)	{
		if( irand.rand()==0 )	this.<"c"+styp+"play">( ssnd );
	}
	cplayf(string styp, string ssnd, string sfun)	{
		this.<"c"+styp+"play">(ssnd);
		if( <ssnd>.isplaying() && sfun!=null)	<ssnd>.addmethod("onfinish",sfun);
	}
	//cactsndstop(bool bfin)	{	if(_csplay!=null)	<_csplay>.stop(bfin);	}
	cactsndstop(bool bfin)	{
		if(.cisplaying)	<_csplay>.stop(bfin);
	}
	bool cisplaying()	{	_csplay!=null ? <_csplay>.isplaying() : false;	}
}

/***************************************************************************/
class classsndbank	{
	init()	{
		new int itype;
		new int ilicz = 0;
		new int iile;
		new string splay=null;
		new string ssnd = "snd";
	}
	/********************************/
	loadsingle(string sfile, int ile)	{
		if( ile<=0)	{	iile=0;	return;	}
		iile=ile;
		itype=0;
		for( int i=0; i<ile; i++)	newvars::newsnd( ssnd+i, sfile );
	}
	/********************************/
	load(string sfilebase, int ifilefrom, int ifileto, int ityp, int itypstart)	{
		iile = ifileto-ifilefrom+1;
		if(iile<=0)	{
			iile = 0;
			return;
		}
		newvars::newsnds( ssnd, 0, sfilebase, ifilefrom, ifileto);
		itype = ityp;			// 0 - po kolei, 1 - random
		if(itypstart==1)	{	// 0 - od pierwszego, 1 - randomowy
			ilicz = iile.rand( );
		}
	}
	addmethod(string ssig, string sfunc)	{
		for( int i=0; i<iile; i++)	<ssnd+i>.addmethod( ssig, sfunc );
	}
	stop(int ifin)	{	if(splay!=null)	<splay>.stop(ifin);	}
	int isplaying()	{	splay!=null ? <splay>.isplaying() : false;	}
	randplay( int irand )	{	if( irand.rand()==0 )	this.play();	}
	playid(int id)	{
		ilicz=id%iile;
		this.play();
	}
	play()	{
		this.stop(false);
		this.bgplay();
	}
	reset()	{	ilicz=0;	}
	/************************************************/
	rbgplay()	{	if( !this.isplaying() )	this.bgplay();	}
	rplay()	{	if( !this.isplaying() )	this.play();	}
	bgplay()	{
		splay = ssnd + ilicz;
		<splay>.play();
		if( itype==0)	ilicz = (ilicz+1)%iile;
		else if (itype==1)	ilicz = iile.rand();
	}
	setvol(int vol)	{	for( int i=0; i<iile; i++)	<ssnd+i>.setvol( vol );	}
}

/**************************************************************/
	// standardowe czynnosci przy grach, popakowane w metody
class classgame : newvars , classsound {
	init()	{
		newvars::init();
		classsound::init();
		new int _iconstid;
	}
	/**************************************************************/
	bkg=(@sfile)	{
		if( sfile.contains(".pyz") ) .newanima("anbkg", sfile, 0);
		else .newimg("imgbkg",sfile,0);
	}
	bgr=(@sfile)	{	this.csndplayloop("sndbgr",sfile);}
	path=(@s)	{	.setgraphpath("scripts/"+s+"/");	}
	cycle=(@stimer, @sfun)	{	.cnewtimercyclefin(stimer,1,1,sfun);	}
	timer=(@stimer, @itime, @sfun) { .cnewtimerfin(stimer,itime,1,sfun);	}
	def _getflags(string s)	{
		@bloop = false;
		if( s.contains("L") )	{
			s.strremove("L");
			bloop=true;
		}
		@bplay = false;
		if( s.contains("P") )	{
			s.strremove("P");
			bplay=true;
		}
		@bhide = false;
		if( s.contains("H") )	{
			s.strremove("H");
			bhide=true;
		}
		return s,bloop,bplay,bhide;
	}
	img=(@sfile)	{
		|sfile,@bloop,@bplay,@bhide| = ._getflags(sfile);
		@iz = 0;
		if( sfile.contains(" ") )	{
			iz = sfile.strgetfrom(" ");
			sfile = sfile.strgetto(" ");
		}
		string sname = sfile.strsube(4);
		string s;
		if( sfile.contains(".pyz") ) {
			s = "an" + sname;
			.newanima(s, sfile, iz);
		} else {
			s = "img" + sname;
			.newimg(s, sfile, iz);
		}
		if( bloop ) <s>.anloopfin;
		if( bplay ) <s>.play(-1);
		if( bhide ) <s>.hide;
	}
	imgs=	{	.withlist("img=");	}
	clone(string sob)	{
		<gameapi.getgamename> (this, .gettype, sob) { (@sthis, @styp, @sob)
			new <styp> <sob>;
			<sob>.copy(sthis);
		};
	}
	clones=	{	.withlist("clone");	}
	list=(@sname)	{
		@s=_;
		new gmobjvec <sname>;
		while(A!=s)	{
			<sname>.addbegin(s);
			s = _;
		}
	}
	debug=(@b)	{	engine.setdebugstate(b);	}
	sfx=(string s)	{
		|s,@bloop,@bplay,_| = ._getflags(s);
		@ivol = 100;
		if( s.contains(" ") )	{
			ivol = s.strgetfrom(" ");
			s = s.strgetto(" ");
		}
		string sf = "fx"+s;
		.newsnd(sf, "sfx/"+s+".wav");
		<sf>.setvol( ivol );
		if( bloop ) <sf>.addmethod("onfinish","_stdsndloop");
		if( bplay ) <sf>.play;
	}
	sfxs=	{	.withlist("sfx=");	}
	tickstart	{
		if( !.hasvar("__timspeed") )	new TicksCounter __timspeed;
		__timspeed.start;
	}
	tickstop	{	__timspeed.print("ticker: ");	}
	/**************************************************************/
	csndplayloop(string ssnd, string sfile)	{
		this.newsndloop(ssnd,sfile);
		<ssnd>.play();
	}
	csndbgr(string sfile)	{	this.csndplayloop("sndbgr",sfile);}
	cloadcursor(string sfile)	{
		if( sfile.contains(".") )	{
			.newimg("imgkursor", sfile,0);
			sfile = "imgkursor";
		}
		<sfile>.hide();
		mouse.setcursor(sfile);
		engine.stdbutcursor(sfile);
		bsms.setown();
	}
	/****************************************************************/
	newimgarray(string sname, string styp, string sn, int ile)	{
		new gmimgvec <sname>;
		<sname>.buildarray(styp,sn,ile);
	}
	newfont(string sfnt, string sfile, int isize)	{
		new font <sfnt>;
		<sfnt>.load( sfile, isize );
	}
	monofont(string sfnt, int isize)	{	.newfont(sfnt, sgmfontmono, isize);	}
	string snewfont(string sfontfile, int isize)	{
		string s = .newconst("font");
		<s>.load( sfontfile, isize );
		return s;
	}
	string stdfont(int isize)	{	.snewfont( sgmfontfile, isize	);	}
	string newconst(string styp)	{
		string s = "const"+styp+_iconstid;
		new <styp> <s>;
		_iconstid++;
		return s;
	}
	string consttext(string stext, int x, int y, int isize, int r, int g, int b)	{
		string s = this.newconst("text");
		string sf = .stdfont(isize);
		<s>.setfont(sf);
		<s>.set(stext);
		<s>.createtxt(r,g,b);
		<s>.setpos(x,y);
		return s;
	}
	newtext(string stxt, string stext, string sfont, int r, int g, int b)	{
		new text <stxt>;
		<stxt>.set(stext);
		<stxt>.setfont(sfont);
		<stxt>.createtxt(r,g,b);
	}
	newtextposz(string stxt, string stext, string sfont, int r, int g, int b, int x, int y, int z)	{
		.newtext(stxt,stext,sfont,r,g,b);
		<stxt>.anposz(x,y,z);
	}
	/****************************************************************/
	cfinmethod(string sobj, string sfuncfin)	{	<sobj>.addmethod("onfinish", sfuncfin);	}
	cnewsndfin(string sname, string sfile, string sfunc)	{
		this.newsnd(sname,sfile);
		this.cfinmethod(sname,sfunc);
	}
	cnewsndsfin(string sbase, int inamestart, string sfilebase, int ifilefrom, int ifileto, string sfunc)	{
		this.newsnds(sbase, inamestart, sfilebase, ifilefrom, ifileto);
		this.caddobjsfunfin(sbase, inamestart, inamestart+( ifileto-ifilefrom), sfunc);
	}
	cnewsndfinbplay(string sname, string sfile, string sfunc)	{
		this.cnewsndfin(sname,sfile,sfunc);
		this.cbplay(sname);
	}
	cnewtimerfin(string sname, int idelay, int iticks, string sfunc)	{
		this.newtimer(sname,idelay,iticks);
		this.cfinmethod(sname,sfunc);
	}
	cnewtimercyclefin(string sname, int icycle, int iticks, string sfunc)	{
		this.newtimercycle(sname,icycle,iticks);
		this.cfinmethod(sname,sfunc);
	}
	/****************************************************************/
	caddobjsfun(string ssnd, int ifrom, int ito, string ssig, string sfunc)	{
		while( ifrom <= ito )	{
			<ssnd+ifrom>.addmethod( ssig, sfunc+ifrom );
			ifrom++;
		}
	}
	caddobjsfunfin(string ssnd, int ifrom, int ito, string sfunc)	{
		this.caddobjsfun( ssnd, ifrom, ito, "onfinish", sfunc );
	}
	/****************************************************************/
	newancounter(string scounter, string sname, string sfile, int z, int ile)	{
		this.newanimas( sname, sfile, z, ile);
		new classancounter <scounter>;
		<scounter>.set( sname, ile );
	}
	newancounterh(string scounter, string sname, string sfile, int z, int ile)	{
		this.newancounter( scounter, sname, sfile, z , ile );
		for( int i=0; i<ile; i++)	<sname+i>.hide();
	}
	newancounterf(string scounter, string sname, string sfile, int z, int ile, string sfun)	{
		this.newancounter( scounter, sname, sfile, z , ile );
		for( int i=0; i<ile; i++)	<sname+i>.addmethod("onfinish", sfun);
	}
	newancounterhf(string scounter, string sname, string sfile, int z, int ile, string sfun)	{
		this.newancounter( scounter, sname, sfile, z , ile );
		for( int i=0; i<ile; i++)	{
			<sname+i>.addmethod("onfinish", sfun);
			<sname+i>.hide();
		}
	}
	cnewanimafin(string sname, string sfile, int z, string sfunc)	{
		this.newanima(sname, sfile, z);
		<sname>.addmethod("onfinish", sfunc );
	}
	ccopyanimafin(string sname, string snew, string sfunc)	{
		this.copyanima(sname, snew);
		<snew>.addmethod("onfinish", sfunc );
	}
	/****************************************************************/
	cloadwavs(string sdb, string sfile)	{
		this.newdb( sdb, sfile );
		int id = 0;
		int ile = <sdb>.getrowsno();
		int i[6], string s[5];
		while( id < ile )	{
			i1 = <sdb>.getcolsno(id);
			i2 = 0;
			s1 = <sdb>.get( id, i2 );	i2++;
			if( s1.getb(0,1)!="#" )	{
				s3 = <sdb>.get( id, i2 );	i2++;
				if( s1=="wav" || s1=="sfx" )	{
					s2 = <sdb>.get( id, i2 );	i2++;
					if( s1=="sfx")	{
						this.newsnd( s3, "sfx/"+s2 );
					} else { this.newsnd( s3, s2 ); }
					if( i2 < i1 )	{
						s1 = <sdb>.get( id, i2 );	i2++;
						s2 = <sdb>.get( id, i2 );	i2++;
						if( s1=="method" )	{
							<s3>.addmethod("onfinish", s2 );
						} else if (s1.gete(0,4)=="play")	{
							this.<"c"+s1.gete(4,10)+"playonfin">(s3, s2);
						} else if ( s1=="vol" )	{
							<s3>.setvol( s2 );
						}
					}
				} else if (s1=="group")	{
					s2 = <sdb>.get( id, i2 );	i2++;
					i3 = <sdb>.get( id, i2 );	i2++;
					i4 = <sdb>.get( id, i2 );	i2++;
					if( i2 < i1 )	{		// jest method
						s1 = <sdb>.get( id, i2 );	i2++;
						if( s1=="method" )	{
							s4 = <sdb>.get( id, i2 );	i2++;
							this.cnewsndsfin( s3, i3, s2, i3, i4, s4 );
						}
					} else {
						this.newsnds( s3, i3, s2, i3, i4 );
					}
				} else if (s1=="bank")	{
					s2 = <sdb>.get( id, i2 );	i2++;
					i0 = <sdb>.get( id, i2 );	i2++;
					i3 = <sdb>.get( id, i2 );	i2++;
					i4 = <sdb>.get( id, i2 );	i2++;
					i5 = <sdb>.get( id, i2 );	i2++;
					new classsndbank <s3>;
					<s3>.load( s2, i0, i3, i4, i5);
					if( i2<i1)	{
						s1 = <sdb>.get( id, i2 );	i2++;
						if( s1=="method")	{
							s4 = <sdb>.get( id, i2 );	i2++;
							<s3>.addmethod( "onfinish", s4 );
						} else if (s1=="vol")	{
							<s3>.setvol( <sdb>.get( id, i2 ) );
						}
					}
				} else if ( s1=="method" )	{
					s2 = <sdb>.get( id, i2 );	i2++;
					i3 = <sdb>.get( id, i2 );	i2++;
					i4 = <sdb>.get( id, i2 );	i2++;
					while( i3<=i4)	{
						<s2+i3>.addmethod("onfinish", s3);
						i3++;
					}
				} else if ( s1=="singlebank")	{
					s2 = <sdb>.get( id, i2 );	i2++;
					i3 = <sdb>.get( id, i2 );	i2++;
					new classsndbank <s3>;
					<s3>.loadsingle( s2, i3 );
				} else if ( s1=="bgr" )	{
					this.csndbgr( s3 );
					if( i2 < i1 )	{
						if( <sdb>.get( id, i2 )=="vol" )	{
							i2++;
							sndbgr.setvol( <sdb>.get( id, i2 ) );
							i2++;
						}
					}
				} else if ( s1=="music" )	{
					this.playmusic( s3 );
					if( i2 < i1 )	{
						if( <sdb>.get( id, i2 )=="vol" )	{
							i2++;
							sndbgr.setvol( <sdb>.get( id, i2 ) );
							i2++;
						}
					}
				}
			}
			id++;
		}
	}
	/****************************************************************/
	crestart()	{	gameapi.play( gameapi.getgamename() );	}
}


/***************************************************************************/

class clfindfunc	{
	init()	{}
	int _stdfindfunc(string sobj, int ifirst, int ilast, string sname, string sfunc)	{	
		while(ifirst<=ilast)	{
			if( <sobj + ifirst>.<sfunc>() ==sname )	return ifirst;
			ifirst++;
		}
		-1;
	}
	int _stdfindfunc2(string sobj, int iile, string sname, string sfunc)	{	
		._stdfindfunc(sobj, 0, iile-1, sname, sfunc);
	}
	/****************************************************************/
	cfindandeval2(string sobj, int iile, string sname, string sfunc, string seval)	{	
		.cfindandeval(sobj, 0, iile-1, sname, sfunc, seval);
	}
	cfindandeval(string sobj, int ifirst, int ilast, string sname, string sfunc, string seval)	{	
		int pos = ._stdfindfunc(sobj, ifirst, ilast, sname, sfunc);
		if(pos>=0)	<sobj+pos>.<seval>();
	}
}



/*****************************************************************/
class classbutton 	{
	init()	{
		new string san = "anbut";
		new string sbut = "but";
		new int iilebut = 0;
		new string sfxmon = null;
	}
	_cbuildbutname(string sname)	{	new string _sbutname=sname; }
	string cgetbutname()	{ return _sbutname; }
	build(string sfile, int z, string smouse)	{this.build2(sfile,z,smouse,null);	}
	build2(string sfile, int z, string smouse, string sgrp)	{	// wczytuje animacje i buduje z niej przyciski
		string smain = "_" + san;
		new anima <smain>;
		<smain>.load( sfile );
		<smain>.setz(z);
		int ile = <smain>.nofactions();
		int j;	int k;
		int iliczans = 0;
		string sn1, string sn2, string sn3;
		string spom;
		for(int i=0; i<ile; i++)	{
			sn1 = null;	sn2 = null;	sn3 = null;
			j = <smain>.nofframes(i);
			for(k=1; k<=j; k++)	{
				spom = san + iliczans;
				if(k==1)	{	sn1=spom; } 
				else if (k==2)	{ sn2 = spom; }
				else if (k==3)	{ sn3 = spom; }
				newvars::copyanima( smain, spom );
				<spom>.setframe( i, k-1 );
				iliczans++;
			}
			if( sgrp!=null && <sgrp>.contains( <smain>.nameofaction(i)) ) {
				<sn1>.setz(z-1);
			} else this.addbut(sn1, sn2, sn3, smouse);
		}
		<smain>.hide();
	}
	/***************************** \/ \/ \/ \/ \/ wewnetrzne \/ \/ \/ \/ \/ *************************************************/
	_buildfuncclick( string sname )	{	new string _sfunclick = sname; }
	_stdbutclick()	{	this.<_sfunclick>( this.getbutname() );		}
	_buildfuncrel( string sname )	{	new string _sfuncrel = sname; }
	_stdbutrel()	{	this.<_sfuncrel>( this.getbutname() );	}
	_buildfuncmovon( string sname )	{	new string _sfunmovon = sname; }
	_stdbutmovon()	{
		if( sfxmon!=null )	<sfxmon>.play();
		this.<_sfunmovon>( this.getbutname() );
	}
	_buildfuncmovoff( string sname )	{	new string _sfunmovoff = sname; }
	_stdbutmovoff()	{	this.<_sfunmovoff>( this.getbutname() );	}
	butsigfun(string sb, string sfunc, string ssig, string sfun1, string sfun2)	{
		if( sfunc==null )	return;
		<sb>.addmethod(sfun1, sfun1);
		<sb>.<sfun1>( sfunc );
		<sb>.addmethod(ssig, sfun2);
	}
	sigfunc(string sfunc, string ssig, string sfun1, string sfun2)	{
		for(int i=0; i<iilebut; i++)	this.butsigfun(sbut + i, sfunc, ssig, sfun1, sfun2);
	}
	print()	{for(int i=0; i<iilebut; i++)	engine.print( <sbut+i>.getbutname() );}
	setrect()	{
		string s;
		for( int i=0; i<iilebut; i++)	{
			s = <sbut+i>.getimg;
			<sbut+i>.setrect( <s>.getpx, <s>.getpy, <s>.getex, <s>.getey );
		}
	}
	setflags(bool bvis, bool balph)	{	for(int i=0; i<iilebut; i++)	<sbut+i>.setflags(bvis,balph);	}
	/***************************** /\ /\ /\ /\ /\ wewnetrzne /\ /\ /\ /\ /\ ************************************************/
	sfxonmovon(string ssnd)	{	sfxmon=ssnd;	}
	clickfunc(string sfunc)	{this.sigfunc(sfunc,"onclick", "_buildfuncclick", "_stdbutclick");	}
	relfunc(string sfunc)	{this.sigfunc(sfunc,"onrel", "_buildfuncrel", "_stdbutrel");	}
	movonfunc(string sfunc)	{this.sigfunc(sfunc,"onmoveon", "_buildfuncmovon", "_stdbutmovon");	}
	movofffunc( string sfunc)	{this.sigfunc( sfunc,"onmoveoff", "_buildfuncmovoff", "_stdbutmovoff");}
	/*****************************************************************/
	int ilebuts()	{	return iilebut;	}
	/*****************************************************************/
	int ifind(string sname)	{return clfindfunc::_stdfindfunc2(sbut, iilebut, sname, "getbutname");	}
	string sfind(string sname)	{
		int pos = clfindfunc::_stdfindfunc2(sbut, iilebut, sname, "getbutname");
		return pos>=0 ? sbut+pos : null;
	}
	/*****************************************************************/
	_cbutfun(string sname, string sfunc)	{
		clfindfunc::cfindandeval2(sbut, this.ilebuts(), sname, "getbutname", sfunc );
	}
	_callbutfunc(string sfunc)	{	for(int i=0; i<iilebut; i++)	<sbut+i>.<sfunc>();	}
	_cibutfunc(string sfunc, int ile)	{
		if( ile > iilebut )	ile = iilebut;
		for(int i=0; i<ile; i++)	<sbut+i>.<sfunc>();
	}
	ienable( int ile )	{	this._cibutfunc("enable", ile);	}
	benableall()	{	this.resumeall();	this.enableall();	}
	pauseall()	{	this._callbutfunc("pause");	}
	resumeall()	{	this._callbutfunc("resume");	}
	enableall()	{	this._callbutfunc("enable");	}
	disableall()	{	this._callbutfunc("disable");	}
	
	benable(string sname)	{	this.resume(sname);	this.enable(sname);	}
	disable(string sname)	{	this._cbutfun( sname, "disable");	}
	enable(string sname)	{	this._cbutfun( sname, "enable");	}
	pause(string sname)	{	this._cbutfun( sname, "pause");	}
	resume(string sname)	{	this._cbutfun( sname, "resume");	}
	/*****************************************************************/
	string getimg(string sname)	{
		string s= this.sfind(sname);
		return s!=null ? <s>.getimg() : null;	
	}
	/*****************************************************************/
	newmouse(string sname, string snewmouse)	{
		string s = this.sfind(sname);
		if(s!=null)	<s>.setmouse( snewmouse );
	}
	addbut(string san1, string san2, string san3, string smouse)	{
		string spom = sbut + iilebut;
		newvars::newbutan( spom, san1, san2, san3, smouse);
		<spom>.addmethod("getbutname","cgetbutname");
		<spom>._cbuildbutname( <san1>.actionname() );	// nazwa buttonu to nazwa akcji
		iilebut++;
	}
	/*****************************************************************/
	_addfunc(string s, string sfclick, string sfrel, string sfmvon, string sfmvoff)	{
		if( s== null)	return;
		this.butsigfun( s, sfclick, "onclick", "_buildfuncclick", "_stdbutclick");
		this.butsigfun( s, sfrel, "onrel", "_buildfuncrel", "_stdbutrel");
		this.butsigfun( s, sfmvon, "onmoveon", "_buildfuncmovon", "_stdbutmovon");
		this.butsigfun( s, sfmvoff, "onmoveoff", "_buildfuncmovoff", "_stdbutmovoff");
	}
	addfuncto(string sname, string sfclick, string sfrel, string sfmvon, string sfmvoff)	{
		this._addfunc( this.sfind(sname), sfclick, sfrel, sfmvon, sfmvoff);
	}
	addfunctolast(string sfclick, string sfrel, string sfmvon, string sfmvoff)	{
		this._addfunc( sbut + (iilebut-1) , sfclick, sfrel, sfmvon, sfmvoff);
	}
	/*****************************************************************/
	_transmet(string sob, string sfunc, string smet, string s)	{
		new string <"_sob" + s> = sob;
		new string <"_sf" + s> = sfunc;
		this.<smet>( "_trf"+s );
	}
	transclickfunc(string sob, string sfunc)	{this._transmet( sob, sfunc, "clickfunc", "cl" );	}
	transrelfunc(string sob, string sfunc)	{this._transmet( sob, sfunc, "relfunc", "rl" );	}
	transmovonfunc(string sob, string sfunc){this._transmet( sob, sfunc, "movonfunc", "mn" );	}
	transmovofffunc(string sob, string sfunc){this._transmet( sob, sfunc, "movofffunc", "mf" );	}
	_trfcl(string s)	{	<_sobcl>.<_sfcl>(s);		}
	_trfrl(string s)	{	<_sobrl>.<_sfrl>(s);		}
	_trfmn(string s)	{
		if( sfxmon!=null )	<sfxmon>.play();
		<_sobmn>.<_sfmn>(s);
	}
	_trfmf(string s)	{	<_sobmf>.<_sfmf>(s);		}
}

class classsimplebutton	{
	init()	{
		new string simgob=null;
		new gmimgvec grbut;
	}
	public stdbuild(string sfile, string smouse, int z)	{this.build(this.getgraphpath()+sfile, smouse, 0, 0, z, 0);	}
	public getimgfunc(string sfunc)	{	simgob==null ? 0 : <simgob>.<sfunc>();	}
	public setbutpos(int x, int y)	{	grbut.setpos(x,y);	}
	public build(string sfile, string smouse, int x, int y, int z, int iact)	{
		new button but1;
		but1 (this.getname()) {(string s) new string sbut = s; };
		but1.addmethod("onclick", func { this.<sbut+"_CLICK">(); });
		but1.addmethod("onrel", func { this.<sbut+"_REL">(); } );
		but1.addmethod("onmoveon", func { this.<sbut+"_MOVEON">(); });
		but1.addmethod("onmoveoff", func { this.<sbut+"_MOVEOFF">(); });
		
		if( sfile.contains(".pyz") )	{
			new anima anbut0;
			anbut0.load( sfile );
			anbut0.setpos(x,y);
			anbut0.setz(z);
			anbut0.setframe(iact,0);
			simgob="anbut0";
			grbut.add(simgob);
			string s0="anbut0";
			string s1=null;
			string s2=null;
			int ile = anbut0.nofframes(iact);
			if( ile>1 )	{
				new anima anbut1;
				anbut1.copy("anbut0");
				anbut1.setframe(iact,1);
				s1 = "anbut1";
				grbut.add(s1);
			}
			if (ile>2)	{
				new anima anbut2;
				anbut2.copy("anbut0");
				anbut2.setframe(iact,2);
				s1 = "anbut2";
				grbut.add(s1);
			}
			but1.setan(s0,s1,s2);
		} else {
			new img imgbut;
			simgob="imgbut";
			grbut.add(simgob);
			imgbut.load(sfile);
			imgbut.setpos(x,y);
			imgbut.setz(z);
			but1.set("imgbut",null,null);
		}
		but1.setmouse(smouse);
	}
}

/*****************************************************************/

class classmask : classbutton	{
	init()	{
		classbutton::init();
	}
	buildmask(string sfile, string smouse)	{
		this.build(sfile, 0, smouse);
		int ile = this.ilebuts();
		for(int i=0; i<ile; i++)	{
			<sbut+i>.setflags(false, false);
			<sbut+i>.hide();
		}
	}
	buildmaskfunc(string sfile, string smouse, string sfunc)	{
		this.buildmask(sfile, smouse);
		this.clickfunc(sfunc);
	}
	addmask(string sanim, string sname, string smouse, int bhide)	{		// dodanie np. ludka jako maski
		string spom = sbut + iilebut;
		newvars::newbutan( spom, sanim, null, null, smouse);
		<spom>.addmethod("getbutname","cgetbutname");
		sname==null ? <spom>._cbuildbutname(<sanim>.actionname()) : <spom>._cbuildbutname(sname);
		if(bhide)	{
			<spom>.setflags(false, false);
			<spom>.hide();
		}
		iilebut++;
	}
	addadvmask(string sanim, string sname, string smouse, string sfuncclick)	{
		this.addmask( sanim, sname, smouse, false );
		this.addfunctolast( sfuncclick, null, null, null);	
	}
}

/*****************************************************/
public callfun(string sob, string sfun)	{if( sfun!=null ) sob==null ? this.<sfun>() : <sob>.<sfun>();}
public _stdanloop()	{	this.play(-1); }
public _stdanhide()	{	this.hide();	}
public _stdsndloop()	{	this.play(); }
public __std_finish()	{	this.<this+"_FINISH">();	}
public looponfinish(string san)	{	<san>.addmethod("onfinish", "_stdanloop");	}
public hideonfinish(string san)	{	<san>.addmethod("onfinish", "_stdanhide");	}
/*****************************************************/
public string strsube(int ile)	{	return this.getb( 0, this.length()-ile );	}
public string strsubb(int ile)	{	return this.getb( ile, this.length() - ile );	}
public string strsubbs(string s)	{	return this.strsubb( s.length() );	}
public string strsubes(string s)	{	return this.strsube( s.length() );	 }
public string strgetto(string schar)	{
	@id = .find(schar);
	id<0 ? .get : .getb(0, id);
}
public string strgetfromto(int ipos, string schar)	{	return this.getb(ipos, this.find(schar));	}
public string strgetfrom(string schar)	{	return .getb(.find(schar)+schar.length, .length );	}
public strremove(string s)	{	.set( .strgetto(s) + .strgetfrom(s) ); }
public bool strisbetween(int b1, int b2)	{
	int ib;
	for(int i=0; i<.length; i++)	{
		ib = .getbyte(i);
		if( ib<b1 || ib>b2 )	return false;
	}
	true;
}
public bool strisint		{	.strisbetween(BYTE0, BYTE9);	}
public bool strisbin	{	.strisbetween(BYTE0, BYTE0+1);	}
public bool strisalpha	{	.strisbetween(BYTEa, BYTEz);	}
public streach(string sfun)	{
	string s;
	for( int i=0; i<.length; i++) {
		s = .getb(i,1);
		<s>.<sfun>(i);
	}
}
/*****************************************************/
public swap(string s1, string s2)	{
	[s1];
	<s1> = [s2];
	<s2> = _;
}
public bool stats(int ile)	{	(ile <= 0) ? false : ( 100->rand <= ile );}
public int between(int i1, int i, int i2)	{	( i < i1 ) ? i1 : (i>i2) ? i2 : i;}
public def max(def val1, def val2)	{	val1>val2 ? val1 : val2;	}
public def min(def val1, def val2)		{	val1<val2 ? val1 : val2;	}
/*************** do wykorzystania na obiektach!! ***********************************/
public anresizemets()	{	anima_pack::resizemethods(this.getname());	}
public def anfirstnontr	{	classansearcher::firstnotrx1y(this);	}
public anloopfin()	{	this.addmethod("onfinish", "_stdanloop");	}
public anloopplay(int iact)	{	this.anloopfin();	this.play(iact);	}
public anloopsplay(string sact)	{	this.anloopfin();	this.play(sact);	}
public anhidefin()	{	this.addmethod("onfinish","_stdanhide");	}
public anputgr()	{	this.setz( this.getey() );	}
public anputy(int ypos)	{	this.move(0, ypos - this.geth() - this.getpy());	}
public anputx(int xpos)	{	this.move(0, xpos - this.geth() - this.getpy());	}
public ansetposgr(int x, int y)	{	this.setpos(x,y);	this.anputgr();	}
public anplayz(int id, int z)	{	this.setz(z);	this.play(id);	}
public anplaygr(int id)	{	this.play(id);	this.anputgr();	}
public anplayzpos(int id, int z, int x, int y)	{	this.setpos(x,y);	this.anplayz(id,z);	}
public anplaypos(int x, int y)	{	this.setpos(x,y);	this.play(-1);	}
public anplayposgr(int x, int y)	{	this.ansetposgr(x,y);	this.play(-1);	}
public anplaypos2(int x, int y, string sact)	{	this.setpos(x,y);	this.play(sact);	}
public anplaypos3(int x, int y, int iact)	{	this.setpos(x,y);	this.play(iact);	}
public anhide()	{	this.stop(false);	this.hide();	}
public andownpos(int x, int y)	{	this.setpos( x, y-this.geth() );	}
public ansetbpos(int x, int y)	{	this.setpos( x-this.lodx(), y-this.lody() );	}
public ansetcpos(int x, int y)	{	.ansetbpos( x - .getw/2, y - .geth/2 );	}
public ansetframe(int id)	{	this.setframe( this.actionnr(-1), id );	}
public int anonscreen()	{	return clsurf.inscreen(this.getcx(), this.getcy(), this.getw()/2, this.geth()/2);	}
public objplayfin(string sfun)	{	this.addmethod("onfinish", sfun);	this.play();	}
public objplayloop()	{	this.addmethod("onfinish","_stdsndloop");		this.play();	}
public anplayfin(int iact, string sfun)	{	this.addmethod("onfinish", sfun);	this.play(iact);	}
public anytoz()	{	this.setz(this.getposy());	}
public anposz(int x, int y, int z)	{	.setpos(x,y);	.setz(z);	}
public string annextaction(string sact)	{return this.nameofaction( (this.actionnr(sact)+1)%this.nofactions() );}
public ansetnextact	{	.setframe( (.actionnr(-1)+1)%.nofactions, 0 ); }
public ansetnextfr		{	.setframe( -1, (.framenr+1)%.nofframes(-1)); }
public anaddfilter()	{	classanfilter::build(this.getname());	}
public anputc(int x1, int y1, int x2, int y2)	{
	.ansetbpos(x1,y1);
	.move( (x2-x1-.getw)/2, (y2-y1-.geth)/2 );
}
public aninlod(int itoler)	{	itoler.length( .getpx - .lodx, .getpy - .lody ) <= itoler; }
public angetcpos	{	return .getcx, .getcy;	}
public angetcrgba	{	.getrgba(.getcx, .getcy);	}
/***************** text ****************/
public txtset(string s)	{	.set(s);	.create;	}
public txtsetcol(string s, int r, int g, int b)	{	.set(s);	.createtxt(r,g,b);	}
public txtshadow(int w, string sfont)	{
	if( !.hasvar("txts") )	{
		new text txts;
		txts.setfont(sfont);
	}
	txts.set(.get);
	txts.setpos(.getpx+w, .getpy+w);
	txts.setz(.getz-1);
	txts.show;
	txts.createtxt(0,0,0);
}
public txthides	{	.hide; if(.hasvar("txts")) txts.hide; }
public txtisin(int x, int y)	{
	x>=.getpx && x<.getpx+.getw && y>=.getpy && y<=.getpy+.geth;
}
/***************** vector ****************/
public vecinc(int pos)	{	this.set( pos, this.get(pos)+1 );	}
public vecdec(int pos)	{	this.set( pos, this.get(pos)-1 );		}
public vecnewint(int ile)	{
	this.free();
	if( ile>0 )	for( int i=0; i<ile; i++)	{	this.add(i);	}
}
public veccopy(string svec)	{
	this.free();
	for( int i=0; i< <svec>.size(); i++ )	this.add( <svec>.get(i) );
}
public int vecnextid(def val)	{
	int id = .find(val);
	if( id>=0 )	id = (id+1)%.size;
	id;
}
public int vecprevid(def val)	{
	int id = .find(val);
	if( id>0 )	id--;
	else if (id==0)	id = .size-1;
	id;
}
public def vecget(int id)	{
	( id>=0 && id<.size) ? .get(id) : null;
}
public def vecnext(def val)	{	.vecget( .vecnextid(val) );	}
public def vecprev(def val)	{	.vecget( .vecprevid(val) );	}
public def veclast()	{
	int ile = this.size();
	ile>0 ? this.get(ile-1) : null;
}
public def vecpop()	{
	@x = .last;
	.removeat( .size - 1 );
	x;
}
public veclimes(int ile)	{	while( .size > ile )	_ = .vecpop;	}
public def vecpopfront()	{
	def x = this.get(0);
	this.removeat( 0 );
	return x;
}
public insertsort(int ile, string sgetfun, string scomparefun, string sswapfun)	{
	if( ile<=1 )	{	return;	}
	def s[2], int id, int i, int j;
	for( i=0; i<ile; i++)	{
		s0 = this.<sgetfun>(i);
		id = i;
		for( j=i+1; j<ile; j++)	{
			s1 = this.<sgetfun>(j);
			if( this.<scomparefun>(s1,s0) )	{
				s0 = s1;
				id = j;
			}
		}
		this.<sswapfun>(i,id);
	}
}
public obbuildfromstring(string s, string separator, string sfunadd)	{
	int pos = s.find(separator);
	while( pos>-1 )	{
		this.<sfunadd>( s.getb(0,pos) );
		s = s.strsubb(pos+1);
		pos = s.find(separator);
	}
	if( s.length()>0 )	{	this.<sfunadd>(s);	}
}
public obbuildfromstring2(string s, string separator, string sfunadd)	{
	int pos = s.find(separator);
	while( pos>-1 )	{
		if( pos>0 )	this.<sfunadd>( s.getb(0,pos) );
		s = s.strsubb(pos+1);
		pos = s.find(separator);
	}
	if( s.length()>0 )	{	this.<sfunadd>(s);	}
}
public vecsort(string scomparefun)	{ .insertsort( .size, "get", scomparefun,"swap" ); }
public string vecbuildfromstring(string s, string separator)	{
	this.free();
	this.obbuildfromstring(s,separator,"add");
}
public string vecbuildfromstring2(string s, string separator)	{
	this.free();
	this.obbuildfromstring2(s,separator,"add");
}
public vecremoveto(int ito)		{	for( int i=0; i<ito; i++ ) this.removeat(0);		}
public vecremovefrom(int ifrom)	{	while( ifrom<this.size() ) this.removeat(ifrom);	}
public vecposfromto(int i1, int i2)	{
	if( i1==i2 || .size==0 )	return;
	def x = .get(i1);
	if( i1>i2 )	for( int i=i1; i>i2; i--)	{	.set(i, .get(i-1));		}
	else if (i1<i2)	for( int i=i1; i<i2; i++)	{	.set(i, .get(i+1));	}
	.set(i2,x);
}
public vecposfirst( def x )	{
	int id = .find(x);
	if( id>=0 )	.vecposfromto(id, 0);
	else	.addbegin(x);
}
public vecposlast( def x )	{
	int id = .find(x);
	if( id>=0 )	.vecposfromto(id, .size-1);
	else	.addbegin(x);
}
public vecset(def x, def d2)	{
	int id = .find(x);
	if( id>=0 )	.set(id,d2);
}
public bool veceq(string svec)	{
	int id = .size;
	if( id != <svec>.size  )	return false;
	for( int i=0; i< id; i++)	if( .get(i)!=<svec>.get(i) ) return false;
	true;
}
public vecbuild	{	.withlist("addbegin");}
public bool veceq2	{
	new vector ___v;
	___v.type(.getvectype);
	___v.vecbuild;
	bool b = .veceq("___v");
	delete ___v;
	b;
}
public veccopydbrow(string sdb, int irow)	{
	.free;
	for( int i=0; i< <sdb>.getcolsno(irow); i++)	.add( <sdb>.get(irow,i) );
}
/************** db ************************/
public dbbuild(int icol)	{
	if( icol<=0 )	return;
	icol--;
	.free;
	string s = _, int id;
	for( int i = 0; s!=A; )	{
		if( i==0 )	id = this.addbeginrow() - 1;
		this.addbegin(0,s);
		s = _;
		i = (i<icol)? i+1 : 0;
	}
}
public dbcopy(string sdb)	{
	this.free;
	int i, int j;
	for( i =0; i< <sdb>.getrowsno; i++)	{
		_ = .addrow;
		for( j=0; j< <sdb>.getcolsno(i); j++)	{
			.add( i, <sdb>.get(i,j) );
		}
	}
}
public dbremovelast()	{
	.removerow( .getrowsno-1 );
}
public dbcuttosize(int isize)	{
	if( isize>0 ) while( .getrowsno > isize )	.dbremovelast;
	else	.free;
}
public dbaddlast(string svar)	{	this.add( this.getrowsno()-1, svar );	}
public dbaddstringrow(string s, string separator)	{
	_ = this.addrow();
	this.obbuildfromstring(s,separator,"dbaddlast");
}
public dbaddrow	{
	@id = .addrow - 1;
	@s = _;
	while(A!=s)	{
		.addbegin(id, s);
		@s = _;
	}
}
public dbaddrowfrom(string sdb, int irow, int icol)	{
	if( <sdb>.rowinrange(irow) && icol>=0)	{
		int id = this.addrow()-1;
		int ile = <sdb>.getcolsno(irow);
		while( icol < ile )	{
			this.add( id, <sdb>.get( irow, icol ) );
			icol++;
		}
	}
}
public string dbchecknext(int irow, int icol)	{
	icol++;
	icol < this.getcolsno(irow) ? this.get(irow,icol) : null;
}
public string dbgets(string s, int icol)	{return this.get( this.findbyrow(s), icol );}
public int dbinsertless(int i1)	{
	int id = this.addrow()-1;
	this.add(id,i1);
	this.dbsort("cmpless");
	while( id>=0 )	{
		if( i1==this.get(id,0) )	return id;
		id--;
	}
	return -1;
}
public bool dbdelvar(int irow, string svar)	{return this.dbdelvarn(irow,svar,1);}
public bool dbdelvarn(int irow, string svar, int n)	{
	int id = this.dbfindinrow(irow,svar);
	if( id>=0 )	{
		this.removen(irow,id,n);
		return true;
	}
	return false;
}
public int dbfindinrow(int irow, string svar)	{
	if( this.rowinrange(irow) )	{
		for( int i=0; i<this.getcolsno(irow); i++)	if( this.get(irow,i)==svar )	return i;
	}
	return -1;
}
public int dbfindbycol(int icol, string svar)	{
	for( int i=0; i<this.getrowsno(); i++)	{if( this.get(i,icol)==svar ) return i;}
	return -1;
}
public bool dbrowcontains(int irow, string svar)	{	return this.dbfindinrow(irow,svar)!=-1;	}
public string dbfirst(int id)		{	return this.get(id,0);	}	
public bool cmpless(int i1, int i2)	{	return i1<i2;	}
public bool cmpabove(int i1, int i2)	{	i1>i2;	}
public bool dbfirstless(int i1, int i2)	{	.get(i1,0) < .get(i2,0);	}
public dbsort(string scomparefun)	{	.insertsort( .getrowsno, "dbfirst",scomparefun, "swap" ); }
public dbsetall(string svar)	{	for( @i=0; i<.getrowsno; i++)	for(@j=0; j<.getcolsno(i); j++)	.set(i,j,svar);	}
/************** int ************************/
public int randdiff(int zakres, int odjakiej)	{
	if( zakres<=1 )		return -1;
	for( int i1 = zakres.rand; i1==odjakiej; i1= zakres.rand )	{}
	return i1;
}
public int bin_to_i	{
	string s = .get;
	int idwa = 1;
	int iout = 0;
	for( int i=s.length-1; i>=0; i--)	{
		if( s.getb(i,1)=="1") iout+=idwa;
		idwa*=2;
	}
	iout;
}

/***************************************************************************/
class classgamepause	{
	init()	{
		new button butpause;
		butpause.setrect( 0, 0, 800, 600 );
		butpause.addmethod("onclick", "resume");
		butpause.disable();
	}
	resume()	{
		butpause.disable();
		gameapi.resume();
	}
	pause()	{
		gameapi.pause();
		butpause.enable();
		butpause.resume();
	}
}

class TicksCounter	{
	init()	{
		new int istart;
	}
	start()	{	istart = engine.getticks();	}
	stop()	{	istart = engine.getticks() - istart;	}
	get()		{	return istart;	}
	int stopget()	{	this.stop();	return this.get();	}
	print(string s)	{	engine.print(s+" delay: "+this.stopget()+" ms");	}
	put()	{	.print("");	}
}

class ObjController	{
	init()	{
		new string _sme = this.getname();
		<GAME>.addgmobj(_sme);
	}
	removefromgame	{	<GAME>.removegmobj(_sme); }
}
class LObjController : ObjController, classlocker	{
	init()	{
		ObjController::init;
		classlocker::init;
	}
}

class gmbankvec : gmobjvec	{
	init()	{
		new int iid=-1;
	}
	play()	{
		this.stop(false);
		int ile = this.size();
		if( ile==0 ) return;
		iid = (iid+1)%ile;
		<this.get(iid)>.play();
	}
	onfinish()	{}
	stop(bool bfin)	{
		if( this.isplaying() )	{
			<this.getplay()>.stop(bfin);
			if( bfin ) this.onfinish();
		}
	}
	isplaying()	{
		if( iid>=0 )	return <this.getplay()>.isplaying();
		return false;
	}
	getplay()	{	return this.get(iid);	}
}

class GameController : classlocker {
	init(string ssndbase)	{
		classlocker::init();
		new gmobjvec __grobj;
		
		new db _dbsnd;
		_dbsnd.setseparator("|");
		new string _sndbase = ssndbase;
		new string GAME = this;
	}
	public game_exit()	{
		this.stdexportsnd();
	}
	/*************************************************/
	public setsndbase(string sb)	{	_sndbase=sb;	}
	public say(string styp, string stxt)	{	this.sayf(styp,stxt,null);	}
	public sayf(string styp, string stxt, string sfun)	{
		string s = this.getsndtxt(stxt);
		<s>.setstartstopflag(false,true);
		this.cplayf(styp, s, sfun);
	}
	public string getsndtxt(string stxt)	{
		string ssnd = "snd" + _sndbase + _dbsnd.getrowsno();
		this.addsnd( ssnd, stxt );
		return ssnd;
	}
	_sndtimerstart()	{
		int id = _dbsnd.dbfindbycol(1,this.getname());
		if( id>=0 )	engine.print( _dbsnd.get( id,2) );
		else 		engine.print( this.getname() + " not in _dbsnd");
		engine.print("");
	}
	public addsndf(string ssnd, string stxt, string sfun)	{
		this.addsnd(ssnd,stxt);
		<ssnd>.addmethod("onfinish", sfun );
	}
	public asf(string ssnd, string stxt)	{	this.addsndff( "snd" + ssnd, stxt, "end" + ssnd);	}
	public addsndff(string ssnd, string stxt, string sfun)	{
		this.addsndf(ssnd,stxt,sfun);
		//<ssnd>.setstartstopflag(false,true);
	}
	gmconsnd(string ssnd, string swav)	{
		new snd <ssnd>;
		<ssnd>.setstartstopflag(false,true);
		<ssnd>.load( .getsndpath+swav );
	}
	public addsnd(string ssnd, string stxt)	{
		int id = _dbsnd.addrow()-1;
		string swav = _sndbase + id + ".wav";
		string sg = gameapi.getgamename();
		if( engine.fileexist( this.getsndpath() + swav ) )	{
			<sg>.gmconsnd( ssnd, swav );
		} else {
			<sg>.newtimer( ssnd, stxt.length()*40, 1);
			<ssnd>.addmethod("onstart", "_sndtimerstart");
			<ssnd>.addmethod("setstartstopflag", func { (bool b1, bool b2) ; });
		}
		_dbsnd.add(id, swav);
		_dbsnd.add(id, ssnd);
		_dbsnd.add(id, stxt);
	}
	public addbank(string sbank)	{
		new gmbankvec <sbank>;
		string s = _;
		while( s!=A )	{
			<sbank>.addbegin( this.getsndtxt(s) );
			s = _;
		}
	}
	public exportsnd(string sfile)	{	if( igmdebug) _dbsnd.save(sfile);	}
	public stdexportsnd()	{	this.exportsnd( "exports/" + _sndbase + ".dlg" );	}
	public sounds=()	{	.buildsnds;	}
	public sounds_from(string sbase)	{
		new db __tmpdb;
		@stmpbase = _sndbase;
		.setsndbase(sbase);
		__tmpdb.load("exports/"+sbase+".dlg");
		_dbsnd.free;
		@s = _;
		int id, string sf;
		while( A!=s )	{
			@s1 = _;
			id = __tmpdb.dbfindbycol(1, s1);
			if( id>=0 )	{
				sf = .getsndpath + __tmpdb.get(id,0);
				if( engine.fileexist( sf ) )	{
					<GAME>.gmconsnd( s1, __tmpdb.get(id,0) );
					<s1>.addmethod("onfinish", s );
				} else	.addsndf( s1, __tmpdb.get(id,1), s );
			}
			@s = _;
		}
		_dbsnd.free;
		delete __tmpdb;
		.setsndbase(stmpbase);
	}
	public buildsnds()	{
		new db __dbsnd;
		__dbsnd.dbbuild(3);
		.buildfromdb("__dbsnd");
		delete __dbsnd; 
	}
	public buildfromdb(string sdb)	{
		for( int i=0; i< <sdb>.getrowsno; i++)	{
			if( <sdb>.get(i,2) == null )	.addsnd( <sdb>.get(i,0), <sdb>.get(i,1) );
			else	.addsndf( <sdb>.get(i,0), <sdb>.get(i,1), <sdb>.get(i,2) );
// 			<sdb>.addbegin(i, sbase + i + ".wav");
		}
// 		if( igmdebug )	<sdb>.save( "exports/" + sbase + ".dlg" );
	}
	public importsnd(string sbase, string sfun)	{	this.importgroup(sbase, sfun, null );	}
	public importgroup(string sbase, string sfun, string sgr)	{
		new db __tmpdb;
		@stmpbase = _sndbase;
		.setsndbase(sbase);
		__tmpdb.load("exports/"+sbase+".dlg");
		_dbsnd.free();
		if( sfun==null )	{
			for( int i=0; i<__tmpdb.getrowsno(); i++)	{
				if( sgr==null || <sgr>.contains(__tmpdb.get(i,1)) )
					this.addsnd( __tmpdb.get(i,1), __tmpdb.get(i,2) );
			}
		} else {
			for( int i=0; i<__tmpdb.getrowsno(); i++)	{
				if( sgr==null || <sgr>.contains(__tmpdb.get(i,1)) )
					this.addsndf( __tmpdb.get(i,1), __tmpdb.get(i,2), sfun );
			}
		}
		_dbsnd.free();
		__tmpdb.free();
		delete __tmpdb;
		.setsndbase(stmpbase);
	}
	public freesnd()	{	_dbsnd.free();	}
	/*************************************************/
	public addgmobj(string s)		{	__grobj.add(s);		}
	public removegmobj(string s)	{	__grobj.remove(s);	}
	public deletegmobj(string s)	{
		if( .hasvar(s) )	{
			.removegmobj(s);
			delete <s>;
		}
	}
	public lockall()		{
		__grobj.eval("lock");
		this.lock();	
	}
	public unlockall()		{
		__grobj.eval("unlock");
		this.unlock();
	}
	mousemove()	{
		__grobj.eval("onmousemove");
		this.mouse_move();
	}
	mouselclick()	{
		__grobj.eval("onmouselclick");
		this.mouse_lclick();	
	}
	mouserclick()	{
		__grobj.eval("onmouserclick");
		this.mouse_rclick();
	}
	mouselrel()	{
		__grobj.eval("onmouselrel");
		this.mouse_lrel();
	}
	mouserrel()	{
		__grobj.eval("onmouserrel");
		this.mouse_rrel();
	}
	keydown()	{
		__grobj.eval("onkeydown");
		this.key_down();
	}
}

/* classadv : klasa do przygodowek	*/

class classadv : classgame {
	init()	{
		classgame::init();
	}
	/**************************************************************************/
	newclpathf(string spt, string san, string sfile, int x, int y, real rstep, int ityp)	{
		new classpathf <spt>;
		<spt>.build(san, this.getgraphpath() + sfile, x, y, rstep, ityp);
	}
	newclpathfcopy(string spt, string san, string sptf, real rstep)	{
		new classpathf <spt>;
		<spt>.buildfrom( san, sptf, rstep );
	}
	newpathf(string spathf, string sfile, int x, int y)	{
		new path <spathf>;
		<spathf>.build( this.getgraphpath() +sfile, x, y, 2.0, 1 );
	}
	/**************************************************************************/
	newclbut(string sbut, string sfile, int z, string smouse)	{
		new classbutton <sbut>;
		<sbut>.build( this.getgraphpath() + sfile, z, smouse );
	}
	newclmask(string sm, string sfile, string smouse)	{
		new classmask <sm>;
		<sm>.buildmask( this.getgraphpath() + sfile, smouse );
	}
	newclmaskfunc(string sm, string sfile, string smouse, string sfunc)	{
		new classmask <sm>;
		<sm>.buildmaskfunc( this.getgraphpath() + sfile, smouse, sfunc );
	}
}

public transparent	{	return 0,0,0,0;	}
public red		{	return 255,0,0;	}
public green		{	return 0,255,0;	}
public blue		{	return 0,0,255;	}
public white		{	return 255,255,255; }
public black		{	return 0,0,0;		}
public grey(int c)	{	return c,c,c;		}

class Color	{
	init	{
		.vars(A,"r","g","b","a");
	}
	operator=(string scol)	{	this.set( <scol>.get() );	}
	img=(@simg)	{
		|r,g,b,a| = <simg>.getrgba( classansearcher::firstnotrx1y(simg) );
	}
	get			{	return r,g,b,a;	}
	set(int r2, int g2, int b2, int a2)	{	|r,g,b,a| = r2,g2,b2,a2;	}
	rgb=(int r2, int g2, int b2)	{	|r,g,b|=r2,g2,b2;	}
	rgb	{	return r,g,b;	}
	print	{	engine.print("Color::" + this + " (r,g,b,a) = ("+r+","+g+","+b+","+a+")");	}
}

/***************************************************************************/

class classasker : newvars	{
	init()	{
		newvars::init();
		new string sfuncyes = null;
		new string sfuncno = null;
		new string ssndask;
		new string ssndyes;
		new string ssndno;
		new classsound clsnd;
	}
	reset()	{	sfuncyes=null;	sfuncno=null;	}
	setfuncs(string syes, string sno)	{
		sfuncyes = syes;
		sfuncno = sno;
	}
	fxonmovon(string ssnd)	{	buts.sfxonmovon(ssnd);	}
	setmouse(string smouse)	{
		buts.newmouse("yes", smouse);
		buts.newmouse("no", smouse);
	}
	load(string sfile, int z)	{
		new classbutton buts;
		buts.build(sfile, z, null);
		buts.transclickfunc( engine.actclassname(), "butclick");
		buts.transmovonfunc( engine.actclassname() , "butmovon");
		buts.disableall();
	}
	ask( string sask, string syes, string sno, string sf1, string sf2 )	{
		this.setfuncs(sf1,sf2);
		this.ask2( sask, syes, sno );
	}
	ask2( string sask, string syes, string sno )	{
		ssndask=sask;
		ssndyes = syes;
		ssndno = sno;
		gameapi.pause();
		buts.benableall();
		buts.pause("bkg");
		clsnd.creset();
		clsnd.cbplay( sask );
	}
	/**********************************************/
	butmovon(string sc)	{
		/*if( ssndask!=null )	{
			if( <ssndask>.isplaying()==true )	{
				return;
			}
		}*/
		if( sc=="yes" )	{
			<ssndask>.stop(false);
			clsnd.cbplay( ssndyes );
		} else if (sc=="no")	{
			<ssndask>.stop(false);
			clsnd.cbplay( ssndno );
		}
	}
	butclick(string sc)	{
		if( sc=="bkg" )	{	return;	}
		gameapi.resume();
		buts.disableall();
		clsnd.cactsndstop(false);
		if( sc=="yes" && sfuncyes!=null)	{
			this.<sfuncyes>();
		} else if( sc=="no" && sfuncno!=null)	{
			this.<sfuncno>();
		}
	}
}

/***************************************************************************/
class classplacepointer	{
	init()	{
		new anima anpointer;
		anpointer.addmethod("onfinish", func { this.play(-1); } );
		new int _iz = 1000;
	}
	public load(string sfile)	{
		anpointer.load(sfile);
		this.setz(_iz);
		anpointer.hide();
	}
	public setz(int iz)	{
		_iz = iz;
		anpointer.setz(iz);
	}
	public stop()	{	anpointer.stop(false);	}
	public stoph()	{	anpointer.stop(false);	anpointer.hide();	}
	public show(int x, int y, string sdir)	{
		anpointer.setpos(x,y);
		anpointer.play(sdir);
	}
	move(@x, @y)	{	anpointer.move(x,y);	}
	public showob(string sob, string sdir)	{	this.show(<sob>.getcx(), <sob>.getcy(), sdir);	}
	public showpob(string sob, string sdir)	{	this.show(<sob>.getpx(), <sob>.getpy(), sdir);	}
}

/***************************************************************************/

class classfadeinout		{
	init()	{
		new timer timf;
		new string _sob;
		new int _istep;
		new int _ival;
		new int _ib1;
		new int _ib2;
		new string _sfun;
		new string _sfunfin;
		timf.addmethod("onfinish", "_ctimffin");
	}
	/***************\/\/\/\/\/ wewnetrzne \/\/\/\/\/\/************************************/
	_cfinito(int v)	{
		<_sob>.<_sfun>( v );
		if( _sfunfin!=null)	this.<_sfunfin>();
	}
	_ctimffin()	{
		_ival+=_istep;
		if( _ival >= _ib2 )	{
			this._cfinito( _ib2 );
		} else if( _ival<=_ib1 )	{
			this._cfinito( _ib1 );
		} else {
			<_sob>.<_sfun>( _ival );
			this.play();
		}
	}
	_play( int icycle, int istep, string sob, string sfun, int ib1, int ib2, string sfun2 )	{
		_sfunfin = sfun2;
		_ib1 = ib1;
		_ib2 = ib2;
		int i = istep.abs();
		if( icycle <= 0 || i==ib1 || i>ib2 )	return;
		_sfun = sfun;
		timf.setcycle( icycle );
		_sob = sob;
		if( istep>0 )	_ival = _ib1;
		else if( istep<0 )	_ival=_ib2;
		else return;
		<sob>.<sfun>( _ival );
		_istep = istep;
		timf.play();
	}
	/******************* /\/\/\/\/\/\/\ wewnetrzne /\/\/\/\ ****************************/
	imgtransparency(int icycle, int istep, string simg, string sfun)	{
		this._play( icycle, istep, simg, "transparency", 0, 255, sfun );
	}
	setopacity(int icycle, int istep, string simg, string sfun)	{
		this._play( icycle, istep, simg, "setopacity", 0, 255, sfun );
	}
	sndvolume(int icycle, int istep, string ssnd, string sfun)	{
		this._play( icycle, istep, ssnd, "setvol", 0, 100, sfun );
	}
	/***************************************************/
}

class SimpleCounter	{
	init(int ilength)	{
		.var2("length", ilength );
		new int iid = 0;
	}
	int next()	{	iid = (iid+1)%length;		iid;	}
	set(int i)	{	iid=i;	}
	reset()	{	iid=0;	}
	get()	{	iid;	}
}

/******************************************/

module clstrdigit	{
	init()	{}
	public string getdigit(int idigit, int ilepozycji)	{
		string s = idigit;
		while( s.length() < ilepozycji )	s = "0" + s;
		return s;
	}
	public string gettime(int itime, string smod)	{
		return this.getstime( this.geth(itime), this.getm(itime), this.gets(itime), 
			smod.contains("h"), smod.contains("m"), smod.contains("s") );
	}
	public string getstime(int ih, int im, int is, bool bh, bool bm, bool bs)	{
		string s = "";
		if( bh ) s+= ih;
		if( bm ) s+= (bh?":":"") + this.getdigit(im,2);
		if( bs ) s+= ((bh||bm)?":":"") + this.getdigit(is,2);
		return s;
	}
	public int geth(int itime)	{	return itime/3600;	}
	public int getm(int itime)	{	return (itime/60)%60;	}
	public int gets(int itime)	{	return itime%60;	}
	public string getns(int itime, int n)	{	return this.getdigit( this.gets(itime),n );	}
	public string getnm(int itime, int n)	{	return this.getdigit( this.getm(itime),n );	}
	string getbinary(int ival)	{
		string s = "";
		while(ival>0)	{
			s = "" + (ival%2) + s;
			ival/=2;
		}
		return s;
	}
}

public string getbinary			{	clstrdigit::getbinary(.get);		}
public string getdigit(int ile)		{	clstrdigit::getdigit(.get,ile);		}
public string getbindigit(int ile)	{	clstrdigit::getdigit( .getbinary,ile);	}

class Text	{
	init(string sfont, int ifontsize, int ifr, int ifg, int ifb, int x, int y, int z)	{
		if( sfont==null )	sfont = sgmfontfile;
		if( sfont.contains(".ttf") )	{
			new font _fnt;
			_fnt.load( sfont, ifontsize );
			sfont = "_fnt";
		}
		new int iR = ifr;
		new int iG = ifg;
		new int iB = ifb;
		new int iFontSize = ifontsize;
		new text txt;
		txt.setfont(sfont);
		txt.setz(z);
		txt.setpos(x,y);
		txt.show;
		
		new text txtbg;
		txtbg.hide();
	}
	public hide()	{	txt.hide;	}
	public show()	{	txt.show;	}
	public setpos(int x, int y)	{	txt.setpos(x,y);	}
	public set(string s)	{
		txt.set( s );
		txt.createtxt( iR, iG, iB );
	}
	public string get()	{	return txt.get;	}
	public setbg(int ir, int ig, int ib, int ia)	{
		txtbg.setbkg(txt.getpx()-iFontSize/2, txt.getpy()-iFontSize/2,
			txt.getw()+iFontSize, iFontSize*2, ir, ig, ib, ia );
		txtbg.setborders(1,255,255,255,128);
		txtbg.show();
	}
	operator=(string val)	{	this.set(val);	}
}

class Cypher : Text	{
	init(string sfont, int ifontsize, int ifr, int ifg, int ifb, int x, int y, int z)	{
		Text::init(sfont, ifontsize, ifr, ifg, ifb, x, y, z );
		this.set(0);
	}
	add(int dt)	{	this.set( dt + this.get );	}
	iget()		{	this.get->to_i;		}
	operator+(int val)	{	this.add(val);	}
	operator++()	{	this.add(1);	}
	operator--()	{	this.add(-1);	}
	operator-(int val)	{	this.add(-val);	}
	operator=(int val)	{	this.set(val);	}
	operator==(int val)	{	.get==val;	}
	operator!=(int val)	{	.get!=val;	}
	operator>(int val)	{	.get>val;	}
	operator<(int val)	{	.get<val;	}
}

class SecCounter	{
	init(string sdigits)	{
		new string sdigit = sdigits;
		new int itime;
		this.reset();
		this.cnewtimerfin("timcyk",1000,1, func { .update(1); .play; } );
	}
	public play()	{	timcyk.play();	}
	public stop()	{	timcyk.stop(false);	}
	public string sgettime()	{	return clstrdigit.gettime(itime, sdigit);	}
	public int gettime()	{	return itime;	}
	public reset()	{	this.update(-itime);	}
	public update(int isec)	{	itime+=isec;	}
}

class TextTimeCounter : Text, SecCounter	{
	init(string sfont, int ifontsize, int ifr, int ifg, int ifb, int x, int y, int z, string sdigits)	{
		Text::init(sfont, ifontsize, ifr, ifg, ifb, x, y, z);
		SecCounter::init(sdigits);
		.reset;
	}
	public update(int isec)	{
		SecCounter::update(isec);
		this.set( this.sgettime() );
	}
}

class gfxObject	{
	init(string sob)	{	new string sgfxobj = sob; }
	setpos		{	<sgfxobj>.setpos;	}
	move		{	<sgfxobj>.move;	}
	getpos		{	<sgfxobj>.getpos;	}
	getposx		{	<sgfxobj>.getposx;	}
	getposy		{	<sgfxobj>.getposy;	}
	getpx		{	<sgfxobj>.getpx;	}
	getpy		{	<sgfxobj>.getpy;	}
	getw			{	<sgfxobj>.getw;	}
	geth			{	<sgfxobj>.geth;	}
	getcx		{	<sgfxobj>.getcx;	}
	getcy		{	<sgfxobj>.getcy;	}
	getex		{	<sgfxobj>.getex;	}
	getey		{	<sgfxobj>.getey;	}
	lodx			{	<sgfxobj>.lodx;	}
	lody			{	<sgfxobj>.lody;	}
	setz			{	<sgfxobj>.setz;		}
	getz			{	<sgfxobj>.getz;	}
	show		{	<sgfxobj>.show;	}
	hide			{	<sgfxobj>.hide;	}
	isvisible		{	<sgfxobj>.isvisible;	}
	bool isin		{	<sgfxobj>.isin;		}
}

class gfxSquare : Color, gfxObject	{
	init(int x1, int y1, int w1, int h1)	{
		Color::init;
		.vars(A, "w", "h");
		w=w1; h=h1;
		new img imggfx;
		imggfx.setpos(x1,y1);
		gfxObject::init("imggfx");
	}
	build	{	imggfx.create(w,h,r,g,b,a);	}
	shadow(int dx, int dy, int alpha)	{
		|@x,@y| = imggfx.getpos;
		imggfx.setpos(0,0);
		new img _img1;
		new img _img2;
		if( imggfx.getw>0 )	{
			_img1.create(w,h,.transparent);
			_img1.blit("imggfx");
		} else _img1.create(w,h,.get);
		_img2.create(w,h,.black,alpha);
		if( dx<0 )	{
			_img1.move(-dx, 0);
			x+=dx;
		} else	_img2.move( dx, 0 );
		if( dy<0 )	{
			_img1.move(0,-dy);
			y+=dy;
		} else	_img2.move( 0, dy );
		w += dx.abs;
		h += dy.abs;
		imggfx.create(w, h, .transparent);
		imggfx.blit("_img2");
		imggfx.blit("_img1");
		delete _img1;
		delete _img2;
		imggfx.move(x,y);
	}
	blackborder(int width, int a2)	{	.border(width,width, .black,a2);	}
	border(int width, int height, int r2, int g2, int b2, int a2)	{
		|@x,@y| = imggfx.getpos;
		imggfx.setpos(0,0);
		new img _img;
		if( imggfx.getw>0 )	{
			_img.create(w,h,.transparent);
			_img.blit("imggfx");
		} else _img.create(w,h,.get);
		_img.move(width,height);
		w += 2*width;
		h += 2*width;
		imggfx.create(w,h,r2,g2,b2,a2);
		imggfx.blit("_img");
		delete _img;
		imggfx.move(x,y);
	}
}

class TextTyper : classlocker, gfxObject {
	init(string sfont, int isize, int ir, int ig, int ib, string schars, int ilimit)	{
		classlocker::init();
		sfont = .checkfont(sfont, isize);
		new int iR = ir;
		new int iG = ig;
		new int iB = ib;
		new int iFontSize = isize;
		new string sChars = schars;
		new int iLimit = ilimit;		// 0 - unlimited
		
		new text txt1;
		txt1.setfont(sfont);
		txt1.set("");
		new text txt2;
		txt2.setfont(sfont);
		txt2.set("_");
		txt2.createtxt(iR,iG,iB);
		txt2.hide();
		
		new string _sob=null;
		new string _sfun=null;
		
		this.cnewtimerfin("timcyk",300,1,"fintimcyk");
		
		gfxObject::init("txt1");
	}
	public isin(int x, int y, bool bv, bool ba)	{	txt1.isin(x,y,bv,ba);	}
	getcol	{	return iR,iG,iB;	}
	fintimcyk()	{
		if( this.getlock() )	return;
		this.updatecyk();
		this.play();
	}
	updatecyk()	{
		if( txt2.isvisible() )	{
			txt2.hide();
		} else {
			txt2.setpos( txt1.getex(), txt1.getpy() );
			txt2.show();
		}
	}
	public enable()	{
		this.unlock();
		this.updatecyk();
		timcyk.play();
	}
	public disable()	{
		txt2.hide();
		timcyk.stop(false);
		this.lock();
	}
	public onenter(string sob, string sfun)	{	_sob=sob;	_sfun=sfun;	}
	public setpos(int x, int y)	{	txt1.setpos(x,y);	}
	public setz(int z)	{	txt1.setz(z);txt2.setz(z);	}
	public get()	{
		string s = txt1.get();
		( s.length()>0 ) ? s : "";
	}
	getpx	{	txt1.getpx;	}
	getpy	{	txt1.getpy;	}
	public length	{	txt1.get->length;	}
	public set(string s)	{	txt1.set(s);	}
	public txtset(string s)	{	txt1.txtsetcol(s,.getcol);	}
	public limit=(int il)	{	iLimit=il;	}
	public onkeydown()	{
		if( this.getlock() )	return;
		.<this+"_ontype">;
		if( keyboard.iskeydown("enter") )	{
			this.disable();
			this.callfun(_sob,_sfun);
			return;
		}
		string s;
		if( sChars.contains("t") && keyboard.iskey("tab") )	s = " ";
		else s = keyboard.getkey();
		string s2 = txt1.get();
		if( ( (keyboard.isalpha && sChars.contains("a") ) || ( keyboard.isdigit && sChars.contains("0") )
			|| sChars.contains(s) ) && (iLimit<=0 || iLimit>s2.length)  )	{
			txt1.set( s2+s );
			txt1.createtxt(iR,iG,iB);
			this.updatecyk();
		} else if (keyboard.iskey("backspace") && s2.length()>0)	{
			txt1.set( s2.strsube(1) );
			txt1.createtxt(iR,iG,iB);
			this.updatecyk();
		}
	}
}

class ConTextTyper : TextTyper, ObjController	{
	init()	{
		TextTyper::init();
		ObjController::init();
	}
}

class TextBoxTyper : LObjController	{
	init(string sfont, int ish, int isw, int ir, int ig, int ib, string schars, int x, int y, int w, int h, int dy)	{
		LObjController::init;
		new @Font = .checkfont(sfont, ish);
		.vars(A,"Cols", "Rows");
		Cols = w/isw;
		Rows = h/(ish+dy);
		new @Row = 0;
		new @X = x;
		new @Y = y;
		new @W = w;
		new @H = h;
		new @Size = ish;
		new @Dy = dy;
		new @Z = 0;
		string s;
		new gmimgvec grtt;
		new gmimgvec gren;
		for( int i=0; i<Rows; i++)	{
			s = "tt"+i;
			new TextTyper <s>(Font,ish,ir,ig,ib,schars,Cols);
			<s>.setpos( x, y+i*(ish+dy) );
			grtt.add(s);
		}
	}
	size	{	grtt.size;	}
	setz(int z)	{	Z = z; grtt.setz(z);	gren.setz(z); }
	getz	{	Z;	}
	show	{	grtt.show;	}
	hide		{	grtt.hide;		}
	enumerate(int dx)	{
		string s[2];
		for( int i=0; i<grtt.size; i++)	{
			s0 = "txte"+i;
			new text <s0>;
			gren.add(s0);
			<s0>.setz(Z);
			<s0>.setfont(Font);
			<s0>.txtsetcol(""+(i+1)+".", tt0.getcol);
			<s0>.setpos(X-<s0>.getw-dx,Y+i*(Size+Dy));
		}
	}
	cut(int id)	{	Rows=id;	}
	enable	{	.unlock;	.activateact;	}
	disable	{	.lock; grtt.eval("disable");	}
	actual	{	"tt"+Row;	}
	activate(int id)	{
		.unlock;
		if( id>=0 && id<Rows )	{
			.deactivate;
			Row = id;
			<"tt"+ Row>.enable;
		}
	}
	activateact	{	.activate(Row);	}
	deactivate	{	<"tt"+Row>.disable;	}
	onkeydown	{
		if(.getlock)	return;
		.<this+"_boxontype">;
		if( keyboard.iskeydown("enter") )		{
			@s = .getid(Rows-1);
			s.clear;
			if( s.length==0 )	{
				for( @i=Rows-1; i>Row+1; i--)	.setid( .getid(i-1), i);
				.setid("", Row+1);
			}
			.activate(Row+1);
		} else if (keyboard.iskey("up") && Row>0) .activate(Row-1);
		else if (keyboard.iskey("down") && Row<Rows-1) .activate(Row+1);
		else if (keyboard.iskey("backspace") && <.actual>.length==0 ) {
			for( @i=Row; i<Rows-1; i++)	.setid( .getid(i+1), i);
			.setid("",Rows-1);
			.activate(Row-1);
		} else grtt.eval("onkeydown");
	}
	onmouselclick	{
		if(.getlock)	return;
		|int x, int y| = mouse.getpos;
		
		if( clsurf.isin2(x,y,X,Y,W,H) )	{
			.deactivate;
			.activate( ((y-Y)*Rows)/H );
		} else {
			.<this+"_OUTSIDE">;
		}
	}
	string getid(int id)	{	<"tt"+id>.get;	}
	string get	{	.getfrom(0);	}
	string getfrom(int id)	{
		string s = "";
		for( int i=id; i<grtt.size; i++) s += <"tt"+i>.get;
		s;
	}
	int nonempty(int id)	{
		string s;
		for( ; id<grtt.size; id++)	{
			s = <"tt"+id>.get;
			s.clear;
			if( s.length > 0 ) return id;
		}
		-1;
	}
	clear	{	grtt.txtreset;	}
	setid(string s, int id)	{	if( grtt.size>=id )	<"tt"+id>.txtset(s);	}
	settext(int ile)	{
		while(ile>0)	{
			ile--;
			.setid(_,ile);
		}
	}
}

/****************************************************************/
class DelayTaker	{
	init()	{
		new bool bonrel = false;
		new bool bstart = false;
		this.cnewtimerfin("timwez",300,1, func { bonrel=true; } );
	}
	public setdelay(int idelay)	{	timwez.delay(idelay);	}
	public take()	{
		timwez.play();
		bstart=true;
		bonrel=false;
	}
	public ret()	{
		bonrel=false;
		bstart=false;
		timwez.stop(false);
	}
	public bool isonclick()	{
		this.stoptimer();
		( bstart && !bonrel );
	}
	public bool isonrel()	{
		this.stoptimer();
		( bstart && bonrel );
	}
	public bool istaken()	{	bstart;	}
	public stoptimer()	{	timwez.stop(false);	}
}


class ImgMover	{
	init()	{
		new string smoved=null;
		new int ilastx;
		new int ilasty;
		new int irelx;
		new int irely;
	}
	public mssetobj(string s)	{	this.setobj(s,mouse.getpos);	}
	public setobj(string s, int x, int y)	{	this.set(s,x,y,0,0);	}
	public set(string s, int x, int y, int dx, int dy)	{
		ilastx = <s>.getposx()-dx;
		ilasty = <s>.getposy()-dy;
		irelx = x-<s>.getpx();
		irely = y-<s>.getpy();
		smoved = s;
	}
	public msmove()	{	this.move(mouse.getpos);	}
	public msftmove()	{	this.ftmove(mouse.getpos);	}
	public move(int x, int y)	{
		if( smoved!=null )	<smoved>.setpos( x-<smoved>.lodx()-irelx, y-<smoved>.lody()-irely );
	}
	public ftmove( int x, int y)	{	if( smoved!=null )	<smoved>.setpos( x, y );	}
	public retobj()	{	this.ret(0,0);	}
	public ret(int dx, int dy)	{
		<smoved>.setpos(ilastx+dx, ilasty+dy);
		this.free();
	}
	public put(int x, int y)	{
		<smoved>.setpos(x,y);
		this.free();
	}
	public free()	{	smoved=null;	}
	public string getmover()	{	return smoved;	}
	public string getfree	{	@s = smoved; .free; s; }
	public bool moving()	{	return smoved!=null;	}
}

class ConImgMover : ImgMover, ObjController	{
	init()	{
		ImgMover::init();
		ObjController::init();
	}
	onmousemove()	{	this.msmove();	}
}

class DelayMover : ImgMover, LObjController	{
	init()	{
		ImgMover::init();
		LObjController::init();
		new DelayTaker cldt; 
	}
	_put()	{
		cldt.ret();
		this.<_sme+"_PUT">();
	}
	set(string s, int x, int y, int dx, int dy)	{
		ImgMover::set(s,x,y,dx,dy);
		cldt.take;
	}
	onmousemove()	{	this.msmove();	}
	onmouselclick()	{
		if( this.getlock() ) return;
		if( cldt.isonclick() )	this._put();
		else if (!cldt.istaken())
			this.<_sme+"_GET">();
	}
	onmouselrel()	{
		if( this.getlock() ) return;
		if( cldt.isonrel() )
			this._put();
	}
}

class Rewinder : classlocker	{
	init()	{
		classlocker::init();
		new string sarrowdir;
		new int ilenx;
		new int ileny;
		new string sgr;
		new string sorientation;
		new bool bvertical;
		new bool bfilteritem = false;
		
		// clip obiektow
		new int ibx1=0;
		new int ibx2=800;
		new int iby1=0;
		new int iby2=600;
		
		new int iodleg = 2;	// odleglosc pomiedzy przedmiotami
		
		new ImgMover clmv;
		
		this.cnewtimercyclefin("timtick", 1, 1, "timfin");
		
		new snd fxrew;
// 		fxrew.addmethod("onfinish", func { this.play(); } );
	}
	public movefilter()		{	bfilteritem=true;	}
	public movenormal()	{	bfilteritem=false;	}
	public setfxrew(string sfile)	{
		fxrew.load(this.getsndpath()+sfile);
	}
	public getitem(string s, int x, int y)	{
		/*clmv.set(s,x,y,<sgr>.getpx(),<sgr>.getpy());
		<s>.clip(0,0,800,600);
		<sgr>.movefrom(s, 0, -<s>.geth);
		<sgr>.remove(s);*/
		<s>.setz( <s>.getz+1 );
		clmv.set(s,x,y,<sgr>.getpx(),<sgr>.getpy());
		<s>.clip(0,0,800,600);
		if( sorientation=="up" || sorientation=="down")	{
			<sgr>.movefrom(s, -(<s>.getw+iodleg), 0 );
			<s>.move( <s>.getw,0 );
		} else {
			<sgr>.movefrom(s, 0, -(<s>.geth+iodleg));
			<s>.move(0, <s>.geth );
		}
		<sgr>.remove(s);
	}
	public bool pickup(int x, int y)	{
		if( <sgr>.isin(x,y,true,true) )	{
			this.getitem( <sgr>.getsfound(), x, y );
			return true;
		}
		return false;
	}
	public bool mspickup()	{	return this.pickup(mouse.getpos );	}
	public freeitem()	{	clmv.free();	}
	public moveitem()	{
		if( bfilteritem )		clmv.msftmove();
		else		clmv.msmove();
	}
	public retitem()	{
		string s = clmv.getmover();
		clmv.ret(<sgr>.getpx(),<sgr>.getpy());
		this.putitem(s);
	}
	public putitem(string s)	{
		if( sorientation=="up" || sorientation=="down")	{
			<s>.move( <sgr>.getex-<s>.getpx+iodleg, 0);
		} else {
// 			@dx = anupstd.getex - <s>.getw;
// 			<s>.setpos( dx - <s>.lodx, <sgr>.getey-<s>.lody);
			<s>.move( 0, <sgr>.getey-<s>.getpy+iodleg);
		}
		<sgr>.add(s);
		<s>.setz( <s>.getz-1 );
		<s>.clip(ibx1,iby1,ibx2,iby2);
	}
	public string getmoved()	{	return clmv.getmover();	}
	public int getbutw()	{	return anupstd.getw();	}
	public int getbuth()	{	return anupstd.geth();	}
	public movearrows(int x, int y)	{	grarrows.move(x,y);	}
	public build(string sfile, int z, string scursor, string sorient, int dt, string sgrelem)	{
		sgr = sgrelem;
// 		this.newanima("anupstd",sfile,z);
		new anima anupstd;
		anupstd.load(sfile);
		anupstd.setz(z);
		
		anupstd.setframe("up",0);
		this.copyanima("anupstd","anupact");
		anupact.setframe("up",1);
		this.copyanima("anupstd","andownact");
		andownact.setframe("down",1);
		this.copyanima("anupstd","andownstd");
		andownstd.setframe("down",0);
		this.newbutan("butup","anupstd","anupact",null,scursor);
		this.newbutan("butdown","andownstd","andownact",null,scursor);
		butup.addmethod("onmoveon","_rewbutmoveon");
		butdown.addmethod("onmoveon","_rewbutmoveon");
		butup.addmethod("onmoveoff","_rewstrzalkaoff");
		butdown.addmethod("onmoveoff","_rewstrzalkaoff");
		butup.addmethod("onclick","_rewbutclick");
		butdown.addmethod("onclick","_rewbutclick");
		butup.addmethod("onrel","_rewbutrel");
		butdown.addmethod("onrel","_rewbutrel");
		sorientation=sorient;
		new gmimgvec grarrows;
		_ = "grarrows" .+ "anupstd" .+ "anupact" .+ "andownact" .+ "andownstd";
		
		int dy, int dx, int ix, int iy;
		if( sorientation=="up" || sorientation=="down")	{
			bvertical = false;
			ilenx = dt;
			if( sorientation=="down")	{
				anupstd.setpos(0,600-anupstd.geth());
				anupact.setpos(0,600-anupact.geth());
				andownstd.setpos(800-andownstd.getw(),600-andownstd.geth());
				andownact.setpos(800-andownact.getw(),600-andownact.geth());
				dy = andownstd.getey();
			} else {
				anupstd.setpos(0,0);
				anupact.setpos(0,0);
				andownstd.setpos(800-andownstd.getw(),0);
				andownact.setpos(800-andownact.getw(),0);
				dy = 0;
			}
			ibx1 = anupstd.getex()+iodleg;
			ibx2 = andownstd.getpx()-iodleg;
			dx = ibx1;
		} else {
			bvertical = true;
			ileny = dt;
			if( sorientation=="right")	{
				anupstd.setpos(800-anupstd.getw(),0);
				anupact.setpos(800-anupact.getw(),0);
				andownstd.setpos(800-andownstd.getw(),600-andownstd.geth());
				andownact.setpos(800-andownact.getw(),600-andownact.geth());
				dx = anupstd.getex();
			} else {
				anupstd.setpos(0,0);
				anupact.setpos(0,0);
				andownstd.setpos(0,600-andownstd.geth());
				andownact.setpos(0,600-andownact.geth());
				dx = 0;
			}
			iby1 = anupstd.getey()+iodleg;
			iby2 = andownstd.getpy()-iodleg;
			dy = iby1;
		}
		butup._rewbuildbut(this.getname(),"up");
		butdown._rewbuildbut(this.getname(),"down");
		
		int ile = <sgrelem>.size();
		<sgrelem>._setpos(dx,dy);
		new int ilimx = dx;
		new int ilimy = dy;
		string s;
		for(int i=0; i<ile; i++)	{
			s = <sgr>.get(i);
			if( sorientation=="right")	{
				<s>.setpos( dx - <s>.getw() - <s>.lodx(), dy - <s>.lody() );
				dy += <s>.geth()+iodleg;
			} else if (sorientation=="left")	{
				<s>.setpos( dx - <s>.lodx(), dy - <s>.lody() );
				dy += <s>.geth()+iodleg;
			} else if (sorientation=="up")	{
				<s>.setpos( dx - <s>.lodx(), dy - <s>.lody() );
				dx += <s>.getw()+iodleg;
			} else if (sorientation=="down")	{
				<s>.setpos( dx - <s>.lodx(), dy - <s>.geth() - <s>.lody() );
				dx += <s>.getw()+iodleg;
			}
			<s>.clip(ibx1,iby1,ibx2,iby2);
		}
	}
	/*************************************/
	_rewbuildbut(string s, string s2)	{
		new string _sob = s;
		new string _sdir;
		if( s2=="up" )	{
			if(bvertical==false)	{	_sdir = "left";	}
			else {	_sdir = "up";	}
		} else if (s2=="down")	{
			if(bvertical==false)	{	_sdir = "right";	}
			else {	_sdir = "down";	}
		}
	}
	_rewbutmoveon()	{
		//this.mstrzalkaon(_sdir);
		this.<_sob+"_"+_sdir+"_MOVEON">();
	}
	_rewbutclick()	{
		this.mstrzalkaon(_sdir);
		this.<_sob+"_"+_sdir+"_CLICK">();
	}
	mstrzalkaon(string s)	{
		sarrowdir=s;
		timtick.play();
	}
	_rewbutrel	{
		sarrowdir=null;
		timtick.stop(false);
		fxrew.stop(false);
	}
	_rewstrzalkaoff()	{
		sarrowdir=null;
		timtick.stop(false);
		fxrew.stop(false);
		this.<_sob+"_"+_sdir+"_MOVEOFF">();
	}
	timfin()	{
		if( this.getlock() )	{	return;	}
		bool bok = false;
		if( sarrowdir!=null && !<sgr>.empty())	{
			if( sarrowdir=="up")	{
				if( <sgr>.getey() > andownstd.getpy() - ileny )	{
					<sgr>.move(0,-ileny);
					bok=true;
				}
			} else if (sarrowdir=="down") {
				if( <sgr>.getpy() < ilimy )	{
					<sgr>.move(0,ileny);
					bok=true;
				}
			} else if (sarrowdir=="left")	{
				if( <sgr>.getex() > andownstd.getpx() - ilenx )	{
					<sgr>.move(-ilenx,0);
					bok=true;
				}
			} else if (sarrowdir=="right") {
				if( <sgr>.getpx() < ilimx )	{
					<sgr>.move(ilenx,0);
					bok=true;
				}
			}
		}
		if( bok )	{
			if( !fxrew.isplaying() )	fxrew.play();
		} else {
			fxrew.stop(false);
		}
		this.play();
	}
}

class ConRewinder : Rewinder, ObjController {
	init()	{
		Rewinder::init();
		ObjController::init();
		new DelayTaker cldt; 
	}
	public getitem(string s, int x, int y)	{
		Rewinder::getitem(s,x,y);
		cldt.take();
	}
	_put()	{
		cldt.ret();
		this.<_sme + "_PUT">();
	}
	onmousemove()	{	this.moveitem();	}
	onmouselrel()	{
		if( this.getlock() )	return;
		if( cldt.isonrel() )	{	this._put();	}
	}
	onmouselclick()	{
		if( this.getlock() ) return;
		if( cldt.isonclick() )	{
			this._put();
		} else if ( !cldt.istaken() )	{
			this.<_sme+"_GET">();
		}
	}
}

class Buttons : LObjController	{
	init(string sfile)	{
		LObjController::init;
		.unlock;
		new gmimgvec grbuts;
		new string sanbut = "anbut";
		.newanima(sanbut, sfile, 10);
		_ = .newanactionsgr(sanbut, sanbut, "grbuts");
		anbut.hide;
		grbuts.setz(10);
		grbuts.removeif( func {
			if( .actionname=="bkg" ) { .setz( .getz-1); true; }
			else false; 
			});
		new string slastb = null;
		.var2("sobject", null);
	}
	_release()	{
		<slastb>.setframe(-1,0);
		.copyobj;
		.<this + "_moveoff">();
		slastb = null;
	}
	onmousemove()	{
		if( .getlock ) return;
		grbuts.setframe(-1,0);
		def id =  grbuts.isin(mouse.getpos,true,true);
		if( slastb!=null ) <slastb>.setframe(-1, 1);
		if( id ) {
			string s = grbuts.getsfound;
			if( s!=slastb )	{
				if( slastb!=null )	._release;
				slastb = s;
				<s>.setframe(-1,1);
				.copyobj;
				.<this + "_moveon">();
			}
		} else if( slastb!=null )	{
			._release;
		}
		slastb==null ? bsms.setstd : bsms.setact;
	}
	copyobj()	{	sobject = <slastb>.actionname;	}
	onmouselclick()	{
		if( .getlock ) return;
		if( slastb!=null )	{
			.copyobj;
			.<this + "_lclick">;
		}
	}
	disable	{
		.lock;
		grbuts.hide;
		if( slastb!=null )	{
			bsms.setstd;
			slastb=null;
		}
	}
	enable	{
		.unlock;
		grbuts.show;
	}
}

class TextDb : classlocker, ObjController, gfxObject {
	init(string sfont, int isize, string sdbfile, int r, int g, int b, int x, int y, int dy, int z, string sdir)	{
		classlocker::init;
		ObjController::init;
		new string sFont = sfont;
		sfont = .checkfont( sfont, isize );
		new int iFontSize = isize;
		if( sdbfile.contains(".db") )	{
			.newdb( "dbtxt", sdbfile );
		} else {
			new db dbtxt;
			if( sdbfile.getb(0,5)=="$var:" )	dbtxt.dbcopy( sdbfile.strsubb(5) );
			else dbtxt.dbaddlast( sdbfile );
		}
		string s;
		int w = 0, int ile = dbtxt.getrowsno;
		new gmimgvec grtxt;
		grtxt._setpos(x,y);
		for( int i=0; i< ile; i++)	{
			s = "txt" + i;
			new text <s>;
			<s>.setfont( sfont );
			<s>.set( dbtxt.get(i,0) );
			<s>.setpos(x,y);
			y+=isize+dy;
			<s>.setz(z);
			<s>.createtxt(r,g,b);
			if( <s>.getw>w ) w = <s>.getw;
			grtxt.add(s);
		}
		if( sdir == "right" || sdir =="center" )	{
			for( i=0; i<ile; i++)	{
				s = "txt" + i;
				if( sdir == "center" )	{
					<s>.move( (w-<s>.getw)/2, 0 );
				} else {
					<s>.move( w-<s>.getw, 0 );
				}
			}
		}
		gfxObject::init("grtxt");
	}
	stdshadow(int dt)	{	.setshadow(0,0,0,dt);	}
	setshadow(int r, int g, int b, int dt)	{
		string s[2];
		string sfont = ._checkfont(sFont, iFontSize, "_fntbrd");
		for( int i=0; i< dbtxt.getrowsno; i++)	{
			s0 = "txt" + i;
			s1 = "txts" + i;
			new text <s1>;
			<s1>.set( <s0>.get );
			<s1>.setfont( sfont );
			<s1>.setz( <s0>.getz-1 );
			<s1>.setpos( <s0>.getpx+dt, <s0>.getpy+dt );
			<s1>.createtxt(r,g,b);
			grtxt.add(s1);
		}
	}
	setz(int z)	{
		for( int i=0; i< dbtxt.getrowsno; i++)	{
			<"txt" + i>.setz(z);
			<"txts" + i>.setz(z-1);
		}
	}
	view	{
		@s = _;
		string s2;
		while(A!=s)	{
			s2 = grtxt.get(s);
			<s2>.show;
			s2 = "txts" + s2.strsubbs("txt");
			if( engine.varexist(s2) ) <s2>.show;
			@s=_;
		}
	}
}

class Lexer	{
	init	{}
	buildlex	{
		.vars(A,"id","found");
		new vector vconsts;
		vconsts.type("string");
		new vector vtmp1;
		vtmp1.type("string");
		new vector vtmp2;
		vtmp2.type("string");
		
		new int dot = "."->getbyte(0);
	}
	bool _isvar(int b1, int b2)	{
		int i = id;
		found = "";
		int ib;
		while(i<.length)	{
			ib = .getbyte(i);
			if( ib>=b1 && ib<=b2 )	{
				found += .getb(i,1);
				i++;
			} else i = .length;
		}
		found.length;
	}
	bool isreal	{
		int i = id;
		found = "";
		int ib;
		bool kropka=true;
		while(i<.length)	{
			ib = .getbyte(i);
			if( (ib>=BYTE0 && ib<=BYTE9) || (ib==dot&&kropka) )	{
				if( ib==dot ) kropka=false;
				found += .getb(i,1);
				i++;
			} else i = .length;
		}
		if( kropka || found.getb(0,1)=="." || found.gete(0,1)=="." ) found="";
		found.length;
	}
	bool isident	{
		int i = id;
		found = "";
		int ib;
		while(i<.length)	{
			ib = .getbyte(i);
			if( (ib>=BYTEa && ib<=BYTEz) || (ib>=BYTEA && ib<=BYTEZ) || ib==BYTE_ ||
				(i>id && ib>=BYTE0 && ib<=BYTE9) )	{
				found += .getb(i,1);
				i++;
			} else i = .length;
		}
		found.length;
	}
	bool isliteral	{
		if( .check!="\"" )	return false;
		int i = id+1;
		found = "";
		string s;
		while(i<.length)	{
			s = .getb(i,1);
			if( s=="\"" )	{
				//found += s;
				return true;
			} else {
				found += s;
				i++;
			}
		}
		false;
	}
	bool isconst	{
		string s0;
		bool b = .isident;
		for( int i=0; i< vconsts.size; i++)	{
			s0 = vconsts.get(i);
			if( b )	{
				if( s0 == found )	return true;
			} else {
				found = .getb(id, s0.length);
				if( s0 == found ) return true;
			}
		}
		false;
	}
	gettoken(string svec, bool bideal)	{
		<svec>.free;
		while( .notend )	{
			if (.check==" ")	id++;
			else if (.isconst)	{	<svec>.add(.read);	}
			else if (.isreal )		{<svec>.add( "$real" );	.next; if( bideal ) <svec>.add( found );}
			else if (.isint )		{<svec>.add( "$int" );	.next; if( bideal ) <svec>.add( found );}
			else if (.isident )	{<svec>.add( "$alpha" );	.next; if( bideal ) <svec>.add( found );}
			else if (.isliteral )	{<svec>.add( "$literal" );	.next; id+=2; if( bideal ) <svec>.add( found );}
			else	{<svec>.add("$error"); id++; }
		}
	}
	int expectdb(string sdb, bool bideal)	{	// identyczne lub parse
		int j, string s;
		for( int i=0; i< <sdb>.getrowsno; i++)	{
			//vtmp2.veccopydbrow(sdb,i);
			vtmp2.free;
			for( j=0; j< <sdb>.getcolsno(i); j++)	{
				s = <sdb>.get(i,j);
				s.clear;
				if( s!="" ) vtmp2.add(s);
			}
			if( .expectvec("vtmp2", bideal) )	return i;
		}
		-1;
	}
	bool expectvec(string svecsrc, bool bideal)	{
		id = 0;
		.gettoken("vtmp1", bideal);
		/*vtmp1.print;
		<svecsrc>.print;*/
		vtmp1.veceq(svecsrc);
		/*bool b = vtmp1.veceq(svecsrc);
		if( !b ) {
			("wrong expect "+.get)->print;
			vtmp1.print;
			<svecsrc>.print;
		}
		b;*/
	}
	bool expects(string s, string ssep, bool bideal)	{
		vtmp2.vecbuildfromstring(s,ssep);
		.expectvec("vtmp2", bideal);
	}
	consts=	{	vconsts.withlist("addbegin");	}
	setas(string sob)	{
		<sob>.addmethod("buildlex", "buildlex");
		<sob>.buildlex;
		<sob>.addmethod("start",	func { (string s) .set(s);	id=0; } );
		<sob>.addmethod("notend",	func {	id<.length;	} );
		<sob>.addmethod("getnext",	func { if( id==.length ) return null;
					id++;	.getb(id-1,1);	} );
		<sob>.addmethod("next",	func { id+=found.length;	} );
		<sob>.addmethod("check",	func { if( id==.length ) return null; found=.getb(id,1); found; });
		<sob>.addmethod("ischar",	func { (string s) s.contains( .getb(id,1) ); } );
		<sob>.addmethod("isint",	func{	._isvar(BYTE0, BYTE9);	} );
		<sob>.addmethod("isreal", "isreal");
		<sob>.addmethod("isbinary",	func{	._isvar(BYTE0, BYTE0+1);	} );
		<sob>.addmethod("isident",	"isident" );
		<sob>.addmethod("isconst",	"isconst" );
		<sob>.addmethod("_isvar", "_isvar");
		<sob>.addmethod("read",	func { .next;	found;	} );
		<sob>.addmethod("isliteral", "isliteral");
		<sob>.addmethod("gettoken", "gettoken");
		<sob>.addmethod("expects", "expects");
		<sob>.addmethod("expectvec", "expectvec");
		<sob>.addmethod("expectdb", "expectdb");
		<sob>.addmethod("consts=", "consts=");
	}
}

game Tclassmenu	{
	init()	{
		new db _dbl;
		new gmobjvec gr1;
		gr1.add("bkg");
	}
	public tload(string spath, string sbuts, string sdbfile)	{
		this.setgraphpath(spath);
		if( sdbfile!=null )	{
			_dbl.loadscript(this.getgraphpath()+sdbfile);
			for(int i=0; i<_dbl.getrowsno();i++)	{
				this.newsnd("snd"+_dbl.get(i,0), _dbl.get(i,1)+".wav");
			}
		}
		new classbutton _clb;
		_clb.build2( this.getgraphpath() + sbuts, 10, "imglobcurs", "gr1" );
		_clb.clickfunc("_gmbutclick");
		_clb.movonfunc("_gmbutmove");
		if(engine.varexist("sndintro"))	this.cbplay("sndintro");
	}
	mouselclick()	{
		this.cactsndstop(true);
	}
	_gmbutmove(string s)	{
		sndakskermovon.play();
		if( engine.varexist("sndintro") && sndintro.isplaying() )	return;
		if( engine.varexist("snd"+s) )	this.crselfplay("snd"+s);
	}
	_gmbutclick(string s)	{
		this.<s+"_BUTCLICK">();
	}
}

class TMenu : GameController	{
	init()	{}
	tinit(string sbase, string spath, string sbuts)	{
		.setgraphpath(spath);
		GameController::init(sbase);
		new Buttons but1(sbuts);
	}
	mousel_click()	{
		.cactsndstop(true);
	}
	but1_moveon	{
		string s = but1.sobject;
		sndakskermovon.play;
		if( engine.varexist("sndintro") && sndintro.isplaying )	return;
		if( engine.varexist("snd"+s) )	this.crselfplay("snd"+s);
		.<s+"_MOVEON">;
	}
	but1_moveoff	{	.<but1.sobject + "_MOVEOFF">;	}
	but1_lclick()	{
		this.<but1.sobject+"_BUTCLICK">();
	}
}

class classadvkomputro : classadv	{
	init()	{
		igmstate = 0;
		classadv::init();
		this.setwavpath("sounds/komputro/");
		this.newsnd("sfxgetitem", "sfx/getitem.wav");
		bsms.setstd();		// ustawia standardowo 
		clmusic.play();
		clbuts.reset();
		//clesav.save();
	}
	playtalk	{	.play("talk"+2->rand);	}
	cfinprof	{	if (.actionname->strsube(1)=="talk")	.playtalk;	}
	cshowbut(@dir)	{	clp.show(cbok.getimgfunc("getcx"), cbok.getimgfunc("getcy"), dir); }
	profstop	{	anprof.play("stand");	}
	jackstop	{	anjack.play("stand");	}
	jacksay(string s)    {
		<GAME>(s) { (@s)
			classsound::cbplay2(s);
			anjack.playtalk;
		};
	}
	profsay(string s)    {
		<GAME>(s) { (@s)
			classsound::cbplay2(s);
			anprof.playtalk;
		};
	}
	loadguys	{	._loadguys("scripts/common/profesor","scripts/common/jacek"); }
	_loadguys(string sprof, string sjack)	{
		new anima anprof (sprof) { (@sprof)
			.load(sprof+".pyz");
			.setz(100);
			.setframe("stand",0);
			.addmethod("onfinish", "cfinprof");
		};
		new anima anprofsh	{
			.copy("anprof");
			.setframe("shadow",0);
			.setz(15);
		};
		new anima anjack (sjack) { (@sjack)
			.load(sjack + ".pyz");
			.setframe("stand",0);
			.addmethod("onfinish", "cfinprof");
			.setz(110);
		};
		new anima anjacksh	{
			.copy("anjack");
			.setframe("shadow",0);
			.setz(15);
		};
	}
	komnapis(string sname, string snapis, int isize, string scol, int z)	{
		int c[3];
		match(scol)	{
			"red"		=> |c0,c1,c2| = 255, 15, 15;
			"lred"	=> |c0,c1,c2| = 255, 105, 105;
			"green"	=> |c0,c1,c2| = 15, 255, 15;
			"blue"	=> |c0,c1,c2| = 15, 15, 255;
			"lblue"	=> |c0,c1,c2| = 105, 105, 255;
			"black"	=> |c0,c1,c2| = 5, 5, 5;
			? 		=> |c0,c1,c2| = 255, 255, 255;
		}
		new TextDb <sname>(null,isize, snapis, c0,c1,c2, 0,0,isize/2, z, "center");
		<sname>.stdshadow( ( isize<=12 ? 1 : 2 ) );
		<sname>.hide;
	}
	napisshow(int x, int y)	{
		.show;
		.move(x,y);
	}
	napispod(string s)	{	.napisshow(<s>.getcx-.getw/2, <s>.getey+5); }
	loadlekcja	{
		new db dblekcja;
		dblekcja.load("scripts/common/lekcje.db");
		@id = dblekcja.findbyrow( gameapi.getgamename );
		.komnapis("tdlekcja", dblekcja.get(id,1), 22, dblekcja.get(id,2), 200);
		tdlekcja.napisshow(3,3);
		@icol = 3;
		while(icol<dblekcja.getcolsno(id) )	{
			.komnapis(dblekcja.get(id, icol), dblekcja.get(id,icol+1),
				dblekcja.get(id,icol+2), dblekcja.get(id, icol+3), 200);
			icol+=4;
		}
	}
	printend(string s)	{
		new gfxSquare gsend(100,100,600,400);
		gsend.set(.grey(240), 255);
		gsend.build;
		gsend.setz(1500);
		gsend.shadow(2,2,128);
		
		new TextDb tdend(null, 12, s, .blue, 125,115, 5, 1550, "left");
	}
	/***********************************************************/
	exit()	{
		bsms.setstd;
		this.game_exit;
	}
	public askrestart()	{	claskexit.askrestart;	}
	/***********************************************************/
	advclick()	{
		if( igmdebug && (igmstate==0 || igmstate==5) )	{
			this.cactsndstop(true);
		}
	}
	public keyrestart	{
		if( igmdebug && keyboard.iskeydown("lctrl") && keyboard.iskey("r") )
			gameapi.play(this);
	}
	/***********************************************************/
	keydown()	{
		if( igmdebug==false )	{	return;	}
		
		if( keyboard.iskey("p") )	{
			clpause.pause();
		} else if( keyboard.iskey("escape") )	{
			claskexit.askexittomenu();
		} else {
// 			clnextgm.checkkey();
		}
	}
	/***********************************************************/
	key_down	{
		if( igmdebug && keyboard.iskeydown("lctrl") && keyboard.iskey("r") )	.crestart;
	}
	cbok_MOVEON	{	sndakskermovon.play;	}
}

class Komputro : classadvkomputro, GameController	{
	init(string s)	{
		classadvkomputro::init;
		GameController::init(s);
	}
}

new classgamepause clpause;
new classgamemusic clmusic;
clmusic.sndbgrpath("sounds/komputro/bgr/");
clmusic.musicpath("sounds/music/");
clmusic.load("sounds/musickomputro.db");

new snd sndakskermovon;
sndakskermovon.load("sounds/komputro/sfx/butmovon.wav");

module claskexit : classasker	{
	init()	{
		classasker::init();
		
		this.setwavpath("sounds/komputro/");
		this.newsnd("sndaskexit", "nar07.wav");
		this.newsnd("sndyes", "nar08.wav");
		this.newsnd("sndno", "nar09.wav");
		this.newsnd("sndaskrestart", "nar11.wav");
		this.newsnd("sndaskrestart2", "nar14.wav");
		this.load( "scripts/common/asker.pyz", 2000 );
		this.fxonmovon("sndakskermovon");
	}
	askexittomenu()	{
		this.ask( "sndaskexit", "sndyes", "sndno", "myestomenu", "mnotomenu");
	}
	askrestart()	{
		this.ask( "sndaskrestart", "sndyes", "sndno", "myesrestart", "mnorestart");
	}
	askrestart2()	{
		this.ask( "sndaskrestart2", "sndyes", "sndno", "myesrestart", "mnorestart");
	}
	mnotomenu()	{}
	myestomenu()	{
		match( gameapi.getgamename() )	{
			"MenuGlowne" => "Outro";
			? => "MenuGlowne";
		}
		gameapi.play;
	}
	mnorestart()	{
		/*match(gameapi.getgamename)	{
			"Memo" => "MenuGlowne";
			? => "MenuGlowne";
		}
		gameapi.play;*/
	}
	myesrestart()	{	this.crestart();	}
}


module clbuts	{
	init()	{}
	load()	{
		new classbutton buts;
		buts.build("scripts/common/buttons.pyz", 4000, "imglobcurs");
		buts.transclickfunc( engine.actclassname(), "butclick");
		buts.transmovonfunc( engine.actclassname(), "butmovon");
		buts.transmovofffunc( engine.actclassname(), "butmovoff");
		buts.disableall();
		new db dbb;
		dbb.load("scripts/common/buts.db");
		new snd sndfxglobon;
		sndfxglobon.load("sounds/komputro/sfx/globbutmovon.wav");
		new @bvisible = true;
	}
	reset()	{
		buts.disableall();	
		@sgame = gameapi.getgamename;
		int pos = dbb.findbyrow( sgame );
		if( pos>=0 )	{
			int ile = dbb.getcolsno( pos );
			for( int i=1; i<ile; i++)	{
				buts.enable( dbb.get( pos, i ) );
			}
		}
	}
	enable(string sbu)	{
		buts.enable( sbu );
	}
	/*****************************************/
	butmovon(string sc)	{
		sndfxglobon.play();
		bvisible = mouse.isvisible;
		mouse.show;
	}
	butmovoff(string sc)	{
		if( !bvisible ) mouse.hide;
	}
	butclick(string sc)	{
		match(sc)	{
			"pause" => clpause.pause;
			"exit", "exit2", "exit3" => claskexit.askexittomenu;
			"restart" => claskexit.askrestart;
			? => ;
		}
	}
}

class classplacepointer2 : classplacepointer    {
	init()  {
		classplacepointer::init();
		this.load("scripts/common/strzalka.pyz");
	}
}

new int KomputroMode = 3;
game IntroOld : classadvkomputro , TMenu  {
	init	{
		classadvkomputro::init;
		.tinit("intro", "scripts/intro/", "intro.pyz");
		.loadguys;
		new @bgadaja=true;
		.sounds = ( A,
			"sndstart", "Witamy w programie Nauka Informatyki",
				func { .profstop; .jacksay("sndstart2"); },
			"sndstart2", "Wybierz rodzaj kursu w zalenoci od swojego wieku",
				func { .jackstop; bgadaja=false; },
			"sndl1", "Kurs podstawowy od sidmego roku ycia", "jackstop",
			"sndl2", "Kurs redniozaawansowany", "jackstop",
			"sndl3", "Kurs dla modziey i dorosych", "jackstop"
		);
		.profsay("sndstart");
		new TextDb tdtytul(null,40, "tytul.db",10,10,255, 300,100,25, 20, "center");
		tdtytul.stdshadow(2);
	}
	cbplay(string s)	{	if( !bgadaja ) .jacksay(s);	}
	graj(int id)	{
		KomputroMode=id;
		gameapi.play("MenuGlowne");
	}
	l1_BUTCLICK	{	.graj(1);	}
	l2_BUTCLICK	{	.graj(2);	}
	l3_BUTCLICK	{	.graj(3);	}
}

game Intro : Komputro	{
	init	{
		Komputro::init("intro");
		.path = ("intro");
		//.bkg = ("intro.png");
		new @idbg = 1;
		.sfxs = (A, "type2", "machine2 40");
		.newimg("imgbg", "2.jpg", 0);
		string s;
		for( int i=1; i<=3; i++)	{
			s = "gr"+i;
			new gmimgvec <s>;
			s ..< ("napis"+i+".pyz");
			<s>.hide;
		}
		.timer = ("timtik", 100, func {
				idbg++;
				if (idbg>33) {
					.delay(3000);
					fxmachine2.setvol(20);
				} else if( idbg>30 )	.delay(1000);
				
				if( idbg>34 )	{
					.mouse_lclick;
				} else {
					//imgbg.load( .getgraphpath + "intro" + idbg + ".jpg");
					imgbg.load( .getgraphpath + "" + idbg + ".jpg");
					.play;
				}
			} );
		.timer = ("timpisz", 140, func {
			idbg++;
			match( igmstate )	{
				1 => if( idbg==gr1.size )	{
						igmstate = 2;
						gr1.hide;
						idbg = -1;
						.play;
					} else {
						fxtype2.play;
						<gr1.get(idbg)>.show;
						.play;
					}
				2 => if( idbg==gr2.size )	{
						.delay(80);
						igmstate = 3;
						idbg = -1;
						.play;
					} else {
						fxtype2.play;
						<gr2.get(idbg)>.show;
						.play;
					}
				3 => if( idbg < gr3.size )	{
						fxtype2.play;
						<gr3.get(idbg)>.show;
						.play;
					} else {
						igmstate = 4;
						.delay(1000);
						.play;
					}
				4 => .mouse_lclick;
				? => ;
			}
			} );
		timtik.play;
		fxmachine2.play;
	}
	mouse_lclick	{	gameapi.play("MenuGlowne");	}
}

game Outro : Komputro	{
	init	{
		Komputro::init("outro");
		.path = ("intro");
		.bkg = ("outro.pyz");
		.timer = ("timfin", 20000, func { .mouse_lclick; } );
		timfin.play;
	}
	mouse_lclick	{	gameapi.play("exit");	}
}

game MenuGlowne : classadvkomputro , TMenu  {
	init	{
		classadvkomputro::init;
		.tinit("mglowne", "scripts/menu/", "menu.pyz");
		.loadguys;
		
		.sounds = ( A,
			"sndintro", "Witamy w programie! Kliknij Start aby zacz kurs od pocztku lub wczytaj lekcj", "profstop",
			"sndnew", "Start kursu", "jackstop",
			"sndload", "Wczytaj lekcj", "jackstop");
		.newanima("anzwierze", "zwierzaki.pyz", 20);
		if( igmbegin )	{
			igmbegin = false;
			.profsay("sndintro");
		}
	}
	cbplay(string s)	{	.jacksay(s);	}
	new_BUTCLICK	{	gameapi.play("Historia");	}
	load_BUTCLICK	{
		bwejdzdoload = true;
		gameapi.play("LoadGame");
	}
}

new string sdemogame = "bramki";
new bool bwejdzdoload;
game Demo : Komputro {
	init	{
		Komputro::init("demo");
		.path = ("demo");
// 		sdemogame.print;
		.bkg = (sdemogame+".png");
		
		@x = 400;
		@y = 80;
		new gfxSquare gsq(x,y,300,380);
		gsq.set( .white, 222);
		gsq.build;
		gsq.blackborder(2, 192);
		new @stdfont16 = .snewfont( "configs/fonts/normal.ttf", 16);
		new TextDb tdopis(stdfont16, 16, sdemogame+".db", .red, x+15,y+15, 4, 550, "left");
// 		tdopis.stdshadow(1);
		
	}
	mouse_lclick	{	gameapi.play("LoadGame");	}
}

game LoadGame : Komputro {
	init	{
		Komputro::init("load");
		.path = ("load");
		.bkg = ("bkg.pyz");
		new Buttons buto("buty.pyz");
		.list = (A, "Logika", "Elektro", "Bramki", "Tasma", "AsmEasy", "Liczy",
			"Robot", "Grafika", "Komputer", "Linuks", "Binary", "grgry");
		.list = (A, "logika", "elektro", "bramki", "tasma", "asmeasy", "liczy",
			"robot", "grafika", "komputer", "linuks", "binary", "grdema");
		new db dblek;
		dblek.load("scripts/common/lekcje.db");
		@isize = 12;
		new TextDb td1(null, isize, dblek.get(1,1), .mcol, 4,7, 5,550,"left");	td1.stdshadow(2);
		new TextDb td2(null, isize, dblek.get(2,1), .mcol, 179,30, 5,550,"left");	td2.stdshadow(2);
		new TextDb td3(null, isize, dblek.get(3,1), .mcol, 379,49, 5,550,"left");	td3.stdshadow(2);
		new TextDb td4(null, isize, dblek.get(4,1), .mcol, 559,150, 5,550,"left");	td4.stdshadow(2);
		new TextDb td5(null, isize, dblek.get(5,1), .mcol, 576,1, 5,550,"left");	td5.stdshadow(2);
		new TextDb td6(null, isize, dblek.get(6,1), .mcol, 5,190, 5,550,"left");	td6.stdshadow(2);
		@spom = dblek.get(7,1);
		new TextDb td7(null, isize, spom.strgetto("is:")+"is:", .mcol, 260,216, 5,550,"left");	td7.stdshadow(2);
		new TextDb td72(null, isize, spom.strgetfrom("is:"), .mcol, 275,235, 5,550,"left");	td72.stdshadow(2);
		spom = dblek.get(8,1);
		new TextDb td8(null, isize, spom, .mcol, 470,295, 5,550,"left");	td8.stdshadow(2);
// 		new TextDb td82(null, isize, "obiekt" + spom.strgetfrom("obiekt"), .mcol, 661,313, 5,550,"left");	td82.stdshadow(2);
		new TextDb td9(null, isize, dblek.get(9,1), .mcol, 3,360, 5,550,"left");	td9.stdshadow(2);
		new TextDb td10(null, isize, dblek.get(10,1), .mcol, 199,420, 5,550,"left");	td10.stdshadow(2);
		new TextDb td11(null, isize, dblek.get(11,1), .mcol, 440,453, 5,550,"left");	td11.stdshadow(2);
	//init(string sfont, int isize, string sdbfile, int r, int g, int b, int x, int y, int dy, int z, string sdir)
		.sounds = (A,
			"sndintro", "Wybierz lekcj", func { buto.unlock; }
			);
		if( bwejdzdoload )	{
			bwejdzdoload = false;
			.cbplay("sndintro");
		} else buto.unlock;
		
		if( igmdemo )	{
			new @stdfont = .stdfont(14);
			buto {
				grbuts.each( func { (@id)
					if( id<2 ) return;
					.newtextposz("txtid", "Demo: tylko opis lekcji", stdfont, .red, .getpx+5, .getcy-14, .getz+1);
					txtid.txtshadow(1,stdfont);
					} );
			};
		}
		//new text txtpom;
	}
	buto_moveon	{
		sndakskermovon.play;
	}
	mcol	{	return 192,230,255; }
	buto_lclick	{
		int id = sobject.to_i;
		if( igmdemo )	{
			if( id==0 || id==1 )	gameapi.play(grgry.get(id));
			else {
				sdemogame = grdema.get(id) ;
				gameapi.play("Demo");
			}
		} else
			gameapi.play( grgry.get(id) );
	}
	mouse_move	{
		//txtpom.set("" + mouse.getposx + ","+mouse.getposy);
	}
}

/***************************************************/
// new classnextgame clnextgm;
igmstate = 0;
|igmdebug, igmeasy, igmdemo, igmbegin| = false, false, false, true;

bsms.setstd;

//clnextgm.load("scripts/common/games.db");
clbuts.load;

new db dbgogame;

dbgogame.load("scripts/common/gry.db");

int i = dbgogame.findbyrow("go");
gameapi.play(dbgogame.get(i,1));

//   gameapi.play("LoadGame");
//  gameapi.play("Historia");
//     gameapi.play("Logika");
//      gameapi.play("Elektro");
//       gameapi.play("Tasma");
//      gameapi.play("Bramki");
//    gameapi.play("AsmEasy");
//     gameapi.play("Liczy");
//      gameapi.play("Robot");
//  gameapi.play("Grafika");
//  gameapi.play("Komputer");
//  gameapi.play("Linuks");
//   gameapi.play("Binary");
/***************************************************/


game Historia : Komputro	{
	init	{
		Komputro::init("historia");
		.path=("menu");
		.bkg=("menu.pyz");
		.loadguys;
		.imgs = (A, "obrazy.pyz", "pascalinaH.pyz", "liczydlo.pyzH", "matematyka.pyzH",
			"compute.pyzH");
		.sfxs = (A, "wysunL 40");
		anobrazy.setframe("pascal",0);
		anobrazy.move( 800-anobrazy.getpx, 0 );
		.cycle=("timgo", "wysun");
		new int krokx = -30;
		.loadlekcja;
		
		.sounds = (A,
			"sndintro", "Nasz przygod z informatyk rozpoczniemy od dawnych czasw kiedy jeszcze nie istniay komputery", func { .cbplay("sndgo2"); ancompute.show; },
			"sndgo2", "Sowem komputer pochodzcym od angielskiego czasownika compute liczy okrelamy maszyn wykonujc obliczenia",
				func { .cbplay("sndgo3");
					anliczydlo.show;
					ancompute.hide;
					anliczydlo.ansetbpos(400,130);
					tdlicz.napispod("anliczydlo"); },
			"sndgo3", "Jednym z pierwszych narzdzi usprawniajcych obliczenia byo liczydo ktre do dzi suy dzieciom w poznawaniu tajnikw dodawania i odejmowania",
				func { .profstop; anliczydlo.hide; tdlicz.hide; fxwysun.play; timgo.play; } ,
			"sndgo4", "Jednak filozofowie pragnli zaprzc reguy matematyki do powaniejszych oblicze",
				func {
					.cbplay("sndgo5");
					anpascalina.show;
					anpascalina.ansetbpos(350, 460);
					tdpasc.napispod("anpascalina"); },
			"sndgo5", "Pionierem w tej dziedzinie by Blaise Pascal ktry zaprojektowa mechaniczn maszyn dodajc i odejmujc nazywan od jego nazwiska Pascalin",
				func { .profstop; .jacksay("sndgo6"); },
			"sndgo6", "A czy kto korzysta z tej maszyny?", func { .jackstop; .profsay("sndgo7"); },
			"sndgo7", "Oczywicie; do 1652 roku wyprodukowano okoo 50 takich maszyn do wspomagania pracy poborcw podatkowych i geodetw",
				func { .profstop;
					anpascalina.hide;
					tdpasc.hide;
					tdblaise.hide;
					anobrazy.setframe("boole", 0);
					anobrazy.move( 800-anobrazy.getpx, 0 );
					fxwysun.play;
					timgo.play; },
			"sndgo8", "Nie istniayby jednak wspczesne komputery bez angielskiego matematyka Georgesa Boolea", func { .cbplay("sndgo9"); },
			"sndgo9", "Jego prace z dziedziny logiki matematycznej stay si podwalin podstawowych operacji obliczeniowych w maszynach liczcych", func { .cbplay("sndgo10"); },
			"sndgo10", "Od poznania elementarnych praw logiki rozpoczniemy nasz kurs",
				func { .profstop; .jacksay("sndgo11");	},
			"sndgo11", "Ojej to musz poznawa matematyk eby zrozumie jak dziaa komputer?",
				func { .jackstop; .profsay("sndgo12"); tdboole.hide; anobrazy.hide; anmatematyka.show;	},
			"sndgo12", "Tak; wszystko w informatyce oparte jest o prawa matematyczne; kiedy je poznasz komputery odsoni ci swoje tajemnice", func { .profstop; .jacksay("sndgo13");	},
			"sndgo13", "Zaczynajmy zatem pierwsz lekcj!", "nextgame"
		);
		.profsay("sndintro");
	}
	wysun	{
		if( anobrazy.getposx + krokx > 0 )	{
			anobrazy.move(krokx, 0);
			.play;
		} else {
			fxwysun.stop(false);
			<GAME>.<"out_"+anobrazy.actionname>;
		}
	}
	out_pascal	{
		tdblaise.napispod("anobrazy");
		.profsay("sndgo4");
	}
	out_boole		{
		tdboole.napispod("anobrazy");
		.profsay("sndgo8");
	}
	nextgame	{	gameapi.play("Logika");	}
	mouse_rclick	{	if( igmdebug )	.nextgame;	}
	mouse_lclick	{	.cactsndstop(true);	}
}

game Logika : Komputro {
	init	{
		Komputro::init("logika");
		.path = ("logika");
		.bkg = ("bkg.pyz");
		.imgs = (A,"help.pyz", "znaki.pyz");
		.sfxs = (A, "cios2", "error", "skok2", "brawo 30", "buu 30");
		new gmimgvec groks;
		new gmimgvec groks2;
		new @Ilosc = 7;
		.copyanimas("anznaki", "anok", 0, Ilosc);
		anznaki.hide;
		groks.additer("anok",0 , Ilosc);
		.newarray("text", "txtok", Ilosc);
		groks2.additer("txtok", 0, Ilosc);
		groks2.hide;
		
		.loadguys;
		.loadlekcja;
		new TextDb tdhelp(null, 12, "help.db", 20,20,20, anhelp.getpx+25, anhelp.getpy+55, 5, 50, "left");
		tdhelp.hide;
		new classplacepointer2 clp;
		new classsimplebutton cbok;
		cbok.build("scripts/common/butok.pyz", "imglobcurs", 250, 525, 100, 0);
		new vector veczd;
		veczd.vecnewint(20);
		veczd.hash;
		new vector veczd2;
		veczd2.vecnewint(20);
		veczd2.hash;
		new vector veclev;
		
		.newdb("dbask", "zdania.db");
		.newarray("text", "txtodp", 20);
		new gmimgvec grodp;
		grodp.additer("txtodp",0,20);
		grodp.hide;
		if( KomputroMode==1 )	{	// swiety mikolaj istnieje dla dzieci
			dbask.set(18,3,1);
			dbask.set(19,3,0);
		}
		
		@sfungo = func { .profstop; igmstate=1; };
		@sfungo2 = func { .jackstop; igmstate=1; };
		@sfunjakto = func { .profstop; .jacksay("sndjakto"); };
		new @Level = 1;
		new @ilstate = 1;
		.sounds = (A,
			"sndintro", "Pierwsze zadanie jest bardzo proste: na kartce widzisz zdania",
				func { .cbplay("sndgo1"); clp.showob(groks.get(0), "ru"); },
			"sndgo1", "Klikajc na znakach zapytania zaznacz ktre zdania s prawdziwe a ktre faszywe",
				func { clp.show(cbok.getimgfunc("getcx"), cbok.getimgfunc("getcy"), "rd"); .cbplay("sndgo2"); },
			"sndgo2", "Kiedy skoczysz wcinij ten przycisk abym sprawdzi poprawno rozwizania",
				func { igmstate=1; .profstop; clp.stoph; },
			"sndnotall", "Nie wszystkie zdania zostay oznaczone", func { .profstop; .jacksay("sndnotall2"); },
			"sndnotall2", "Ojej rzeczywicie", sfungo2,
			"sndnon1", "Niestety widz prawdziwe zdanie oznaczone jako faszywe", sfungo,
			"sndnon2", "Niestety widz faszywe zdanie oznaczone jako prawdziwe", sfungo,
			"sndmik1", "Jacku! Wiadomym powszechnie jest i wity Mikoaj istnieje!", sfunjakto,
			"sndmik2", "Niestety musz ci zmartwi: prawdziwy wity Mikoaj nie istnieje", sfunjakto,
			"sndjakto", "Ojej! A ja mylaem e jest odwrotnie", sfungo2,
			"sndok1", "Brawo! Prawdziwo wszystkich zda okrelie poprawnie",
				func { veczd.hash; <GAME>.insertzdania; groks.hide; groks2.show; .cbplay("snd1t1"); },
			"snd1t1", "Teraz zrb to samo ale zdania prawdziwe oznacz jedynk a faszywe zerem", sfungo,
			"sndok2", "wietnie! Teraz zadanie nieco trudniejsze",
				func { tdhelp.view(A,0,1); .cbplay("snd2t1"); clp.showob("anhelp","uu"); },
			"snd2t1", "Korzystajc z tego schematu", func { .cbplay("snd2t2"); clp.stoph; },
			"snd2t2", "Oznacz poprawnie zaprzeczone zdania wiedzc e nieprawda e prawda oznacza fasz" ,
				func { .preparelevel(2); },
			"sndok3", "Doskonale! Teraz trudniejsze zadanie", func { .cbplay("snd3t1"); },
			"snd3t1", "Dotychczas oznaczae pojedyncze zdania; Teraz poka ci kiedy pozna czy zdanie jest prawdziwe jeeli skada si z dwch czci poczonych spjnikiem I",
				func { .profstop; .jacksay("snd3t2"); },
			"snd3t2", "Ojej nic nie rozumiem", "viewand",
			"snd3t3", "Spokojnie ju tumacz; Oto dwa zdania proste poczone za pomoc I",
				func { txtzd1.createtxt( 200,20,20 ); .cbplay("snd3t4"); },
			"snd3t4", "Pierwsze",
				func { txtzd1.createtxt(.grey(22)); .cbplay("snd3t5");txtzd2.createtxt( 200,20,20 ); },
			"snd3t5", "I drugie", func { <GAME> { 
					txtzd2.createtxt( .grey(22) );
					.newtext("txtoki1", "1", "fnttxtok", .black);
					txtoki1.anposz( txtzd1.getpx+20, txtzd1.getpy - FontSize-5, 510);
					.newtext("txtoki2", "1", "fnttxtok", .black);
					txtoki2.anposz( txtzd2.getex-20, txtzd2.getpy - FontSize-5, 510);
					.cbplay("snd3t6");
				}; },
			"snd3t6", "Jak wiesz oba te zdania s prawdziwe", func { txtoki.txtset("1"); .cbplay("snd3t7"); },
			"snd3t7", "Przypuszczamy zatem e cae zdanie jest prawdziwe; I jest tak w rzeczywistoci",
				func { .cbplay("snd3t8"); txtoki.txtset("?"); txtzd1.txtset(.get1(8)); txtoki1.txtset("0");
					clp.showpob("txtzd1", "rd"); },
			"snd3t8", "C jednak powiemy o takim zdaniu zoonym ktrego pierwszy czon jest faszywy?",
				func { .profstop; .jacksay("snd3t9"); clp.stoph; },
			"snd3t9", "e jest prawdziwe?", func { .jackstop; .profsay("snd3t10"); },
			"snd3t10", "Niestety nie; Do okrelenia czy zdanie zoone jest prawdziwe czy faszywe bdziemy potrzebowali specjalnej tabelki", func { <GAME> {
					tdhelp.view(A,2,3,4,5);
					.newtext("txti1", "0 and 0 -> 0", "fntask", .black);
					.newtext("txti2", "0 and 1 -> 0", "fntask", .red);
					.newtext("txti3", "1 and 0 -> 0", "fntask", .black);
					.newtext("txti4", "1 and 1 -> 1", "fntask", .black);
					@y = 120;
					@dy = FontSize+3;
					txti1.anposz(300, y, 510);
					txti2.anposz(300, y+dy, 510);
					txti3.anposz(300, y+2*dy, 510);
					txti4.anposz(300, y+3*dy, 510);
					clp.showpob("txti2", "ru");
					.cbplay("snd3t11");
				}; },
			"snd3t11", "Jak widzisz nasze zdanie pasuje do tej reguy; pierwsze faszywe czyli 0 a drugie prawdziwe czyli 1", func { .cbplay("snd3t12"); txtoki.txtset("0"); clp.showpob("txtoki","ld"); },
			"snd3t12", "Odczytujemy zatem z tabeli e cae zdanie zoone jest faszywe",
				func { .cbplay("snd3t13"); <GAME> {
					new gmimgvec grprzyk;
					grprzyk.additer("txti", 1, 4);
					grprzyk.addlist(A, "txtoki", "txtoki1", "txtoki2", "txtzd1", "txtzd2", "txtand", "gsq");
					clp.showob("anhelp", "uu");
					}; },
			"snd3t13", "Reguy zdania zoonego z I zostawiam tutaj; Sprbuj okreli czy zdania zoone s prawdziwe czy faszywe",
				func { grprzyk.hide; .preparelevel(3); },
			"sndok4", "Wspaniale! Wszystkie zdania zoone oznaczye bezbdnie!", func {.cbplay("snd4t1");},
			"snd4t1", "Przed nami kolejne zadanie; Oznaczenie zda ze spjnikiem Lub", func {
					grprzyk.show;
					txtand.txtset("or");
					txtoki.txtset("1");
					txti1.txtset("0 or 0 -> 0");
					txti2.txtset("0 or 1 -> 1");
					txti3.txtset("1 or 0 -> 1");
					txti4.txtset("1 or 1 -> 1");
					.profstop;
					.jacksay("snd4t2");
				},
			"snd4t2", "O widz e wystarczy tylko jedno prawdziwe zdanie proste eby cae zdanie byo prawdziwe", func { .jackstop; .profsay("snd4t3"); },
			"snd4t3", "Bardzo suszna uwaga; Myl e z tymi zdaniami nie bdziesz mia problemu",
				func { .cbplay("snd4t4"); tdhelp.view(A,6,7,8,9); clp.showob("anhelp", "dd"); },
			"snd4t4", "Doczam pomocnicz tabelk dla zda ze spjnikiem Lub; Powodzenia!",
				func { grprzyk.hide; .preparelevel(4); },
			"sndok5", "Znakomicie! Poprawnie rozrniasz wszystkie podstawowe konstrukcje logiczne; W nagrod rozwi ostatnie zadanie", func { for( int i=0; i<Ilosc; i++) veclev.add( 4->rand+1 );
				.preparelevel(5); },
			"sndok6", "Brawo! Zaliczam lekcj", "finito"
		);
		
		new font fntask;
		new @FontSize = 16;
		fntask.load( sgmfontfile, FontSize );
		//if( KomputroMode==1 )	{
			.newimgarray("grhelp", "text", "txth", 2*Ilosc);
			new classsimplebutton cbhelp;
			cbhelp.build("scripts/common/help.pyz", "imglobcurs", 262, 440, 100, 0);
			grhelp.each( func { (@id) .setfont("fntask"); } );
		//}
		new font fnttxtok;
		fnttxtok.load( sgmfontfile, 22 );
		groks.each( func { (@id)
			.setframe("ask",0);
			@y = id * .geth;
			.ansetbpos( 390, 90 + y );
			@i2 = veczd.get(id);
			@s = "txtodp" + (2*id);
			<s>.setpos( 395 + .getw, 95+y );
			<s>.setfont( "fntask" );
			<s>.show;
			
			s = "txtodp" + (2*id+1);
			<s>.setpos( 415 + .getw, 97+y+FontSize );
			<s>.setfont( "fntask" );
			<s>.show;
			
			s = "txtok" + id;
			<s>.setfont("fnttxtok");
			//<s>.setpos( 390, 90 + y );
			<s>.set("?");
			<s>.createtxt( 20, 20, 20 );
			//setbkg(int x,int y,int w,int h,int r,int g,int b,int a)
			<s>.setbkg( 390, 90+y, <s>.getw+5, <s>.geth+5, 20,20,20,20);
			} );
		.insertzdania;
		.profsay("sndintro");
// 		.viewand;
	}
	preparelevel(int idlev)	{
		Level=idlev;
		clp.stoph;
		.profstop;
		igmstate=1;
		veczd.hash;
		veczd2.hash;
		.preparegroks2;
		<GAME>.insertzdania;
	}
	get1(@id)	{	dbask.get(id,1)->to_u + dbask.get(id,2);	}
	get2(@id)	{	dbask.get(id,1) + dbask.get(id,2);	}
	viewand	{
		<GAME> {
			new gfxSquare gsq(200,100,400,300);
			gsq.set(.grey(240), 255);
			gsq.build;
			gsq.setz(500);
			gsq.border(1,1, .grey(192), 255);
			gsq.border(1,1,.black,255);
			gsq.shadow(2,2,128);
			
			@y = 150;
			.newtext("txtoki", "?", "fnttxtok", .grey(22) );
			txtoki.setbkg( 220, y + 105, txtoki.getw+5, txtoki.geth+5, 20,20,20,20);
			txtoki.setz(510);
			.newtext("txtzd1", .get1(3), "fntask", .grey(22) );
			txtzd1.anposz(250, y + 100, 510);
			.newtext("txtand", "and", "fntask", .red );
			txtand.anposz(300, y + 110 + FontSize, 510);
			.newtext("txtzd2", .get2(5)+".", "fntask", .grey(22) );
			txtzd2.anposz(350, y + 110 + FontSize, 510);
			
			.jackstop;
			.profsay("snd3t3");
		};
	}
	preparegroks2	{	groks2.each( func { (@id) .set("?"); .createtxt(20,20,20); } ); }
	insertzdania	{
		groks.each( func { (@id)
			.setframe("ask",0);
			@s1 = "txtodp"+(id*2);
			@s2 = "txtodp"+(id*2+1);
			@i2 = veczd.get(id);
			int i1 = ( Level==5 ) ? veclev.get(id) : Level;
			match( i1 )	{
				1 =>	{<s1>.set( .get1(i2) + "." ); <s2>.set(""); }
				2 => { <s1>.set( dbask.get(20, 1) );
					<s2>.set( .get2(i2) + "." ); }
				3 => { <s1>.set( .get1( veczd2.get(id) ) );
					<s2>.set( "and  " + .get2(i2) + "." ); }
				4 => { <s1>.set( .get1( veczd2.get(id) ) );
					<s2>.set( "or " + .get2(i2) + "." ); }
				? => ;
			}
			<s1>.createtxt(133,16,200);
			if( <s2>.get->length > 0 )	{
			<s2>.createtxt(133,16,200); <s2>.show; } else <s2>.hide; } );
	}
	cbok_CLICK	{	<GAME>.check;	}
	cbok_MOVEON	{
		sndakskermovon.play;
	}
	cbhelp_MOVEON	{
		sndakskermovon.play;
		if( igmstate!=1 || ilstate==1)	return;
		int i[5], string s[3];
		i3=0;
		@dx = 16;
		for( i0=0; i0<Ilosc; i0++)	{
			i2 = veczd.get(i0);
			i1 = ( Level==5 ) ? veclev.get(i0) : Level;
			s0 = "txtodp" + (2*i0);
			s1 = "txtodp" + (2*i0+1);
			@col = func { return 50,50,255; };
			if( i1==1 )	{
				s2 = grhelp.get(i3); i3++;
				<s2>.set( dbask.get(i2, 3) );
				<s2>.setpos( <s0>.getpx-dx, <s0>.getpy );
				<s2>.createtxt( .<col> );
				<s2>.show;
			} else if (i1==2)	{
				s2 = grhelp.get(i3); i3++;
				<s2>.set( dbask.get(i2, 3) );
				<s2>.setpos( <s1>.getpx-dx, <s1>.getpy );
				<s2>.createtxt( .<col> );
				<s2>.show;
			} else {
				s2 = grhelp.get(i3); i3++;
				<s2>.set( dbask.get(i2,3) );
				<s2>.setpos( <s0>.getpx-dx, <s0>.getpy );
				<s2>.createtxt( .<col> );
				<s2>.show;
				s2 = grhelp.get(i3); i3++;
				<s2>.set( dbask.get( veczd2.get(i0),3 ) );
				<s2>.setpos( <s1>.getpx-dx, <s1>.getpy );
				<s2>.createtxt( .<col> );
				<s2>.show;
			}
		}
	}
	cbhelp_MOVEOFF	{
		grhelp.hide;
	}
	check	{
		if( igmstate!=1 )	return;
		fxerror.play;
		igmstate = 2;
		int i[3], string s[2];
		for( i0=0; i0<Ilosc; i0++)	{
			i2 = veczd.get(i0);
			i1 = ( Level==5 ) ? veclev.get(i0) : Level;
			match(i1)	{
				1 => i1 = dbask.get(i2, 3);
				2 => i1 = !(dbask.get(i2, 3)->to_i);
				3 => i1 = ( dbask.get(i2,3)->to_i && dbask.get( veczd2.get(i0),3 )->to_i );
				4 => i1 = ( dbask.get(i2,3)->to_i || dbask.get( veczd2.get(i0),3 )->to_i );
				? => ;
			}
			if( ilstate==1)	s0 = <groks.get(i0)>.actionname;
			else if (ilstate>1)
				s0 = <groks2.get(i0)> {
					match(.get)	{
						"?" => "ask";
						"0" => "no";
						"1" => "ok";
						? => ;
					} };
			if( Level==1 && (i2==18 || i2==19) && s0!="ask" )	{
				if( KomputroMode==1 )	{
					if( (i2==18 && s0=="no") || (i2==19 && s0=="ok") )	{
						.profsay("sndmik1");
						return;
					}
				} else {
					if( (i2==18 && s0=="ok") || (i2==19 && s0=="no") )	{
						.profsay("sndmik2");
						return;
					}
				}
			} else {
				if( s0=="ask" )	{
					fxbuu.play;
					.profsay("sndnotall");
					return;
				} else if (s0=="no" && i1==1 )	{
					fxbuu.play;
					.profsay("sndnon1");
					return;
				} else if (s0=="ok" && i1==0 )	{
					fxbuu.play;
					.profsay("sndnon2");
					return;
				}
			}
		}
		igmstate=2;
		fxbrawo.play;
		.profsay("sndok"+ilstate);
		ilstate++;
	}
	mouse_lclick	{
		.cactsndstop(true);
		if ( igmstate!=1 ) return;
		string s[2];
		if( ilstate==1 )	{
			if ( groks.isin(mouse.getpos, 1,0) ) {
				<groks.getsfound>.ansetnextact;
				fxskok2.play;
			}
		} else if (ilstate>1)	{
			if ( groks2.isin(mouse.getpos, 1,1) ) {
				s0 = groks2.getsfound;
				match(<s0>.get)	{
					"?" => "0";
					"0" => "1";
					"1" => "?";
					? => ;
				}
				<s0>.set;
				<s0>.createtxt(20,20,20);
				fxskok2.play;
			}
		}
	}
	key_down	{	if(igmdebug) .keyrestart;	}
	finito	{
		.profstop;
		gameapi.play("Elektro");
	}
}

// KomputroMode=3;
game Elektro : Komputro {
	init	{
		Komputro::init("elektro");
		.path = ("elektro");
		.bkg = ("bkg.pyz");
		.sfxs = (A, "przekladnia 30", "pik", "mikrofala", "getpuz", "putpuz", "blink", "brawo 30",
			"ups 40", "maszynaL 2");
		new gmimgvec grand;		"grand" ..< "and.pyz";
		new gmimgvec grands;		"grands" ..< "ands.pyz";
		new gmimgvec gror;		"gror" ..< "or.pyz";
		new gmimgvec grors;		"grors" ..< "ors.pyz";
		new gmimgvec grlight;		"grlight" .* "swiatla.pyz";
		new gmimgvec grgates;
		grgates.addlist(A, "anands0_0", "anors0_0");
		grands.setz(10);	grors.setz(10);
		.imgs=(A, "bposH.pyz", "myszkaPL.pyz", "bg2H.pyz 200", "invertH.pyz 270");
		.copyanima("anmyszka", "anokol");	anokol.hide; anokol.setframe("r",0);
		.copyanima("anmyszka", "anokor");	anokor.hide; anokor.setframe("l",0);
		answiatla0.addmethod("onfinish", func { .mupdate; timgo.play; } );
		.loadguys;
		.loadlekcja;
		gror.setz(210);
		grand.setz(210);
		new TextDb tdand(null, 12, "and.db", .grey(20), 535,123, 5,250, "left");
		new TextDb tdor(null, 12, "or.db", .grey(20), 535,305, 5,250, "left");
		new @sFont = .stdfont(14);
		.newdb("dbprad", "prad.db");
		.newtext("txtplynie", dbprad.get(0,0), sFont, .red); txtplynie.anposz(160,260,260);
		.newtext("txtnplynie", dbprad.get(1,0), sFont, .black);	txtnplynie.anposz(160,280,260);
		.newtext("txtand", "gate \"and\"", sFont, .black);	txtand.anposz(366,195,260);
		.newtext("txtor", "gate \"or\"", sFont, .black);	txtor.anposz(387,375,260);
		.newtext("txtin0", "0", sFont, .black);
		txtin0.anposz( anand1_0.getpx, anand1_0.getpy-20,260);
		.newtext("txtin1", "0", sFont, .black);
		txtin1.anposz( anand1_1.getpx, anand1_1.getpy-20,260);
		.newtext("txtin2", "0", sFont, .black);
		txtin2.anposz( anand1_2.getex-50, anand1_2.getpy-20,260);
		.newtext("txton0", "0", sFont, .black);
		txton0.anposz( anor1_0.getpx, anor1_0.getpy-20,260);
		.newtext("txton1", "0", sFont, .black);
		txton1.anposz( anor1_1.getpx, anor1_1.getpy-20,260);
		.newtext("txton2", "0", sFont, .black);
		txton2.anposz( anor1_2.getex-50, anor1_2.getpy-20,260);
		.newtext("txtzad", "0", sFont, 20,20,250);
		txtzad.anposz( 370, 576,260);	txtzad.hide;
		new gmimgvec grtxt;
		grtxt.addlist(A, "txtin0", "txtin1", "txtin2", "txton0", "txton1", "txton2", "txtor",
			"txtplynie", "txtnplynie", "txtand");
		grtxt.hide;
		.newtext("txtodp", "0", sFont, .black);
		txtodp.anposz( 700, 265, 260 );
		txtodp.hide;
		new classplacepointer2 clp;
		new classsimplebutton cbok;
		cbok.build("scripts/common/butok.pyz", "imglobcurs", 290, 525, 100, 0);
		@sfungo = func { .profstop; igmstate=1; };
		@sfungo2 = func { .jackstop; igmstate=1; };
		.with(A, "grand", "gror", "grands", "grors", "grlight", "tdand", "tdor",
			"hide");
		.sounds = (A,
			"sndintro", "W tej lekcji wykorzystasz praktycznie swoj wiedz o zdaniach z I oraz Lub; Przypomnijmy", func { anbg2.show; tdand.show; .cbplay("snd1t1"); clp.showpob("tdand","rr"); },
			"snd1t1", "Na podstawie tych regu sprawdzamy czy zdanie z I jest prawdziwe czy faszywe",
				func { clp.showob("anand0_0", "rd"); anand0_0.show; .cbplay("snd1t2"); },
			"snd1t2", "Na takich samych zasadach dziaa ta oto elektryczna puszka z trzema drutami",
				func { clp.show(anand0_0.getpx, anand0_0.getcy,"rr"); .cbplay("snd1t3"); },
			"snd1t3", "Przez te dwa druciki prd moe wpywa do puszki; Nazywamy je wic wejciami",
				func { clp.show(anand0_0.getex, anand0_0.getcy, "lu"); .cbplay("snd1t4"); },
			"snd1t4", "A tdy moe wypywa; jest to wyjcie puszki",
				func { .cbplay("snd1t5"); clp.stoph; txtand.show; },
			"snd1t5", "Nasz puszk nazywamy bramk and; And po angielsku znaczy I",
				func { .cbplay("snd1t6"); txtplynie.show; txtnplynie.show; },
			"snd1t6", "Pyncy przez przewody prd oznaczmy jedynk a jego brak zerem",
				func { .cbplay("snd1t7"); txtin0.show; clp.showpob("txtin0","rr"); },
			"snd1t7", "Przez pierwszy przewd wejciowy nie pynie prd wic wpisujemy 0",
				func { .cbplay("snd1t8"); txtin1.show; clp.showpob("txtin1","rr"); },
			"snd1t8", "Przez drugi rwnie nie pynie prd wic wpisujemy 0",
				func { .cbplay("snd1t9"); clp.showpob("tdand","rd"); },
			"snd1t9", "Odczytujemy z tabeli jaka jest warto na wyjciu dla 0 i 0",
				func { .cbplay("snd1t10"); clp.showpob("txtin2","ld"); txtin2.show; },
			"snd1t10", "Wynikiem dziaania logicznego 0 i 0 jest rwnie 0",
				func { clp.showob("anand1_0","dd");
					.cbplay("snd1t11"); txtin0.txtsetcol("1",.red); anand1_0.show; },
			"snd1t11", "Teraz na wejciu pierwszym pojawi si prd",
				func { clp.showpob("txtin2","ld"); .cbplay("snd1t12"); },
			"snd1t12", "Jednak na wyjciu nadal prd nie pynie gdy 1 i 0 zgodnie z reguami dla bramki I daje 0",
				func { clp.showob("anand1_1", "dd"); .cbplay("snd1t13");
					txtin1.txtsetcol("1",.red); anand1_1.show; },
			"snd1t13", "Dopiero kiedy na obu wejciach pojawi si prd",
				func { txtin2.txtsetcol("1",.red); anand1_2.show;
					clp.showpob("txtin2","ld"); .cbplay("snd1t14"); },
			"snd1t14", "Bramka and poda prd na wyjcie",
				func { .cbplay("snd1t15"); clp.showob("anor0_0","dd");
					anor0_0.show; txton0.show; txton1.show;
					txton2.show; txtor.show; tdor.show; },
			"snd1t15", "Inaczej zachowuje si bramka or",
				func { .cbplay("snd1t16"); clp.showpob("tdor","rd"); },
			"snd1t16", "Ktra realizuje funkcj logiczn lub",
				func { .cbplay("snd1t17"); clp.showob("anor1_1","dd"); anor1_1.show;
					txton1.txtsetcol("1",.red); },
			"snd1t17", "Wystarczy e na jednym z wej pojawi si prd",
				func { .cbplay("snd1t18"); clp.showpob("txton2","ld");
					anor1_2.show; txton2.txtsetcol("1",.red); },
			"snd1t18", "I zgodnie z reguami dla funkcji Lub na wyjciu rwnie przepywa prd",
				func { .profstop; clp.stoph; .jacksay("snd1t19"); },
			"snd1t19", "Chyba ju wszystko rozumiem; jestem gotowy do zadania",
				func { .jackstop; anbg2.hide; grand.hide; gror.hide; grtxt.hide;
					.profsay("snd1t20");
					tdand.move( 22-tdand.getpx, 350-tdand.getpy );
					tdor.move( 22-tdor.getpx, 455-tdor.getpy );
					anands0_0.show; anors0_0.show; },
			"snd1t20", "Dobrze; zaczynamy", func { clp.showob("anands0_0", "ld"); .cbplay("snd2t1"); },
			"snd2t1", "Tutaj znajduj si dwie bramki: and i or",
				func { clp.showob("anbpos", "rr"); .cbplay("snd2t2"); },
			"snd2t2", "Twoim zadaniem bdzie wstawienie jednej z nich w to miejsce maszyny tak aby wykonaa moje polecenie",
				func { clp.showob("anmyszka", "rd");  .cbplay("snd2t3"); .mshowzad; },
			"snd2t3", "Zadanie 1; Zaprogramuj maszyn eby sprawdzaa czy myszka pi",
				func { clp.show(730,270,"rd"); .cbplay("snd2bt3"); },
			"snd2bt3", "Maszyna wypisze wynik w tym miejscu; Jeeli na wyjciu bramki pojawi si prd to maszyna wypisze TAK jeeli natomiast prdu na wyjciu nie bdzie wypisze NIE",
				func { clp.stoph; .cbplay("snd2t4"); },
			"snd2t4", "Mysz pi kiedy ma zamknite oba oczka",
				func { .cbplay("snd2t5"); clp.showob("answiatla0", "ll"); },
			"snd2t5", "Kiedy prawe oko myszki bdzie zamknite ten czujnik wczy prd w czerwonym przewodzie",
				func { .cbplay("snd2t6"); clp.showob("answiatla1", "rr"); },
			"snd2t6", "Natomiast ten wczy prd w niebieskim przewodzie kiedy lewe oczko myszki bdzie zamknite",
				func { .cbplay("snd2t7"); clp.show(cbok.getimgfunc("getcx"), cbok.getimgfunc("getcy"), "dd"); },
			"snd2t7", "Tym przyciskiem wczysz maszyn", func { clp.stoph; .cbplay("snd2t8"); },
			"snd2t8", "Do dziea!", "menable",
			"snd3nog", "Nie wstawie adnej z bramek do maszyny",
				func { .profstop; .jacksay("snd3oj"); clp.stoph; },
			"snd3oj", "Za szybko wczyem maszyn", sfungo2,
			"snd6no", "Oj maszyna le zaprogramowana; wystarczy e jedno oko myszki zamknite a wypisuje e myszka pi; Sprbuj ponownie; wyczam maszyn", "mreset",
			"snd6ok", "Tak jest! Poprawnie uye bramki and; zadanie zaliczone!", "mnextzad",
			"snd7go", "Kolejne zadanie: zaprogramuj maszyn by sprawdzaa czy mysz ma przynajmniej jedno oko zamknite", "menable",
			"snd7ok", "Super! Jestem z ciebie dumny", "mnextzad",
			"snd7no", "Niestety; Jedno oko jest zamknite a maszyna wypisuje NIE; Prbuj dalej", "mreset",
			"snd8go", "Teraz niech maszyna wypisze czy oba oczka myszy s zamknite", "menable",
			"snd8no", "Co nie tak; Sprbuj jeszcze raz", "mreset",
			"snd8ok", "wietnie!", func { if( KomputroMode<=2 ) .cbplay("sndend"); else .mnextzad; },
			"sndend", "Umiesz ju wykorzysta bramki logiczne do budowy prostych maszyn; Przechodzimy do kolejnej lekcji.", "finito",
			"snd9go", "Teraz rozbudujemy moliwoci naszej maszyny", func { <GAME> {
				grgates.hide;
				anbg2.show;
				new TextDb tdnand(null, 12, "nand.db", .grey(20), 215,130, 5,250, "left");
				new TextDb tdnor(null, 12, "nor.db", .grey(20), 215,275, 5,250, "left");
				new TextDb tdnot(null, 12, "not.db", .grey(20), 465,190, 5,250, "left");
				anbpos.setz(anbg2.getz+10);
				anbpos.show;
				
				.newtext("txtinvert", dbprad.get(4,1), sFont, .red);
				txtinvert.anposz( 460, 235,260);
				txtinvert.hide;
				new gfxSquare gsq( txtinvert.getpx-2,txtinvert.getpy-2, txtinvert.getw+4,txtinvert.geth+4);
				gsq.set( 90,222,50, 255);
				gsq.build;
				gsq.setz(200);
				gsq.border(1,1, .grey(192), 255);
				gsq.border(1,1,.black,255);
				gsq.shadow(1,1,128);
				gsq.hide;
				
				.cbplay("snd4t1");
				}; },
			"snd4t1", "Bramki and i or nie s jedynymi bramkami; Jak pamitasz zaprzeczenie zdania zmieniao jego prawdziwo",
				func { .cbplay("snd4t2"); aninvert.show; clp.showob("aninvert","uu"); },
			"snd4t2", "Jeeli dodamy do naszej bramki przy samym wyjciu takie keczko",
				func { .cbplay("snd4t3"); clp.showpob("tdnot","rd"); },
			"snd4t3", "To wynik bramki bdzie odwrotny",  func { .cbplay("snd4t4"); clp.show(315,130,"rd"); },
			"snd4t4", "A nasza bramka and bdzie teraz bramk nand co znaczy not and i bdzie zwraca wartoci jak w tej tabelce",
				func { clp.showpob("tdnor","rr"); .cbplay("snd4t5"); },
			"snd4t5", "Rwnie bramka or ma swoje przeciwiestwo: bramk nor",
				func { clp.stoph; .profstop; .jacksay("snd4t6"); },
			"snd4t6", "Widz to proste: kiedy and zwraca 0 to nand zwraca 1; kiedy natomiast and zwraca 1 nand daje na wyjciu 0",
				func { .jackstop; .profsay("snd4t7"); },
			"snd4t7", "W rzeczy samej; identycznie zachowuje si bramka nor w stosunku do bramki or",
				func { gsq.show; tdnand.hide; tdnor.hide; tdnot.hide; anbg2.hide;
					txtinvert.show; .cbplay("snd4t8"); clp.showob("gsq","lu"); },
			"snd4t8", "Kiedy bdziesz chcia zamieni bramk and na nand lub or na nor i spowrotem kliknij tutaj; Czytam kolejne zadanie",
				func { grgates.show; clp.stoph; anbpos.hide; aninvert.hide; .cbplay("snd9b"); },
			"snd9b", "Niech maszyna stwierdzi czy mysz jest obudzona", "menable",
			"snd9no", "Tak zaprogramowana maszyna nie stwierdza czy mysz jest obudzona; Prbuj dalej", "mreset",
			"snd9ok", "Doskonale! Maszyna wykrywa e myszka jest obudzona", "mnextzad",
			"snd10go", "Teraz zaprogramuj maszyn by odpowiedziaa czy mysz ma otwarte oczy", "menable",
			"snd10no", "Co nie tak; Jeszcze raz", "mreset",
			"snd10ok", "Wspaniale! Ostatnie zadanie", "mnextzad",
			"snd11go", "Nie maszyna odpowie czy mysz ma conajmniej jedno oko otwarte", "menable",
			"snd11no", "Co le dziaa; Sprbuj ponownie", "mreset",
			"snd11ok", "Brawo! Wykonae wszystkie zadania; Przed nami kolejna lekcja", "finito"
		);
		new @schosen = null;
		new @Level = 6;		// odkad w db sie zaczyna odpowiedz do zadania
		new @idlook = 0;
		new @breverse = false;
		.timer = ("timgo", 4000, func { .play; .mupdate; } );
		new DelayMover cmov;
		.profsay("sndintro");
		//.profsay("snd1t19");
	}
	mshowzad	{
		txtzad.txtset( dbprad.get(Level,3) );
		txtzad.show;
	}
	mnextzad	{
		Level++;
		.mwylacz;
		.mpos;
		aninvert.hide;
		schosen = null;
		breverse=false;
		.cbplay("snd"+Level+"go");
		.mshowzad;
	}
	mreset	{	.mwylacz; .menable;	}
	menable	{
		.profstop;
		igmstate=1;
		cmov.unlock;
	}
	cmov_GET	{
		if( grgates.isin( mouse.getpos, true, true ) )	{
			fxgetpuz.play;
			string s = grgates.getsfound;
			<s>.setz(900);
			.mssetobj( s );
			if( s==schosen)	{
				aninvert.hide;
				schosen = null;
				breverse=false;
			}
		}
	}
	cmov_PUT	{
		fxputpuz.play;
		string s = cmov.getfree;
		<s>.setz(10);
		string s2;
		if( cllen.ilen5(s,"anbpos")<40 )	{
			.mpos;
			s2 = grands.contains(s) ? "grands" : "grors";
			<s2>.move( anbpos.getpx-<s>.getpx, anbpos.getpy-<s>.getpy);
			schosen = s;
		} else {
			if( s == schosen)	{
				.mpos;
				grands.hide;
				grors.hide;
				grgates.show;
				aninvert.hide;
				breverse=false;
			} else {
				<s>.setpos(0,0);
			}
		}
	}
	mpos	{	grands.setpos(0,0);		grors.setpos(0,0);	}
	mwylacz	{
		answiatla0.anhide;
		answiatla1.anhide;
		txtodp.hide;
		grands.hide;
		grors.hide;
		grgates.show;
		idlook=0;
		anokol.hide;
		anokor.hide;
		timgo.stop(false);
		fxmaszyna.stop(false);
	}
	mwlacz	{
		fxmaszyna.play;
		answiatla0.play(-1);
		answiatla1.play(-1);
	}
	mgetid	{
		match(idlook)	{
			0 => { 0; 0; }
			1 => { 1; 0; }
			2 => { 0; 1; }
			3 => { 1; 1; }
			? => { 2->rand; 2->rand; }
		}
		idlook++;
	}
	mupdate	{
		fxpik.play;
		@s = dbprad.get(Level,2);
		bool b=false, @s2;
		if( idlook==4 )	{
			if( s.getb(0,1)=="n" )	{	b=true;	s2 = s.strsubb(1);	}
			if( b )	{
				if( breverse && schosen==("an"+ s2 +"s0_0") )	{
					.profsay("snd"+Level+"ok");
					fxbrawo.play;
				} else	{
					.profsay("snd"+Level+"no");
					fxups.play;
				}
			} else {
				if( schosen==("an"+ s +"s0_0") )	{
					.profsay("snd"+Level+"ok");
					fxbrawo.play;
				} else	{
					.profsay("snd"+Level+"no");
					fxups.play;
				}
			}
		}
		txtodp.show;
		|bool br, bool bl| = .mgetid;
		string sid = schosen.strsube(1);
		if( br )	{ anokor.show; <sid+1>.show; } else { anokor.hide; <sid+1>.hide; }
		if( bl )	{ anokol.show; <sid+2>.show; } else { anokol.hide; <sid+2>.hide; }
		if( schosen=="anands0_0")		b = (br && bl);
		else if (schosen=="anors0_0")		b = (br || bl);
		if( breverse ) b=!b;
		if( b ) {txtodp.txtsetcol( dbprad.get(Level,1), .red); <sid+3>.show; }
		else	{ txtodp.txtsetcol( dbprad.get(Level,0), .blue); <sid+3>.hide; }
	}
	cbok_CLICK	{
		if( igmstate!=1 || cmov.moving)	return;
		if( schosen==null )	{ .profsay("snd3nog"); return; }
		cmov.lock;
		igmstate=0;
		fxprzekladnia.play;
		fxblink.play;
		.mwlacz;
	}
	cbok_MOVEON	{	sndakskermovon.play;	}
	finito	{
		gameapi.play((igmdemo?"LoadGame" : "Bramki"));
	}
	mouse_lclick	{
		.cactsndstop(true);
		if( igmstate==1 && schosen!=null && engine.varexist("gsq") && gsq.isin(mouse.getpos,1,1) ) {
			( aninvert.isvisible ) ? aninvert.hide : aninvert.show;
			breverse = aninvert.isvisible;
			fxpik.play;
		}
	}
}

// KomputroMode=3;
game Bramki : Komputro {
	init	{
		Komputro::init("bramki");
		.path = ("bramki");
		.bkg = ("bkg.pyz");
		.imgs = (A, "kolejne.pyzH", "zad.pyz 10");
		.sfxs = (A, "error", "mikrofala", "skok2");
		new @ilevel = 0;
		.newimgarray("grtin", "text", "txti", 20);
		.newimgarray("grtout", "text", "txto", 20);
		new @sfont = .stdfont(14);
		new @idy = 10;
		new classplacepointer2 clp;
		new classsimplebutton cbok;
		cbok.build("scripts/common/butok.pyz", "imglobcurs", 380, 505, 100, 0);
		grtin.each( func { (@id) .setfont( sfont ); } );
		grtout.each( func { (@id) .setfont( sfont ); } );
		.loadlekcja;
		.newdbscript("dbzad", "zadania.db");
		.buildlev;
		new @inextpl=3;
		
		.sounds = (A,
			"sndstart", "Na tej lekcji powiczymy zadania z bramkami",
				func { .cbplay("sndgo1"); clp.show(184,274,"ll"); },
			"sndgo1", "Po lewej widzisz tabelk z poznanymi dotd bramkami",
				func { .cbplay("sndgo2"); clp.showob("anzad","rd"); },
			"sndgo2", "Na rodku natomiast bramk ze zdefiniowanymi sygnaami wejciowymi",
				func { .cbplay("sndgo3"); },
			"sndgo3", "W miejscu znakw zapytania na czerwonym tle ustaw prawidowy sygna wyjciowy",
				func { .cbplay("sndgo4"); .cshowbut("dd"); },
			"sndgo4", "Kiedy oznaczysz wartoci wyj wcinij przycisk sprawd; Powodzenia!",
				func { clp.stoph; igmstate=1; },
			"sndok", "Dobrze", "next",
			"sndhm", "Nie oznaczye wszystkich wyj; widz znaki zapytania ", "fungo",
			"sndno", "Niestety widz bd; Przypatrz si uwanie i popraw", "fungo",
			"sndfin", "wietnie; wszystkie zadania zaliczone",
				func { grtin.hide; grtout.hide; anzad.hide; .cbplay("sndd1"); },
			"sndd1", "Jak widzisz bramki moemy czy w rne coraz bardziej skomplikowane ukady",
				func { ankolejne.show; .cbplay("sndd2"); },
			"sndd2", "And or i not to nie jedyne rodzaje bramek; istnieje 16 rnych funkcji logicznych z dwoma wejciami i wyjciem", "nextplay",
			"sndd3", "Obecnie w prawdziwych ukadach elektronicznych korzysta si z bardziej zoonych elementw posiadajcych wiele wej i wyj; Ale czasem uywamy na przykad ukadu 7408 zbudowanego z czterech bramek And", "nextplay",
			"sndd4", "Jak w praktyce to wyglda? Oto model ukadu realizujcego funkcj logiczn nand",
				"nextplay",
			"sndd5", "Ukad taki zamknity jest w czarnej kostce", "nextplay",
			"sndd6", "Ktr przylutowuje si do plastikowej pytki", "nextplay",
			"sndd7", "I czy przewodami z innymi kostkami", "nextplay",
			"sndd8", "Miliony elementw realizujcych proste funkcje logiczne buduj pyty gwne karty graficzne i procesory", func { .cbplay("sndd9"); },
			"sndd9", "Kliknij aby przej do nastpnej lekcji", func { igmstate=3; }
		);
		
		.cbplay("sndstart");
	}
	nextplay	{	.cbplay("sndd"+inextpl);	ankolejne.ansetnextfr; inextpl++;	}
	next		{
		if( (KomputroMode==1 && ilevel==2) || (KomputroMode>1 && ilevel==3 ) )	{
			.cbplay("sndfin");
		} else {
			ilevel++;
			.buildlev;
			igmstate=1;
		}
	}
	fungo	{	igmstate=1;	}
	buildlev	{
		grtin.hide;
		grtout.hide;
		string s;
		int il = ilevel*3;
		for( int i=0; i<anzad.nofframes(il+1); i++)	{
			anzad.setframe(il+1,i);
			s = "txti"+i;
			<s>.txtsetcol( dbzad.get(2*ilevel,i+1),.grey(40));
			<s>.setbkg( anzad.getpx, anzad.getpy-idy, <s>.getw+5, <s>.geth+5, .grey(20),20);
			<s>.show;
		}
		for( i=0; i<anzad.nofframes(il+2); i++)	{
			anzad.setframe(il+2,i);
			s = "txto"+i;
			<s>.txtsetcol("?",.grey(240));
			<s>.setbkg( anzad.getpx, anzad.getpy-idy, <s>.getw+5, <s>.geth+5, .red,192);
			<s>.show;
		}
		anzad.setframe(il,0);
	}
	cbok_MOVEON	{
		sndakskermovon.play;
	}
	cbok_CLICK	{
		if( igmstate==1 )	{
			igmstate=2;
			int il = anzad.nofframes(3*ilevel+2);
			bool b = true, bool bhm = false;
			for( int i=0; i<il; i++)	{
				if( <"txto"+i>.get != dbzad.get(2*ilevel+1,i+1 ) )	{
					b = false;
					if( <"txto"+i>.get=="?" ) bhm = true;
				}
			}
			if( b ) 	{
				.cbplay("sndok");
				fxmikrofala.play;
			} else {
				.cbplay( (bhm ? "sndhm" : "sndno" ) );
				fxerror.play;
			}
		}
	}
	mouse_lclick	{
		.cactsndstop(true);
		if( igmstate==3)	gameapi.play("Binary");
		else if( igmstate==1 )	{
			if ( grtout.isin(mouse.getpos, 1,1) ) {
				string s0 = grtout.getsfound;
				match(<s0>.get)	{
					"?" => "0";
					"0" => "1";
					"1" => "?";
					? => ;
				}
				<s0>.set;
				<s0>.createtxt(.grey(240));
				fxskok2.play;
			}
		}
	}
}

game Tasma : Komputro {
	init	{
		Komputro::init("tasma");
		.path = ("tasma");
		.imgs = (A, "bkg.pyz 10", "czytacz.pyzL 20", "kod01.pyz 20", "kompi.pyz 20", "kodH.pyz 20",
			"trawa.pyz 15", "machine.pyz 30", "zarowkaH.pyz 20", "strzH.pyz 50");
		.sfxs = (A, "error", "mikrofala", "skok2", "type", "pik", "brawo 40", "buu 40", "zapis",
			"komputer 20", "pik2 50", "unosi 40", "machine2");
		._loadguys("scripts/tasma/profesor", "scripts/tasma/jacek");
		ankompi.addmethod("onfinish",
			func { @s = .actionname;
				if( s=="wait" ) .dali2;
				else {
					fxunosi.play;
					grtas.move(0,-26);
					antas.move(0,-26);
					.play("wait");
				} } );
		anjack.setz(12);
		anprof.setz(12);
		anjack.move(-20,0);
		anprof.move(-60,0);
		new gmimgvec grtas;
		"grtas" ..< "tasma.pyz";
		grtas.each( func { (@id) .setz(15); .clip(400,130, 500, 440 ); } );
		grtas.removefirst;
		antasma0_0.addtogamevars("antas");
		grtas.hide;
		.loadlekcja;
		new classplacepointer2 clp;
		new classsimplebutton cbok;
		cbok.build("scripts/common/butok.pyz", "imglobcurs", 0, 485, 100, 0);
		tdopis.napisshow(200, 30);
		//.newtextposz("txtopis", "1 Hertz: 1 operacja na sekund, sfont, .grey(128), x+dx, 200+dx, 515);
		new TextDb tdopis2( .snewfont( "configs/fonts/normal.ttf", 12), 12, "opis.db",
			255,150,150, 210,52, 5, 35, "left");
		tdopis2.stdshadow(1);
		new @sfont = .stdfont(16);
		new TextDb tdzad(null, 12, "zad.db", .green, 630,10, 5, 550, "left");
		tdzad.stdshadow(1);
		tdzad.hide;
		new @Level = 1;
		new gmimgvec grtxt;
		grtxt.addlist(A, "tdlicz", "tddzies", "gsq");
		new @ilezad = 6;
		new @instr = 0;
		.newimgarray("grzad", "text", "txtz", ilezad);
		.newimgarray("grzadid", "text", "txtzid", ilezad);
		new vector vecid { .type("string"); .beginadd("begin","000","001","010","011","100","101","110"); };
		grzadid.each( func { (@id) .setz(50);
			.set("" + id + "(" + vecid.get(id)+")" );
			.setpos( 163, 190+id*25 );
			.setfont(sfont);
			.createtxt(.grey(40)); });
		grzad.each( func { (@id) .setz(50);
			.set("?");
			.setfont(sfont);
			//<s>.setbkg( 390, 90+y, <s>.getw+5, <s>.geth+5, 20,20,20,20);
			.createtxt(.grey(40));
			.setbkg( 240, 190+id*25, .getw+3, .geth+3, .grey(20),20 );
			 });
		.newimgarray("grzd2", "text", "txtz2", ilezad);
		.newimgarray("grzid2", "text", "txtzid2", ilezad);
		grzid2.each( func { (@id) .setz(50);
			.set(""+id+" :" );
			.setpos( 33, 85+id*25 );
			.setfont(sfont);
			.createtxt(.grey(40)); });
		grzd2.each( func { (@id) .setz(50);
			.set( "white" );
			.setfont(sfont);
			//.setpos( 70, 85+id*25 );
			.createtxt(.grey(40));
			.setbkg( 70, 85+id*25, .getw, .geth, .grey(220),2 );
			 });
		grzid2.hide;
		grzd2.hide;
		new TextDb tdrozk(null, 12, "rozkazy.db", 255,100,100, 15,264, 5, 550, "left");
		tdrozk.stdshadow(1);
		tdrozk.hide;
		new @sfont13 = .stdfont(14);
		.newtext("txtzad", "0", sfont13, 255,250,250);
		.newdb("dbzad","zadania.db");
		txtzad.anposz( 100, 550, 260);
		.newtext("txtzad2", "0", sfont13, 255,250,250);
		txtzad2.anposz( 100, 570, 260);
		txtzad2.hide;
		txtzad.hide;
		.newtext("txtinstr", "0", sfont13, .grey(64));
		txtinstr.anposz( 742, 92, 260);
		txtinstr.hide;
		.sounds = (A,
			"sndintro", "W tej lekcji napiszesz swj pierwszy program", func { .cbplay("snd1"); },
			"snd1", "Tworzenie maszyn ktrych wszystkie zadania realizuj ukady elektroniczne jest bardzo trudne i pracochonne",
				func { .cbplay("snd2"); },
			"snd2", "Dlatego wymylono ukady czytajce instrukcje z zewntrz i na ich podstawie wykonujce rne zadania",
				func { .cbplay("snd3"); },
			"snd3", "Nim zaczniemy oprogramowywa maszyn ktr widzisz przed sob poznasz podstawowe pojcia zwizane z liczbami",
				func { <GAME> { .viewhelp; }; .cbplay("snd4"); },
			"snd4", "Komputery s zbudowane z ukadw cyfrowych o ktrych dowiedziae si troch w poprzednich lekcjach",
				func { .cbplay("snd5"); },
			"snd5", "Ukady te dziaaj w oparciu o dwie liczby 0 i 1 co w rzeczywistoci oznacza brak napicia i jego wystpienie na wejciach i wyjciach",
				func { .cbplay("snd6"); tddzies.setz(510); tddzies.napisshow(300,200); },
			"snd6", "Liczby ktrymi posugujesz si na codzie zapisujesz za pomoc dziesiciu cyfr od 0 do 9; Mwimy wtedy e liczby zapisujemy w systemie dziesitnym",
				func { .cbplay("snd7"); tdlicz.show; },
			"snd7", "Kad z nich moemy zapisa take w systemie dwjkowym czyli za pomoc dwch cyfr",
				func { .cbplay("snd8"); },
			"snd8", "Komputery przechowuj liczby w komrkach o rnej wielkoci",
				func { .cbplay("snd9"); <GAME> {
					tddzies.hide;
					@w = 30;
					@x = 550;
					@dx = 7;
					new gfxSquare gsbit(x,200,w,w);
					gsbit.set(.grey(240),255);
					gsbit.build;
					gsbit.setz(510);
					gsbit.border(1,1,.black,240);
					.newtextposz("txtbit", 2->rand, sfont, .grey(128), x+dx, 200+dx, 515);
					string s;
					for( int i=0; i<8; i++)	{
						s = "gsb"+i;
						new gfxSquare <s>(x-i*w,300,w,w);
						<s>.set(.grey(240),255);
						<s>.build;
						<s>.setz(510);
						<s>.border(1,1,.black,240);
						grtxt.add(s);
						.newtextposz("txtbajt"+i, 2->rand, sfont, .grey(128), x-i*w+dx, 300+dx, 515);
						grtxt.add("txtbajt"+i);
					}
					tdbit.napisshow( x - w, 205+w );
					tdbit.setz(515);
					tdbajt.napisshow( x - 6*w, 305+w );
					tdbajt.setz(515);
					grtxt.addlist(A,"gsbit","tdbit","tdbajt","txtbit");
					clp.showob("gsbit", "ld");
				}; },
			"snd9", "Podstawow komrk jest bit ktry przechowuje 2 liczby 0 lub 1",
				func {.cbplay("snd10"); clp.showob("gsb3","dd"); },
			"snd10", "8 bitw skada si na bajt ktry pomieci 256 liczb od 0 do 255",
				func { grtxt.hide; clp.showpob("antas", "rr"); .cbplay("snd11"); },
			"snd11", "Nasz komputer pobierze program z tej szeciobitowej tamy",
				func { clp.showob("ankod01", "lu"); .cbplay("snd12"); },
			"snd12", "Tutaj bdziesz pisa program", func { .cshowbut("dd"); .cbplay("snd13"); },
			"snd13", "Tutaj wczysz maszyn", func { clp.showob("anzarowka", "rr"); .cbplay("snd14"); },
			"snd14", "Maszyna posiada dwie instrukcje 1 oznacza zapalenie arwki na czerwono 0 oznacza zapalenie na biao",
				func { clp.stoph; .cbplay("snd15"); tdzad.show; },
			"snd15", "Maszyna przetwarza jedn instrukcj na sekund",
				func { clp.showpob("txtzad", "dd"); .showzad; .cbplay("sndz1"); },
			"sndz1", "Na dole widzisz tre zadania; Do dziea! ", func { clp.stoph; .startgame; },
			"sndr0", "Zero", "dali",
			"sndr1", "Jeden", "dali",
			"sndrhm", "Za instrukcja; Kompilacja si nie powioda; Popraw bdy i uruchom ponownie", 
				"viewzad",
			"sndok", "Dobrze; kolejne zadanie", "startgame",
			"sndno", "Program zadziaa niepoprawnie; popraw bdy i uruchom ponownie", "viewzad",
			"sndgo1", "Teraz program bdziesz pisa tutaj uywajc rozkazw czytelnych dla czowieka; Kompilator przetumaczy go na jzyk zrozumiay dla maszyny",
				func { clp.stoph; .startgame; },
			"sndend", "Wspaniale! Otrzymujesz tytu programisty maszyny jednobitowej",
				func { .profstop; .jacksay("sndend2"); },
			"sndend2", "Hip hip hurra; ju si nie mog doczeka kolejnej lekcji", "finito"
		);
		.profsay("sndintro");
		.cycle = ("timout", func {
			antas.move(0,-10);
			grtas.move(0,-10);
			if( antas.getey > 155 ) .play;
			else {
				fxmachine2.stop(false);
				fxmikrofala.play;
				imachine=0;
				timm.play;
			}
			} );
		new @imachine = 0;
		.timer = ("timm", 1000, func {
			if( imachine==6 )	{
				anzarowka.hide;
				txtinstr.hide;
				string s="";
				int i;
				if( Level<5)	for(i=0; i<ilezad; i++) s+=<"txtz"+i>.get;
				else	for(i=0; i<ilezad; i++) s+= (<"txtz2"+i>.get=="red" ? 1 : 0);
				bool b = false;
				match(Level)	{
					1 => b = s.contains("1");
					2 => b = s=="000000";
					3 => b = ( s.getb(0,4)=="1110" || s.contains("01110") );
					4 => b = s=="010101";
					5 => {
						int ile=0;
						for( i=0; i<ilezad; i++) if( s.getb(i,1)=="0" ) ile++;
						b = ile==4;
					}
					6 => b = s=="001110";
					7 => b = (s.getb(0,3)=="000" || s=="100000");
					? => ;
				}
				if( b ) {
					Level++;
					if( Level==8 )	.profsay("sndend");
					else if( Level==5 )	{
						.profsay("sndgo1");
						clp.showob("ankod","ll");
						tdrozk.show;
						ankod.show;
						grzd2.show;
						grzid2.show;
					} else {
						.profsay("sndok");
						fxbrawo.play;
					}
				} else {
					.profsay("sndno");
					fxbuu.play;
				}
			} else {
				fxpik.play;
				anzarowka.setframe(0,<"txtz"+imachine>.get);
				anzarowka.show;
				txtinstr.txtset( vecid.get(imachine) );
				txtinstr.show;
				imachine++;
				.play;
			}
			} );
	}
	viewst(int id)	{
		@s = ( Level<5 ? "txtzid" : "txtzid2" ) + id;
		anstrz.setpos(<s>.getpx-anstrz.getw, <s>.getpy+3);
		anstrz.show;
	}
	dali2	{
		string s;
		if( instr==6 )	{
			fxmachine2.play;
			timout.play;
		} else {
			anczytacz.play(0);
			s = <"txtz"+instr>.get;
			.viewst(instr);
			fxpik2.play;
			if( s=="?" ) .cbplay("sndrhm");
			else {
				.cbplay("sndr"+s);
			}
		}
	}
	dali	{
		anczytacz.stop(false);
		anczytacz.setframe(0,0);
		@s = <"txtz"+instr>.get;
		ankompi.play( s );
		if( s == "1" )	{<grtas.get(instr)>.show; fxtype.play;	}
		instr++;
	}
	viewzad	{
		.viewst(0);
		anczytacz.stop(false);
		anczytacz.setframe(0,0);
		.profstop;
		igmstate=1;
		instr = 0;
		grtas.hide;
		antas.setpos(0,0);
		grtas.setpos(0,0);
		.showzad;
	}
	showzad	{
		@id = Level-1;
		txtzad.txtset( dbzad.get(id,0) );
		txtzad.txtshadow(2,sfont13);
		txtzad.show;
		if( dbzad.getcolsno(id) > 1 )	{
			txtzad2.txtset( dbzad.get(id,1) );
			txtzad2.txtshadow(2,sfont13);
			txtzad2.show;
		} else txtzad2.txthides;
	}
	startgame	{
		.profstop;
		grzad.each( func { (@id) .txtset("?"); } );
		.viewzad;
	}
	viewhelp	{
		new gfxSquare gsq(200,100,400,300);
		gsq.set(.grey(240), 255);
		gsq.build;
		gsq.setz(500);
// 		gsq.border(1,1, .grey(192), 255);
		gsq.border(1,1,.black,255);
		gsq.shadow(2,2,128);
		
		new TextDb tdlicz(null, 12, "liczby.db", .grey(20), 210, 115, 5, 550, "left");
		tdlicz.hide;
	}
	cbok_MOVEON	{	sndakskermovon.play;	}
	cbok_CLICK	{
		if( igmstate!=1 )	return;
		igmstate=2;
		fxkomputer.play;
		if( Level>4 )	{
			for( int i=0; i<ilezad; i++)	{
				<"txtz"+i>.txtset( (<"txtz2"+i>.get=="red" ? "1" : "0" ) );
			}
		}
		.dali2;
	}
	mouse_lclick	{
		.cactsndstop(true);
		if( igmstate!=1 ) return;
		if( Level<5 )	{
			if( grzad.isin(mouse.getpos,1,0) )	{
				string s = grzad.getsfound;
				match(<s>.get)	{
					"?" => "0";
					"0" => "1";
					"1" => "?";
					? => ;
				}
				<s>.txtset;
				fxskok2.play;
			}
		} else {
			if( grzd2.isin(mouse.getpos,1,0) )	{
				string s = grzd2.getsfound;
				<s>.txtset( (<s>.get=="red" ? "white" : "red") );
				fxzapis.play;
			}
		}
	}
	finito	{
		//gameapi.play( ( KomputroMode < 3 ? "AsmEasy" : "AsmHard") );
		gameapi.play("AsmEasy");
	}
}

 KomputroMode=3;
class Asm : Komputro	{
	init(string sp)	{
		new @spref = sp;
		Komputro::init("asm");
		.path = ("asm");
		.imgs=(A,"bkg.pyz", "strzalH.pyz 10", "monitor.Hpyz 10", "zarowkaH.pyz 10", "klawH.pyz 10");
		.sfxs = (A, "error", "mikrofala", "skok2", "type", "pik", "pik2 40", "zapis", "wlacznik 20",
			"ups 30", "bum 30", "brawo 40");
		.copyanima("anmonitor", "anmo2");
		anmo2.setframe(1,0);
		.copyanima("anzarowka", "anzar2");
		anzar2.setframe(1,0);
		anzar2.hide;
		new classplacepointer2 clp;
		new classsimplebutton cbok;
		cbok.build("scripts/common/butok.pyz", "imglobcurs", 0,525, 100, 0);
		.sounds = (A,
			"sndintro", "W tej lekcji dowiesz si czym jest jzyk asembler", func { .cbplay("snd1"); },
			"snd1", "Przed sob widzisz prosty komputer zbudowany z",
				func { .cbplay("snd2"); clp.show(139,139,"ll"); },
			"snd2", "procesora ktry czyta rozkazy z pamici", func { .cbplay("snd3"); clp.show(350,124,"rd"); },
			"snd3", "oraz pamici", func { .cbplay("snd4"); clp.show(643,94,"rr"); },
			"snd4", "Tutaj natomiast znajduje si specjalny notatnik ktry przesya pisane programy wprost do pamici",
				func { .cbplay("snd5"); .cshowbut("dd"); },
			"snd5", "Tutaj bdziesz wcza ukad", func { .cbplay("snd6"); clp.showob("gsh","rd"); },
			"snd6", "Tutaj jest opis rozkazw ktre wykonuje procesor",
				func { clp.stoph; .cbplay("sndgo1"); .viewhelp; },
			"sndnoins", "Nieprawidowa instrukcja; Popraw bd i skompiluj ponownie", "dali",
			"sndpoza", "Zabrako pamici! Usu zbdne instrukcje", "dali",
			"sndbrak", "Brak programu","dali",
			"sndok", "Dobrze! Przeanalizuj przykad i kliknij aby przej do kolejnego zadania lub wcz program ponownie", "nextzad",
			"sndnon", "Program zadziaa jednak musisz napisa go dokadnie tak jak wymaga tego tre zadania", "dali",
			"sndnext", "Kolejne zadanie", "showzad",
			"snddig", "Dozwolone s tylko liczby w zapisie dwjkowym zapisane przy pomocy 0 i 1", "dali",
			"sndwkod", "Stary hakerski trik chciae wpisa instrukcj w kod programu; niestety procesor pracuje w trybie chronionym i nie pozwala na takie sytuacje", "dali",
			"sndmov1", "Odwoae si do adresu spoza zakresu pamici", "dali",
			"sndmov2", "Liczba nie mieci si w pamici", "dali"
		);
		new db dbcode;
		new vector veccode;
		veccode.type("string");
		new @ileram;
		new @sdigram;
		new @iledigram;
		new @proglen;
		new @proglen2;
		new @progid;
		new @levlen = 4;
		new @Good;
		new @Binary;
		new @Zaduza;
		new @Level = 1;
		new @HelpLevel = 1;
		new @ZadLevel = 1;
		new @ileramu = 21;
		new @codeline;
		new @codeid = 0;
		new string Code;
		Lexer::setas("Code");
		new @stdfnt = .stdfont(12);
		.newimgarray("grram", "text", "txtr", ileramu);
		.newimgarray("grins", "text", "txti", ileramu);
		.newimgarray("grpod", "text", "txtp", ileramu);
		new @ifontsize = 14;
		.monofont("fnkod", ifontsize);
		grram.each( func { (@id)
			.setfont("fnkod");
			@y = 112+id*(ifontsize+4);
			.setpos( 320, y );
			<"txtp"+id>.setfont("fnkod");
			<"txtp"+id>.setpos( 480, y );
			//<"txtp"+id>.createtxt(240,240,20);
			<"txtp"+id>.createtxt(.grey(240));
			} );
		grins.each( func { (@id)
			.setfont("fnkod");
			.setpos( 410, 112+id*(ifontsize+4) );
			} );
		new img imgerror {
			.create(160,ifontsize,.red,128);
			.setz(0);
			.hide;
		};
		new gfxSquare gsh(553,384,240,190);
		gsh.set(.grey(240), 192);
		gsh.build;
		gsh.shadow(2,2,128);
		.newimgarray("grhelp", "text", "txth", 15);
		.newimgarray("grhelp2", "text", "txth2", 15);
		grhelp.each( func {(@id)
			<"txth2"+id>.setfont(stdfnt);
			<"txth2"+id>.setz(10);
			.setfont(stdfnt);
			.setpos(gsh.getpx+7, gsh.getpy+10+id*15);
			.setz(10);
			} );
		new db dbhelp;
		.newtext("txtzad", "0", stdfnt, 255,250,250);
		.newdb("dbzad", spref + "zadania.db");
		.newdb("dbexp", spref + "expect.db");
		txtzad.anposz( 80, 555, 260);
		.newtext("txtzad2", "0", stdfnt, 255,250,250);
		txtzad2.anposz( 80, 575, 260);
		txtzad2.hide;
		txtzad.hide;
		.newtext("txtram", "0", stdfnt, 255,250,250);
		txtram.anposz( 282,502, 260);
		.loadlekcja;
		
		new classsimplebutton cbhelp;
		cbhelp.build("scripts/common/help.pyz", "imglobcurs", 0,100, 100, 0);
		new TextBoxTyper ttb("fnkod", ifontsize, 0.6*ifontsize, .black, "a0 ,[]", 602,65, 160,280, 3);
		ttb.enumerate(5);
		.newimgarray("grhm", "text", "txthm", ttb.size);
		grhm.each( func { (@id)
			.setpos( 602, 65+id*(ifontsize+3) );
			.setfont("fnkod");
			} );
		
		tdmikro.napisshow(135 - tdmikro.getw/2,60);
		tdram.napisshow(384 - tdram.getw/2,60);
		tdproc.napisshow( tdmikro.getpx+(tdmikro.getw-tdproc.getw)/2,80);
		tdadres.napisshow(304,85);
		tdvar.napisshow(400,85);
		
		new vector veckod;
		veckod.type("string");
		new vector vecpom;
		vecpom.type("string");
		new vector vecinstr;
		
		.timer = ("timgo", 1000, "fintimgo");
		
		.newimgarray("grkable", "img", "imgk", 3);
		imgk0.create(60,2,.colkabel);
		imgk0.setpos(206,97);
		imgk2.create( txtr0.getpx-imgk0.getex, 2, .colkabel );
		.setkable(0);
		
		.linkmonitor;
		grmon.hide;
	}
	fintimgo	{
		if( progid==proglen )	{
			anmo2.hide;
			anzar2.hide;
			if( Good )	{
				<GAME>.cbplay("sndok");
				fxbum.play;
			} else {
				<GAME>.cbplay("sndnon");
				fxups.play;
			}
		} else {
			fxpik.play;
			.play;
			.setkable(vecinstr.get(progid));
			.setinstr;
		}
	}
	setkable(int id)	{
		int y = <"txtr"+id>.getpy+5;
		imgk1.create(2,y-imgk0.getpy,.colkabel);
		imgk1.setpos(imgk0.getex, imgk0.getpy);
		imgk2.setpos(imgk1.getpx, imgk1.getey);
	}
	dali	{
		igmstate = 1;
		ttb.enable;
	}
	viewhelp	{
		grhelp.hide;
		grhelp2.hide;
		dbhelp.load( .getgraphpath + spref +"help" + HelpLevel + ".db" );
		string s[2];
		for( int i=0; i<dbhelp.getrowsno; i++)	{
			s0 = "txth"+i;
			s1 = "txth2"+i;
			<s1>.txtsetcol( dbhelp.get(i,1), .grey(64) );
			<s1>.show;
			if( dbhelp.get(i,0)->length>0 )	{
				<s0>.txtsetcol( dbhelp.get(i,0), .red );
				<s0>.show;
				<s1>.setpos( <s0>.getpx + <s0>.getw + 4, <s0>.getpy );
			} else {
				<s0>.hide;
				<s1>.setpos( gsh.getpx+7, gsh.getpy+10+i*15);
			}
		}
	}
	showzad	{
		.viewzad;
		@id = Level-1;
		ttb.clear;
		.clearram;
		.setkable(0);
		id = id*levlen+3;
		grhm.each( func { (@id) .txtset(""); } );
		//if( Level>2 && KomputroMode<3 ) id--;
		//if( Level>2 ) id--;
		id--;
		for( int i=1; i<dbexp.getcolsno(id); i++)	{
			<"txthm"+(i-1)>.txtsetcol( dbexp.get(id,i), .grey(128) );
		}
		grhm.hide;
	}
	viewzad	{
		@id = ZadLevel-1;
		txtzad.txtset( dbzad.get(id,0) );
		txtzad.txtshadow(2,stdfnt);
		txtzad.show;
		if( dbzad.getcolsno(id) > 1 )	{
			txtzad2.txtset( dbzad.get(id,1) );
			txtzad2.txtshadow(2,stdfnt);
			txtzad2.show;
		} else txtzad2.txthides;
	}
	colkabel	{	return 226,239,221,255;	}
	clearram	{
		for( int i=0; i<ileramu; i++)	{
			if( i<ileram )	{
				<"txtr"+i>.txtsetcol( i.getbindigit(iledigram), .black );
				<"txti"+i>.txtsetcol( sdigram, .black );
			} else {
				<"txtr"+i>.txtset( "" );
				<"txti"+i>.txtset( "" );
			}
			<"txtp"+i>.txtset("");
		}
		imgerror.hide;
	}
	cbhelp_MOVEON	{
		sndakskermovon.play;
		if( igmstate!=1 ) return;
		grhm.show;
		ttb.hide;
	}
	cbhelp_MOVEOFF	{
		grhm.hide;
		if( igmstate==1 )	{
			ttb.show;
		}
	}
	cbok_MOVEON	{	sndakskermovon.play;	}
	cbok_CLICK	{
		if( !(igmstate==1 || igmstate==10) ) return;
		fxzapis.play;
		.clearram;
		igmstate = 2;
		veckod.free;
		ttb.disable;
		string s;
		for( int i=0; i < ttb.Rows; i++)	{
			s = ttb.getid(i);
			s.clear;
			veckod.add(s);
		}
		Good = true;
		Binary = false;
		Zaduza=false;
		@id = (Level-1)*levlen;
		proglen=0;
		proglen2=0;
		progid = 0;
		vecinstr.free;
		.setkable(0);
		for( i=0; i<veckod.size; i++)	{
			s = veckod.get(i);
			codeline = "";
			if( s.length>0 )	{
				if( proglen2>=ileram) {
					.cbplay("sndpoza");
					return;
				} else if( .wronginstr(id,s) )	{
					.cbplay("sndnoins");
					imgerror.show;
					imgerror.setpos( 602, 65+i*(ifontsize+3) );
					return;
				} else if (Level<3 && (proglen+1>=dbexp.getcolsno(id+2)) || s!=dbexp.get(id+2,proglen+1)){
					Good = false;
				}
				.insertorder(s);
				
				if( Level>2 ) {
					if (Binary||Zaduza) 	{
						if( Binary )	.cbplay("snddig");
						else if( Zaduza )	.cbplay("sndmov"+Zaduza);
						imgerror.show;
						imgerror.setpos( 602, 65+i*(ifontsize+3) );
						fxups.play;
						return;
					}
					Good = ( Good && proglen < veccode.size && codeline==veccode.get(proglen) );
					/*if( proglen<veccode.size)	{
						"**************"->print;
						codeline.print;
						veccode.get(proglen)->print;
						"**************"->print;
					} */
				}
				proglen++;
			}
		}
		if( Level<3 )	{if( Good && proglen+1<dbexp.getcolsno(id+2) ) Good=false;}
		else	{	Good = (Good && proglen==veccode.size);	}
		if( proglen==0 )	{	.cbplay("sndbrak");	fxups.play;	}
		else timgo.play;
	}
	linkmonitor	{
		@dy = 7;
		.newimgarray("grmon", "img", "imgm", 4);
		imgm0.create(imgk0.getw, 2, .colkabel);
		imgm1.create(2, txtr15.getpy - txtr14.getpy, .colkabel);
		imgm1.setpos( imgk0.getex, txtr14.getpy + dy );
		imgm0.setpos( imgm1.getpx - imgm0.getw, imgm1.getcy );
		@w = txtr14.getpx - imgm1.getex;
		imgm2.create(w, 2, .colkabel);
		imgm3.create(w, 2, .colkabel);
		imgm2.setpos( imgm1.getex, imgm1.getpy );
		imgm3.setpos( imgm1.getex, imgm1.getey-imgm3.geth );
	}
	startzad	{
		.showzad;
		igmstate = 1;
		ttb.activate(0);
	}
	nextzad	{	igmstate=10;	}
	setram(int iler, int iledig, string sdr)	{
		|ileram,iledigram,sdigram| = iler,iledig,sdr;
		txtram.txtset( "RAM: "+ileram+"   "+sdigram.length + "-bit cells");
		txtram.txtshadow(1,stdfnt);
	}
}

game AsmEasy : Asm {
	init	{
		Asm::init("");
		.setsndbase("asmeasy");
		
		.sounds = (A,
			"sndgo1", "Nasz procesor obsuguje 3 rozkazy On zapalenie arwki Off zgaszenie arwki oraz Stop czyli zakoczenie pracy",
				func { .cbplay("sndg2"); .showzad; },
			"sndg2", "Napisz program ktrego tre widzisz na dole", func { igmstate=1; ttb.activate(0); },
			"sndzad1", "A teraz wska komrk w pamici RAM w ktrej znajduje si kod instrukcji ON",
				func { igmstate=3; clp.stoph; },
			"sndok1", "wietnie to jest wanie instrukcja ON; kolejne zadanie", "viewnext",
			"sndnon1", "Niestety to jest instrukcja STOP a nie ON", "daliclick",
			"sndnieokreslona", "W tej komrce nie ma adnej instrukcji", "daliclick",
			"sndok2", "wietnie to jest instrukcja mov", "nextshow",
			"sndok3", "Tak to jest adres pod ktry instrukcja mov wpisze liczb", "nextshow",
			"sndok4", "Dobrze to jest liczba ktr mov wpisze pod adres; jak widzisz instrukcja mov zajmuje a 3 komrki pamici", "nextshow",
			"sndok5", "Brawo pod tym adresem znajduje si instrukcja STOP", func { .cbplay("sndproc3"); },
			"sndnonall", "Niestety wskazae bdn komrk pamici", "daliclick",
			"sndnoad", "Niestety wskazae zy adres", "daliclick",
			"sndnextproc", "Teraz zmienimy procesor na bardziej zoony podobny do prawdziwych procesorw w komputerach; Na pocztek wyposaony w dwie instrukcje MOV i STOP", "startproc2",
			"sndproc3", "Kolejny procesor ma a 16 komrek pamici i wicej rozkazw", "startproc3",
			"sndp4", "Teraz dodaj kolejn instrukcj ADD", "startproc4",
			"sndp5", "Add podobnie jak Mov ma rwnie drug form", "startproc5",
			"sndp6", "Teraz podczymy do ukadu monitor",
				func { .cbplay("sndp61"); clp.showpob("txti14","rr"); grmon.show; anmonitor.show;},
			"sndp61", "Z tej komrki monitor odczytuje stan",
				func { .cbplay("sndp62"); clp.showpob("txti15","rr"); },
			"sndp62", "A z tej kolor jaki ma wywietli na ekranie; Zaczynamy", func { clp.stoph; .startproc6; },
			"sndend", "Gratuluj! Rozwizae wszystkie zadania; Przeczytaj i zastanw si nad tekstem a potem kliknij aby przej do nastpnej lekcji",
				func { igmstate=11; <GAME>.showend;	}
		);
		.setram(8,3,"00");
		.clearram;
		anzarowka.show;
		
		new @smoved = null;
		new @Level2 = 1;
		new Color scol;
		
 		.cbplay("sndintro");
		
		//Level=3;
		/*Level=7;
		Level2 = 5;
		//ZadLevel = 8;
		ZadLevel = 12;
		//HelpLevel = 2;
		HelpLevel = 5;
		
		dbcode.dbbuild(A,
			"mov", "[", "$int", "]", ",", "$int",
			"stop", "", "", "", "", "",
			6);
		//.cbplay("sndok5");
		dbcode.dbaddstringrow("mov|[|$int|]|,|[|$int|]","|");
		Code.consts = (A,"mov",",","[","]", "add", "stop");
		.setram(16,4,"0000");
		.cbplay("sndp6");
		.viewhelp;*/
// 		.showend;
	}
	nextshow	{
		igmstate=3;
		ZadLevel++;
		.viewzad;
		Level2++;
	}
	daliclick	{	igmstate=3;	}
	wronginstr(int id, string s)	{
		match(Level)	{
			1,2 => !dbexp.dbrowcontains(id,s);
			3,4,5,6,7,8 => {
				Code.start(s);
				codeid = Code.expectdb("dbcode", 0);
				codeid < 0;
			}
			? => ;
		}
	}
	nextzadl	{
		match(Level)	{
			1 => {
				clp.show(425,157,"dd");
				igmstate=4;
				ZadLevel++;
				.viewzad;
				.cbplay("sndzad1");
			}
			2 => {
				if( KomputroMode==1 )	.cbplay("sndend");
				else .cbplay("sndnextproc");
			}
			3 => .nextshow;
			4 => {
				veccode.free;
				veccode.beginadd("begin",
					"mov [ 1101 ] , 0001 ",
					"mov [ 1101 ] , 0010 ",
					"mov [ 1110 ] , 0111 ",
					"mov [ 1111 ] , [ 0010 ] ",
					"stop ");
				.viewnext;
			}
			5 => .cbplay("sndp4");
			6 => .cbplay("sndp5");
			7 => .cbplay("sndp6");
			8 => { fxbrawo.play; .cbplay("sndend"); }
			? => ;
		}
	}
	startproc6	{
		veccode.free;
		//mov [1110],1|mov [1111],10|mov [1111],1|mov [1111],11|stop|
		veccode.beginadd("begin",
			"mov [ 1110 ] , 0001 ",
			"mov [ 1111 ] , 0010 ",
			"mov [ 1111 ] , 0001 ",
			"mov [ 1111 ] , 0011 ",
			"stop ");
		.viewnext;
	}
	startproc5	{
		HelpLevel++;
		.viewhelp;
		veccode.free;
		
		veccode.beginadd("begin",
			"mov [ 1100 ] , [ 0000 ] ",
			"add [ 1100 ] , [ 0001 ] ",
			"add [ 1100 ] , [ 0010 ] ",
			"stop ");
		dbcode.dbaddstringrow("add|[|$int|]|,|[|$int|]","|");
		.viewnext;
	}
	startproc4	{
		HelpLevel++;
		.viewhelp;
		veccode.free;
		//mov [1110],0011|add [1110],0010|mov [1111],[1110]|stop|
		veccode.beginadd("begin",
			"mov [ 1110 ] , 0011 ",
			"add [ 1110 ] , 0010 ",
			"mov [ 1111 ] , [ 1110 ] ",
			"stop ");
		Code.consts = (A,"mov",",","[","]", "add", "stop");
		dbcode.dbaddstringrow("add|[|$int|]|,|$int","|");
		.viewnext;
	}
	startproc2	{
		HelpLevel++;
		.viewhelp;
		.setram(8,3,"000");
		Code.consts = (A,"mov",",","[","]", "stop");
		dbcode.dbbuild(A,
			"mov", "[", "$int", "]", ",", "$int",
			"stop", "", "", "", "", "",
			6);
		veccode.free;
		veccode.beginadd("begin",
			"mov [ 110 ] , 010 ",
			"stop ");
		anzarowka.hide;
		anzar2.hide;
		.viewnext;
	}
	startproc3	{
		HelpLevel++;
		.viewhelp;
		.setram(16,4,"0000");
		Code.consts = (A,"mov",",","[","]", "stop");
		dbcode.dbaddstringrow("mov|[|$int|]|,|[|$int|]","|");
		veccode.free;
		veccode.beginadd("begin",
			"mov [ 1100 ] , 1111 ",
			"mov [ 1110 ] , [ 1100 ] ",
			"stop ");
		.viewnext;
	}
	viewnext	{
		Level++;
		ZadLevel++;
		<GAME>.startzad;
	}
	insertorder(string s)	{
		@id = (Level-1)*levlen;
		vecinstr.add( proglen2 );
		string s2;
		match(Level)	{
			1,2 => {
				<"txti"+proglen2>.txtset( dbexp.get(id+1,dbexp.dbfindinrow(id, s)) );
				<"txtp"+proglen2>.txtset( s );
				proglen2++; }
			3,4,5,6,7,8 => {
				Code.id = (0);
				Code.gettoken("vecpom",true);
				for( int i=0; i< vecpom.size; i++)	{
					s2 = vecpom.get(i);
					match( s2 )	{
						// mov [ $int ? ] , $int ?
						"mov", "add" => { 
							if( codeid==0 || codeid==3 )	{
								<"txti"+proglen2>.txtset( .ordkod(s2+codeid) );
								<"txtp"+proglen2>.txtset(s2);
								<"txtp"+(proglen2+1)>.txtset("[address]");
								<"txtp"+(proglen2+2)>.txtset("value");
								proglen2++;
								codeline = s2 + " ";
								if( !vecpom.get(3)->strisbin ) {
									Binary=true;
								} else {
									id = vecpom.get(3);
									s = id.getdigit(3);
									codeline+=("[ " + s + " ] , ");
									if( id.bin_to_i >= ileram ) Zaduza=1;
									else <"txti"+proglen2>.txtset(s);
									proglen2++;
									if( !vecpom.get(7)->strisbin ) {
										Binary=true;
									} else {
										id = vecpom.get(7);
										s = id.getdigit( sdigram.length );
										codeline+=(s+" ");
										if( s.length>sdigram.length ) Zaduza=2;
										else <"txti"+proglen2>.txtset(s);
										proglen2++;
									}
								}
							} else {	// 0mov 1[ 2$int 3? 4] 5, 6[ 7$int 8? 9]
								<"txti"+proglen2>.txtset( .ordkod(s2+codeid) );
								<"txtp"+proglen2>.txtset(s2);
								<"txtp"+(proglen2+1)>.txtset("[address 1]");
								<"txtp"+(proglen2+2)>.txtset("[address 2]");
								proglen2++;
								codeline = s2 + " ";
								if( !vecpom.get(3)->strisbin ) {
									Binary=true;
								} else {
									id = vecpom.get(3);
									s = id.getdigit(3);
									codeline+=("[ " + s + " ] , [ ");
									if( id.bin_to_i >= ileram ) Zaduza=1;
									else <"txti"+proglen2>.txtset(s);
									proglen2++;
									if( !vecpom.get(8)->strisbin ) {
										Binary=true;
									} else {
										id = vecpom.get(8);
										s = id.getdigit( sdigram.length );
										codeline+=(s+" ] ");
										if( s.length>sdigram.length ) Zaduza=1;
										else <"txti"+proglen2>.txtset( s );
										proglen2++;
									}
								}
							}
						}
						"stop" => {
							<"txti"+proglen2>.txtset(111->getdigit(iledigram));
							<"txtp"+proglen2>.txtset("stop");
							proglen2++;
							codeline = "stop ";
						}
						? => ;
					}
				}
			}
			? => ;
		}
	}
	string ordkod(string s)	{
		match(s)	{
			"mov0" =>	1;
			"mov2" =>	10;
			"add3" =>		11;
			"add4" =>		100;
			? => ;
		}
		int id = _;
		id.getdigit(iledigram);
	}
	setinstr	{
		if( Level==1||Level==2 )	{
			match( <"txti"+progid>.get )	{
				"01" => { anzar2.show; progid++; fxwlacznik.play;}
				"10" => { anzar2.hide; progid++; }
				"11" => { progid=proglen; }
				? => { "error!"->print; }
			}
		} else {
			int id = vecinstr.get(progid);
			string s = <"txti"+id>.get;
			match( s )	{
				"001", "0001", "0010", "0011", "0100" => {
					int i = <"txti"+(id+1)>.get;
					i = i.bin_to_i;
					if( i<proglen2 ) {
						//(""+i+" "+proglen2)->print;
						.cbplay("sndwkod");
						timgo.stop(false);
						return;
					} else if (i>=ileram)	{
						.cbplay("sndmov1");
						timgo.stop(false);
						return;
					}
					match(s)	{
						//"0010" => <"txti"+i>.txtset( <"txti" + <"txti"+(id+2)>.get->to_i->bin_to_i >.get );
						"0010" => <"txti"+i>.txtset( <"txti" + .gettxtint(id+2) >.get );
						"001", "0001" => <"txti"+i>.txtset( <"txti"+(id+2)>.get );
						//"0011" => <"txti"+i>.txtset( ( <"txti"+(id+2)>.get->to_i->bin_to_i +
						//	<"txti"+i>.get->to_i->bin_to_i)->getbindigit(iledigram) );
						"0011" => <"txti"+i>.txtset( (.gettxtint(id+2)+.gettxtint(i))->cgetbound );
						"0100" => <"txti"+i>.txtset( (.gettxtadr(id+2)+.gettxtint(i))->cgetbound );
						? => ;
					}
					if( Level>7)	{
						if( i==14 )	{
							if (txti14.get->to_i==1) {
								anmo2.show;
								.viewmon;
							} else anmo2.hide;
						} else if (i==15)	.viewmon;
					}
					progid++;
					//.debug = (true);
				}
				"111", "0111" => progid=proglen;
				? => {
					.cbplay("sndwkod");
					timgo.stop(false);
				}
			}
		}
	}
	showend	{
		.printend( ( KomputroMode<3 ? "zastanow" : "zastanow2" ) + ".db" );
	}
	viewmon	{
		match(txti15.get->to_i)	{
			1 => anmo2.setframe(1,1);
			10 => anmo2.setframe(1,2);
			11 => anmo2.setframe(1,3);
			? => anmo2.setframe(1,0);
		}
	}
	string cgetbound	{	.getbindigit(iledigram)->gete(0,iledigram);	}
	int gettxtint(int id)	{	<"txti"+id>.get->to_i->bin_to_i;	}
	int gettxtadr(int id)	{	<"txti" + .gettxtint(id)>.get->to_i->bin_to_i;	}
	mouse_move	{
		if( igmstate!=3 ) return;
		string s;
		match( Level2 )	{
			1,2,3,4 => { s = "grins"; scol.rgb = ( .black ); }
			5 => { s = "grram"; scol.rgb = ( .black ); }
			? => return;
		}
		if( <s>.isin(mouse.getpos,1,0) )	{
			.setcol(s);
			//fxpik2.play;
		} else .retcol;
	}
	retcol	{
		if( smoved!=null )	{
			<smoved>.createtxt( scol.rgb );
			smoved = null;
		}
	}
	setcol(string s)	{
		if( smoved!=null && smoved!=<s>.getsfound )	{
			<smoved>.createtxt( scol.rgb );
		}
		smoved = <s>.getsfound;
		<smoved>.createtxt( .red );
	}
	mouse_rclick	{
		if( igmdebug && (igmstate==1||igmstate==3))	{
			if( igmstate==1 )	{
				.cbplay("sndok");
				return;
			}
			match( Level2 )	{
				1 => .cbplay("sndok1");
				2 => .cbplay("sndok2");
				3 => .cbplay("sndok3");
				4 => .cbplay("sndok4");
				5 => .cbplay("sndok5");
				? => ;
			}
		}
	}
	mouse_lclick	{
		if( igmstate==11 )	.finito;
		else if( igmstate==10 )	{
			igmstate = 2;
			.nextzadl;
			return;
		} else if( igmstate!=4 )	.cactsndstop(true);
		if( igmstate!=3 ) return;
		string s = ( Level2 < 5 ) ? "grins" : "grram";
		@b = <s>.isin(mouse.getpos,1,0);
		if( b ) {
			igmstate = 2;
			.setcol(s);
			s = < <s>.getsfound >.get;
		}
		match( Level2 )	{
			1 => if( b )	{
				match(s)	{
					"01" => .cbplay("sndok1");
					"11" => .cbplay("sndnon1");
					? => .cbplay("sndnieokreslona");
				}
				fxpik.play;
			}
			2 => if (b)	{s=="001" ? .cbplay("sndok2") : .cbplay("sndnonall"); fxpik.play;}
			3 => if (b)	{s=="110" ? .cbplay("sndok3") : .cbplay("sndnonall"); fxpik.play;}
			4 => if (grins.getfound==2)	{.cbplay("sndok4");	fxpik.play;}
				else if (b) {	.cbplay("sndnonall");	fxpik.play;	}
			5 => if( grram.getfound==3 )	{
				//Level++;
				igmstate=2;
				.retcol;
				.cbplay("sndok5");
				fxpik.play;
				} else if (b) {	.cbplay("sndnoad");	fxpik.play;	}
			? => ;
		}
	}
	finito	{
		gameapi.play("Liczy");
	}
}

game Liczy : Komputro {
	init	{
		Komputro::init("liczy");
		.path = ("liczy");
		.bkg = ("bkg.pyz");
		.loadlekcja;
		.sfxs = (A, "mikrofala", "skok2", "type2 40", "brawo 40", "pik 60");
		tdlekcja.move(0,-5);
		new Buttons butst("strzalki.pyz");
		butst {
			<grbuts.get(0)>.addtogamevars("anst1");
			<grbuts.get(1)>.addtogamevars("anst2");
			<grbuts.get(2)>.addtogamevars("anexit");
			<grbuts.get(3)>.addtogamevars("andown");
			anst1.ansetbpos( 160, 600 - anst1.geth );
			anst2.ansetbpos( anst1.getex + 10, anst1.getpy );
			anexit.ansetbpos( 735, 24 );
			andown.ansetbpos( anst2.getex + 10, anst1.getpy );
			//andown.ansetbpos( 800 - andown.getw, 500 - andown.geth );
			grbuts.setz(180);
			.disable;
		};
		tdfunk.napisshow(652-tdfunk.getw/2, 270);
		tdfunk.setz(50);
		
		//new @stdfont = .stdfont(10);
		new @stdfont = .snewfont( "configs/fonts/normal.ttf", 12);
		.monofont("fnmon10", 10);
		new @stdfont14 = .snewfont( "configs/fonts/normal.ttf", 14);
		new TextDb tdfn(stdfont, 12, "funkcje.db", 10,10,192, 550,315, 5,50, "left");
		tdfn.hide;
		tdfn.view(A,0,1,2,3,4,5);
		
		new @Stron = 0;
		new @Strona = 0;
		.newtextposz("txtpage", "", stdfont14, 4,4,64, anst1.getex - 10, 600-anst1.geth-16, 150);
		//new TextDb tdopis(stdfont14, 12, "$var:dbpom", 4,4,64, 31,48, 5,150, "left");
		txtpage.hide;
		
		.sounds = (A,
			"sndintro", "W poprzedniej lekcji poznae podstawy jzyka asembler", func { .cbplay("snd1"); },
			"snd1", "Chocia mona napisa w nim kady program na dany procesor asembler wymaga zdecydowanie za duo pracy i wiedzy by w nim programowa", func { .cbplay("snd2"); },
			"snd2", "Do tworzenia programw uywane s jzyki wysokiego poziomu zrozumiae dla czowieka",
				func { .cbplay("snd3"); },
			"snd3", "W tej lekcji poznasz podstawy jzyka C; jest to ju wiekowy jzyk i rzadziej uywany jednak na jego przykadzie omwimy powizania jzykw wysokiego poziomu z asemblerem",
				func { .cbplay("snd4"); clp.showpob("tdhelp", "dd"); },
			"snd4", "Wykonaj zadanie napisane tutaj", func { .cbplay("snd5"); .cshowbut("rd"); },
			"snd5", "I kliknij tutaj aby sprawdzi czy wykonae je poprawnie", 
				func { .cbplay("snd6"); clp.showpob("txto1","rr"); },
			"snd6", "Wynik programu zobaczysz na monitorze; Zaczynamy",
				func { clp.stoph; igmstate = 1; ttk.enable;},
			"sndok", "Dobrze; kliknij aby przej dalej", "mnext",
			"sndnon", "Co nie tak", "mret",
			"sndfinito", "Doskonale! Ukoczye kurs podstaw jzyka C! Kliknij aby przej do kolejnej lekcji",
				func { igmstate = 6; }
			);
		
		new classplacepointer2 clp;
		new classsimplebutton cbok;
		cbok.build("scripts/common/butok.pyz", "imglobcurs", 546,525, 100, 0);
		new classsimplebutton cbhelp;
		cbhelp.build("scripts/common/help.pyz", "imglobcurs", 650,527, 100, 0);
		
		new string Code;
		Lexer::setas("Code");
		new db dbcode;
		Code.consts = (A,"int",";","(",")","float", "char","[","]","if","else", "while", "main","return","#include","<",".",">","{","}","=","/","*","+","-",",",":","&");
		
		//dbcode.dbaddstringrow(""," ");
		
		new @ifontsize = 10;
		.monofont("fnkod", ifontsize);
		new TextBoxTyper ttb("fnkod", ifontsize, 0.6*ifontsize, .black, "",
			290,78, 212,294, 2);
		new TextBoxTyper tth("fnkod", ifontsize, 0.6*ifontsize, .grey(64), "",
			290,78, 212,294, 2);
		ttb.setz(100);
		tth.setz(100);
		tth.hide;
		new TextBoxTyper ttk("fnkod", ifontsize, 0.6*ifontsize, .black, "at0; ,[](){}-+_/=#<>*.\"\\!?%:&",
			40,78, 212,294, 2);	//int x, int y, int w, int h, int dy)	{
		ttk.setz(100);
		new @HelpLevel = 0;
		new @LekcjaLevel = 0;
		
		new vector veccheck;
		new vector vecp1;
		new db dblek;
		new db dbasm;
		new @idlekcja = 0;
		
		.monofont("fnmon",12);
		//init(string sfont, int isize, int ir, int ig, int ib, string schars, int ilimit)	{
		new ConTextTyper ttp("fnmon", 12, .white, "at0; ,[](){}-+_/=#<>*.\"\\!?%:$&", 19);
		ttp.setpos(553, 60+ 1*14);
		ttp.onenter(GAME, func {
			txto2.txtset("Your name: " + ttp.get->strgetto(" ") );
			.cbplay("sndok");
			} );
		ttp.disable;
		new ConTextTyper ttp0("fnmon", 12, .white, "at0; ,[](){}-+_/=#<>*.\"\\!?%:$&", 19);
		ttp0.setpos(553, 60);
		ttp0.onenter(GAME, func {
			real r = ttp0.get;
			if( r<0 )	txto1.txtset("negative");
			else if (r>0)	txto1.txtset("positive");
			else 	txto1.txtset("zero");
			.cbplay("sndok");
			} );
		ttp0.disable;
		.newimgarray("grout", "text", "txto", 8);
		grout.each( func { (@id)
			.setfont("fnmon");
			.createtxt(.white);
			.setpos(553, 60+ id*14);
			} );
		
		new gfxSquare gsq(20,20,760,580);
		gsq.set(.grey(240), 240);
		gsq.build;
		gsq.setz(100);
		gsq.hide;
		
		.nextzad;
		ttk.disable;
		igmstate = 2;
		.cbplay("sndintro");
	}
	ttp0_ontype	{	fxtype2.play;	}
	ttp_ontype	{	fxtype2.play;	}
	mnext	{
		igmstate = 5;
	}
	ttk_boxontype	{	fxtype2.playif;	}
	showlekcja	{
		idlekcja = 0;
		dblek.load( .getgraphpath + "lekcja" + LekcjaLevel+".db" );
		dbasm.load( .getgraphpath + "asm" + LekcjaLevel + ".db");
		.deletegmobj("tdasm");
		new TextDb tdasm("fnmon10", 10, "$var:dbasm", .grey(48), 400,20, 1,150, "left");
		//tdasm.hide;
		.viewlekcja(0);
		butst.enable;
		gsq.show;
		
		Stron = 0;
		Strona = 0;
		for( int i=0; i<dblek.getrowsno; i++)	{
			if( dblek.get(i,0) =="---next---" )	Stron++;
		}
		txtpage.show;
		txtpage.txtset("" + (Strona+1) + "/"+(Stron+1));
	}
	mret	{
		igmstate = 1;
		ttk.enable;
	}
	setcode(int ile)	{
		ttb.settext(ile);
		ttb.show;
	}
	cbhelp_MOVEON	{
		sndakskermovon.play;
		if( HelpLevel>1 && igmstate==1 )	{
			ttb.hide;
			tth.show;
		}
	}
	cbhelp_MOVEOFF	{
		ttb.show;
		tth.hide;
	}
	cbok_CLICK	{
		if( igmstate!=1) return;
		igmstate = 2;
		if( .checkcode ) {
			ttk.disable;
			match(HelpLevel)	{
				1 => txto0.txtset("Hello World!");
				2 => txto0.txtset("Result: " + (10*(9-2)/3+1));
				3 => txto0.txtset("One hundred ten: 6e");
				4 => {	txto0.txtset("Net: 15.950000");
					txto1.txtset("After tax: 19.459000");
				}
				5 => {	txto0.txtset("Net: 15.95");
					txto1.txtset("After tax: 19.46");
				}
				6 => {
					txto0.txtset("Give name:");
					ttp.enable;
					return;
				}
				7 => { ttp0.enable; return; }
				8 => {
					for( int i=1; i<9; i++)	{
						<"txto"+(i-1)>.txtset("" + i +" : " + (i*i*i));
					}
					fxbrawo.play;
					.cbplay("sndfinito");
					return;
				}
				? => ;
			}
			.cbplay("sndok");
			fxmikrofala.play;
		}	else	{
			.cbplay("sndnon");
			fxskok2.play;
		}
	}
	bool checkcode	{
		veccheck.free;
		vecp1.free;
		int id = 0;
		while( id>=0 )	{
			id = ttk.nonempty(id);
			if( id >= 0 ) {veccheck.add(id); id++; }
		}
		if( veccheck.size==0 ) return false;	// brak kodu
		string s="";
		string s2;
		for( int i=0; i<veccheck.size; i++)	{
			s2 = ttk.getid( veccheck.get(i) );
			s2.clear;
			if( s2.getb(0,1)=="#" )	{
				Code.start( s2 );
				vecp1.add( Code.expectdb("dbcode", 1) );
				s = "";
			} else {
				s += s2;
			}
		}
		if( s.length>0 )	{
			Code.start( s );
			vecp1.add( Code.expectdb("dbcode", 1) );
		}
		if( vecp1.size != dbcode.getrowsno ) return false;
		for( i=0; i<vecp1.size; i++)	{	if( vecp1.get(i) != i ) return false;	}
		true;
	}
	viewhelp	{
		.deletegmobj("tdhelp");
		new TextDb tdhelp(stdfont, 12, "pomoc"+HelpLevel+".db", .blue, 36,412, 5,10, "left");
		HelpLevel++;
	}
	viewlekcja(int id)	{
		idlekcja += id;
		if( idlekcja<0 ) { idlekcja = 0; return; }
		new db dbpom;
		
		int page = 0, int row=0;
		while( idlekcja!=page )	{
			if( row < dblek.getrowsno )	{
				if( dblek.get(row,0) == "---next---" ) page++;
				row++;
			} else {
				page = idlekcja;
				row = -1;
			}
		}
		if( row==-1 ) {
			//tdasm.show;
			idlekcja-=id;
			delete dbpom;
			return;
		}
		Strona = page;
		txtpage.txtset("" + (Strona+1) + "/"+(Stron+1) );
		while( row< dblek.getrowsno && dblek.get(row,0) !="---next---" )	{
			_ = dbpom.addrow;
			dbpom.dbaddlast( dblek.get(row,0) );
			row++;
		}
		.deletegmobj("tdopis");
		new TextDb tdopis(stdfont14, 12, "$var:dbpom", 4,4,64, 31,48, 5,150, "left");
		tdopis.show;
		delete dbpom;
		//init(string sfont, int isize, string sdbfile, int r, int g, int b, int x, int y, int dy, int z, string sdir)	{
	}
	butst_moveon	{	sndakskermovon.play; if( sobject=="down" )	tdasm.move(0,-130);	}
	butst_moveoff	{	if( sobject=="down" )	tdasm.move(0,130);		}
	butst_lclick	{
		fxpik.play;
		match( sobject )	{
			"left"		=>	<GAME>.viewlekcja(-1);
			"right"	=>	<GAME>.viewlekcja(1);
			"exit"	=>	{ txtpage.hide; <GAME>.hidelekcja; }
			? => ;
		}
	}
	mouse_rclick	{
		if( igmdebug )	{
			igmstate = 5;
			.mouse_lclick;
		}
	}
	nextzad	{
		.viewhelp;
		grout.txtreset;
		ttp.txtset("");
		ttp0.txtset("");
		if( HelpLevel!=5 )	{
			dbcode.free;
			ttk.clear;
			tth.clear;
			ttb.clear;
		} else {
			dbcode.set(1, dbcode.dbfindinrow(1,"$literal")+1,
				"Net: %.2f\\nAfter tax: %.2f");
			ttb.setid(" printf(\"Net: ??\\nAfter tax: ??\",", 4);
			tth.setid(" printf(\"Net: %.2f\\nAfter tax: %.2f\",", 4);
		}
		ttk.enable;
		ttk.activate(0);
		igmstate = 1;
		match( HelpLevel )	{
			1 => {
				.setcode(	"#include <stdio.h>",
					"int main() {",
					"   printf(\"Hello World!\\n\");",
					"   return 0;",
					"}",
					5);
				dbcode.dbaddstringrow("#include < $alpha stdio . $alpha h >"," ");
				dbcode.dbaddstringrow("int|main|(|)|{|$alpha|printf|(|$literal|Hello World!\\n|)|;|return|$int|0|;|}","|");
			}
			2 => {
				.setcode("#include <??.h>",
					"int ??() {",
					" int result = ?? ;",
					" ??f(\"Result: %d\\n\", result);",
					" return 0;",
					"}",
					6);
				tth.settext("#include <stdio.h>",
					"int main() {",
					" int result = 10*(9-2)/3+1;",
					" printf(\"Result: %d\\n\", result);",
					" return 0;",
					"}",
					6);
				dbcode.dbaddstringrow("#include < $alpha stdio . $alpha h >"," ");
				dbcode.dbaddstringrow("int|main|(|)|{|int|$alpha|result|=|$int|10|*|(|$int|9|-|$int|2|)|/|$int|3|+|$int|1|;|$alpha|printf|(|$literal|Result: %d\\n|,|$alpha|result|)|;|return|$int|0|;|}","|");
			}
			3 => {
				.setcode("#?? <??.h>",
					"int ?? ??",
					" ??(\"One hundred ten: ??\\n\",??);",
					" return 0;",
					"??",
					5);
				tth.settext("#include <stdio.h>",
					"int main() {",
					" printf(\"One hundred ten: %x\\n\",",
					"       110);",
					" return 0;",
					"}",
					6);
				dbcode.dbaddstringrow("#include < $alpha stdio . $alpha h >"," ");
				dbcode.dbaddstringrow("int|main|(|)|{|$alpha|printf|(|$literal|One hundred ten: %x\\n|,|$int|110|)|;|return|$int|0|;|}","|");
			}
			4 => {
				.setcode("#??",
					"int ??",
					" float net = 15.95;",
					" float aftax = ?? * net;",
					" printf(\"Net: %f\\nAfter tax: %f\",",
					"       net, aftax);",
					" return 0;",
					"??",
					8);
				tth.settext("#include <stdio.h>",
					"int main() {",
					" float net = 15.95;",
					" float aftax = 1.22 * net;",
					" printf(\"Net: %f\\nAfter tax: %f\",",
					"       net, aftax);",
					" return 0;",
					"}",
					8);
				dbcode.dbaddstringrow("#include < $alpha stdio . $alpha h >"," ");
				dbcode.dbaddstringrow("int|main|(|)|{|float|$alpha|net|=|$real|15.95|;|float|$alpha|aftax|=|$real|1.22|*|$alpha|net|;|$alpha|printf|(|$literal|Net: %f\\nAfter tax: %f|,|$alpha|net|,|$alpha|aftax|)|;|return|$int|0|;|}","|");
			}
			6 => {
				.setcode("#??",
					"int ??",
					"  char name[20];",
					"  printf(\"Give name:\\n\");",
					"  scanf(\"%s\", name);",
					"  printf(\"Your name: %s\\n\", ??);",
					"  return 0;",
					"??",
					8);
				tth.settext("#include <stdio.h>",
					"int main() {",
					"  char name[20];",
					"  printf(\"Give name:\\n\");",
					"  scanf(\"%s\", name);",
					"  printf(\"Your name: %s\\n\", name);",
					"  return 0;",
					"}",
					8);
				dbcode.dbaddstringrow("#include < $alpha stdio . $alpha h >"," ");
				dbcode.dbaddstringrow("int|main|(|)|{|char|$alpha|name|[|$int|20|]|;|$alpha|printf|(|$literal|Give name:\\n|)|;|$alpha|scanf|(|$literal|%s|,|$alpha|name|)|;|$alpha|printf|(|$literal|Your name: %s\\n|,|$alpha|name|)|;|return|$int|0|;|}","|");
			}
			7 => {
				tth.settext("#include <stdio.h>",
					"int main() {",
					"  float number;",
					"  scanf(\"%f\", &number);",
					"  if( number<0 ) {",
					"    printf(\"negative\");",
					"  } else if( number>0 ) {",
					"    printf(\"positive\");",
					"  } else {",
					"    printf(\"zero\");",
					"  }",
					"  return 0;",
					"}",
					13);
				.setcode("??",
					"??",
					"  float number;",
					"  scanf(\"%f\", &??);",
					"  if( ??<0 ) {",
					"    printf(\"negative\");",
					"  } else if( ?? ) {",
					"    printf(\"positive\");",
					"  } else {",
					"    ??",
					"  }",
					"  return 0;",
					"??",
					13);
				dbcode.dbaddstringrow("#include < $alpha stdio . $alpha h >"," ");
				dbcode.dbaddstringrow("int|main|(|)|{|float|$alpha|number|;|$alpha|scanf|(|$literal|%f|,|&|$alpha|number|)|;|if|(|$alpha|number|<|$int|0|)|{|$alpha|printf|(|$literal|negative|)|;|}|else|if|(|$alpha|number|>|$int|0|)|{|$alpha|printf|(|$literal|positive|)|;|}|else|{|$alpha|printf|(|$literal|zero|)|;|}|return|$int|0|;|}","|");
			}
			8 => {
				tth.settext("#include <stdio.h>",
					"int pow3(int n) {",
					"  return n*n*n;",
					"}",
					"int main() {",
					"  int i = 1;",
					"  while( i < 9 ) {",
					"    printf(\"%d : %d\\n\", i, pow3(i));",
					"    i = i + 1;",
					"  }",
					"  return 0;",
					"}",
					12);
				.setcode("??",
					"int pow3(int n) {",
					"  return ??;",
					"}",
					"int main??",
					"  int i = ??;",
					"  while( ?? < ?? ) {",
					"    printf(\"?? : ??\\n\", ??, ?? );",
					"    i = ??;",
					"  }",
					"  return 0;",
					"}",
					12);
				dbcode.dbaddstringrow("#include < $alpha stdio . $alpha h >"," ");
				//dbcode.dbaddstringrow("int|$alpha|pow3|(|int|$alpha|n|)|{|return|$alpha|n|*|$alpha|n|*|$alpha|n|;|}|int|main|(|)|{|int|$alpha|i|=|$int|1|;|while|(|$alpha|i|<|$int|9|)|{|$alpha|printf|(|$literal|%d : %d\\n|,|$alpha|i|,|$alpha|pow3|(|$alpha|i|)|)|;|$alpha|i|=|$alpha|i|+|$int|1|;|}|return|$int|0|;|}","|");
				dbcode.dbaddrow(A,
					"int", "$alpha", "pow3", "(", "int", "$alpha", "n" , ")", "{",
						"return", "$alpha", "n", "*", "$alpha", "n", "*", "$alpha", "n", ";",
					"}",
					"int", "main", "(", ")", "{",
						"int", "$alpha", "i", "=", "$int", "1", ";",
						"while", "(", "$alpha", "i", "<", "$int", "9", ")", "{",
							"$alpha", "printf", "(", "$literal", "%d : %d\\n", ",", "$alpha", "i", ",",
								"$alpha", "pow3", "(", "$alpha", "i", ")", ")",";",
							"$alpha", "i", "=", "$alpha", "i", "+", "$int", "1", ";",
						"}",
						"return", "$int", "0", ";",
					"}" );
			}
			? => ;
		}
	}
	hidelekcja	{
		.deletegmobj("tdopis");
		.deletegmobj("tdasm");
		butst.disable;
		gsq.hide;
		LekcjaLevel++;
		match( LekcjaLevel )	{
			1,2,3 => .nextzad;
			? => ;
		}
	}
	mouse_lclick	{
		if( igmstate==5)	{
			igmstate = 2;
			match(HelpLevel)	{
				1, 2, 6 => .showlekcja;
				3, 4, 7 => .nextzad;
				5 => { tdfn.show; .nextzad; }
				? => ;
			}
			return;
		} else if (igmstate==6)	{
			.mfinito;
			return;
		}
		.cactsndstop(true);
	}
	mfinito	{
		gameapi.play("Robot");
	}
}

game Robot : Komputro {
	init	{
		Komputro::init("robot");
		.path = ("robot");
		.bkg = ("bkg.pyz");
		.loadlekcja;
		tdlekcja.move(0,-5);
		
		.sfxs = (A, "robocik", "goto 70", "bada 50", "pik", "komputer 50", "bum 30", "brawo 50" );
		
		.imgs = (A, "robo.pyz 10");
		.copyanima("anrobo", "anl");
		anl.setframe("left",0);
		anl.anloopfin;
		.copyanima("anrobo", "anr");
		anr.setframe("right",0);
		anr.anloopfin;
		.copyanima("anrobo", "anczek");
		anczek.setframe("left",0);
		anczek.hide;
		anczek.anhidefin;
		new @itafle = 8;
		int j, string s, int itaf=itafle-1;
		for( int i=0; i<itafle; i++)	{
			for( j=0; j<itafle; j++)	{
				s = "imgt"+i+"_"+j;
				new img <s>;
				if( i==0 || j==0 || i==itaf || j==itaf)	<s>.create(53, 53, .mblue, 255);
				else	<s>.create(53, 53, .white, 255);
				<s>.setpos( 10 + j*56, 10 + i*56 );
			}
		}
		anrobo.vars(A, "row", "col", "destr", "destc");
		anrobo.destpos(3,1);
		.robpos(3, 1);
		
		new classsimplebutton cbok;
		cbok.build("scripts/common/butok.pyz", "imglobcurs", 546,525, 100, 0);
		new classsimplebutton cbhelp;
		cbhelp.build("scripts/common/help.pyz", "imglobcurs", 650,527, 100, 0);
		
		new gfxSquare gsq(50,30,700,500);
		gsq.set(.grey(40), 240);
		gsq.build;
		gsq.setz(500);
		gsq.hide;
		
		new db dbzad;
		new db dbopis;
		new vector veckod;
		veckod.type("string");
		new vector vec1;
		vec1.type("string");
		new vector vecid;
		new vector vecid2;
		new @idinstr = 0;
		
		new @Level = 0;
		new @stdfont14 = .snewfont( "configs/fonts/normal.ttf", 14);
		new @stdfont12 = .snewfont( "configs/fonts/normal.ttf", 12);
		new @bzobacz=true;
		new @ijumpto = -1;
		new @bendhelp = false;
		new @bisels = false;
		new @bwlaczony = false;
		new @snazwa = null;
		new @swartosc = null;
		
		.sounds = (A,
			"sndintro", "Przed nami kolejna lekcja: podstawy programowania obiektowego; opis ktry za chwil zobaczysz bdziesz mg przywrci klikajc przycisk Help",
				func { <GAME>{ .buildopis; .viewopis; igmstate = 5; }; },
			"sndwrong", "Nieprawidowa konstrukcja", "mret",
			"sndint", "Przerwane wykonanie programu", "mret2",
			"sndbrzeg", "Bd Robot wszed na brzeg podogi", "mret2",
			"sndklik", "Zaprogramuj zadanie jeszcze raz", "mret",
			"sndbaddir", "Niepoprawnie podany kierunek do metody go", "mret2",
			"sndok", "Zadanie wykonane poprawnie; kliknij aby przej dalej", "mnext",
			"sndnon", "Niestety program zadziaa niepoprawnie; popraw bdy i uruchom ponownie", "mret",
			"sndred", "Alarm! Robot wszed na zabroniony teren" , "mret2",
			"sndbad", "Uyj konstrukcji wymaganej przez tre zadania", "mret2",
			"sndbrak", "Bd; Odwoae si do nieistniejcego obiektu", "mret2",
			"sndzlazm", "Niepoprawna nazwa obiektu", "mret2",
			"sndend", "Doskonale! Wszystkie zadania wykonane", "mend"
		);
		sndok.addmethod("onstart", func { fxkomputer.play; } );
		
		new @ifontsize = 10;
		.monofont("fnkod", ifontsize);
		new TextBoxTyper ttb("fnkod", ifontsize, 0.6*ifontsize, 20,20,120, "",
			520,295, 262,222, 2);
		new img imgerror {
			.create(262,ifontsize,.red,128);
			.setz(0);
			.hide;
		};
		new img imggo {
			.create(262,ifontsize, 250,250,10, 128);
			.setz(0);
			.hide;
		};
		new TextBoxTyper tth("fnkod", ifontsize, 0.6*ifontsize, .grey(64), "",
			520,295, 262,222, 2);
		ttb.setz(100);
		tth.setz(100);
		tth.hide;
		new TextBoxTyper ttk("fnkod", ifontsize, 0.6*ifontsize, .black, "at0; ,[](){}-+_/=#<>*.\"\\!?%:&",
			520,76, 262,222, 2);	//int x, int y, int w, int h, int dy)	{
		ttk.setz(100);
		
		new string Code;
		Lexer::setas("Code");
		new db dbcode;
		Code.consts = (A,"robot","(",")","if","else", "while","end", "<",".",">","==","!=", "/","*","+","-",",", "go", "check", "=", "seton", "control", "string", "null");
		dbcode.dbaddstringrow("robot . go ( $literal )"," ");							// 0
		
		.timer = ("timrob", 1000, "finrob");
		
		.cbplay("sndintro");
	}
	mblue	{	return 120,160,255;	}
	destpos(int r, int c)	{	destr=r; destc=c;	}
	recreate	{
		int j, string s, int itaf=itafle-1;
		for( int i=0; i<itafle; i++)	{
			for( j=0; j<itafle; j++)	{
				s = "imgt"+i+"_"+j;
				if( i==0 || j==0 || i==itaf || j==itaf)	<s>.create(53, 53, .mblue, 255);
				else	<s>.create(53, 53, .white, 255);
			}
		}
	}
	msetcol(int i, int j, int r, int g, int b)	{
		<"imgt"+i+"_"+j>.create(53, 53, r,g,b,255);
	}
	setcol(int i, int j, int r, int g, int b)	{
		string s = "imgt"+i+"_"+j;
		<s>.create(53, 53, r,g,b,255);
		<s>.setpos( 10 + j*56, 10 + i*56 );
	}
	miscol(int i, int j, int r, int g, int b)	{
		int r[3];
		|r0,r1,r2,_| = <"imgt"+i+"_"+j>.angetcrgba;
		r==r0 && g==r1 && b==r2;
	}
	setrobpos(int x, int y)	{
		anrobo.ansetbpos(x,y);
		anl.setpos( anrobo.getpos );
		anr.setpos( anrobo.getpos );
	}
	robpos(int i, int j)	{
		anrobo.row = (i);
		anrobo.col = (j);
		|i,j| = <"imgt"+i+"_"+j>.getpos;
		.setrobpos( i + (53-anrobo.getw)/2, j+40-anrobo.geth );
	}
	buildopis	{
		dbopis.load( .getgraphpath + "opis" + Level + ".db");
		.deletegmobj("tdopis");
		new TextDb tdopis(stdfont14, 10, "$var:dbopis", .grey(200), 65,35, 4, 550, "left");
		tdopis.hide;
	}
	mretpos	{
		@r = anrobo.destr;
		if( r==-1 ) r = (itafle-1)->rand + 1;
		@c = anrobo.destc;
		if( c==-1 ) c = (itafle-1)->rand + 1;
		.robpos( r, c );
	}
	mret	{
		.mretpos;
		imgerror.hide;
		igmstate = 1;
		ttk.enable;
	}
	mret2	{	igmstate = 3; .cbplay("sndklik");	}
	mstart	{
		ttk.clear;
		tth.clear;
		ttb.clear;
		ttk.enable;
		igmstate = 1;
		match(Level)	{
			0 => {tth.settext("robot.go(\"right\")",
					"robot.go(\"right\")",
					"robot.go(\"right\")",
					"robot.go(\"right\")",
					"robot.go(\"right\")",
					5);
				ttb.settext("robot.go(\"??\")",
					"robot.go(\"??\")",
					"robot.??",
					"??",
					"??",
					5);
			}
			1 => {
				anrobo.destpos(4,1);
				.mretpos;
				.msetcol(4,3,.red);
				.msetcol(3,4, .red);
			}
			2 => {
				anrobo.destpos(1,1);
				.mretpos;
				.msetcol(1,2,.red);
				.msetcol(2,2,.red);
				.msetcol(2,3,.red);
				.msetcol(4,1,.red);
				.msetcol(6,4,.red);
				.msetcol(5,5,.red);
				.msetcol(4,6,.red);
			}
			3 => {
				dbcode.dbaddstringrow("while robot . control . check ( $literal ) != $literal", " ");		// 1
				dbcode.dbaddstringrow("while robot . control . check ( $literal ) == $literal", " ");	// 2
				dbcode.dbaddstringrow("end", " ");											// 3
				dbcode.dbaddstringrow("robot . control . seton ( )"," ");							// 4
				anrobo.destpos(1,3);
				.mretpos;
				.recreate;
				tth.settext(
					"robot.control.seton()",
					"while robot.control.check(\"down\")!=\"blue\"",
					"   robot.go(\"down\")",
					"end",
					"--------- or --------",
					"robot.control.seton()",
					"while robot.control.check(\"down\")==\"white\"",
					"   robot.go(\"down\")",
					"end",
					9);
				ttb.settext(
					"robot.control.???",
					"while robot.control.check(\"??\") ?? ??",
					"   robot.go(\"down\")",
					"end",
					4);
			}
			4 => {
				anrobo.destpos( itafle-2, itafle-2);
				.mretpos;
				tth.settext(
					"robot.control.seton()",
					"while robot.control.check(\"left\")==\"white\"",
					"   robot.go(\"left\")",
					"   robot.go(\"up\")",
					"end",
					"--------- or --------",
					"robot.control.seton()",
					"while robot.control.check(\"left\")!=\"blue\"",
					"   robot.go(\"left\")",
					"   robot.go(\"up\")",
					"end",
					11);
				ttb.settext(
					"robot.control.???",
					"while ???",
					"  ???",
					"  ???",
					"end",
					5);
			}
			5 => {
				dbcode.dbaddstringrow("if robot . control . check ( $literal ) != $literal", " ");		// 5
				dbcode.dbaddstringrow("if robot . control . check ( $literal ) == $literal", " ");	// 6
				dbcode.dbaddstringrow("else", " ");											// 7
				anrobo.destpos( itafle-2, 3);
				.mretpos;
				.msetcol(4,3,.red);
				.msetcol(2,2,.red);
				.msetcol(2,4,.red);
				tth.settext(
					"robot.control.seton()",
					"while robot.control.check(\"up\")!=\"blue\"",
					"   if robot.control.check(\"up\")==\"red\"",
					"      robot.go(\"right\")",
					"   else",
					"      robot.go(\"up\")",
					"   end",
					"end",
					"--------- or --------",
					"robot.control.seton()",
					"while robot.control.check(\"up\")!=\"blue\"",
					"   if robot.control.check(\"up\")!=\"red\"",
					"      robot.go(\"up\")",
					"   else",
					"      robot.go(\"left\")",
					"   end",
					"end",
					17);
				ttb.settext(
					"??",
					"while ??",
					"   if robot.control.check(??) ???",
					"      robot.go(??)",
					"   else",
					"      robot.go(??)",
					"   end",
					"end",
					8);
			}
			6 => {
				dbcode.dbaddstringrow("while robot . control . check ( $alpha ) != $literal", " ");		// 8
				dbcode.dbaddstringrow("while robot . control . check ( $alpha ) == $literal", " ");	// 9
				dbcode.dbaddstringrow("robot . go ( $alpha )"," ");							// 10
				dbcode.dbaddstringrow("string $alpha"," ");							// 11
				dbcode.dbaddstringrow("$alpha = $literal"," ");							// 12
				.recreate;
				anrobo.destpos( 4, (2->rand ? 1 : itafle-2));
				.mretpos;
				tth.settext(
					"robot.control.seton()",
					"string dir",
					"if robot.control.check(\"left\")==\"blue\"",
					"  dir = \"right\"",
					"else",
					"  dir = \"left\"",
					"end",
					"while robot.control.check(dir)!=\"blue\"",
					"  robot.go(dir)",
					"end",
					10 );
				ttb.settext(
					"robot.???",
					"string ??",
					"if robot.control.check(??) ???",
					"  ?? = ??",
					"else",
					"  ?? = ??",
					"end",
					"while robot.control.check(??) ???",
					"  ???",
					"end",
					10 );
			}
			? => ;
		}
	}
	viewzad	{
		dbzad.load( .getgraphpath + "zad" + Level + ".db");
		.deletegmobj("tdzad");
		new TextDb tdzad(stdfont12, 10, "$var:dbzad", .grey(20), 30,480, 4,150, "left");
		if( Level==0 )	{
			tduw1.napisshow(513, 446);
			tduw2.napisshow(513, 461);
			tduw3.napisshow(513, 476);
		} else {
			.with(A, "tduw1", "tduw2", "tduw3", "hide");
		}
	}
	mnext	{
		<GAME> {
			Level++;
			match(Level)	{
				1,2,4 => bzobacz = false;
				? => {
					.buildopis;
					.viewopis;
					bzobacz = true;
				}
			}
			igmstate = 5;
		};
	}
	viewopis	{
		gsq.show;
		tdopis.show;
	}
	hideopis	{
		gsq.hide;
		tdopis.hide;
	}
	cbhelp_CLICK	{
		if( igmstate==1 /*&& bzobacz*/)	{
			igmstate = 10;
			.viewopis;
		}
	}
	cbhelp_MOVEON	{
		sndakskermovon.play;
		if( igmstate==1 )	{
			ttb.hide;
			tth.show;
		}
	}
	cbhelp_MOVEOFF	{
		ttb.show;
		tth.hide;
	}
	wronginstr(int k)	{
		imgerror.show;
		imgerror.setpos( 520, 76+k*(ifontsize+2) );
	}
	cbok_CLICK	{
		if( igmstate!=1 ) return;
		igmstate = 2;
		idinstr = 0;
		ijumpto = -1;
		bendhelp = false;
		bisels = false;
		bwlaczony = false;
		snazwa = null;
		swartosc = null;
		string s, int j;
		veckod.free;
		vecid.free;
		vecid2.free;
		ttk.disable;
		for( int i=0; i < ttk.Rows; i++)	{
			s = ttk.getid(i);
			s.clear;
			if( s.length>0 )	{
				veckod.add( s );
				Code = s;
				j = Code.expectdb("dbcode", 0);
				vecid.add( j );
				vecid2.add( i );
				if( j<0 )	{
					.wronginstr(i);
					igmstate = 3;
					.cbplay("sndwrong");
					return;
				}
			}
		}
		if( vecid.empty )	{	.mret;	return; }
		match( Level )	{
			3 => {
				if( !( vecid.veceq2(A,4,1,0,3) || vecid.veceq2(A,4,2,0,3) ) )	{
					igmstate = 3;
					.cbplay("sndbad");
					return;
				}
			}
			4 => {
				if( !( vecid.veceq2(A,4,1,0,0,3) || vecid.veceq2(A,4,2,0,0,3) ) )	{
					igmstate = 3;
					.cbplay("sndbad");
					return;
				}
			}
			5 => {
				if( !( vecid.veceq2(A,4,1,5,0,7,0,3,3) || vecid.veceq2(A,4,1,6,0,7,0,3,3) ) )	{
					igmstate = 3;
					.cbplay("sndbad");
					return;
				}
			}
			6 => {
				if( ! ( vecid.veceq2(A,4, 11,6,12,7,12,3, 8,10,3) ||
					vecid.veceq2(A,4, 11,5,12,7,12,3, 8,10,3) ||
					vecid.veceq2(A,4, 11,6,12,7,12,3, 9,10,3) ||
					vecid.veceq2(A,4, 11,5,12,7,12,3, 9,10,3) ) )	{
					igmstate = 3;
					.cbplay("sndbad");
					return;
				}
			}
			? => ;
		}
		fxrobocik.play;
		timrob.play;
	}
	robgo(int ir, int ic)	{
		fxgoto.play;
		ir += anrobo.row;
		ic += anrobo.col;
		int itaf = itafle-1;
		.robpos(ir, ic);
		if( ir==0 || ir==itaf || ic==0 || ic==itaf )	{
			igmstate = 3;
			fxbum.play;
			.cbplay("sndbrzeg");
		} else if ( .miscol(ir, ic, .red) )	{
			igmstate = 3;
			fxbum.play;
			.cbplay("sndred");
		} else {
			idinstr++;
			timrob.play;
		}
	}
	finrob	{
		if( idinstr==vecid.size )	{
			imggo.hide;
			igmstate = 3;
			match( Level )	{
				0, 1, 2 => .cbplay( anrobo.col==itafle-2 ? "sndok" : "sndnon" );
				3 => .cbplay( anrobo.row==itafle-2 ? "sndok" : "sndnon" );
				4 => .cbplay( (anrobo.row==1&&anrobo.col==1) ? "sndok" : "sndnon" );
				5 => .cbplay( anrobo.row==1 ? "sndok" : "sndnon" );
				6 => {
					if( (anrobo.destc==1 && anrobo.col==itafle-2) ||
						(anrobo.destc==itafle-2 && anrobo.col==1) ) {
							fxbrawo.play;
							.cbplay("sndend");
					} else .cbplay("sndnon");
				}
				? => ;
			}
			return;
		}
		Code = veckod.get( idinstr );
		imggo.show;
		imggo.setpos( 520, 76 + vecid2.get( idinstr ) * (ifontsize+2) );
		fxpik.play;
		Code.id = (0);
		Code.gettoken( "vec1", 1 ) ;
		string s;
		match( vecid.get( idinstr ) )	{
			0, 10 => {
				if( vec1.get(4)=="$alpha" )	{
					if( snazwa==vec1.get(5) )	{
						s = swartosc;
					} else {
						igmstate = 3;
						.cbplay("sndbrak");
						return;
					}
				} else s = vec1.get(5);
				match( s ) {
					"up"		=>	.robgo(-1,0);
					"right"	=>	.robgo(0,1);
					"down"	=>	.robgo(1,0);
					"left"		=>	.robgo(0,-1);
					? => { igmstate=3; .cbplay("sndbaddir"); }
				}
			}
			1, 2, 8, 9 => if( .misdir2( vec1.get(7), vec1.get(8) ) )	{
					s = ( vec1.get(7)=="$alpha" ? swartosc : vec1.get(8) );
					@b1 = .miscol2( s, vec1.get(12) );
					@b2 = vecid.get( idinstr );
					if( ((b2==1||b2==8)&&!b1) || ((b2==2||b2==9)&&b1) )	{
						ijumpto = idinstr;
						idinstr++;
						timrob.play;
					} else {
						ijumpto=-1;
						.mtoend;
						timrob.play;
					}
				}
			3 =>	{
				if( bendhelp ) { idinstr++; bendhelp=false; }
				else if (ijumpto!=-1) idinstr=ijumpto;	// end while
				else idinstr++;
				timrob.play;
				}
			4 => { idinstr++; bwlaczony=true; timrob.play;	}
			5, 6 => if( .misdir( vec1.get(8) ) )	{
					@b1 = .miscol2( vec1.get(8), vec1.get(12) );
					@b2 = vecid.get( idinstr );
					bendhelp = true;
					if( (b2==5&&!b1) || (b2==6&&b1) )	{
						idinstr++;
						bisels = false;
						timrob.play;
					} else {
						.mtoelse;
						bisels = true;
						timrob.play;
					}
				} else {
					igmstate = 3;
					.cbplay("sndbaddir");
				}
			7 => { if( bisels ) idinstr++; else .mtoend; timrob.play; }
			11 => {
				Code = vec1.get(2);
				Code.id = (0);
				if( Code.isident ) {	snazwa = Code; idinstr++; timrob.play; }
				else {	igmstate = 3;	.cbplay("sndzlazm");	}
			}
			12 => {
				Code = vec1.get(1);
				Code.id = (0);
				if( Code.isident ) {
					if( snazwa==Code ) {
						swartosc = vec1.get(4);
						idinstr++;
						timrob.play;
					} else {
						igmstate = 3;
						.cbplay("sndbrak");
					}
				} else	{	igmstate = 3;	.cbplay("sndzlazm");	}
			}
			? => ;
		}
	}
	miscol3(int r, int c, string scol)	{
		int x[2];
		|x0,x1| = <"imgt"+r+"_"+c>.angetcpos;
		anczek.ansetbpos( x0-anczek.getw/2, x1-anczek.geth/2 );
		fxbada.play;
		anczek.play(-1);
		match(scol)	{
			"white"	=> .miscol(r,c,.white);
			"blue"	=> .miscol(r,c,.mblue);
			"red"		=> .miscol(r,c,.red);
			?		=> false;
		}
	}
	miscol2(string sdir, string scol)	{
		@r = anrobo.row;
		@c = anrobo.col;
		match( sdir ) {
			"up"		=>	.miscol3( r-1, c, scol);
			"right"	=>	.miscol3( r, c+1, scol);
			"down"	=>	.miscol3( r+1, c, scol);
			"left"		=>	.miscol3( r, c-1, scol);
			? => ;
		}
	}
	mtoend	{
		@id = vecid.get(idinstr)==7 ? 1 : 0;
		@b = true;
		while( b ) {
			match ( vecid.get(idinstr) )	{
				3 => { id--; if( id==0 ) return; else idinstr++; }
				1,2,5,6,8,9 => { id++; idinstr++; }
				? => idinstr++;
			}
		}
	}
	mtoelse	{	.mtoid(7);	}
	mtoid(int id)	{
		while( vecid.get(idinstr) != id ) idinstr++;
	}
	misdir(string s)	{	s.in(A, "up", "right", "down", "left");	}
	mplaybaddir	{	igmstate = 3;	.cbplay("sndbaddir");	}
	bool misdir2(string s1, string s2)	{
		if( s1=="$alpha" )	{
			if( snazwa==s2 )	{
				if( .misdir(swartosc) ) return true;
				.mplaybaddir;
				return false;
			} else {
				igmstate = 3;
				.cbplay("sndbrak");
				return false;
			}
		} else {
			if( .misdir(s2) ) return true;
			.mplaybaddir;
			return false;
		}
	}
	mend	{
		Level++;
		igmstate = 20;
		.buildopis;
		.viewopis;
		bzobacz = true;
	}
	mouse_rclick	{
		if( igmdebug && igmstate==1 )	{
			igmstate = 3;
			.cbplay("sndok");
		}
	}
	mouse_lclick	{
		match( igmstate )	{
			5 => {
				.hideopis;
				.viewzad;
				.mstart;
				}
			2 => { timrob.stop(false); imggo.hide; igmstate = 3; .cbplay("sndint"); }
			10 => { igmstate = 1; .hideopis; }
			20 => gameapi.play("Grafika");
			? => .cactsndstop(true);
		}
	}
}

game Grafika : Komputro {
	init	{
		Komputro::init("grafika");
		.path = ("grafika");
		.loadlekcja;
		.imgs = (A, "bkg.pyz", "obraz.pyz 10");
		.sfxs = (A, "pedzel", "pik", "brawo 50", "mikrofala", "error 40");
		anobraz.clones=(A, "anramka", "anr2", "anr1", "ang2", "ang1", "anb2", "anb1");
		anramka.setframe(0,1);
		anr1.setframe(1,0);		anr2.setframe(1,1);		ang1.setframe(1,0);
		ang2.setframe(1,1);		anb1.setframe(1,0);		anb2.setframe(1,1);
		@h = anr2.geth + 5;
		ang1.move(0, h);	ang2.move(0, h);
		anb1.move(0, 2*h);	anb2.move(0, 2*h);
		.mimage("r");
		.mimage("g");
		.mimage("b");
		
		.sounds_from(A,
			"sndwrong", /* "Nieprawidowa konstrukcja",*/ "mret",
			"sndint", /*"Przerwane wykonanie programu",*/ "mret2",
			"sndklik", /*"Zaprogramuj zadanie jeszcze raz",*/ "mret",
			"sndok", /*"Zadanie wykonane poprawnie; kliknij aby przej dalej",*/ "startzad",
			"sndnon", /*"Niestety program zadziaa niepoprawnie; popraw bdy i uruchom ponownie",*/ "mret",
			"sndbad", /*"Uyj konstrukcji wymaganej przez tre zadania",*/ "mret2",
			"sndbrak", /*"Bd; Odwoae si do nieistniejcego obiektu",*/ "mret2",
			"sndzlazm", /*"Niepoprawna nazwa obiektu",*/ "mret2",
			"sndend", /*"Doskonale! Wszystkie zadania wykonane",*/ "mend",
			"robot" );
		@serror = func { fxerror.play; };
		@sok = func { fxmikrofala.play; };
		sndok.addmethod("onstart", sok );
		sndnon.addmethod("onstart", serror );
		sndwrong.addmethod("onstart", serror );
		sndint.addmethod("onstart", serror );
		sndbad.addmethod("onstart", serror );
		sndbrak.addmethod("onstart", serror );
		sndzlazm.addmethod("onstart", serror );
		.sounds = (A,
			"sndbadval", "Dozwolone wartoci to zero i jeden", "mret2",
			"sndpoza", "Piksel spoza zakresu!", "mret2",
			"sndzip", "wietnie; przed nami ostatnia czc lekcji kompresja obrazw", "startzad",
			"sndfinito", "Wspaniale! Policja w caym kraju ma ju portret pamiciowy gangstera a my przechodzimy do kolejnej lekcji",
				"mfinito",
			"sndnorle", "Niestety obrazek nie jest skompresowany poprawnie; prbuj dalej", func { tdrle.enable; }
			);
		sndzip.addmethod("onstart", sok );
		sndzip.addmethod("onstart", func { fxbrawo.play; } );
		sndbadval.addmethod("onstart", serror );
		sndpoza.addmethod("onstart", serror );
		sndnorle.addmethod("onstart", serror );
		new map2 mapv("string");
		new stack st1("string");
		new vector veccol;
		new vector veckod;
		veckod.type("string");
		new vector vec1;
		vec1.type("string");
		new vector vecid;
		new vector vecid2;
		new @idinstr = 0;
		new @Level = 0;
		new @HelpLevel = 0;
		new @itafle = 10;
		new @H = 26;
		@dh = 1;
		new @NoVar = false;
		@x = 8;
		int i, int j, string s;
		new gmimgvec grtaf;
		new @ifontsize = 10;
		.monofont("fnkod", ifontsize);
		new @stdfont10 = .snewfont( "configs/fonts/normal.ttf", 10);
		new @stdfont14 = .snewfont( "configs/fonts/normal.ttf", 14);
		new @stdfont12 = .snewfont( "configs/fonts/normal.ttf", 12);
		new img imgtlo(H, dh, x)	{
			(@h, @dh, @x)
			.setpos( x - dh, 40 - dh );
			h = (h+dh)*itafle + 1;
			.create( h, h, .black, 255 );
		};
		for( i=0; i<itafle; i++)	{
			for( j=0; j<itafle; j++)	{
				s = "img"+i+"_"+j;
				new img <s>;
				<s>.create( H, H, .white, 255 );
				<s>.setpos( j*(H+dh) + x, i*(H+dh) + 40 );
				grtaf.add(s);
				s = "txt"+i+"_"+j;
				new text <s>;
				<s>.setfont( stdfont10 );
				<s>.set( "["+i+","+j+"]" );
				<s>.createtxt( 142, 120, 222 );
				<s>.setpos(  j*(H+dh) + x, i*(H+dh) + 42 );
			}
		}
		new gfxSquare gsq(50,30,700,500);
		gsq.set( 20,60,50, 240);
		gsq.build;
		gsq.setz(500);
		gsq.hide;
		
		new classsimplebutton cbok;
		cbok.build("scripts/common/butok.pyz", "imglobcurs", 546,525, 100, 0);
		new classsimplebutton cbhelp;
		cbhelp.build("scripts/common/help.pyz", "imglobcurs", 650,527, 100, 0);
		
		new int dfor {
			.vars(A, "id", "ifrom", "ito", "iter", "bstart", "idinstr");
			.addmethod("reset", func { 
				id = 0;
				iter = null;
				ifrom = 0;	ito=0;
				bstart = true;
				idinstr=0;	} );
			.reset;
		};
		new int dwhile	{
			.vars(A, "idinstr", "bstart");
			.addmethod("reset", func { idinstr=0; bstart=true; });
			.reset;
		};
		
		new string Code;
		Lexer::setas("Code");
		new db dbcode;
		Code.consts = (A,"p","[","]","if","else", "for","end", "<=",">","<", "==","!=", "/","*","+","-",",", "=", "int", "string", "null", "..", "in",".", "(", ")", "while");
		dbcode.dbaddstringrow("p [ $int , $int ] = $int"," ");					// 0
		.timer = ("timtik", 600, func { <GAME>.fintik; } );
		
		new TextBoxTyper ttb("fnkod", ifontsize, 0.6*ifontsize, 20,20,120, "",
			309,360, 268,222, 2);
		new img imgerror {
			.create(268,ifontsize,.red,128);
			.setz(0);
			.hide;
		};
		new img imggo {
			.create(268,ifontsize, 250,250,10, 128);
			.setz(0);
			.hide;
		};
		new TextBoxTyper tth("fnkod", ifontsize, 0.6*ifontsize, .grey(64), "",
			309,360, 268,222, 2);
		ttb.setz(100);
		tth.setz(100);
		tth.hide;
		new TextBoxTyper ttk("fnkod", ifontsize, 0.6*ifontsize, 10,20,60, "at0; ,[](){}-+_/=#<>*.\"\\!?%:&",
			309,108, 268,252, 2);
		ttk.setz(100);
		.startzad;
	}
	porownaj	{
		int i[3], int j;
		veccol.free;
		for( int i=0; i<itafle; i++)	{
			for( j=0; j<itafle; j++)	{
				|i0,i1,i2,_| = <"img"+i+"_"+j>.angetcrgba;
				if( i0!=255 || i1!=255 || i2!=255 ) {
					veccol.add(i);
					veccol.add(j);
					veccol.add(i0);
					veccol.add(i1);
					veccol.add(i2);
				}
			}
		}
	}
	mimage(string s)	{
		@s1 = "an"+s+"1";
		<s1>.hide;
		s = "im"+s+"1";
		new img <s>;
		<s>.create(<s1>.getw,<s1>.geth,<s1>.angetcrgba);
		<s>.setpos(<s1>.getpx,<s1>.getpy);
		<s>.setz(<s1>.getz-1);
		<s>.show;
		<s1>.hide;
	}
	zapal(@i, @j, @r, @g, @b)	{	<"img"+i+"_"+j>.create( H, H, r, g, b, 255 );	}
	fintik	{
		if( idinstr==vecid.size )	{
			imggo.hide;
			igmstate = 3;
			match( Level )	{
				1 =>	{.porownaj;
					.cbplay( ( veccol.veceq2(A,4,4,.black) ? "sndok" : "sndnon") );}
				2 =>	{.porownaj;
					.cbplay( ( veccol.veceq2(A,0,0,.black,0,9,.black,9,0,.black,9,9,.black) ?
						"sndok" : "sndnon") );}
				3, 4, 5, 6, 7 => {
					.porownaj;
					@ile =  veccol.size/5;
					if( ile!=ilejedynek )	{
						.cbplay("sndnon");
						return;
					}
					int id, int i[2];
					for( int i=0; i<ile; i++)	{
						id=i*5;
						i0 = veccol.get(id);
						i1 = veccol.get(id+1);
						if( ! ( dbdraw.get( i0, i1 )==1 && .miscol(i0, i1, .black) ) )	{
							.cbplay("sndnon");
							return;
						}
					}
					.cbplay("sndok");
				}
				? => ;
			}
			return;
		}
		Code = veckod.get( idinstr );
		imggo.show;
		imggo.setpos( 309, 108 + vecid2.get( idinstr ) * (ifontsize+2) );
		fxpik.play;
		Code.id = (0);
		Code.gettoken( "vec1", 1 ) ;
		string s, int i[3];
		@idin = vecid.get( idinstr );
		match( idin )	{
			0, 3, 4, 5, 6, 7, 8 => {
				match(idin)	{
					6 => {i0 = .mread(3);
						i1 = .mread(6)->to_i - .mread(9)->to_i;
						i2 = vec1.get(13);}
					7 => { i0 = .mread(3)->to_i - .mread(6)->to_i;
						i1 = .mread(9);
						i2 = vec1.get(13); }
//dbcode.dbaddstringrow("p [ $int 3 - $int 6 * $alpha 9 , $alpha 12 + $int 15 ] = $int 19"," ");		// 8
					8 => { i0 = .mread(3)->to_i - ( .mread(6)->to_r * .mread(9)->to_r );
						i1 = .mread(12)->to_r + .mread(15)->to_r;
						i2 = vec1.get(19); }
					? => {
						i0 = .mread(3);
						i1 = .mread(6);
						i2 = vec1.get(10);
					}
				}
				if( NoVar ) 	{
					NoVar = false;
					return;
				}
				if( i0<0||i0>=10||i1<0||i1>=10 )	{
					.playbad("sndpoza");
					return;
				}
				if( i2!=0 && i2!=1 )	{
					.playbad("sndbadval");
					return;
				}
				.zapal(i0, i1, (i2 ? .black : .white ) );
				fxpedzel.play;
				.gonext;
			}
			1, 9 => {
				if( idin == 1 )	{
					i0 = vec1.get(5);
					i1 = vec1.get(8);
				} else {
					i0 = 0 - vec1.get(6);
					i1 = vec1.get(9);
				}
				if( dfor.bstart == true )	{
					dfor.bstart = (false);
					dfor.ifrom = (i0);
					dfor.ito = (i1);
					dfor.id = ( dfor.ifrom );
					dfor.idinstr = (idinstr);
					st1.push("for");
					dfor.iter = ( vec1.get(2) );
					mapv.add( dfor.iter, dfor.id );
				}
				if( dfor.id > dfor.ito )	{
					.mtoend;
					dfor.bstart = (true);
					timtik.play;
				} else .gonext;
			}
			2 => {
				if( st1.top == "if" )	{
					_ = st1.pop;
					.gonext;
				} else if (st1.top=="while")	{
					if( dwhile.bstart )	{
						_ = st1.pop;
						idinstr++;
					} else {
						idinstr = dwhile.idinstr;
					}
					timtik.play;
				} else {
					if( dfor.bstart )	{
						_ = st1.pop;
						idinstr++;
					} else {
						dfor.id = ( dfor.id + 1 );
						mapv.set( dfor.iter, dfor.id );
						idinstr = dfor.idinstr;
					}
					timtik.play;
				}
			}
			10 => {
				mapv.add( vec1.get(1), -(vec1.get(5)->to_r) );
				.gonext;
			}
			11 => {
				s = .mread(1);
				@r = .mread(4)->to_r + vec1.get(7)->to_r;
				if( NoVar ) 	{ NoVar=false; return;	}
				mapv.set( vec1.get(1), r );
				.gonext;
			}
			12 => {
				if( dwhile.bstart == true )	{
					dwhile.bstart = (false);
					dwhile.idinstr = (idinstr);
					st1.push("while");
				}
				@r = .mread(2)->to_r;
				if( NoVar ) { NoVar=false; return; }
				if( r > vec1.get(5)->to_r )	{
					.mtoend;
					dwhile.bstart = (true);
					timtik.play;
				} else .gonext;
			}
			? => ;
		}
	}
	mtoend	{
		@id = vecid.get(idinstr)==20 ? 1 : 0;		// else
		@b = true;
		while( b ) {
			match ( vecid.get(idinstr) )	{
				2 => { id--; if( id==0 ) return; else idinstr++; }
				1, 9, 12 => { id++; idinstr++; }
				? => idinstr++;
			}
		}
	}
	mvar2(string s)	{
		if( mapv.contains(s) )	return mapv.get(s);
		.playbad("sndbrak");
		NoVar = true;
		return 0;
	}
	mread(int id)	{	vec1.get(id-1)=="$int" ? vec1.get(id) : .mvar2(vec1.get(id));	}
	miscol(int i, int j, int r, int g, int b)	{
		int r[3];
		|r0,r1,r2, _| = <"img"+i+"_"+j>.angetcrgba;
		r==r0 && g==r1 && b==r2;
	}
	gonext	{	idinstr++; timtik.play;	}
	playbad(@s)	{	igmstate=3; .cbplay(s);	}
	mreset	{
		idinstr = 0;
		dfor.reset;
		dwhile.reset;
		st1.free;
		mapv.free;
	}
	cbok_CLICK	{
		if( igmstate==11 )	{
			int c[3];
			|c0,c1,c2,_|=anobraz.angetcrgba;
			/*1) czerwony 255,0,0
2) zielony 0,255,0
3) niebieski 0,0,255
4) ty 249,231,26
5) czarny 0,0,0
6) biay 255,255,255
7) ciemny szary 64,64,64
8) jasny szary 192,192,192
9) fioletowy 220,17,244
10) bkitny 54,255,238*/
			match(colpos)	{
				1 => (c0==255&&c1==0&&c2==0);
				2 => (c0==0&&c1==255&&c2==0);
				3 => (c0==0&&c1==0&&c2==255);
				4 => (c0==249&&c1==231&&c2==26);
				5 => (c0==0&&c1==0&&c2==0);
				6 => (c0==255&&c1==255&&c2==255);
				7 => (c0==64&&c1==64&&c2==64);
				8 => (c0==192&&c1==192&&c2==192);
				9 => (c0==220&&c1==17&&c2==244);
				10 => (c0==54&&c1==255&&c2==238);
				? => false;
			}
			c0 = _;
			if( c0 )	{
				fxmikrofala.play;
				.nextcol;
			}
			return;
		}
		if( igmstate!=1 ) return;
		igmstate = 5;
		.mreset;
		string s, int j;
		veckod.free;
		vecid.free;
		vecid2.free;
		ttk.disable;
		for( int i=0; i < ttk.Rows; i++)	{
			s = ttk.getid(i);
			s.clear;
			if( s.length>0 )	{
				veckod.add( s );
				Code = s;
				j = Code.expectdb("dbcode", 0);
				vecid.add( j );
				vecid2.add( i );
				if( j<0 )	{
					.wronginstr(i);
					igmstate = 3;
					.cbplay("sndwrong");
					//vecid.print;
					return;
				}
			}
		}
		if( vecid.empty )	{	.mret;	return;	}
		match( Level )	{
			4 => {
				if( !( vecid.veceq2(A,1,0,2) || vecid.veceq2(A,1,3,2) || vecid.veceq2(A,1,4,2) ||
					vecid.veceq2(A,1,5,2) ) )	{
					igmstate = 3;
					.cbplay("sndbad");
					return;
				}
			}
			5 => {
				if( !( vecid.veceq2(A,1,5,6,2) || vecid.veceq2(A,1,6,5,2) || vecid.veceq2(A,1,5,7,2)
					|| vecid.veceq2(A,1,7,5,2)
					) )	{
					igmstate = 3;
					.cbplay("sndbad");
					return;
				}
			}
			6 => {
				if( !( vecid.veceq2(A,9,8,2) ) )	{
					igmstate = 3;
					.cbplay("sndbad");
					return;
				}
			}
			7 => {
				if( !( vecid.veceq2(A,10,12,8,11,2) ) )	{
					igmstate = 3;
					.cbplay("sndbad");
					return;
				}
			}
			? => ;
		}
		timtik.play;
	}
	wronginstr(int k)	{
		imgerror.show;
		imgerror.setpos( 309,108+k*(ifontsize+2) );
	}
	mret	{
		imgerror.hide;
		.recreate;
		igmstate = 1;
		ttk.enable;
	}
	mret2	{	igmstate = 3; .cbplay("sndklik");	}
	startzad	{
		<GAME> {
			match(Level)	{
				0, 3, 5, 6, 7, 8 => { .buildopis; .viewopis; igmstate = 4;	}
				? => .mstart1;
			}
		};
	}
	mstart1	{	igmstate=6; }
	mstart	{
		.viewzad;
		.recreate;
		ttk.clear;
		tth.clear;
		ttb.clear;
		ttk.activate(0);
		igmstate = 1;
		match(Level)	{
			1 => {tth.settext( "p[4,4] = 1", 1 );
				ttb.settext( "p[???] = ??", 1 );}
			2 => {tth.settext( "p[0,0] = 1",
					"p[0,9] = 1",
					"p[9,0] = 1",
					"p[9,9] = 1",
					4 );
				}
			3 => {
				@h = 10;
				@dh = 1;
				@x = 88;
				@s;
				new gmimgvec grtaf2;
				new img imgtlo2(h, dh, x)	{
					(@h, @dh, @x)
					.setpos( x - dh, 410 - dh );
					h = (h+dh)*itafle + 1;
					.create( h, h, .black, 255 );
					grtaf2.add(this);
				};
				for( @i=0; i<itafle; i++)	{
					for( @j=0; j<itafle; j++)	{
						s = "img2"+i+"_"+j;
						new img <s>;
						<s>.create( h, h, .white, 255 );
						<s>.setpos( j*(h+dh) + x, i*(h+dh) + 410 );
						grtaf2.add(s);
					}
				}
				new db dbdraw;
				new @ilejedynek = 0;
				dbdraw.dbbuild(A,
					0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
					0, 0, 0, 1, 1, 1, 0, 0, 0, 0,
					0, 0, 1, 0, 0, 0, 1, 0, 0, 0,
					0, 1, 0, 1, 0, 1, 0, 1, 0, 0,
					0, 1, 0, 0, 0, 0, 0, 1, 0, 0,
					0, 1, 0, 1, 0, 1, 0, 1, 0, 0,
					0, 0, 1, 0, 1, 0, 1, 0, 0, 0,
					0, 0, 0, 1, 1, 1, 0, 0, 0, 0,
					0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
					0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
					10 );
				.zliczjedynki;
			}
			4 => {
				grtaf2.hide;
				dbdraw.dbsetall(0);
				for(@i=0; i<10; i++) dbdraw.set(8,i,1);
				.zliczjedynki;
				dbcode.dbaddstringrow("for $alpha in $int .. $int"," ");		// 1
				dbcode.dbaddstringrow("end"," ");						// 2
				dbcode.dbaddstringrow("p [ $alpha , $int ] = $int"," ");		// 3
				dbcode.dbaddstringrow("p [ $int , $alpha ] = $int"," ");		// 4
				dbcode.dbaddstringrow("p [ $alpha , $alpha ] = $int"," ");		// 5
				tth.settext( "for i in 0..9",
					"  p[8, i] = 1",
					"end",
					3 );
				ttb.settext( "for ?? in ??..??",
					"  p[??, ??] = ??",
					"end",
					3 );
			}
			5 => {
				dbdraw.dbsetall(0);
				for(@i=0; i<10; i++) { dbdraw.set(i,i,1); dbdraw.set(i,9-i,1); }
				.zliczjedynki;
				dbcode.dbaddstringrow("p [ $alpha , $int - $alpha ] = $int"," ");		// 6
				dbcode.dbaddstringrow("p [ $int - $alpha , $alpha ] = $int"," ");		// 7
				tth.settext( "for i in 0..9",
					"  p[i, i] = 1",
					"  p[i, 9-i] = 1",
					"end",
					"---------- lub ----------",
					"for i in 0..9",
					"  p[i, i] = 1",
					"  p[ 9-i, i] = 1",
					"end",
					9 );
					ttb.settext( "for ?? in ??..??",
					"  p[???] = ??",
					"  p[???] = ??",
					"end",
					4 );
			}
			6 => {
				dbdraw.dbsetall(0);
				for(@i=-2; i<=2; i++) { dbdraw.set( 5-(2*i),i+5,1); }
				.zliczjedynki;
				dbcode.dbaddstringrow("p [ $int - $int * $alpha , $alpha + $int ] = $int"," ");		// 8
				dbcode.dbaddstringrow("for $alpha in - $int .. $int"," ");		// 9
				tth.settext( "for x in -2..2",
					"  p[ 5-2*x, x+5 ] = 1",
					"end",
					3 );
					ttb.settext( "for x in ???",
					"  p[ ??, ?? ] = 1",
					"end",
					3 );
			}
			7 => {
				dbdraw.dbsetall(0);
				for(@x = -2.0; x<=2.5; x+=0.5) { dbdraw.set( 5-(x*2),x+5,1); }
				.zliczjedynki;
				dbcode.dbaddstringrow("$alpha = - $real"," ");		// 10
				dbcode.dbaddstringrow("$alpha = $alpha + $real"," ");		// 11
				dbcode.dbaddstringrow("while $alpha <= $real"," ");		// 12
				tth.settext( "x = -2.0",
					"while x <= 2.5",
					"  p[ 5-2*x, x+5 ] = 1",
					"  x = x + 0.5",
					"end",
					5 );
					ttb.settext( "x = ??",
					"while x <= ??",
					"  p[ ??? ] = 1",
					"  x = x + ??",
					"end",
					5 );
			}
			8 => {
				.newdb("dbrgb", "zadrgb.db");
				new TextDb tdrgb(stdfont12, 12, "$var:dbrgb", .grey(20), 315,157, 4,150, "left");
				new @colpos = 0;
				imggo.show;
				new ConTextTyper tcr(null, 16, .black, "0", 3);
				tcr	{
					.setpos(anr2.getpx-60, anr2.getpy+15);
					.disable;
					.onenter(this,"colenter");
					new @splotno = "anr1";
					_ = .consttext("R:", .getpx-25, .getpy, 16, .red);
				};
				new ConTextTyper tcg(null, 16, .black, "0", 3);
				tcg	{
					.setpos(ang2.getpx-60, ang2.getpy+15);
					.disable;
					.onenter(this,"colenter");
					new @splotno = "ang1";
					_ = .consttext("G:", .getpx-25, .getpy, 16, .green);
				};
				new ConTextTyper tcb(null, 16, .black, "0", 3);
				tcb	{
					.setpos(anb2.getpx-60, anb2.getpy+15);
					.disable;
					.onenter(this,"colenter");
					new @splotno = "anb1";
					_ = .consttext("B:", .getpx-25, .getpy, 16, .blue);
				};
				new @slastcol = null;
				int ic[3];
				|ic0,ic1,ic2,_| = anobraz.angetcrgba;
				tcr.txtset(ic0);
				tcg.txtset(ic1);
				tcb.txtset(ic2);
				new gmimgvec grtc;
				grtc.addlist(A,"tcr","tcg","tcb");
				ttk.disable;
				tcr.colenter;	tcg.colenter;	tcb.colenter;
				tcr.enable;
				.nextcol;
			}
			9 => {
				ttk.disable;
				tdrgb.hide;
				grtc.eval("disable");
				grtc.hide;
				imggo.hide;
				igmstate = 12;
				new ConTextTyper tdrle(stdfont12, 12, .black, "0 ", 135);
				.newtext("txtrle", "13 0 2 4 8 0 1 4 1 6 1 0 2 4 4 0 1 6 2 4 1 0 1 6 4 0 1 6 1 0 2 4 1 6 4 0 3 2 2 4 8 2 1 0 1 2 1 0 7 2 1 0 1 2 1 0 24 2", stdfont12, .grey(128) );
				txtrle.setz(522);
				txtrle.hide;
				txtrle.setpos(35,328);
				tdrle.setpos(35,328);
				tdrle.setz(500);
				new img imglast {
					.create( 750, 20, .white, 192 );
					.setz(10);
					.setpos(25,322);
				};
				new img imgcol0	{
					.create( 20, 20, .black, 255 );
					.setpos( 350, 150 );
					_ = .consttext("0  (black)", .getex+15, .getpy, 16, .black);
				};
				new img imgcol2	{
					.create( 20, 20, 0,170,0, 255 );
					.setpos( 350, 150+.geth+5 );
					_ = .consttext("2  (green)", .getex+15, .getpy, 16, .black);
				};
				new img imgcol4	{
					.create( 20, 20, 170,0,0, 255 );
					.setpos( 350, 150 + 2*(.geth+5) );
					_ = .consttext("4  (red)", .getex+15, .getpy, 16, .black);
				};
				new img imgcol6	{
					.create( 20, 20, 170,85,0, 255 );
					.setpos( 350, 150 + 3*(.geth+5) );
					_ = .consttext("6  (brown)", .getex+15, .getpy, 16, .black);
				};
				tdrle.enable;
				tdrle.onenter(null, func {
					@s = tdrle.get;
					s.clear;
					if ( s=="13 0 2 4 8 0 1 4 1 6 1 0 2 4 4 0 1 6 2 4 1 0 1 6 4 0 1 6 1 0 2 4 1 6 4 0 3 2 2 4 8 2 1 0 1 2 1 0 7 2 1 0 1 2 1 0 24 2" ) {
						.cbplay("sndfinito");
						fxbrawo.play;
					} else .cbplay("sndnorle");
					} );
				dbdraw.dbbuild(A,
					0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
					0, 0, 0, 4, 4, 0, 0, 0, 0, 0,
					0, 0, 0, 4, 6, 0, 4, 4, 0, 0,
					0, 0, 6, 4, 4, 0, 6, 0, 0, 0,
					0, 6, 0, 4, 4, 6, 0, 0, 0, 0,
					2, 2, 2, 4, 4, 2, 2, 2, 2, 2,
					2, 2, 2, 0, 2, 0, 2, 2, 2, 2,
					2, 2, 2, 0, 2, 0, 2, 2, 2, 2,
					2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
					2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
					10 );
				for( int i=0; i<10; i++)	{
					for( int j=0; j<10; j++)	{
						match(dbdraw.get(i,j))	{
							0 => .zapal(i,j,.black);
							2 => .zapal(i,j,0,170,0);
							4 => .zapal(i,j,170,0,0);
							6 => .zapal(i,j,170,85,0);
							? => ;
						}
					}
				}
			}
			? => ;
		}
	}
	colenter	{
		int ile = .get;
		if( ile<0 ) ile=0;
		else if (ile>255) ile = 255;
		.txtset(ile);
		int w = imr1.getw;
		int h = imr1.geth;
		.disable;
		match(splotno)	{
			"anr1" => imr1.create(w,h,ile,0,0,255);
			"ang1" => img1.create(w,h,0,ile,0,255);
			"anb1" => imb1.create(w,h,0,0,ile,255);
			? => ;
		}
		slastcol=this;
		int c[3];
		|c0,c1,c2| = tcr.get, tcg.get, tcb.get;
		anobraz.paint(c0,c1,c2, 255, 0);
		fxpedzel.play;
	}
	nextcol	{
		imggo.setpos(315, 157 + (12+4)*(colpos+2) );
		colpos++;
		if( colpos==11 )	{
			igmstate = 3;
			//Level++;
			.cbplay("sndzip");
		} else
			igmstate = 11;
	}
	zliczjedynki	{
		ilejedynek = 0;
		.double_for(10, 10, func { (@i,@j)
						if( dbdraw.get(i,j)==1 )	{
							<"img2"+i+"_"+j>.create(10,10,.black,255);
							ilejedynek++;
						}
						} );
	}
	viewzad	{
		.deletegmobj("dbzad");
		.newdb( "dbzad", "zad" + Level + ".db");
		.deletegmobj("tdzad");
		new TextDb tdzad(stdfont12, 10, "$var:dbzad", .grey(20), 50,350, 4,150, "left");
		Level++;
	}
	buildopis	{
		.deletegmobj("dbopis");
		.newdb("dbopis", "opis" + HelpLevel + ".db");
		.deletegmobj("tdopis");
		new TextDb tdopis(stdfont14, 10, "$var:dbopis", .grey(222), 65,35, 4, 550, "left");
		tdopis.hide;
		HelpLevel++;
	}
	viewopis	{	igmstate = 2;	gsq.show;		tdopis.show;	}
	hideopis	{
		if( Level==8 ) igmstate=11;
		else if (Level==9) igmstate=12;
		else	igmstate = 1;
		gsq.hide;
		tdopis.hide;
	}
	recreate	{	grtaf.each( func { (@id) .create( H, H, .white, 255 ); } );	}
	cbhelp_CLICK	{	if( igmstate==1 || igmstate==11 || igmstate==12 )	.viewopis;	}
	cbhelp_MOVEON	{
		sndakskermovon.play;
		if( igmstate==1 )	{	ttb.hide;	tth.show;	}
		else if (igmstate==12)	txtrle.show;
	}
	cbhelp_MOVEOFF	{
		if( engine.varexist("txtrle") )	txtrle.hide;
		ttb.show;	tth.hide;
	}
	mouse_lclick	{
		|int x, int y| = mouse.getpos;
		match( igmstate )	{
			1 => ;
			2 => .hideopis;
			4 => { .hideopis; .mstart; }
			5 => { timtik.stop(false); imggo.hide; igmstate = 3; .cbplay("sndint"); }
			6 => .mstart;
			11 => {
				grtc.eval("disable");
				if( grtc.isin(x,y,1,0) )	{
					<grtc.getsfound>.enable;
				}
			}
			? => .cactsndstop(true);
		}
	}
	mouse_rclick	{
		if( igmdebug ) {
			if( igmstate==1 )	{
				igmstate = 3;
			/*Level=7;
			.mstart;*/
				.cbplay("sndok");
			} else if (igmstate==11)	{
				igmstate = 3;
				//Level=8;
				.cbplay("sndzip");
			}
		}
	}
	key_down	{
		if(igmstate==11 && keyboard.iskey("enter"))	{
			match(slastcol)	{
				"tcr" => tcg.enable;
				"tcg" => tcb.enable;
				"tcb" => tcr.enable;
				? => ;
			}
		}
	}
	mfinito	{	gameapi.play("Komputer");	}
}

game Komputer : Komputro {
	init	{
		Komputro::init("komputer");
		.path = ("komputer");
		.loadlekcja;
		.imgs = (A, "bkg.pyz", "ukgfx.pyzH 1200", "ukhdd.pyzH 1200", "ukprocramHL.pyz 1200",
			"uksndH.pyz 1200", "bg2.pyzH 1115");
		.sfxs = (A,"butmovon2 15");
		new Buttons buto("obiekty.pyz");
		tdsnd.napisshow(120,229);
		tdgfx.napisshow(126,278);
		tdproc.napisshow(174,74);
		tdram.napisshow(250,170);
		tdnet.napisshow(398,143);
		tdzas.napisshow(530,88);
		tdmon.napisshow(90,414);
		tdmysz.napisshow(666,498);
		tdklaw.napisshow(352,510);
		tdhdd.napisshow(396,210);
		tddvd.napisshow(558,268);
		.copyanima("anukgfx", "angfx1");
		angfx1.anloopfin;
		.copyanima("anukgfx", "angfx2");
		angfx2.setz(angfx2.getz+1);
		angfx2.setframe(4,0);
		.copyanima("anukhdd", "anhdd1");
		anhdd1.anloopfin;
		.copyanima("anukprocram", "anram1");
		anram1.anloopfin;
		.copyanima("anuksnd", "ansnd1");
		ansnd1.anloopfin;
		
		new gmimgvec gral;
		gral.addlist(A, "anukgfx", "angfx1", "angfx2", "anukhdd", "anhdd1", "anukprocram", "anram1",
			"anuksnd", "ansnd1", "anbg2");
		gral.move(400 - anbg2.getw/2, 300 - anbg2.geth/2);
		
		new classsimplebutton cbok;
		cbok.build("scripts/common/butok.pyz", "imglobcurs", 360,528, 100, 0);
		
		.sounds = (A,
			"sndintro", "Na rysunku widzisz model zestawu komputerowego; klikaj na poszczeglnych podzespoach aby dowiedzie si jak dziaaj", func { .cbplay("snd2"); },
			"snd2", "Kiedy zaspokoisz ciekawo kliknij przycisk ok aby przej do nastpnej lekcji", "mret",
			"snddvd", "Napd odczytuje przy pomocy lasera dane z pyt dvd; jeeli laser natrafia na wgbienie odczytuje jedynk jeli wgbienia nie ma odczytuje zero", "mret",
			"sndzas", "Zasilacz zamienia napicie z sieci elektrycznej na wielkoci wymagane przez pyt gwn dyski napdy i wiatraki", "mret",
			"sndproc", "Serce komputera procesor steruje prac caego systemu", "mret",
			"sndnet", "Karta sieciowa pozwala odbiera i wysya sygnay na zewntrz", "mret",
			"sndmysz", "Uywajc myszy wybrae mysz nie musz chyba wicej nic mwi", "mret",
			"sndklaw", "Klawiatura nazywana jest standardowym wejciem wicej o tym w lekcji powiconej podstawom jzyka C", "mret",
			"sndram", "Pami RAM przechowuje dane ktrymi manipuluje procesor: przesya je do innych urzdze kopiuje pomidzy blokami pamici i wylicza nowe wartoci", "mclose",
			"sndsnd", "Procesor kopiuje dane z pamici", func { .cbplay("sndsnd2"); ansnd1.play(2); },
			"sndsnd2", "I wysya do karty dwikowej", func { .cbplay("sndsnd3"); ansnd1.play(3); },
			"sndsnd3", "Karta przetwarza dane cyfrowe i generuje dwiki ktre syszymy dziki wzmaczniaczowi", func { .cbplay("sndsnd4"); ansnd1.anhide; },
			"sndsnd4", "Aby odciy procesor", func { .cbplay("sndsnd5"); ansnd1.play(4); },
			"sndsnd5", "Inicjuje on kontroler DMA Direct Memory Acces czyli bezporedni dostp do pamici",
				func { .cbplay("sndsnd6"); ansnd1.play(5); },
			"sndsnd6", "I dane przesyane s przez porednictwo kontrolera", "mclose",
			"sndhdd", "Procesor moe kopiowa dane z dysku", func { .cbplay("sndhdd2"); anhdd1.play(2); },
			"sndhdd2", "Do pamici RAM", func { .cbplay("sndhdd3"); anhdd1.play(3); },
			"sndhdd3", "I zapisywa dane z pamici", func { .cbplay("sndhdd4"); anhdd1.play(4); },
			"sndhdd4", "Na dysk; Poniewa jednak", func { .cbplay("sndhdd5"); anhdd1.anhide; },
			"sndhdd5", "Odwoanie do komrki pamici na dysku jest ponad 1000 razy wolniejsze ni do pamici RAM kopiowanie bardzo spowalnia dziaanie komputera", func { .cbplay("sndhdd6"); anhdd1.play(5); },
			"sndhdd6", "Dlatego dysk powinien pracowa z kontrolerem bezporedniego dostpu do pamici DMA", func { .cbplay("sndhdd7"); anhdd1.play(6); },
			"sndhdd7", "Ktry przekopiuje dane bez porednictwa procesora", "mclose",
			"sndgfx", "Obraz ktry widzisz na ekranie powstaje poprzez naklejanie na siebie wielu mniejszych obrazkw",
				func { .cbplay("sndgfx2"); angfx1.play(1); },
			"sndgfx2", "Obrazki te trzymane s w pamici RAM jako dwuwymiarowe tablice pikseli tzw powierzchnie z ktrymi pracowae w lekcji powiconej grafice komputerowej; procesor czyta z pamici algorytmy manipulujce obrazami i tworzy z nich jedn powierzchni",
				func { .cbplay("sndgfx3"); angfx1.play(2); },
			"sndgfx3", "Ktr przesya do pamici karty graficznej do obszaru zwanego pamici ekranu",
				func { .cbplay("sndgfx4"); angfx1.play(3); },
			"sndgfx4", "Specjalny przetwornik w karcie przeksztaca dane cyfrowe na sygna analogowy",
				func { .cbplay("sndgfx5"); angfx1.anhide; angfx2.show; },
			"sndgfx5", "Na podstawie sygnau monitor generuje obraz", func { .cbplay("sndgfx6"); },
			"sndgfx6", "Obecnie karty graficzne posiadaj wbudowane procesory graficzne ktre wykonuj  algorytmy bez porednictwa centralnego procesora", "mclose"
			);
		.cbplay("sndintro");
		new @bkliked = false;
	}
	cbok_CLICK	{
		gameapi.play("Linuks");
	}
	mret	{	igmstate=1;	}
	msnd	{
		anbg2.show;
		anuksnd.show;
		.cbplay("sndsnd");
		ansnd1.play(1);
	}
	mram	{
		anbg2.show;
		anukprocram.show;
		anram1.play(1);
		.cbplay("sndram");
	}
	mhdd	{
		anbg2.show;
		anukhdd.show;
		anhdd1.play(1);
		.cbplay("sndhdd");
	}
	mgfx	{
		anbg2.show;
		anukgfx.show;
		.cbplay("sndgfx");
	}
	buto_moveon	{	fxbutmovon2.play;	}
	buto_lclick	{
		<GAME> (sobject)	{ (@sob)
			if( igmstate!=1 ) {
				.mclose;
				return;
			}
			igmstate = 2;
			bkliked = true;
			match(sob)	{
				"glosnik" => .msnd;
				"dzwiek" => .msnd;
				"zasilanie" => .cbplay("sndzas");
				"dvd" => .cbplay("snddvd");
				"ram" => .mram;
				"proc" => .cbplay("sndproc");
				"gfx" => .mgfx;
				"net" => .cbplay("sndnet");
				"hdd" => .mhdd;
				"mysz" => .cbplay("sndmysz");
				"klaw" => .cbplay("sndklaw");
				"monitor" => .mgfx;
				? => igmstate=1;
			}
		};
	}
	mclose	{
		<GAME> {
			if( igmstate==2 )	{
				.cactsndstop(false);
				gral.stop(false);
				gral.hide;
				igmstate = 1;
			} else
				.cactsndstop(true);
		};
	}
	mouse_lclick	{
		if( bkliked ) {
			bkliked=false;
			return;
		}
		.mclose;
	}
}
game Linuks : Komputro {
	init	{
		Komputro::init("linuks");
		.path = ("linuks");
		.loadlekcja;
		.img=("bg.pyz");
		
		new @stdmono12 = .snewfont( "configs/fonts/mono.ttf", 12);
		new @stdfont12 = .snewfont( "configs/fonts/normal.ttf", 12);
		new @stdfont14 = .snewfont( "configs/fonts/normal.ttf", 14);
		new @cols = 40;
		.newimgarray("grti", "text", "txti", cols);
		grti.each(func { (@id)
			.setfont(stdmono12);
			.setpos(9,54+id*12);
			.createtxt(.white);
			 } );
		new @column = 0;
		new @ilimit = 60;
		new string Code;
		Lexer::setas("Code");
		Code.consts = (A, "../", "./","/", "..", ".", "|", ">", ">>", "<" , "<<", "-al", "-la", "-a", "-l", "ls", "'");
		new vector vec1;
		vec1.type("string");
		
		new ConTextTyper ttp(stdmono12, 12, .white, "at0 !@#$%^&*()-=_+{}|\\[];':\",./<>?", ilimit);
		ttp.onenter(GAME, "mcheck");
		
		new TextDb tdhp(stdfont12, 12, "helpos.db", 1,4,52, 491,91, 2,50, "left");
		tdhp.hide;
		//tdhp.view(A,0,1,2,3,4,5);
		
		new @Level = 0;
		new @HelpLevel = 0;
		new @sublevel = 0;
		new @benter = false;
		new @spasswd = "";
		new @sread = "";
		new @Dir = "~";
		new @retdir="~";
		
		new gfxSquare gsq(50,20,700,525);
		gsq.set( 0,128,0, 220);
		gsq.build;
		gsq.setz(500);
		gsq.hide;
		
		.sfxs = (A, "pik", "type2 50", "blink 50");
		
		.sounds = (A,
			"sndok", "okej", null,
			"sndend","Doskonale! Wszystkie zadania z tej lekcji wykonane! Przeczytaj wnioski i kliknij aby powrci do menu gwnego", func { <GAME>.buildopis; igmstate=11; }
			);
		fxpik.addmethod("onstart", func { .mnext; } );
		
		.buildopis;
	}
	mpos(int id)	{
		ttp.txtset("");
		ttp.setpos(9 + <"txti"+id>.getw,54+id*12);
		ttp.limit = ( ilimit-<"txti"+id>.get->length );
	}
	menable	{	.mpos(column);	ttp.enable;	}
	mout(string s)	{	<"txti"+column>.txtset(s);	}
	moutln(string s)	{	.mout(s); .mnewline;	}
	mrewind	{
		for( int i=0; i<cols-1; i++)	<"txti"+i>.txtset( <"txti"+(i+1)>.get );
		<"txti"+(cols-1)>.txtset("");
	}
	mnewline	{
		column++;
		if( column==cols )	{
			column--;
			.mrewind;
		}
	}
	ttp_ontype	{	fxtype2.playif;	}
	mread	{
		Code = ttp.get;
		Code.id = (0);
	}
	mput	{
		@s = "txti"+column;
		.mread;
		<s>.txtset( <s>.get + Code );
		ttp.txtset("");
		.mnewline;
	}
	mclear	{	grti.txtreset;	}
	buildopis	{
		.deletegmobj("dbopis");
		.newdb("dbopis", "help" + HelpLevel + ".db");
		.deletegmobj("tdopis");
		new TextDb tdopis(stdfont14, 10, "$var:dbopis", 255,255,0, 65,35, 4, 550, "left");
		HelpLevel++;
		igmstate = 2;
		gsq.show;
		tdopis.show;
	}
	viewzad	{
		.deletegmobj("dbzad");
		.newdb( "dbzad", "zad" + Level + ".db");
		.deletegmobj("tdzad");
		new TextDb tdzad(stdfont12, 10, "$var:dbzad", 128,0,0, 485,304, 3,150, "left");
		Level++;
	}
	bool mget0	{
		.mput;
		Code.clear;
		if( Code.length )	return true;
		else .mready;
		false;
	}
	bool mget(string s)	{
		if( .mget0 )	{
			if( Code==s ) return true;
			.mno;
		}
		false;
	}
	bool mget2(string s)	{
		if( .mget0 )	{
			if( Code.expects(s, " ", true) ) return true;
			.mno;
		}
		false;
	}
	bool mget3(string s1, string s2)	{
		if( .mget0 )	{
			if( Code.expects(s1, " ", true) || Code.expects(s2," ",true) ) return true;
			.mno;
		}
		false;
	}
	bool mget4(string s1, string s2, string s3)	{
		if( .mget0 )	{
			if( Code.expects(s1, " ", true) || Code.expects(s2," ",true)
			|| Code.expects(s3," ",true) ) return true;
			.mno;
		}
		false;
	}
	mcheck	{
		string s[2];
		benter = true;
		match(sublevel)	{
			0 => {
				.mput;
				if( Code.contains(" ") || !Code.expects("$alpha", " ", false) )	{
					.moutln("Login incorrect");
					.mstart;
				} else {
					sublevel++;
					spasswd = "";
					.mout("Password: ");
				}
			}
			3 => if( .mget("passwd") )	{
					sublevel++;
					spasswd="";
					.mout("type current password: ");
				}
			6 => if (.mget("pwd") )	{
					.moutln("/home/jacek");
					.mok;
				}
			7 => if (.mget4("ls", "ls .", "ls ./") )	{
					.moutln("lekcje  Mail  public_html");
					.mok;
				}
			8, 12 => if (.mget2("$alpha man ls") )	{
					.manls;
					.mnextsub;
				}
			9 => if( .mget4("ls -a", "ls -a .", "ls -a ./") )	{
					.moutln(".  ..  .adresy  lekcje  Mail  public_html  .zajecia");
					.mok;
				} else { sublevel=8; }
			10 => if( .mget3("ls $alpha Mail", "ls $alpha Mail /") )	{
					if( .misdir("Mail") )	{
						.moutln("mbox");
						.mnextsub;
					} else .mno;
				}
			11 => if( .mget3("ls -a ..", "ls -a ../") )	{
					.moutln(". .. jacek");
					.mok;
				} else sublevel=10;
			13 =>  if( .mget4("ls -l", "ls -l .", "ls -l ./") )	{
					.moutln("total 12");
					.moutln("-rw-r--r-- 1 jacek jacek  415 2007-05-16 17:10 lekcje");
					.moutln("drwx------ 2 jacek jacek 4096 2007-05-16 12:51 Mail");
					.moutln("drwxr-xr-x 2 jacek jacek 4096 2007-05-16 13:05 public_html");
					.mok;
				} else sublevel = 12;
			14 => if (.mget3("ls -l $alpha Mail", "ls -l $alpha Mail /") )	{
					if( .misdir("Mail") )	{
						.moutln("total 0");
						.moutln("-rw-r--r-- 1 jacek jacek 0 2007-05-16 12:51 mbox");
						.mok;
					} else .mno;
				}
			15 => if (.mget3("ls -al", "ls -la") )	{
					.moutln("total 28");
					.moutln("drwxr-xr-x 4 jacek jacek 4096 2007-05-16 13:03 .");
					.moutln("drwxr-xr-x 3 jacek jacek 4096 2007-05-16 11:27 ..");
					.moutln("-rw-r--r-- 1 jacek jacek  121 2007-05-16 13:03 .adresy");
					.moutln("-rw-r--r-- 1 jacek jacek  415 2007-05-16 17:10 lekcje");
					.moutln("drwx------ 2 jacek jacek 4096 2007-05-16 12:51 Mail");
					.moutln("drwxr-xr-x 2 jacek jacek 4096 2007-05-16 13:05 public_html");
					.moutln("-rw-r--r-- 1 jacek jacek  130 2007-05-16 13:00 .zajecia");
					.mok;
				}
			16 => if( .mget0 )	{
					if( .misvec(A, "ls", "/home/jacek") || .misvec(A, "ls", "/home/jacek/") )	{
						.moutln("lekcje  Mail  public_html");
						.mok;
					} else .mno;
				}
			17 => if (.mget2("$alpha cat $alpha lekcje") )	{
					.mcatlekcje;
					.mok;
				}
			18 => if (.mget2("$alpha cat $alpha lekcje > $alpha plik_tmp") )	{
					.mnextsub;
				}
			19 => if (.mget4("ls", "ls .", "ls ./") )	{
					.moutln("lekcje  Mail  plik_tmp  public_html");
					.mok;
				} else sublevel=18;
			20 => if ( .mget2("$alpha cat $alpha lekcje") )	{
					.mcatlekcje;
					.mnextsub;
				}
			21 => if( .mget3("$alpha cat $alpha lekcje | $alpha grep $alpha rogramow",
				 "$alpha cat $alpha lekcje | $alpha grep ' $alpha rogramow '") )	{
					if( Code.gete(0,1)=="'" )	{
						if( Code.gete(0,10)=="'rogramow'" &&
							Code.getb(Code.find("grep")+4, 1)==" ")	{
							.mcatlek2;
							.mok;
						} else { .mno; sublevel=20; }
					} else {
						.mcatlek2;
						.mok;
					}
				} else sublevel=20;
			22 => if ( .mget3("ls -a | $alpha grep $alpha a", "ls -a | $alpha grep ' $alpha a '") )	{
					if( Code.gete(0,1)=="'" )	{
						if( Code.gete(0,3)=="'a'" &&
							Code.getb(Code.find("grep")+4, 1)==" ")	{
							.moutln(".adresy");
							.moutln("Mail");
							.moutln(".zajecia");
							.mok;
						} else .mno;
					} else {
						.moutln(".adresy");
						.moutln("Mail");
						.moutln(".zajecia");
						.mok;
					}
				}
			23 => if( .mget4("ls -a", "ls -a .", "ls -a ./") )	{
					.moutln(".  ..  .adresy  lekcje  Mail  plik_tmp  public_html  .zajecia");
					.mnextsub;
				}
			24 => if( .mget0 )	{
					if( .misvec(A, "cat", ".adresy") )	{
						.moutln("Magda, ul. Biala 1/5");
						.moutln("Janek, ul. Zielona 6");
						.moutln("Poziomka prof., ul. Cauchy 1/1");
						.moutln("Ania, ul. Wegierska 3/52");
						.moutln("Witek, ul. Maliny 6/66");
						.mnextsub;
					} else { .mno; sublevel=23; }
				}
			25 => if( .mget2("$alpha cat . $alpha adresy | $alpha sort") )	{
					if( Code.getb(Code.find("adresy")-1,1)=="." )	{
						.moutln("Ania, ul. Wegierska 3/52");
						.moutln("Janek, ul. Zielona 6");
						.moutln("Magda, ul. Biala 1/5");
						.moutln("Poziomka prof., ul. Cauchy 1/1");
						.moutln("Witek, ul. Maliny 6/66");
						.mnextsub;
					} else { .mno; sublevel=23; }
				} else { sublevel=23; }
			26 => if( .mget2("$alpha cat . $alpha adresy | $alpha sort > $alpha nowe_adresy") )	{
					if( Code.getb(Code.find("adresy")-1,1)=="." )	{
						.mnextsub;
					} else { .mno; sublevel=23; }
				} else { sublevel=23; }
			27 => if( .mget2("$alpha cat $alpha nowe_adresy") )	{
					.moutln("Ania, ul. Wegierska 3/52");
					.moutln("Janek, ul. Zielona 6");
					.moutln("Magda, ul. Biala 1/5");
					.moutln("Poziomka prof., ul. Cauchy 1/1");
					.moutln("Witek, ul. Maliny 6/66");
					.mok;
				} else { sublevel=23; }
			28 => if( .mget0 )	{
					if( .misvec(A, "cd", "public_html") || .misvec(A, "cd", "public_html/")
						|| .misvec(A, "cd", "./public_html/") || .misvec(A, "cd", "./public_html"))	{
						Dir = "~/public_html";
						.mnextsub;
					} else .mno;
				}
			29 => if (.mget("pwd") )	{
					.moutln("/home/jacek/public_html");
					.mnextsub;
				} else {sublevel=28;}
			30 => if( .mget3("$alpha cd ..", "$alpha cd ../") )	{
					Dir = "~";
					.mnextsub;
				} else {sublevel=28;}
			31 => if (.mget("pwd") )	{
					.moutln("/home/jacek");
					.mok;
				} else {sublevel=28;}
			32 => if( .mget0 )	{
					if( .misvec(A,"ls","public_html") || .misvec(A,"ls","./public_html") ||
						.misvec(A,"ls","public_html/") || .misvec(A,"ls","./public_html/") )	{
						.moutln("index.html");
						.mnextsub;
					} else .mno;
				}
			33 => if( .mget0 )	{
					if( .misvec(A,"cd","public_html") || .misvec(A,"cd","./public_html") ||
						.misvec(A,"cd","public_html/") || .misvec(A,"cd","./public_html/") )	{
						Dir = "~/public_html";
						.mnextsub;
					} else { sublevel=32; .mno; }
				}
			34 => if( .mget0 )	{
					if( .misvec(A,"mkdir","bekap") || .misvec(A,"mkdir","./bekap") ||
						.misvec(A,"mkdir","bekap/") || .misvec(A,"mkdir","./bekap/") )	{
						.mnextsub;
					} else { sublevel=32; .mno; }
				}
			35 => if( .mget0 )	{
					if( .misvec(A,"cp","index.html", "bekap") || .misvec(A,"cp","./index.html", "bekap") ||
						.misvec(A,"cp","index.html", "bekap/") || .misvec(A,"cp","./index.html", "bekap/") ||
						.misvec(A,"cp","index.html", "./bekap") || .misvec(A,"cp","./index.html", "./bekap") ||
						.misvec(A,"cp","index.html", "./bekap/") || .misvec(A,"cp","./index.html", "./bekap/")) {
						.mnextsub;
					} else { sublevel=32; .mno; }
				}
			36 => if( .mget0 )	{
					if( .misvec(A,"cd","bekap") || .misvec(A,"cd","./bekap") ||
						.misvec(A,"cd","bekap/") || .misvec(A,"cd","./bekap/") )	{
						Dir = "~/public_html/bekap";
						.mnextsub;
					} else { sublevel=32; .mno; }
				}
			37 => if (.mget4("ls", "ls .", "ls ./") )	{
					.moutln("index.html");
					.mnextsub;
				} else sublevel=32;
			38 => if( .mget0 )	{
					if( .misvec(A,"cd","../../") || .misvec(A,"cd") || .misvec(A,"cd","/home/jacek/") ||
						.misvec(A,"cd","~") || .misvec(A,"cd","/home/jacek") || .misvec(A,"cd","../..") )	{
						Dir = "~";
						.mok;
					} else { sublevel=32; .mno; }
				}
				/*1) usu go poleceniem 'rm <file>'.
2) Wywietl zawarto katalogu 'public_html'.
3) Uruchom manual polecenia 'rm'.
4) Usu katalog 'bekap' z 'public_html'.*/
			39 => if( .mget0 )	{
					if( .misvec(A, "rm", ".adresy") )	{
						.mnextsub;
					} else .mno;
				}
			40 => if( .mget0 )	{
					if( .misvec(A,"ls","public_html") || .misvec(A,"ls","./public_html") ||
						.misvec(A,"ls","public_html/") || .misvec(A,"ls","./public_html/") )	{
						.moutln("bekap index.html");
						.mnextsub;
					} else { .mno; sublevel=39; }
				}
			41 =>  if (.mget2("$alpha man $alpha rm") )	{
					.moutln("NAME");
					.moutln("   rm - remove files or directories");
					.moutln("SYNOPSIS");
					.moutln("   rm [OPTION]... FILE...");
					.moutln("DESCRIPTION");
					.moutln("   Removes FILEs. Use option '-r' to remove");
					.moutln("   directory.");
					.moutln("   OPTION");
					.moutln("   -r : remove directories and their contents recursively");
					.moutln("END RM");
					.mnextsub;
				} else sublevel=39;
			42 => if( .mget0 )	{
					if( .misvec(A,"rm","-r","public_html/bekap") ||
						.misvec(A,"rm","-r","./public_html/bekap") ||
						.misvec(A,"rm","-r","public_html/bekap/") ||
						.misvec(A,"rm","-r","./public_html/bekap/") )	{
						.mnextsub;
					} else { sublevel=39; .mno; }
				}
			43 => if( .mget0 )	{
					if( .misvec(A,"ls","public_html") || .misvec(A,"ls","./public_html") ||
						.misvec(A,"ls","public_html/") || .misvec(A,"ls","./public_html/") )	{
						.moutln("index.html");
						igmstate = 10;
						.cbplay("sndend");
					} else { .mno; sublevel=39; }
				}
			? => ;
		}
	}
	mnextsub	{	sublevel++; .mready;	}
	bool misvec	{
		Code.clear;
		vec1.vecbuildfromstring2(Code," ");
		vec1.veceq2;
	}
	misdir(string sdir)	{
		Code.clear;
		@id = Code.find(sdir)+sdir.length;
		return id>=Code.length || Code.getb(id,1)=="/";
	}
	mcatlek2	{
		.moutln("Lekcja 5: Programowanie mikroprocesorow - jezyki Asembler.");
		.moutln("Lekcja 6: Podstawy programowania w jezyku C : obliczenia.");
		.moutln("Lekcja 7: Podstawy programowania obiektowego.");
	}
	mcatlekcje	{
		.moutln("Lekcja 1: Podstawy logiki.");
		.moutln("Lekcja 2: Bramki \"and\" i \"or\".");
		.moutln("Lekcja 3: Cwiczenia na bramkach.");
		.moutln("Lekcja 4: Jednobitowy procesor.");
		.moutln("Lekcja 5: Programowanie mikroprocesorow - jezyki Asembler.");
		.moutln("Lekcja 6: Podstawy programowania w jezyku C : obliczenia.");
		.moutln("Lekcja 7: Podstawy programowania obiektowego.");
		.moutln("Lekcja 8: Podstawy grafiki komputerowej.");
		.moutln("Lekcja 9: Praca podzespolow komputera.");
		.moutln("Lekcja 10: Podstawy systemu operacyjnego Linuks.");
	}
	manls	{
		.moutln("NAME");
		.moutln("  ls - list directory contents;");
		.moutln("SYNOPSIS");
		.moutln("  ls [OPTION]... [FILE]...");
		.moutln("DESCRIPTION");
		.moutln("  list informations about the FILEs -");
		.moutln("  (the current directory by default).");
		.moutln("  OPTION");
		.moutln("  -a : don't ignore hidden files");
		.moutln("  -l : use a long listing format");
		.moutln("END LS");
	}
	mnos(string s)	{	.moutln(s);	.mready;	}
	mno	{ fxblink.play; Dir=retdir; .mnos("Error: repeat whole activity nr "+Level+" again.");	}
	mgo(@id)	{	sublevel=id; .mready;	}
	mstart	{
		match(Level)	{
			1 => { sublevel=0; .mout("jacek login: "); .menable; }
			2 => { tdhp.view(A,0); .mgo(3);	}
			3 => { tdhp.view(A,1,2); .mgo(6);	}
			4 => { tdhp.view(A,3,4); .mgo(7);	}
			5 => { tdhp.view(A,5); .mgo(8);	}
			6 => { .mgo(10);	}
			7 => { .mgo(12);	}
			8 => { .mgo(14);	}
			9 => { .mgo(15);	}
			10 => { .mgo(16);	}
			11 => { tdhp.view(A,6); .mgo(17);	}
			12 => { .mgo(18); }
			13 => { tdhp.view(A,7); .mgo(20); }
			14 => { .mgo(22); }
			15 => { tdhp.view(A,8); .mgo(23); }
			16 => { tdhp.view(A,9); .mgo(28); }
			17 => { tdhp.view(A,10,11); .mgo(32); }
			18 => { tdhp.view(A,12); .mgo(39); }
			? => .mready;
		}
	}
	mready	{	.mout("jacek@jacek:"+Dir+"$ ");	.menable;	}
	mok	{	igmstate=3; fxpik.play; .cbplay("sndok");	}
	bool mreadpas	{
		fxtype2.playif;
		if( keyboard.iskey("enter") )	{
			.mnewline;
			return true;
		} else if( keyboard.iskey("backspace")) {
			spasswd = spasswd.strsube(1);
		} else spasswd += keyboard.getkey;
		false;
	}
	key_down	{
		if( benter )	{
			benter = false;
			return;
		}
		if( igmstate==2 )	{
			.mouse_lclick;
			return;
		}
		if( igmstate!=1) return;
		match(sublevel)	{
			1 =>	if( .mreadpas )	{
					if( Code=="jacek" && spasswd=="jacek")	.mok;
					else {
						.moutln("Login incorrect");
						.mstart;
					}
				}
			4 => if( .mreadpas )	{
					if( spasswd=="jacek" )	{
						sublevel++;
						spasswd="";
						.mout("type new password: ");
					} else {
						sublevel = 3;
						.mnos("Incorrect password");
					}
				}
			5 => if( .mreadpas )	{
					if( spasswd=="he,35hsu" )	{
						.moutln("Password succesfully changed");
						.mok;
					} else {
						sublevel = 3;
						.mnos("Error: write password given in exercise");
					}
				}
			? => ;
		}
	}
	mnext	{	<GAME> { igmstate=1; .viewzad; .mstart; };	}
	mouse_lclick	{
		match(igmstate)	{
			1 => ;
			2 => { gsq.hide; tdopis.hide; igmstate=1; .viewzad; .mstart; }
			10 => ;
			11 => gameapi.play("MenuGlowne");
			? => .cactsndstop(true);
		}
	}
	mouse_rclick	{
		if( igmdebug )	{
			if( Level==18 ) .cbplay("sndend");
			else .mok;
		}
	}
}

game Binary : Komputro {
	init	{
		Komputro::init("binary");
		.path = ("binary");
		.bkg = ("bg.pyz");
		.loadlekcja;
		
		.sfxs = (A, "mikrofala", "type 20");
		.sounds = (A,
			"sndend", "wietnie! Teraz jeste gotowy do kolejnych lekcji",
				func { gameapi.play("Tasma");	}
			);
		
		.newsnd("sndok", "linuks0.wav");
		new gfxSquare gsh(10,50,315,490);
		gsh.set(.grey(200), 128);
		gsh.build;
		gsh.shadow(2,2,192);
		
		new @stdfont12 = .snewfont( "configs/fonts/normal.ttf", 12);
		new @stdfont16 = .snewfont( "configs/fonts/bold.ttf", 16);
		new @stdfont8 = .snewfont( "configs/fonts/normal.ttf", 8);
		.monofont("fnbin", 14);
		
		new img imgprint {
			.create(100,14,.white,128);
			.setz(0);
			.hide;
		};
		
		string s, @pos;
		@w = 40;
		@x = 660;
		new gmimgvec grtxt;
		for( int i=0; i<8; i++)	{
			s = "gsb"+i;
			new gfxSquare <s>(x-i*w,50,w,w);
			<s>.set(.white, 255);
			<s>.build;
			<s>.border(1,1,.black,240);
			
			pos = <s>.getcx;
			.mtextx("txtd"+i, "2", pos, 63, 16);
			.mtextx("txtp"+i, i, pos+<"txtd"+i>.getw, 58, 12);
			.mtextx("txtdwa"+i, 2->pow(i), pos, 93, 16);
			grtxt.add("txtdwa"+i);
			grtxt.add("txtd"+i);
			grtxt.add("txtp"+i);
			grtxt.add(s);
		}
		
		new @Level = 1;
		new @X = 470;
		
		new vector vz1;
		vz1.beginadd("begin", 1, 5, 20, 43, 2, 15, 7, 32, 8, 21, 0 , 51, 17, 6);
		new ConTextTyper ttp("fnbin", 14, .black, "0", 20);
		new @sublevel = 0;
		.newimgarray("grzad1", "text", "txtz", vz1.size);
		grzad1.each( func { (@id)
			.setfont("fnbin");
			.setpos(X, 255+id*(14+2) );
			} );
		ttp.setpos(X, 255);
		ttp.onenter(GAME, func {
			if( vz1.get(sublevel)==ttp.get || (igmdebug&&keyboard.iskeydown("lshift")) )	{
				fxmikrofala.play;
				sndok.play;
				<grzad1.get(sublevel)>.txtsetcol(ttp.get,.black);
				sublevel++;
				if( sublevel>=vz1.size )	{
					Level++;
					sublevel=0;
					<GAME>.<"view"+Level>;
				} else {
					imgprint.move(0,16);
					ttp.move(0,14+2);
					ttp.txtset("");
					ttp.enable;
				}
			} else {
				ttp.enable;
			}
			} );
		.viewzad;
	}
	view2	{
		.viewzad;
		vz1.free;
		vz1.beginadd("begin",1111011,1,111100,11011,100100011,10001010111,
			1010001,1000,110100,1101001101,1100100,1011,100110000,
			1111010000011);
		
		new gfxSquare gsd1(650,300,100,2);
		gsd1.set(.white, 255);
		gsd1.build;
		gsd1.shadow(1,1,128);
		new gfxSquare gsd2(710,280,2,250);
		gsd2.set(.white, 255);
		gsd2.build;
		gsd2.shadow(1,1,128);
		
		@ile = 20;
		new img imgliczba {
			.create(56,15,.white,128);
			.setz(0);
			.setpos(652,283);
		};
		new ConTextTyper tth("fnbin", 14, .black, "0", 4);
		tth.setpos(653,284);
		tth.onenter( GAME, func {
			int liczba = tth.get;
			grzad2.txtreset;
			greszt.txtreset;
			int id = 0;
			while(liczba>0)	{
				<greszt.get(id)>.txtsetcol(liczba%2, .black);
				liczba/=2;
				<grzad2.get(id)>.txtsetcol(liczba, .black);
				id++;
			}
			} );
		.newtextposz("txtreszta","Rest","fnbin",.black,715,280,0);
		.newtextposz("txtwpisz","Number:","fnbin",.black,650,268,0);
		
		.newimgarray("grzad2", "text", "txtr", ile );
		grzad2.each( func { (@id)
			.setpos(650,306+(id*14+2));
			.setfont("fnbin");
			} );
		.newimgarray("greszt", "text", "txtre", ile );
		greszt.each( func { (@id)
			.setpos(720,306+(id*14+2));
			.setfont("fnbin");
			} );
	}
	ttp_ontype	{	fxtype.play;	}
	view3	{
		.viewzad;
		tth.disable;
		vz1.free;
		vz1.beginadd("begin",10,11,100,101,110,111,1000,1001,1010,1011,1100,1101,
			1110,1111);
		.with(A, "txtreszta", "txtwpisz", "greszt", "grzad2", "tth", "imgliczba", "gsd1", "gsd2", "hide");
	}
	view4	{	.cbplay("sndend");	}
	viewzad	{
		if( Level<3)	{
			.deletegmobj("tdopis");
			new TextDb tdopis(stdfont12, 12, "opis"+Level+".db", .grey(255), 13,55, 3,250, "left");
			tdopis.stdshadow(1);
		}
		.deletegmobj("tdhp");
		new TextDb tdhp(null, 12, "zad"+Level+".db", 255,255,255, 330,130, 2,50, "left");
		tdhp.stdshadow(1);
		.deletegmobj("tdzad1");
		//(tdhp.getey+20)->print;
		new TextDb tdzad1("fnbin", 14, "przyk"+Level+".db", .black, 350,222, 2,50, "left");
		tdzad1.setshadow(.white, 1);
		
		ttp.setpos(X, 255);
		ttp.txtset("");
		ttp.enable;
		imgprint.setpos(X,255);
		imgprint.show;
		
		grzad1.txtreset;
	}
	mtextx(@sname, @s, @x, @y, @size)	{
		.newtext(sname, s, ["stdfont"+size], .black);
		<sname>.setpos(x - <sname>.getw/2,y);
	}
	mouse_lclick	{
		if( Level==2 )	{
			|int x, int y| = mouse.getpos;
			if( imgprint.isin(x,y,1,1) )	{
				ttp.enable;
				tth.disable;
			} else if ( imgliczba.isin(x,y,1,1) )	{
				tth.enable;
				ttp.disable;
			}
		}
	}
}
