
new db dbconf;
dbconf.loadscript("configs/config.beh");
public def readcfg(string svar, def val)	{
	int id = dbconf.findbyrow(svar);
	if( id<0 ) val;
	else dbconf.get(id,1);
}
public int ireadscfg(string svar, int val)	{
	.readcfg(svar,val.igetsc)->to_i->igetsc;
}

engine.setdebugstate( .readcfg("enginedebug:", 0) );

new int igmdebug = .readcfg("igmdebug:", 0);
new int igmpcdebug = .readcfg("igmpcdebug:", 0);
if( igmpcdebug )	{
	mouse.showsys;
}
new int igmexportan = .readcfg("igmexportan:", 0);
new int igmimportan = .readcfg("igmimportan:", 0);
new int igmenablesave = .readcfg("igmenablesave:", 0);

new int igmdelay = .readcfg("igmdelay:", engine.getloopdelay);
public imstotick	{	(0.5 + .to_r/igmdelay)->to_i;	}
public iticktoms	{	igmdelay * .get;	}

/**************************************************************/
new int igmwinlocal = .readcfg("igmwinlocal:", 0);		// special folder windows
new int igmmac = .readcfg("igmmac:", 0);
new int igmipad = .readcfg("igmipad:", 0);
new int igmiphone = .readcfg("igmiphone:", 0);
new int igmandroid = .readcfg("igmandroid:", 0);

new string sgmdeveloper = .readcfg("sgmdeveloper:", "Dagiel");
new string sgmproject = dbconf.dbget("sgmproject:");

public bool isapple		{	igmipad || igmmac || igmiphone;		}
public bool checktouchpad	{	igmipad || igmiphone || igmandroid;	}

//---------------------- ekran ------------------------------

|new int igmappw, new int igmapph| = engine.getappsize;	// rozmiar
|new int igmoffsetx, new int igmoffsety| = engine.getscreenoffset;	// przesuniecie na wezszych od apki monitorach
//|new int iResX, new int iResY| = engine.getscreensize;	// rozmiar gry po przeskalowaniu
|new int iResX, new int iResY| = engine.getscreenres;	// rozmiar gry po przeskalowaniu
|new real rgmscalex, new real rgmscaley| = engine.getscreenscale;
new int i1024offsetx = 171->igetsc;
public int getxoffset	{
	igmandroid ? (engine.getxandro < igmoffsetx ? igmoffsetx : engine.getxandro) : igmoffsetx;
}

// ("appw/h: "+igmappw+","+igmapph+" offset: "+igmoffsetx+","+igmoffsety+" resx/y: "+iResX+","+iResY)->print;

public def getappcenter	{
	return igmappw/2, igmapph/2;
}
public int edgeex	{	iResX+igmoffsetx;	}
public int edgeey	{	iResY+igmoffsety;	}
//------------------ sciezki --------------------

public string getwinpath(string spath)	{
	string s = engine.getspecialpath("appdata");
	if( s!=null )	{
		s + "/" + sgmdeveloper + "/" + sgmproject + "/" + spath;
	} else spath;
}

public getsavepath	{
	if( .isapple )	{
		engine.getsavepath;
	} else {
		(igmwinlocal ?  .getwinpath("saves/") :  "saves/");	
	}
}

public buildsavedir	{
	if( igmwinlocal && !.isapple )	{
		string s = engine.getspecialpath("appdata");
		if( s!=null )	{
			s += "/" + sgmdeveloper;
			int odp = engine.mkdir(s);
			odp = 0;
			if( odp==0 || odp==1 )	{
				s +=  "/" + sgmproject;
				odp = engine.mkdir(s);
				odp = 0;
				if( odp==0 || odp==1 )	{
					s+= "/saves";
					_ = engine.mkdir(s);
				}
			}
		}
	}
}
.buildsavedir;

/******** konstrukcje  ********************/
new string	A = "!!!";
new real	PI = 3.14159265358979323846;
new int		BYTE0 = "0"->getbyte(0);
new int		BYTE9 = "9"->getbyte(0);
new int		BYTEa = "a"->getbyte(0);
new int		BYTEz = "z"->getbyte(0);
new int		BYTEA = "A"->getbyte(0);
new int		BYTEZ = "Z"->getbyte(0);
new int		BYTE_ = "_"->getbyte(0);
new int		BYTESPACE = " "->getbyte(0);

public empty_func	{}

public varget(string svar)				{	[svar];				}
public varset(string svar, def val)			{	<svar> = val;			}
public varnew(string styp, string svar)			{	new <styp> <svar>;	}
public varnewif(string styp, string svar)		{	if( !.hasvar(svar) )	.varnew(styp,svar);}
public vardelif(string svar)				{	if( .hasvar(svar) )	.vardel(svar);		}
public vardel(string svar)				{	delete <svar>;		}
public reader(string sname)	{
	.varnewif("def", sname);
	.addmethod( sname, func { [.methodname]; } );
}
public writer(string sname)	{
	.varnewif("def", sname);
	.addmethod( sname+"=", func { (def val) <.methodname->strsube(1)> = val; } );
}
public var(string sname)	{
	.reader(sname);
	.writer(sname);
}
public var2(string sname, def val)	{
	.var(sname);
	<sname> = val;
}
public withlist(string sfun)	{
	@s = _;
	while( A != s )	{
		.<sfun>(s);
		@s = _;
	}
}
public withlist2(string sfun)	{
	@s = _;
	while( A != s )	{
		@s1 = _;
		.<sfun>(s1,s);
		@s = _;
	}
}
public vars	{	.withlist("var");}
public vars2	{	.withlist2("var2");}

/*****************************************************/
public builder_func(string sfun)	{
	<.getbuildername>.<.getbuildername+sfun>;
}
public callfun(string sob, string sfun)	{
	if( sfun!=null ) sob==null ? .<sfun> : <sob>.<sfun>;
}
public string add_callfun(string spref, string sob, string sfun)	{ <gameapi.getgamename> (spref, sob, sfun) { (@spref, @sob, @sfun)
	@s = spref + "_callfun_";
	.vars2(A, s+"sob",sob, s+"sfun",sfun);
	.addmethod(s, func {
		@s = .methodname;
		.callfun( [s + "sob"], [s + "sfun"] );
		} );
	s;
}; }
public string fullname_callfun(string sob, string sfun)	{
	.add_callfun(.getfullname, sob, sfun);
}
public dprint(string smsg)	{
	int d = engine.getstack;
	("stack=" + d + " : " +smsg)->print;
}
public printargs(int ile)	{
	string sargs = "";
	while( ile>0 )	{
		def s = _;
		sargs = "(" + s.gettype + ") " + s + "  " + sargs;
		ile--;
	}
	engine.print("args: " + sargs);
}
/*****************************************************/
public bool in	{
	bool b = false;
	@x = .get;
	@y = _;
	while( A != y )	{
		if( !b )	b = x==y;
		@y=_;
	}
	b;
}
public with(string sfun)	{
	string sob = _;
	while( sob!=A )	{
		<sob>.<sfun>();
		sob=_;
	}
}
public copycall(string sfun, string sob)	{
	string s = "__call" + sfun;
	new string <s>;
	<s> = sob;
	.addmethod( sfun, func {
		string sf = .methodname;
		< [ "__call" + sf ] >.<sf>();
		});
}
public copycalls(string sobj)	{
	string s = _;
	while( s!=A )	{
		.copycall( s, sobj ); 
		s=_;
	}
}
/***********************************/
public mresize()	{	< .gettype + "_pack">::resizemethods( this );	}
/******** petle ********************/
public times(string sfun)		{	this.for_plus(0, this.get()-1, sfun );		}
public upto(int ito, string sfun)	{	this.for_plus( this.get(), ito, sfun );	}
public downto(int ito, string sfun)	{	this.for_minus( this.get(), ito, sfun );	}
public for_plus(int ifrom, int ito, string sfun)	{
	if( ito-ifrom<=0 )	return;
	for( ; ifrom<=ito; ifrom++)	this.<sfun>(ifrom);
}
public for_minus(int ifrom, int ito, string sfun)	{
	if( ifrom-ito<=0 )	return;
	for( ; ifrom>=ito; ifrom--)	this.<sfun>(ifrom);
}
public double_for(int w, int h, string sfun)	{
	int j;
	for( int i=0; i<w; i++)	{
		for( j=0; j<h; j++)	{
			this.<sfun>(i,j);
		}
	}
}
/****************************************/

// klasa do np. dynamicznego tworzenia obiektow z prefixem+id
class classobjcounter	{
	init(string sprefix)	{
		new string _sprefix=sprefix;
		new int _iile=0;
		.var2("limit",0);
	}
	string get()	{
		if( limit>0 ) _iile=_iile%limit+1;
		else _iile++;
		return _sprefix + (_iile-1);
	}
	int size()	{_iile;}
	int getid(int id)	{	_sprefix + (_iile-1-id);	}
}

/*class classvsigobj	{
	init()	{
		new bool bplaying=false;
	}
	virtual play()	{	bplaying=true;	}
	virtual stop(bool bstop)	{ 
		bplaying=false;
		if( bstop )	{	this.onfinish();	}
	}
	virtual bool isplaying()	{	bplaying;	}
}*/

/***************************************************************************/

class classsignals	{
	init()	{}
	/********** std obj **********************/
	stdfinish(string sob) { <sob>.addmethod("onfinish",func { this.<this.getname()+"_FINISH">();}); }
	stdstart(string sob) { <sob>.addmethod("onstart",func { this.<this.getname()+"_START">(); }); }
	stdsigs(string sob)	{
		this.stdstart(sob);
		this.stdfinish(sob);
	}
	/********** anima **********************/
	buildanima(string san)	{
		this.stdsigs(san);
		<san>.addmethod("onendframe", func { this.<this.getname()+"_ENDFRAME">(); } );
	}
	/********** snd **********************/
	buildsnd(string ssnd)	{	this.stdsigs(ssnd);		}
	/********** timer **********************/
	buildtimer(string stimer)	{
		this.stdsigs(stimer);
		<stimer>.addmethod("ontick", func { this.<this.getname()+"_TICK">(); });
	}
	/********** button *******************/
	buildbut(string sbut)	{
		<sbut>.addmethod("onclick", func { this.<this.getname()+"_CLICK">(); });
		<sbut>.addmethod("onrel", func { this.<this.getname()+"_REL">(); });
		<sbut>.addmethod("onmoveon", func { this.<this.getname()+"_MOVEON">(); });
		<sbut>.addmethod("onmoveoff", func { this.<this.getname()+"_MOVEOFF">(); });
	}
}

/******************************************************************/

class classlocker	{
	init()	{
		new bool _block = true;
	}
	public lock()	{	_block=true;	}
	public unlock()	{	_block=false;	}
	public setlock(bool b)	{	_block=b;	}
	public bool getlock()	{	return _block;	}
	public bool unlocked	{	_block==false;	}
	public setaslocker(string sob)	{
		<sob>.addmethod("buildlocker", func { new bool _block=true; });
		<sob>.buildlocker;
		<sob>.addmethod("lock", "lock");
		<sob>.addmethod("unlock", "unlock");
		<sob>.addmethod("setlock", "setlock");
		<sob>.addmethod("getlock", "getlock");
		<sob>.addmethod("unlocked", "unlocked");
	}
}

/***************************************************************************/

module classdbreader	{
	init()	{
		new db dbl;
	}
	readdb( string sfunc )	{
		int id = 0;
		int ile = dbl.getrowsno();
		while( id < ile )	{
			this.<sfunc>( id );
			id++;
		}
	}
	readrow( string srow, string sfunc )	{
		int ipos = dbl.findbyrow( srow );
		if( ipos >= 0 )	{
			this.<sfunc>( ipos );
		}
	}
}

/***************************************************************************/


/***************************************************************************/
class collection	{
	init(string styp)	{	new string stype=styp;	}
	public string type()	{	stype;		}
}

class array : collection {
	init(string styp, int idimens, int isiz)	{
		collection::init(styp);
		new int idim = idimens;
		new int isize = isiz;
		new vector vec;
		vec.type(styp);
		if( idimens>0 && isiz>0 )	{
			//vec.resize( isiz.pow(isiz,idimens), 0 );
			vec.resize( isiz.pow(idimens), 0 );
		}
	}
	int getid()	{
		int pos=0;
		int dim=idim-1;
		while(dim>0)	{
			pos+=_;
			pos*=isize;
			dim--;
		}
		pos+_;
	}
	public def get()	{	vec.get( this.getid() );	}
	public set(def svar)	{	vec.set( this.getid(), svar);	}
	public int getsize()	{	isize;			}
	public int getdim()	{	idim;			}
}

class stack : collection	{
	init(string styp)	{
		collection::init(styp);
		new vector vec;
		vec.type(styp);
		new <styp> var;
	}
	public push(string svar){	vec.add(svar);		}
	public def top()	{	vec.last();	}
	public def pop()	{
		var = this.top();
		vec.removeat( vec.size()-1 );
		var;
	}
	public free	{	vec.free;	}
}

class map : collection	{
	init(string styp)	{
		collection::init(styp);
		new int isize=0;
	}
	set(string svar, def val)	{
		if( !this.hasvar("v"+svar) )	this.add(svar);
		<"v"+svar>.set(val);
	}
	add(string svar)	{	new <stype> <"v"+svar>;		}
	def get(string svar)	{	["v"+svar];		}
	remove(string svar)	{	delete <"v"+svar>;		}
	bool contains(string svar){	this.hasvar("v"+svar);	}
}
class map2 : collection	{
	init(string styp)	{
		collection::init(styp);
		new vector vn;
		vn.type("string");
		new vector vec;
		vec.type(styp);
	}
	add(string svar, def val)	{	vn.add(svar);	vec.add(val);	}
	set(string svar, def val)	{
		if( .contains(svar) )
			vec.set( vn.find(svar), val );
		else .add(svar,val);
	}
	bool contains(string svar)	{	vn.contains(svar);	}
	def get(string svar)		{	vec.get( vn.find(svar) );}
	calc(string svar, string satr, def val)	{
		@id = vn.find(svar);
		if( id>=0 )	{
			@v1 = vec.get(id);
			match(satr)	{
				"+" => .set(svar,v1+val);
				"-" => .set(svar,v1-val);
				"*" => .set(svar,v1*val);
				"/" => .set(svar,v1/val);
				"%" => .set(svar,v1%val);
				? => ;
			}
		}
	}
	remove(string svar)	{
		int id = vn.find(svar);
		if( id>=0 )	{
			vec.removeat( id );
			vn.removeat(id);
		}
	}
	free()	{	vn.free();	vec.free();	}
	print	{
		for( int i=0; i<vn.size; i++ )	{
			(vn.get(i) + ": " + vec.get(i))->print;
		}
	}
}


/***************************************************************************/

class Music	{
	init	{
		new vector vmus;
		vmus.type("string");
		new int ilastid;
		.vars2(A, "musicvolume", 100, "globalvolume", 100);
		new string smixer = "gameapi";
		//onmusicfin      {       mus.play;       }
	}
	smixer	{	 smixer;	}
	smixer=(string s)	{
		smixer = s;
		.updatevolume;
	}
	playdb(string s, int row, int icol)	{
		vmus.free;
		while (icol < <s>.getcolsno(row) )	{
			vmus.add( <s>.get(row, icol) );
			icol++;
		}
		ilastid = 0;
		.play;
	}
	playvec(string s, int id)	{
		vmus.free;
		while( id< <s>.size )	{
			vmus.add( <s>.get(id) );
			id++;
		}
		ilastid = 0;
		.play;
	}
	playstr(string s)	{
		vmus.vecbuildfromstring(s, " ");
		ilastid = 0;
		.play;
	}
	play	{
		if( ilastid >= vmus.size ) return;
		
		string s = MUSICPATH + vmus.get(ilastid);
		if( s.gete(0,3)!="ogg" && s.gete(0,3)!="wav" ) s+=".ogg";
		if( !engine.fileexist(s) )	{
			s = SFXPATH + vmus.get(ilastid);
		}
		
		ilastid++;
		
		bool bloop=false;
		int fin=0;
		int fout = 0;
		musicvolume = globalvolume;
		
		for( int i=ilastid; i<vmus.size; i++)	{
			@s1 = vmus.get(i);
			match(s1)	{
				"-l" => bloop = true;
				"-v", "-vol" => { i++;
					musicvolume = vmus.get(i);
					}
				"-fin" => { i++; fin = vmus.get(i); }
				"-fout" => { i++; fout = vmus.get(i); }
				"-p" => ;
				? => { ilastid=i; i = vmus.size; }
			}
		}
		.updatevolume;
		if( bloop ) {
			ilastid = vmus.size;
			if( smixer=="engine" && engine.ismusicplaying && engine.getactmusic==s ) {
			} else {
				<smixer>.playmusic(s);
			}
		} else {
			<smixer>.loadmusic(s);
			if (fin) <smixer>.fadeinmusic(fin);
			else {
				<smixer>.startmusic;
			}
			if (fout) <smixer>.fadeoutmusic(fout);
		}
	}
	getvol	{	(globalvolume * musicvolume) / 100;	}
	fadeout(int ms)	{
		if( <smixer>.ismusicplaying ) {
			<smixer>.fadeoutmusic(ms);
			ilastid=vmus.size;
		}
	}
	updatevolume	{
		<smixer>.setmusicvol(.getvol);
	}
	isplaying	{	<smixer>.ismusicplaying;	}
	getactmusic	{	engine.getactmusic;	}
	stop	{
		<smixer>.endmusic(false);
	}
}

/**************************************************************/
	// zmienne globalna - stany gry

new int igmstate;
new string sgmstate;
public printstate	{	("sgmstate = "+sgmstate + " ,  igmstate = "+igmstate)->print;}

new bool igmdemo = .readcfg("igmdemo:",false);
new bool igmbegin = true;
new bool igmsoundson = .readcfg("igmsoundson:",true);

new string sgmfontfile = .readcfg("sgmfontfile:", "configs/fonts/normal.ttf");
new string sgmfontmono = .readcfg("sgmfontmono:", "configs/fonts/normal.ttf");
new string sgmfontmonobold = .readcfg("sgmfontmonobold:", "configs/fonts/normal.ttf");
new string sgmfontbold = .readcfg("sgmfontbold:", "configs/fonts/normal.ttf");
new string sgmfontitalic = .readcfg("sgmfontitalic:", "configs/fonts/normal.ttf");

new string SFXPATH = .readcfg("sfxpath:", "sounds/sfx/");
new string BGRPATH = .readcfg("sndbgrpath:", "sounds/sfx/");
new string MUSICPATH = .readcfg("musicpath:", "sounds/music/");

new string LANG;
new string LANGDIR;
new string SNDPATH;

public LANG=(@s)	{
	LANG = s;
	SNDPATH = "sounds/" + LANG + "/";
	LANGDIR = "lang/" + LANG + "/";
}

.LANG = (.readcfg("lang:", "eng"));

/**************************************************************/
	// standardowa klasa do tworzenia zmiennych
class newvars		{
	init()	{
		new string _sclpath = "";
		new string _sclwavpath = "";
	}
	string _checkfont(string sfont, int isize, string sfnt)	{
		if( sfont==null )	sfont=sgmfontfile;
		if( sfont.contains(".ttf") )	{
			new font <sfnt>;
			<sfnt>.load( sfont, isize );
			sfont = sfnt;
		}
		sfont;
	}
	string checkfont(string sfont, int isize)	{
		._checkfont(sfont, isize, "_fnt");
	}
	bool begingame()	{
		igmbegin = !igmbegin;
		!igmbegin;
	}
	newarray(string styp, string sbase, int size)	{
		if( size<= 0 )	return;
		size--;
		while(size>=0)	{
			new <styp> <sbase+size>;
			size--;
		}
	}
	setgraphpath(string spath)	{
		_sclpath = spath;
		engine.setpath(spath);
	}
	setwavpath(string spath)	{	_sclwavpath = spath; }
	string getgraphpath()	{	_sclpath; }
	string getsndpath()	{	_sclwavpath; }
	getpath(string sfile)	{
		if( sfile.getb(0,1)=="$" ) sfile.strsubb(1);
		else .getgraphpath + sfile;
	}
	pathload(string sfile)	{	.load(.getgraphpath + sfile);	}
	newanima(string sname, string sfile, int z)	{
		new anima <sname>;
		if( sfile.gete(0,4)!=".pyz" )
			sfile += ".pyz";
		@s = .getpath(sfile);
		<sname>.load( s );
		if( igmdebug )	{
			if( igmexportan )	{
				<sname>.saveimages("debug/" + s.getb(0, s.length-s.strgeteto("/")->length) + 
					s.strgeteto("/")->strsubes(".pyz") + "/" );
			} else if( igmimportan )	{
				s = "debug/" + s.strsubes(".pyz") + "/";
				if( engine.fileexist( s + "0.png") )	{
					<sname>.loadimages( s );
				}
			}
		}
		<sname>.setz(z);
	}
	newstdanima(string sname, string sfile, int z)	{
		this.newanima(sname, sfile, z);
		this.stdanaction(sname);
	}
	copyanimaactz(string ssrc, string sdest, string saction, int z)	{
		this.copyanimaact(ssrc, sdest, saction);
		<sdest>.setz(z);
	}
	copyanimaact(string ssrc, string sdest, string saction)	{
		this.copyanima(ssrc, sdest);
		<sdest>.setframe( saction, 0 );
	}
	copyanima(string ssrc, string sdest)	{
		new anima <sdest>;
		<sdest>.copy( ssrc );
	}
	copyanimas(string san, string sname, int istart, int ilosc)	{
		if (ilosc>0)	{
			for(int i=0; i<ilosc; i++)
				this.copyanima( san, sname + (istart + i)  );
		}
	}
	newanimas(string sname, string sfile, int z, int ilosc)	{
		if(ilosc>0) {
			this.newanima(sname+"0", sfile, z);		// pierwsza load z zerem
			this.copyanimas(sname+"0", sname, 1, ilosc-1);		// pozostale kopiowane z niej
		}
	}
	int newanframesgr(string san, string sname, int iaction, string sgr)	{	// tworzy animacje z klatek
		int ile = <san>.nofframes( iaction );
		this.copyanimas( san, sname, 0, ile );
		for(int i=0; i<ile; i++)	{
			<sname+i>.setframe(iaction, i);
			if( sgr!=null )	{	<sgr>.add( sname+i );	}
		}
		ile;		// zwraca ilosc stworzonych animacji
	}
	int newanframes(string san, string sname, int iaction)	{	// tworzy animacje z klatek
		this.newanframesgr(san,sname,iaction,null);
	}
	newcanvas(string sname, int w, int h, int r, int g, int b, int a, int z)	{
		new img <sname>;
		<sname>.create(w,h,r,g,b,a);
		<sname>.setz(z);
	}
	newimg(string sname, string sfile, int z)	{
		new img <sname>;
		<sname>.load( .getpath( sfile ) );
		<sname>.setz(z);
	}
	copyimg(string ssrc, string sdest)	{
		new img <sdest>;
		<sdest>.copy(ssrc);
	}
	playmusic(string sfile)	{gameapi.playmusic( MUSICPATH + sfile );	}
	snewsnd(string sname, string sfile)	{
		this.newsnd(sname,sfile);
		<sname>.addmethod("onfinish","__std_finish");
	}
	_newsnd(string sname, string sfile, bool bfree)	{
		new snd <sname>;
		if( !sfile.contains(".") ) {
			sfile += ".wav";
		}
		if( !engine.fileexist(sfile) )	{
			sfile = sfile.strsubes("wav") + "ogg";
		}
		if( bfree )
			<sname>.setstartstopflag(false, true);
		<sname>.load( sfile );
		if( igmsubtitle )	{
			subtitle.register(sname, sfile);
		}
	}
	newsfx(string sname, string sfile)	{	._newsnd(sname, SFXPATH + sfile, false);	}
	newbgr(string sname, string sfile)	{	._newsnd(sname, BGRPATH + sfile, false);	}
	newbgrloop(string s, string s2)		{	.newbgr(s,s2); .sndplayloop(s);	}
	newsnd(string sname, string sfile)	{	._newsnd(sname, .getsndpath+sfile, false);	}
	newsndfree(string sname, string sfile)	{	._newsnd(sname, .getsndpath+sfile, true);	}
	newsndloop(string sname, string sfile)	{
		this.newsnd(sname,sfile);
		this.looponfinish1( sname );
	}
	looponfinish1( string sob )	{<sob>.addmethod("onfinish","_stdsndloop");	}
	sndplayloop(string sob)	{
		this.looponfinish1( sob );
		<sob>.play();
	}
	newsnds(string sbase, int inamestart, string sfilebase, int ifilefrom, int ifileto)	{
		string s;
		int ile = ifileto-ifilefrom+1;
		for(int i=0; i<ile; i++)	{
			s = sbase + (inamestart + i);
			new snd <s>;
			<s>.load( this.getsndpath() + sfilebase + (ifilefrom+i) + ".wav" );
		}
	}
	newtimer(string sname, int idelay, int iticks)	{
		new timer <sname>;
		<sname>.settick(iticks);
		<sname>.delay(idelay);
	}
	newtimercycle(string sname, int icycle, int iticks)	{
		new timer <sname>;
		<sname>.settick(iticks);
		<sname>.setcycle(icycle);
	}
	stdanaction(string san)	{
		string s = <san>.actionname();
		if( s.contains("L")  )	this.looponfinish(san);
		else if( s.contains("H")  )	this.hideonfinish(san);
		if( s.contains("P")  )	<san>.play(-1);
	}
	int newanactionsgr(string san, string sname, string sgr)	{
		int ile = <san>.nofactions();
		this.copyanimas( san, sname, 0, ile );
		string s;
		for(int i=0; i<ile; i++)	{
			s = sname+i;
			<s>.setframe(i,0);
			this.stdanaction(s);
			if( sgr!=null )	{<sgr>.add( s );}
		}
		ile;
	}
	int newanactions(string san, string sname)	{ this.newanactionsgr(san,sname,null);	}
	int newanfrbyactgr(string san, string sname, string sgr)	{
		int ile = <san>.nofactions();
		for( int i=0; i<ile; i++)	_ = this.newanframesgr(san, sname+i+"_", i, sgr);
		ile;
	}
	int newanfrbyact(string san, string sname)	{ this.newanfrbyactgr(san,sname,null);	}
	int loadanfrbyact(string san, string sfile, int z)	{
		string s = "_"+san;
		this.newanima(s,sfile,z);
		int ile = this.newanfrbyact(s, san);
		<s>.hide();
		ile;
	}
	int loadanactions(string san, string sfile, int z)	{
		string s = "_"+san;
		this.newanima(s, sfile, z);
		int ile = this.newanactions(s, san);
		<s>.hide();
		ile;
	}
	int loadanframes(string san, string sfile, int iaction, int z)	{
		string s = "_"+san;
		this.newanima(s, sfile, z);
		int ile = this.newanframes(s, san, iaction);
		<s>.hide();
		ile;
	}
	newbutimg(string sbut, string sstd, string smov, string sclick, string smouse)	{
		new button <sbut>;
		<sbut>.set(sstd, smov, sclick);
		<sbut>.setmouse(smouse);
	}
	newbutan(string sbut, string sanstd, string sanmov, string sanclick, string smouse)	{
		new button <sbut>;
		<sbut>.setan(sanstd, sanmov, sanclick);
		<sbut>.setmouse(smouse);
	}
	/*****************************************************/
	newdb(string sdb, string sfile)	{
		new db <sdb>;
		<sdb>.load( .getpath(sfile) );
	}
	newdbscript(string sdb, string sfile)	{
		new db <sdb>;
		//<sdb>.loadscript( this.getgraphpath() + sfile );
		<sdb>.loadscritp( .getpath(sfile) );
	}
	vargmset(string svar, def val)	{
		string sg = gameapi.getgamename();
		if( !<sg>.hasvar(svar) )	<sg>.varnew( val.gettype(), svar );
		<svar> = val;
	}
}


new anima anmsc;

class classadvmouse	{
	init()	{
		//new anima anmsc;
		new string sactac;
	}
	public load(string sname)	{
		anmsc.load(sname);
		anmsc.addmethod("onendframe", "setnextframe");
		anmsc.addmethod("onsetframe", func { .hide; } );
		anmsc.hide();
	}
	public stdload	{
		if( !igmdebug && .checktouchpad )	.load("scripts/common/kursorypad.pyz");
		else .load("scripts/common/cursors.pyz");
	}
	setnextframe	{
		anmsc.ansetnextfr;
		mouse.setcursor("anmsc");
	}
	setif(string sac)	{
		if( .get!=sac )
			.set(sac);
	}
	set(string saction)	{
		sactac = saction;
		//anmsc.setframe( saction, 0 );
		if( !anmsc.isplaying( saction ) )	{
			anmsc.play( saction );
		}
		mouse.setcursor("anmsc");
	}
	setstd()	{	this.set("normal");	}
	setactive()	{	this.set("active");	}
	setact()	{	this.set("active");	}
	setbut		{	this.set("active");	}
	setexit()	{	this.set("exit");	}
	setwait()	{	this.set("wait");	}
	get()		{	anmsc.actionname();	}
	lodx	{	anmsc.lodx;	}
	lody	{	anmsc.lody;	}
	refresh	{ if( sactac!=null ) .set(sactac);	}
}

new classadvmouse advmouse;
advmouse.stdload;

if( !.checktouchpad )	{
	advmouse.setstd;
	engine.stdbutcursor("anmsc");
}

/***************************************************************************/

module clsurf	{
	init()	{}
	bool isin(int x, int y, int x1, int y1, int x2, int y2)	{	x >= x1 && x<=x2 && y>=y1 && y<=y2;	}
	bool isin2(int x, int y, int x1, int y1, int w, int h)	{	x >= x1 && x < x1+w && y>=y1 && y<y1+h;	}
	bool inscreen(int x, int y, int dx, int dy)	{	this.isin( x, y, 0-dx, 0-dy, 800+dx, 600+dy );	}
	bool insurf(int x, int y, string simg) { .isin(x,y,<simg>.getpx, <simg>.getpy, <simg>.getex-1, <simg>.getey-1);}
	bool issurfin(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)	{
		this.isin(x1,y1, x3,y3,x4,y4) || this.isin(x2,y1, x3,y3,x4,y4) ||
		this.isin(x1,y2, x3,y3,x4,y4) || this.isin(x2,y2, x3,y3,x4,y4) ||
		( x1<x3 && x2>x4 && y1<y3 && y2>y4 );
	}
	bool commonsurface(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)	{
		this.issurfin(x1,y1,x2,y2, x3,y3,x4,y4) || 
				this.issurfin(x3,y3,x4,y4, x1,y1,x2,y2);
	}
	bool commonimgs(string simg1, string simg2)	{
		this.commonsurface(<simg1>.getpx(), <simg1>.getpy(), <simg1>.getex()-1, <simg1>.getey()-1,
				<simg2>.getpx(), <simg2>.getpy(), <simg2>.getex()-1, <simg2>.getey()-1 );
	}
	bool commonimgsurf(string simg, int x1,int y1,int x2,int y2)	{
		.commonsurface(<simg>.getpx, <simg>.getpy, <simg>.getex-1, <simg>.getey-1, x1, y1, x2, y2 );
	}
	bool surfwithinsurf(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)	{
		this.isin(x1,y1, x3,y3,x4,y4) && this.isin(x2,y1, x3,y3,x4,y4) &&
				this.isin(x1,y2, x3,y3,x4,y4) && this.isin(x2,y2, x3,y3,x4,y4);
	}
	bool imgwithinimg(string simg1, string simg2)	{
		this.surfwithinsurf(<simg1>.getpx(), <simg1>.getpy(), <simg1>.getex()-1, <simg1>.getey()-1,
				<simg2>.getpx(), <simg2>.getpy(), <simg2>.getex()-1, <simg2>.getey()-1 );
	}
}

/* modul do obliczen odleglosci */

module cllen	{
	init()	{
		new int il1;
		new int ilx;
		new int ily;
	}
	int ilenx()	{ ilx; }
	int ileny()	{  ily; }
	int ilen4(int x1, int x2)	{	(x1-x2)->abs();	}
	int ilen3(string simg1, string simg2)	{
		return this.ilen( <simg1>.getcx(), <simg1>.getcy(), <simg2>.getcx(), <simg2>.getcy() );
	}
	int ilen5(string simg1, string simg2)	{
		this.ilen( <simg1>.getpx(), <simg1>.getpy(), <simg2>.getpx(), <simg2>.getpy() );
	}
	int ilen2(string simg1, int x, int y)	{ this.ilen( <simg1>.getcx(), <simg1>.getcy(), x,  y );	}
	int ilen(int x1, int y1, int x2, int y2)	{
		ilx = x1-x2;
		ily = y1-y2;
		il1.length( ilx, ily );
	}
	int iclenx(string simg1, int x)	{	<simg1>.getcx() - x;	}
	int iclenx2(string simg1, string simg2)	{	<simg1>.getcx() - <simg2>.getcx();	}
	int icleny(string simg1, int y)	{	<simg1>.getcy() - y;	}
	int icleny2(string simg1, string simg2)	{	<simg1>.getcy() - <simg2>.getcy();	}
	int isbetween2(string simg1, string simg2, int x1, int y1, int x2, int y2)	{
		this.isbetween(simg1, <simg2>.getcx(), <simg2>.getcy(), x1, y1, x2, y2);
	}
	int isbetween(string simg1, int xx, int yy, int x1, int y1, int x2, int y2)	{
		il1 = this.ilen( simg1, xx, yy );
		ilx>=x1 && ilx<=x2 && ily>=y1 && ily<=y2;
	}
	int ilodlen(string s1, string s2)	{	.ilen(<s1>.lodx,<s1>.lody, <s2>.lodx, <s2>.lody);	}
	int iposlen(string simg1, string simg2)	{
		.ilen( <simg1>.getpos, <simg2>.getpos );
	}
}

/****************************************************/
class classansearcher	{
	init()	{}
	def _findnotr(string san, int x, int y, int dx, int dy)	{
		int ex = <san>.getex() , int ey = <san>.getey();
		while( x!=ex && y!=ey )	{
			if( <san>.isin(x,y,false,true) ) return x,y;
			x+=dx;	y+=dy;
		}
		return -1,-1;
	}
	def firstnotrx1y(string san)	{	return ._findnotr(san,<san>.getpx(), <san>.getpy(), 1, 0);	}
	def firstnotrexy1(string san)	{	return ._findnotr(san,<san>.getex()-1, <san>.getpy(), 0, 1);	}
	def firstnotrxy1(string san)	{	return ._findnotr(san,<san>.getpx(), <san>.getpy(), 0, 1);	}
	def firstnotrx1ey(string san)	{	return ._findnotr(san,<san>.getpx(), <san>.getey()-1, 1, 0);	}
}

public def anfindnotr(int x, int y, int dx, int dy)	{
		int ex = .getex() , int ey = .getey();
		while( x!=ex && y!=ey )	{
			if( .isin(x,y,false,true) ) return x,y;
			x+=dx;	y+=dy;
		}
		return -1,-1;
	}
public def anfindalfa(int x, int y, int dx, int dy, int alfa)	{
		int ex = .getex() , int ey = .getey();
		while( x!=ex && y!=ey )	{
			if( .isin(x,y,false,true) ) {
				|_,_,_,int a| = .getrgba(x,y);
				if( a == alfa )
					return x,y;
			}
			x+=dx;	y+=dy;
		}
		return -1,-1;
	}
public def anfirstnotrx1y	{	return .anfindnotr(.getpx(), .getpy(), 1, 0);	}
public def anfirstnotrexy1	{	return .anfindnotr(.getex()-1, .getpy(), 0, 1);	}
public def anfirstnotrxy1	{	return .anfindnotr(.getpx(), .getpy(), 0, 1);	}
public def anfirstnotrx1ey	{	return .anfindnotr(.getpx(), .getey()-1, 1, 0);	}

class signal_pack	{
	init()	{}
	addsignals(string san)	{
		<san>.addmethod("operator<", func { (string sfun) this.addmethod("onfinish", sfun ); } );
	}
}
/***************************************************************************/
class ImagePos	{
	init	{}
	getex	{	.getpx + .getw;	}
	getey	{	.getpy + .geth;	}
	getcx	{	.getpx + .getw/2;	}
	getcy	{	.getpy + .geth/2;	}
	setpos(int x, int y)	{	.move(x-.getpx, y-.getpy);	}
}
class ImageVisible	{
	init	{
		new bool _isvisible=1;
	}
	isvisible	{	_isvisible;	}
	show		{	_isvisible=1;	}
	hide		{	_isvisible=0;	}
}
class Image	{
	init	{}
	public resizemethods(string sob)	{
		<sob>.vars2(A, "getz",0, "getpx",0, "getpy",0, "getw",0, "geth",0, "isvisible", 0);
		<sob>.addmethod("show", func { isvisible=1; }	);
		<sob>.addmethod("hide", func { isvisible=0; }	);
		<sob>.addmethod("setz", func { (int z) getz=z; } );
		<sob>.addmethod("setpos", func { (int x, int y) getpx=x; getpy=y; } );
		<sob>.addmethod("move", func { (int x, int y) getpx+=x; getpy+=y; } );
		<sob>.addmethod("getex", func { getpx+getw; } );
		<sob>.addmethod("getey", func { getpy+geth; } );
		<sob>.addmethod("getcx", func { getpx+getw/2; } );
		<sob>.addmethod("getcy", func { getpy+geth/2; } );
		<sob>.addmethod("isin", func { (int x, int y, int bv, int ba)
			if( !ba ) {
				if( !bv || (bv&&isvisible) )	{
					x>=getpx && x<.getex && y>=getpy && y<.getey;
				} else 0;
			} else 0;
			} );
	}
}
	// rozszerzenia dla animcaji
class anima_pack : signal_pack	{
	init()	{}
	public resizemethods(string san)	{
		<san>.addmethod("_clanbuildpomvars", func { new int _ixp; new int _iyp; } );
		<san>._clanbuildpomvars();
		<san>.addmethod("setbpos", func {(int x, int y) .setpos( x-.lodx, y-.lody ); });
		<san>.addmethod("saverelpos", func {(int x,int y)_ixp=x-.getpx;_iyp=y-.getpy;} );
		<san>.addmethod("setrelpos", func{(int x, int y) .setbpos( x - _ixp, y - _iyp );});
		<san>.addmethod("mssaverelpos", func {.saverelpos( mouse.getpos );} );
		<san>.addmethod("mssetrelpos", func {.setrelpos( mouse.getpos );});
		<san>.addmethod("rplay", func {(string sact)if( !.isplaying(sact) ) .play(sact);});
		<san>.addmethod("setcpos", func {(int x, int y).setbpos( x-.getw/2, y-.geth/2 );});
		<san>.addmethod("operator=", func { (string s) .copy(s); } );
		<san>.addmethod("operator==", func { (string s)
			.actionnr==<s>.actionnr && .framenr==<s>.framenr; } );
		this.addsignals(san);
	}
}

class timer_pack : signal_pack	{
	init()	{}
	resizemethods(string sob)	{
		this.addsignals(sob);
	}
}
/***************************************************************************/
class vector_pack	{
	init()	{}
	each(string sfun)	{	for( int i=0; i<.size; i++) this.<sfun>(.get(i));	}
	resizemethods(string svec)	{
		<svec>.addmethod("each", "each");
		<svec>.addmethod("operator-", func { (def x) this.remove(x); this; } );
		<svec>.addmethod("operator+", func { (def x) this.add(x); this; } );
	}
}

/***************************************************************************/

public new_object(string styp, string sob)	{
	new <styp> <sob>;
	<styp+"_pack">::resizemethods(sob);
}
public new_anima(string s)	{	.new_object("anima",s);	}
public new_vector(string s)	{	.new_object("vector",s);	}

/***************************************************************************/

class classanfilter	{
	init()	{}
	buildanfilter()	{
		new filter ft;
		ft.link( this.getname() );
		ft.setpivottype(1);
	}
	public build(string san)	{
		<san>.addmethod("buildanfilter","buildanfilter");
		<san>.buildanfilter();
		<san>.addmethod("setopacity",	func {	(int iop) ft.setopacity(iop); }		);
		<san>.addmethod("setzoom",		func {	(real r) ft.setzoom(r); }			);
		<san>.addmethod("setangle",		func {	(real r) ft.setangle(r); }			);
		<san>.addmethod("getangle",		func {	return ft.getangle; }			);
		<san>.addmethod("rotate",		func {	(real r)	ft.rotate(r); }			);
		<san>.addmethod("setpivottype",	func {	(int ityp) ft.setpivottype(ityp); }	);
		<san>.addmethod("unlink",		func {	ft.unlink(); }					);
		<san>.addmethod("link",			func {	ft.link(this); }					);
		<san>.addmethod("blend",		func {	(string s) ft.blend(s); }			);
		<san>.addmethod("mask",		func {	(string s) ft.mask(s); }			);
	}
}

/***************************************************************************/

class classancounter	{
	init()	{
		new int iile;
		new int id;
		new string _san;
		new vector _vs;
		new int _pos;
	}
	set(string sname, int ile)	{
		_san = sname;
		iile = ile;
		id = 0;
		_pos = sname.length();
		_vs.resize( ile, false );
	}
	string get()	{
		string s = _san+id;
		id = (id+1)%iile;
		return s;
	}
	string getf()	{
		for(int i=0; i<iile; i++)	{
			if( !_vs.get(i) )	{
				_vs.set(i, true);
				return _san+i;
			}
		}
		return null;	// brak wolnych
	}
	retf(string s)	{	_vs.set( s.strsubbs( _san ), false );	}
	isfree(int pos)	{	return _vs.get(pos);	}
	int getile()	{	return iile;	}
	bool allfree	{	_vs.vecsum==0; }
}

/**************************************************************/
	// operacje na obrazach, dzwiekach, timerach i animacjach
class gmobjvec {
	init()	{
		new vector lsim;
		lsim.type("string");
	}
	operator=(string sgr)	{
		if( engine.varexist(sgr) )	{
			match(<sgr>.gettype())	{
				"vector" => this.copy(sgr);
				"gmobjvec" => this.copy(sgr);
				"gmimgvec" => this.copy(sgr);
				? => {	this.free(); this.add(sgr); }
			}
		} else {
			this.free();
			this.add(sgr);
		}
	}
	save(string s)	{	if( igmenablesave ) lsim.save(s);	}
	load(string s)	{	lsim.load(s);	}
	operator+(string sob)	{	this.add(sob);		this;	}
	operator-(string sob)	{	this.remove(sob);	this;	}
	removegr(string sgr)	{	for( int i=0; i < <sgr>.size; i++)	.remove( <sgr>.get(i) );	}
	addtogr(string sgr)	{	for( int i=0; i<this.size(); i++)	<sgr>.add(this.get(i));	}
	addgr(string sgr)	{	for( int i=0; i< <sgr>.size(); i++)	this.add( <sgr>.get(i) );	}
	addgroups	{	.withlist("addgr");	}
	copy(string sgr)	{
		this.free();
		this.addgr(sgr);
	}
	free()	{ lsim.free();	}
	int size()	{ 	lsim.size;	 }
	bool empty()	{	.size==0;	}
	hash()	{ lsim.hash(); }
	string first()	{ lsim.get(0); }
	string last()	{ lsim.get( lsim.size-1 ); }
	print()	{
		engine.print("");
		engine.print("------ type("+.gettype+") " + this + " ------");
		lsim.print();
		engine.print("------ end ------");
		engine.print("");
	}
	string get(int i)	{	lsim.get(i);	}
	set(int pos, string sval)	{	lsim.set(pos,sval);	}
	add(string simg)	{	lsim.add(simg);	}
	additer(string s, int ifrom, int iile)	{
		while( iile>0 )	{
			.add(s+ifrom);
			ifrom++;
			iile--;
		}
	}
	buildarray(string styp, string sname, int ilosc)	{
		<gameapi.getgamename>.newarray(styp,sname,ilosc);
		.additer(sname,0,ilosc);
	}
	deleteall	{	for( int i=0; i<.size; i++)	delete <.get(i)>;	}
	deleteallgm	{
		@s = gameapi.getgamename;
		for( int i=0; i<.size; i++)	<s>.vardel(.get(i));
	}
	deleteallgmobj	{
		@s = gameapi.getgamename;
		for( int i=0; i<.size; i++)	<s>.deletegmobj(.get(i));
	}
	pause	{	.eval("pause");	}
	resume	{	.eval("resume");	}
	lockall	{	.eval("lock");	}
	unlockall	{	.eval("unlock");	}
	addbegin(string simg)	{	lsim.addbegin(simg);	}
	swap(int i, int j)	{	lsim.swap(i,j);	}
	addonce(string simg)	{	if( !lsim.contains(simg) )	lsim.add(simg);	}
	sepadd(string separator)	{
		string s = _;
		while( s!=separator )	{
			this.addbegin(s);
			s = _;
		}
	}
	addlist	{	.sepadd(A);	}
	removelist	{ .withlist("remove");	}
	insertat(string sob, int pos)	{
		@ile = .size;
		if( pos<=0 )	.addbegin(sob);
		else if (pos>=ile)	.add(sob);
		else {
			.add(null);
			for( @i=ile; i>pos; i--)	.set( i, .get(i-1) );
			.set(pos, sob );
		}
	}
	remove(string simg)	{	lsim.remove(simg);	}
	removeat(int pos)		{	lsim.removeat(pos);	}
	removefirst			{	lsim.removeat(0);	}
	removelast			{	lsim.removeat(.size-1);	}
	removealloccurs(string simg)	{	while(this.contains(simg))	this.remove(simg);	}
	removeif(string sfun)	{
		for( int i=0; i<.size; i++)
			if( <.get(i)>.<sfun>() )  .removeat(i);
	}
	int find(string simg)		{	lsim.find(simg);	}
	int contains(string simg)	{	lsim.contains(simg);	}
	addgroup(string sob, int ile)	{	.addgroup2( sob, 0, ile-1 );	}
	addgroup2(string sob, int ifrom, int ito)	{
		while( ifrom <= ito )	{
			this.add( sob+ifrom );
			ifrom++;
		}
	}
	string rand()	{
		int ile = .size;
		ile>0 ? .get(ile.rand) : null;
	}
	string randdiff(string s)	{
		int ile = .size;
		if( ile>0 )	{
			int id = ile.rand;
			int i = id;
			while( .get(id)==s )	{
				id = (id+1)%ile;
				if( id==i )	return null;
			}
			.get(id);
		} else
			null;
	}
	buildfullvars	{	.each( func { (@id) .buildfullname; } );	}
	buildvars		{	.each( func { (@id) .addtogamevars(this); } );	}
	/******************* metody na obiektach grupy *****************************/
	movefrom(string simg, int x, int y)	{
		int i = this.find(simg);
		if( i>=0 )	{
			while( i<lsim.size() )	{
				<lsim.get(i)>.move(x,y);
				i++;
			}
		}
	}
	move(int x, int y)	{	this.eval2("move",x,y);	}
	setpos(int x, int y)	{	this.eval2("setpos",x,y);	}
	show()	{	this.eval("show");	}
	hide()	{	this.eval("hide");	}
	stop(int fin)	{	this.eval1("stop",fin);	}
	play()	{	this.eval("play");	}
	setdelay(int d)	{	this.eval1("setdelay",d);	}
	isplaying	{
		for( int i=0; i<.size; i++)	if( <.get(i)>.isplaying(-1) ) return true;
		false;
	}
	graddmethod(string sdest, string ssrc)	{	this.eval2("addmethod",sdest,ssrc);	}
	string getimg(int x, int y, int bignorehidden, int bignorealpha)	{
		for( int i=lsim.size()-1; i>=0; i--)	{
			if( <lsim.get(i)>.isin( x,y,bignorehidden,bignorealpha ) )	return lsim.get(i);
		}
		return null;
	}
	int isin(int x, int y, bool bignorehidden, bool bignorealpha)	{
		for( int i=lsim.size()-1; i>=0; i--)	{
			if( <lsim.get(i)>.isin( x,y,bignorehidden,bignorealpha ) )	return i+1;
		}
		return false;
	}
	int isroundin(int x, int y, bool bh, bool ba)	{
		string s;
		for( int i=lsim.size()-1; i>=0; i--)	{
			s = lsim.get(i);
			if( <s>.isin(x,y,bh,ba) || <s>.isin(x-1,y,bh,ba) || <s>.isin(x+1,y,bh,ba) ||
				<s>.isin(x,y-1,bh,ba) || <s>.isin(x,y+1,bh,ba) )	
				return i+1;
		}
		false;
	}
	setframe(def ac, int ifr)	{	this.eval2("setframe",ac,ifr);	}
	setz(int z)	{	this.eval1("setz",z);	}
	/**************/
	eval(string sfunc)	{
		for(int i=0; i<lsim.size(); i++)	{<lsim.get(i)>.<sfunc>();	}
	}
	eval1(string sfunc, def darg)	{
		for(int i=0; i<lsim.size(); i++)	{<lsim.get(i)>.<sfunc>(darg);}
	}
	eval2(string sfunc, def darg1, def darg2)	{
		for(int i=0; i<lsim.size(); i++)	{<lsim.get(i)>.<sfunc>(darg1, darg2);}
	}
	eval3(string sfunc, def darg1, def darg2, def darg3)	{
		for(int i=0; i<lsim.size(); i++)	{<lsim.get(i)>.<sfunc>(darg1, darg2, darg3);}
	}
	int _find(string sfun, def id)	{
		for( int i=0; i<this.size; i++) if ( <this.get(i)>.<sfun>()==id ) return i;
		-1;
	}
	int _find1(string sfun, @id)	{
		for( int i=0; i<.size; i++) if ( <this.get(i)>.<sfun>(id) ) return i;
		-1;
	}
	each(string sfun)	{	for( int i=0; i<.size; i++) <.get(i)>.<sfun>(i);	}
	each1(string sfun, @d1)	{	for( int i=0; i<.size; i++) <.get(i)>.<sfun>(i, d1);	}
	each2(string sfun, @d1, @d2)	{	for( int i=0; i<.size; i++) <.get(i)>.<sfun>(i, d1, d2);	}
	bool ineach(string sfun)	{
		for( int i=0; i<.size; i++) if( !<.get(i)>.<sfun>(i) )	return false;
		true;
	}
	int find_closest(string sob, string sfun)	{
		if( .empty ) return -1;
		int id = 0, real il;
		real ilen = <.get(0)>.<sfun>(sob);
		for( int i=1; i<.size; i++)	{
			il = <.get(i)>.<sfun>(sob);
			if( il < ilen )	{
				id = i;
				ilen = il;
			}
		}
		id;
	}
	/**************/
	sortimgsfun(string sfun)	{	lsim.vecsort(sfun);	}
	sortimgs()	{	// sortowanie od najmniejszych
		lsim.vecsort("_scmpz");
	}
	bool _scmpz(string s0, string s1)	{
		( <s0>.getz() < <s1>.getz() || ( <s0>.getz()==<s1>.getz() && <s0>.getidobj() < <s1>.getidobj() ) );
	}
	sortpx	{	lsim.vecsort( func { (string s0, string s1) <s0>.getpx < <s1>.getpx; } );	}
}

class gmimgvec : gmobjvec	{
	init()	{
		gmobjvec::init();
		new int _ix = 0;
		new int _iy = 0;
		new int _iz = 0;
		new bool _bvisible = true;
		new int _ifound = -1;
		new string sanload = null;
	}
	bool isvisible	{	_bvisible;	}
	hide	{	_bvisible=false;	.eval("hide");	}
	show	{	_bvisible=true;		.eval("show");	}
	_setpos(int x, int y)	{	|_ix, _iy| = x,y;	}
	int lodx()	{0;}
	int lody()	{0;}
	int getposx()	{	_ix;	}
	int getposy()	{	_iy;	}
	int getpos()	{	return _ix, _iy;	}
	int getpx() {	_ix;	}
	int getpy() {	_iy;	}
	int getw()	{	this.getex()-this.getpx();	}
	int geth()	{	this.getey()-this.getpy();	}
	int getcx() {	this.getpx()+this.getw()/2;	}
	int getcy() {	this.getpy()+this.geth()/2;	}
	int getz()	{	_iz;	}
	int getex()	{
		int ile = this.size();
		if( ile<=0 )	{	return _ix;	}
		int x = <this.get(0)>.getex();
		int x2;
		for( int i=1; i<ile; i++)	{
			x2 = <this.get(i)>.getex();
			if( x2>x )	{	x=x2;	}
		}
		x;
	}
	int getey()	{
		int ile = this.size();
		if( ile<=0 )	{	return _iy;	}
		int y = <this.get(0)>.getey();
		int y2;
		for( int i=1; i<ile; i++)	{
			y2 = <this.get(i)>.getey();
			if( y2>y )	{	y=y2;	}
		}
		y;
	}
	int _getpx()	{
		int ile = this.size();
		if( ile<=0 )	{	return _ix;	}
		int x = <this.get(0)>.getpx();
		int x2;
		for( int i=1; i<ile; i++)	{
			x2 = <this.get(i)>.getpx();
			if( x2<x )	{	x=x2;	}
		}
		x;
	}
	int _getpy()	{
		int ile = this.size();
		if( ile<=0 )	{	return _iy;	}
		int y = <this.get(0)>.getpy();
		int y2;
		for( int i=1; i<ile; i++)	{
			y2 = <this.get(i)>.getpy();
			if( y2<y )	{	y=y2;	}
		}
		y;
	}
	int _getw	{	.getex-._getpx;	}
	int _geth	{	.getey-._getpy;	}
	/*minx	{	.find_closest(null, func {(@s) .getpx; } );	}
	miny	{	.find_closest(null, func {(@s) .getpy; } );	}
	countborders	{
		_ix = .minx;
		_iy = .miny;
	}*/
	setz(int z)	{
		_iz = z;
		this.eval1("setz",z);
	}
	move(int x, int y)	{
		_ix +=x;
		_iy +=y;
		this.eval2("move",x,y);
	}
	setpos(int x, int y)	{
		_ix = x;
		_iy = y;
		this.eval2("setpos",x,y);
	}
	setpos2(int x, int y)	{
		_ix = x;
		_iy = y;
		if( !.empty )	{
			x -= <.get(0)>.getpx;
			y -= <.get(0)>.getpy;
			.move(-x,-y);
		}
	}
	changeframe(int ifr) {
		string s;
		for( int i=0; i<.size; i++)	{
			s = .get(i);
			<s>.setframe( <s>.actionnr(-1), ifr );
		}
	}
	nplay(int n)	{	.eval1("play",n);	}
	txtreset	{	for( int i=0; i<.size; i++) <.get(i)>.txtset("");	}
	anputgr()	{	this.eval("anputgr");	}
	anputy(int ypos)	{	this.eval1("anputy", ipos);	}
	int isin(int x, int y, bool bignorehidden, bool bignorealpha)	{
		for( int i=lsim.size()-1; i>=0; i--)	{
			if( <lsim.get(i)>.isin( x,y,bignorehidden,bignorealpha ) )	{
				_ifound=i;
				return i+1;
			}
		}
		_ifound = -1;
		false;
	}
	int isinfunc(int x, int y, string sfunc)	{
		for( int i=lsim.size()-1; i>=0; i--)	{
			if( <lsim.get(i)>.<sfunc>( x,y ) )	{
				_ifound=i;
				return i+1;
			}
		}
		_ifound = -1;
		false;
	}
	int isincut(int x, int y, bool bignorehidden, bool bignorealpha)	{
		for( int i=lsim.size()-1; i>=0; i--)	{
			if( <lsim.get(i)>.withincut(x,y) && <lsim.get(i)>.isin( x,y,bignorehidden,bignorealpha ) )	{
				_ifound=i;
				return i+1;
			}
		}
		_ifound = -1;
		false;
	}
	bool withincut(int x, int y)	{
		y; x;
		.ineach(func { (@id)
			int x = _;
			int y = _;
			.withincut(x,y);
			y; x;
			} );
		x = _;
		y = _;
	}
	int findif(string sfunc)	{	._find( sfunc,true);	}
	int getfound()	{	_ifound;	}
	string getsfound()	{	this.get(_ifound);	}
	int findfr(int id)	{	._find("framenr", id);	}
	int findsfr(string s)	{	._find("framename", s);	}
	int findac(int id)	{	._find("anactnr", id);	}
	int findsac(string sac)	{	._find("actionname", sac);	}
	int nearest_to(string sob)	{
		//.find_closest(sob, func {(string s) 0->length( .getpx-<s>.getpx, .getpy-<s>.getpy ); } );
		.find_closest(sob, func {(string s) cllen.ilen5(this,s); } );
	}
	string getsac(string sac)	{	.get( .findsac(sac) );	}
	string getsacfr(string sac, int fr)	{	for(int i=0; i<.size; i++) if( <.get(i)>.actionname==sac && <.get(i)>.framenr==fr ) return .get(i); null; }
	/*def find_min(string s)	{
		if( .empty ) return;
		int x = <s>.getpx;
		int y = <s>.getpy;
		int id = 0, int il;
		int ilen = id.length( <.get(0)>.getpx-x, <.get(0)>.getpy-y );
		for( int i=1; i<.size; i++)	{
			il = id.length( <.get(i)>.getpx-x, <.get(i)>.getpy-y );
			if( il < ilen )	{
				id = i;
				il = ilen;
			}
		}
	}*/
	blitto(string simg)	{	for( int i=0; i<.size; i++)	<simg>.blit(.get(i));	}
	sortz(int z)	{	for( int i=0; i<.size; i++) <.get(i)>.setz(z+i);	}
	/****************************/
	ancopies(string san, int ile)	{	.ancopiesname(san,san,ile);	}
	ancopiesname(string san, string sname, int ile)	{
		for( int i=0; i<ile; i++)	{
			<GAME>.copyanima(san, sname+"_"+i);
			.add(sname+"_"+i);
		}
	}
	loadallan(string sname, string sfile, int z)	{
		string s = gameapi.getgamename();
		<s>.newanima(sname,sfile,z);
		_ = <s>.newanfrbyactgr(sname, sname, this);
		<sname>.hide();
	}
	addsrcanima(string san) {       .var2("srcanima", san); }
	operator*(string s)	{
		string sg = gameapi.getgamename;
		string san;
		if ( s.contains(".pyz") ) {
			if( s.getb(0,1)=="$" )	{
				new vector _vtmp; _vtmp.type("string");
				_vtmp.vecbuildfromstring(s, "/");
				san = "an" + _vtmp.last->strsubes(".pyz");
				delete _vtmp;
			} else {
				san = "an" + s.strsubes(".pyz");
			}
			<sg>.newanima(san,s,0);
		} else san = s;
		sanload = san;
		_ = <sg>.newanactionsgr(san, san, this);
		<san>.hide();
		.addsrcanima(san);
	}
	operator<(string s)	{
		string sg = gameapi.getgamename;
		string san;
		if ( s.contains(".pyz") ) {
			san = "an" + s.strsubes(".pyz");
			<sg>.newanima(san,s,0);
		} else san = s;
		sanload = san;
		_ = <sg>.newanfrbyactgr(san, san, this);
		<san>.hide();
		.addsrcanima(san);
	}
	deleteloaded	{
		.deleteallgm;
		if( sanload!=null ) <gameapi.getgamename>.vardel(sanload);
	}
	deleteinit	{
		@s = gameapi.getgamename;
		for( int i=0; i<.size; i++)	{
			@s2 = .get(i);
			if( <s2>.gettype=="gmimgvec" )	{
				<s2>.deleteinit;
			}
			<s>.vardel(s2);
		}
		if( sanload!=null ) <gameapi.getgamename>.vardel(sanload);
	}
}

class gmadvvec : gmimgvec	{
	init	{	gmimgvec::init;	}
	int butisin(int x, int y, bool bignorehidden, bool bignorealpha)	{
		for( int i=lsim.size()-1; i>=0; i--)	{
			if( <lsim.get(i)>.butisin( x,y,bignorehidden,bignorealpha ) )	{
				_ifound=i;
				return i+1;
			}
		}
		_ifound = -1;
		false;
	}
}

class gmmaskvec : gmadvvec	{
	init()	{	gmadvvec::init;	}
	int butisin(int x, int y, bool bigvis, bool bigalpha)	{	gmimgvec::butisin(x,y,false,bigalpha);	}
}




new int igmsubtitle = .readcfg("igmsubtitle:", 0);
new int igmlektor = .readcfg("igmlektor:", 1);
new int igmchardelay = .readcfg("igmchardelay:", 100);
new int igmsubmindelay = .between(2000, .readcfg("igmsubmindelay:", 2000), 200000);

class Subtitle	{
	init(string sdbfile, int borx)	{
		real rwidth = 0.5;
		new int col0; new int col1; new int col2;
		.restorecolor;
		string spath = SNDPATH;
		
		new string ssubpos = .readcfg("sgmsubtitlespos:", "down");
		@s = dbconf.dbgets("sgmsubtitlespos:",2);
		new int isubpos = (s!=null ? s : 15);
		new bool bshadow = .readcfg("igmsubshadow:", 0);
		new int bblackbg = .readcfg("igmsubblackbg:", 170);
		
		new int iborx = borx;
		
		new int ifontsize = fntsubtitle.getsize;
		
		new db dbl;
		dbl.load(LANGDIR + sdbfile);
		int i=0;
		string s;
		while( i<dbl.getrowsno )	{
			if( dbl.getcolsno(i) < 2 || dbl.get(i,0)->getb(0,1)=="#" )
				dbl.removerow(i);
			else i++;
		}
		
		
		string s2;
		new vector v1;	v1.type("string");
		int cols = (iResX-2*borx)/(rwidth*ifontsize+1);
		
		int k, int j;
		int linie = 0;
		for( int i=0; i<dbl.getrowsno; i++)	{
			s = spath + dbl.get(i,0)+".wav";
			if( !engine.fileexist(s) )
				s = spath + dbl.get(i,0)+".ogg";
			dbl.set( i, 0, s );
			s = dbl.get(i,1);
			v1.vecbuildfromstring(s, " ");
			s2 = "";
			k = 1;
			for( j=0; j<v1.size; j++)	{
				if( s2.length + v1.get(j)->length + 1 <= cols )	s2 += " " + v1.get(j);
				else {
					if( k==1 )	dbl.set(i, k, s2);
					else dbl.add(i, s2);
					s2 = v1.get(j);
					k++;
				}
			}
			if( k==1 )	dbl.set(i, k, s2);
			else dbl.add(i, s2);
			if( k>linie ) linie = k;
		}
		
		new gmimgvec grtxt;
		new gmimgvec grtxts;
		for( int i=0; i<linie; i++)	{
			s = "txt"+i;
			if( bshadow )	{
				s2 = "txts"+i;
				classgame::newtext(s2,"","fntsubtitle",.black);
				grtxts.add(s2);
			} else if ( bblackbg )	{
				s2 = "imgs"+i;
				new img <s2>;
				grtxts.add(s2);
			}
			classgame::newtext(s,"","fntsubtitle",.getcolor);
			grtxt.add(s);
		}
		
		new db dbsnd;
		new timer timtxt;
		timtxt.settick(1);
		timtxt.setcycle(1);
		timtxt.addmethod("onfinish", func {
			if( !.cisplaying )	.hidesubs;
			else .play;
			} );
		.setz(12000);
	}
	geth	{
		if( grtxts.size )	<grtxts.first>.geth;
		else if ( grtxt.size )	<grtxt.last>.geth;
		else 0;
	}
	reset	{
		.stop;
		dbsnd.free;
	}
	hidesubs	{
		grtxt.hide;
		grtxts.hide;
	}
	setz(int z)	{
		grtxt.setz(z);
		grtxts.setz(z-1);
	}
	stop	{
		.hidesubs;
		timtxt.stop(false);
	}
	register(string ssnd, string sfile)	{
		@id = dbl.findbyrow(sfile);
		if( id>=0 )	{
			@r = dbsnd.findbyrow(ssnd);
			if( r>=0 )	dbsnd.set(r, 1, id);
			else {
				@r = dbsnd.addrow-1;
				dbsnd.add(r, ssnd);
				dbsnd.add(r, id);
			}
		}
	}
	getiddialog(string s)	{	dbsnd.findbyrow(s);	}
	hasdialog(string s)	{	.getiddialog(s) >= 0;	}
	int play(string s)	{
		.stop;
		@id = dbsnd.findbyrow(s);
		if( id>=0 )	{
			int ileznakow = 0;
			id = dbsnd.get(id, 1);
			@ile = dbl.getcolsno(id)-1;
			string s[2], int dx, int dy;
			grtxt.setpos( 0, 0 );
			int dy = 2;
			for( int i=0; i<ile; i++)	{
				s0 = grtxt.get(i);
				<s0>.txtsetcol(dbl.get(id, i+1), col0, col1, col2);
				ileznakow += <s0>.get->length;
				<s0>.setpos( (iResX-<s0>.getw)/2 + igmoffsetx, i*ifontsize + dy + igmoffsety );
				<s0>.show;
				if( bshadow )	{
					s1 = grtxt.get(i);
					<s1>.txtsetcol(<s0>.get,  col0, col1, col2);
					<s1>.setpos(<s0>.getpx+1, <s0>.getpy+1);
					<s1>.show;
				} /*else if ( bblackbg )	{
					s1 = grtxts.get(i);
					dx = 4;
					dy = 2;
					//<s1>.create( <s0>.getw+ dx, <s0>.geth+dy, .black, 255 );
					//<s1>.setpos(<s0>.getpx-dx/2, <s0>.getpy-dy/2);
					<s1>.create( iResX, <s0>.geth, .black, bblackbg );
					<s1>.setpos( 0, <s0>.getpy );
					<s1>.setz( <s0>.getz-1 );
					<s1>.show;
				}*/
			}
			if( bblackbg )	{
				s0 = grtxt.first;
				s1 = grtxts.first;
				if( ssubpos=="up" )	{
					<s1>.create( iResX, <grtxt.get(ile-1)>.getey, .black, bblackbg );
					<s1>.setpos( igmoffsetx, igmoffsety );
				} else {
					<s1>.create( iResX, <grtxt.get(ile-1)>.getey - <s0>.getpy, .black, bblackbg );
					<s1>.setpos( igmoffsetx, <s0>.getpy+igmoffsety );
				}
				<s1>.setz( <s0>.getz-1 );
				<s1>.show;
			}
			if( ssubpos=="up" )	{
				dy = 0;
			} else {
				dy = iResY - ile*(ifontsize+dy)-isubpos;
				grtxt.move( 0, dy );
				if( bshadow || bblackbg ) grtxts.move(0, dy);
			}
			timtxt.play;
			ileznakow *= igmchardelay;
			ileznakow < igmsubmindelay ? igmsubmindelay : ileznakow;
		} else 0;
	}
	setcolor(int r, int g, int b)	{
		col0 = r;
		col1 = g;
		col2 = b;
	}
	getcolor	{	return col0, col1, col2;	}
	restorecolor	{	.setcolor(.white);	}
}

if( igmsubtitle )	{
	new font fntsubtitle;
	fntsubtitle.load( .readcfg("subtitles_font:", sgmfontfile), .readcfg("subtitles_fontsize:", 24->igetsc) );
	new Subtitle subtitle( .readcfg("subtitles_src:", "subtitles.db"), 50);
}

class classsound {
	init()	{
		new string _csplay = null;
		new timer timlektor;
		timlektor {
			//.var2("bsndfin", false);
			new bool bsndfin = true;
		};
		timlektor.addmethod("setsndfin", func { (bool b) bsndfin = b; } );
		timlektor.addmethod("onfinish", func {
			if( bsndfin )	{
				if( _csplay!=null ) <_csplay>.onfinish;
			} else bsndfin = true;
			} );
		if( igmsubtitle )	{
			subtitle.reset;
		}
	}
	creset()		{ _csplay = null; }
	string cgetactsnd()	{ _csplay; }
	bool cisactsnd(string ssnd)	{	ssnd==_csplay;	}
	crselfplay(string ssnd)	{
		if( !this.cisplaying() )	this.cbplay(ssnd);
		else if ( this.cgetactsnd()!=ssnd )	this.cbplay(ssnd);
	}
	cbselfplay(string ssnd)	{
		if( !.cisplaying || .cgetactsnd!=ssnd )	.cbplay(ssnd);
	}
	cbplay(string ssnd)	{
		if(this.cisplaying())
			.csplaystop(true);
		.cbsplay(ssnd);
	}
	cbsplay(string ssnd)	{
		_csplay = ssnd;
		if( ssnd!=null)
			.csubplay(ssnd);
	}
	cbplayfin(string ssnd, string sfun)	{
		<ssnd>.addmethod("onfinish", sfun);
		.cbplay(ssnd);
	}
	cbplay2(string ssnd)	{
		if(this.cisplaying())
			.csplaystop(false);
		.cbsplay(ssnd);
	}
	crplay(string ssnd)	{
		if( !.cisplaying )
			.cbsplay(ssnd);
	}
	/*crplay(string ssnd)	{
		if( _csplay!=null && <_csplay>.isplaying() )	return;
		_csplay = ssnd;
		if( ssnd!=null )
			.csubplay(ssnd);
		//	<ssnd>.play();
	}*/
	cbplayif(string ssnd)	{
		if(.cisplaying)
			.cbplay(ssnd);
	}
	crbgplay(string ssnd)	{
		if( ssnd != null && !<ssnd>.isplaying() )
			.csubplay(ssnd);
			//<ssnd>.play();
	}
	crandplay(string ssnd, int irand, string styp)	{
		if( irand.rand()==0 )	this.<"c"+styp+"play">( ssnd );
	}
	cplayf(string styp, string ssnd, string sfun)	{
		this.<"c"+styp+"play">(ssnd);
		if( <ssnd>.isplaying() && sfun!=null)	<ssnd>.addmethod("onfinish",sfun);
	}
	//cactsndstop(bool bfin)	{	if(_csplay!=null)	<_csplay>.stop(bfin);	}
	cactsndstop(bool bfin)	{
		if(.cisplaying)	.csplaystop(bfin);
	}
	csplaystop(bool bfin)	{
		if( timlektor.isplaying )	{
			timlektor.setsndfin(bfin);
			timlektor.stop(true);
		} else
			<_csplay>.stop(bfin);
	}
	cstopsnds(bool b)	{
		if( _csplay.in && .cisplaying )
			.cactsndstop(b);
	}
	bool cisplaying()	{
		_csplay!=null ? ( timlektor.isplaying || <_csplay>.isplaying ) : false;
	}
	bool cisplayingsnd	{
		_csplay!=null ? <_csplay>.isplaying : false;
	}
	csubplay(string s)	{
		if( igmsubtitle )	{
			int ilektor = igmlektor;
			if( !<s>.loaded )	{
				igmlektor = 0;
			}
			@dt = subtitle.play(s);
			if( igmlektor || dt<=0 ) <s>.play;
			else {
				timlektor.setdelay( dt );
				timlektor.play;
			}
			igmlektor = ilektor;
		} else
			<s>.play;
	}
	cisdialogplaying	{
		.cisplaying && subtitle.hasdialog(.cgetactsnd);
	}
}

/***************************************************************************/
class classsndbank	{
	init()	{
		new int itype;
		new int ilicz = 0;
		new int iile;
		new string splay=null;
		new string ssnd = "snd";
	}
	/********************************/
	loadsingle(string sfile, int ile)	{
		if( ile<=0)	{	iile=0;	return;	}
		iile=ile;
		itype=0;
		for( int i=0; i<ile; i++)	newvars::newsnd( ssnd+i, sfile );
	}
	/********************************/
	load(string sfilebase, int ifilefrom, int ifileto, int ityp, int itypstart)	{
		iile = ifileto-ifilefrom+1;
		if(iile<=0)	{
			iile = 0;
			return;
		}
		newvars::newsnds( ssnd, 0, sfilebase, ifilefrom, ifileto);
		itype = ityp;			// 0 - po kolei, 1 - random
		if(itypstart==1)	{	// 0 - od pierwszego, 1 - randomowy
			ilicz = iile.rand( );
		}
	}
	addmethod(string ssig, string sfunc)	{
		for( int i=0; i<iile; i++)	<ssnd+i>.addmethod( ssig, sfunc );
	}
	stop(int ifin)	{	if(splay!=null)	<splay>.stop(ifin);	}
	int isplaying()	{	splay!=null ? <splay>.isplaying() : false;	}
	randplay( int irand )	{	if( irand.rand()==0 )	this.play();	}
	playid(int id)	{
		ilicz=id%iile;
		this.play();
	}
	play()	{
		this.stop(false);
		this.bgplay();
	}
	reset()	{	ilicz=0;	}
	/************************************************/
	rbgplay()	{	if( !this.isplaying() )	this.bgplay();	}
	rplay()		{	if( !this.isplaying() )	this.play();	}
	bgplay()	{
		splay = ssnd + ilicz;
		<splay>.play();
		if( itype==0)	ilicz = (ilicz+1)%iile;
		else if (itype==1)	ilicz = iile.rand();
	}
	setvol(int vol)	{	for( int i=0; i<iile; i++)	<ssnd+i>.setvol( vol );	}
}

class SoundSource	{
	init	{	}
	setvol(string ssnd, int srcvol, int outvol, real rad, real length)	{
		if( length.abs>=rad ) <ssnd>.setvol(outvol);
		else {
			srcvol = (1.0-length.abs/rad)*srcvol + outvol;
			if( srcvol > 100 ) srcvol=100;
			<ssnd>.setvol(srcvol);
		}
	}
}

/**************************************************************/
	// standardowe czynnosci przy grach, popakowane w metody
class classgame : newvars , classsound {
	init()	{
		newvars::init();
		classsound::init();
		new int _iconstid;
		new gmobjvec _grsfxs;
	}
	/**************************************************************/
	bkg=(@sfile)	{
		if( sfile.contains(".pyz") ) .newanima("anbkg", sfile, 0);
		else .newimg("imgbkg",sfile,0);
	}
	bgr=(@sfile)	{
		//this.csndplayloop("sndbgr",sfile);
		.csndbgr(sfile);
	}
	path=(@s)	{	.setgraphpath("scripts/"+s+"/");	}
	cycle=(@stimer, @sfun)	{	.cnewtimercyclefin(stimer,1,1,sfun);	}
	timer=(@stimer, @itime, @sfun) { .cnewtimerfin(stimer,itime,1,sfun);	}
	timplay(@stimer, @itime, @sfun) {
		.cnewtimerfin(stimer,itime,1,sfun);
		<stimer>.play;
	}
	cycletimer=(string stimer, int itime, string sfun)	{
		itime = itime.imstotick;
		if( itime < 1 ) itime = 1;
		.cnewtimercyclefin(stimer,1,itime,sfun);
	}
	def _getflags(string s)	{
		@bloop = false;
		if( s.contains("L") )	{
			s.strremove("L");
			bloop=true;
		}
		@bplay = false;
		if( s.contains("P") )	{
			s.strremove("P");
			bplay=true;
		}
		@bhide = false;
		if( s.contains("H") )	{
			s.strremove("H");
			bhide=true;
		}
		return s,bloop,bplay,bhide;
	}
	img=(@sfile)	{
		_ = ._build_img(sfile);
	}
	getlangfile(string s)	{
		@s2 = s.strsube(4) + "_" + LANG + s.gete(0,4);
		engine.fileexist( .getpath(s2) ) ? s2 : s;
	}
	getlangpath(string s)	{	.getpath( .getlangfile(s) );	}
	_build_img(@sfile)	{
		|sfile,@bloop,@bplay,@bhide| = ._getflags(sfile);
		bool bgroup = false;
		if(sfile.contains("G"))	{
			sfile.strremove("G");
			bgroup = true;
		}
		@iz = 0;
		if( sfile.contains(" ") )	{
			iz = sfile.strgetfrom(" ");
			sfile = sfile.strgetto(" ");
		}
		string sname;
		if( sfile.contains("/") ) {
			new vector _v_sfile;
			_v_sfile.type("string");
			_v_sfile.vecbuildfromstring(sfile,"/");
			sname = _v_sfile.last->strsube(4);
			delete _v_sfile;
		} else sname = sfile.strsube(4);
		string s;
		if( sfile.contains(".pyz") ) {
			if( bgroup )	{
				s = "gr"+sname;
				.newgrimg(s, .getlangfile(sfile)->strsubes(".pyz"), iz);
			} else {
				s = "an" + sname;
				.newanima(s, .getlangfile(sfile), iz);
			}
		} else {
			s = "img" + sname;
			.newimg(s, .getlangfile(sfile), iz);
		}
		if( bloop ) <s>.anloopfin;
		if( bplay ) <s>.play(-1);
		if( bhide ) <s>.hide;
		s;
	}
	imgsgr=	{
		string sgr = _;
		string simg;
		new gmimgvec <sgr>;
		@s = _;
		while( A != s )	{
			<sgr>.add(._build_img(s));
			@s = _;
		}
	}
	imgs=	{	.withlist("img=");	}
	clone(string sob)	{
		<gameapi.getgamename> (this, .gettype, sob) { (@sthis, @styp, @sob)
			new <styp> <sob>;
			<sob>.copy(sthis);
		};
	}
	clones=	{	.withlist("clone");	}
	list=(@sname)	{
		@s=_;
		new gmobjvec <sname>;
		while(A!=s)	{
			<sname>.addbegin(s);
			s = _;
		}
	}
	list2={
		@s = .newconst("gmobjvec");
		.list=(s);
		s;
	}
	debug=(@b)	{	engine.setdebugstate(b);	}
	sfx=(string s)	{
		bool bloop2 = s.contains("N");
		if( bloop2 )	{
			s.strremove("N");
		}
		|s,@bloop,@bplay,_| = ._getflags(s);
		@ivol = 100;
		if( s.contains(" ") )	{
			ivol = s.strgetfrom(" ");
			s = s.strgetto(" ");
		}
		string sf = "fx"+s;
		//.newsnd(sf, "sfx/"+s+".wav");
		.newsfx( sf, s+".wav");
		<sf>.setvol( ivol );
		if( bloop ) <sf>.addmethod("onfinish","_stdsndloop");
		if( bplay ) <sf>.play;
		else if( bloop2 ) <sf>.playloop;
		_grsfxs.add(sf);
	}
	sfxs=	{	.withlist("sfx=");	}
	snd=(string sname, string sfile, string sfun)	{
		.newsndfree(sname, sfile + ".wav");
		<sname>.addmethod("onfinish", sfun);
	}
	tickstart	{
		if( !.hasvar("__timspeed") )	new TicksCounter __timspeed;
		__timspeed.start;
	}
	tickstop	{	__timspeed.print("ticker: ");	}
	/**************************************************************/
	csndplayloop(string ssnd, string sfile)	{
		this.newsndloop(ssnd,sfile);
		<ssnd>.play();
	}
	csndbgr(string sfile)	{
		//this.csndplayloop("sndbgr",sfile);
		.newbgr("sndbgr", sfile );
		.sndplayloop("sndbgr");
	}
	cloadcursor(string sfile)	{
		if( sfile.contains(".") )	{
			.newimg("imgkursor", sfile,0);
			sfile = "imgkursor";
		}
		<sfile>.hide();
		mouse.setcursor(sfile);
		engine.stdbutcursor(sfile);
// 		bsms.setown();
	}
	/****************************************************************/
	newimgarray(string sname, string styp, string sn, int ile)	{
		new gmimgvec <sname>;
		<sname>.buildarray(styp,sn,ile);
	}
	newfont(string sfnt, string sfile, int isize)	{
		new font <sfnt>;
		<sfnt>.load( sfile, isize );
	}
	monofont(string sfnt, int isize)	{	.newfont(sfnt, sgmfontmono, isize);	}
	newfontbold(string sfnt, int isize)	{	.newfont(sfnt, sgmfontbold, isize);	}
	string snewfont(string sfontfile, int isize)	{
		string s = .newconst("font");
		<s>.load( sfontfile, isize );
		s;
	}
	string stdfont(int isize)	{	.snewfont( sgmfontfile, isize	);	}
	string stdmono(int isize)	{	.snewfont( sgmfontmono, isize);	}
	string stdbold(int isize)	{	.snewfont( sgmfontbold, isize);	}
	int getconstid	{	_iconstid++;	_iconstid-1;	}
	string newconst(string styp)	{
		string s = "const"+styp+.getconstid;
		new <styp> <s>;
		s;
	}
	string consttext(string stext, int x, int y, int isize, int r, int g, int b)	{
		string s = this.newconst("text");
		string sf = .stdfont(isize);
		<s>.setfont(sf);
		<s>.set(stext);
		<s>.createtxt(r,g,b);
		<s>.setpos(x,y);
		s;
	}
	newtxt(string stxt, string stext, string sfont, int r, int g, int b)	{	.newtext(stxt,stext,sfont,r,g,b);	}
	newtext(string stxt, string stext, string sfont, int r, int g, int b)	{
		new text <stxt>;
		<stxt>.set(stext);
		<stxt>.setfont(sfont);
		<stxt>.createtxt(r,g,b);
	}
	newtextposz(string stxt, string stext, string sfont, int r, int g, int b, int x, int y, int z)	{
		.newtext(stxt,stext,sfont,r,g,b);
		<stxt>.anposz(x,y,z);
	}
	newgrimg(string sgr, string sfile, int z)	{
		new gmimgvec <sgr>;
		sgr .* (sfile+".pyz");
		<sgr>.setz(z);
	}
	/****************************************************************/
	cfinmethod(string sobj, string sfuncfin)	{	<sobj>.addmethod("onfinish", sfuncfin);	}
	cnewsndfin(string sname, string sfile, string sfunc)	{
		this.newsnd(sname,sfile);
		this.cfinmethod(sname,sfunc);
	}
	cnewsndsfin(string sbase, int inamestart, string sfilebase, int ifilefrom, int ifileto, string sfunc)	{
		this.newsnds(sbase, inamestart, sfilebase, ifilefrom, ifileto);
		this.caddobjsfunfin(sbase, inamestart, inamestart+( ifileto-ifilefrom), sfunc);
	}
	cnewsndfinbplay(string sname, string sfile, string sfunc)	{
		this.cnewsndfin(sname,sfile,sfunc);
		this.cbplay(sname);
	}
	cnewtimerfin(string sname, int idelay, int iticks, string sfunc)	{
		this.newtimer(sname,idelay,iticks);
		this.cfinmethod(sname,sfunc);
	}
	cnewtimercyclefin(string sname, int icycle, int iticks, string sfunc)	{
		this.newtimercycle(sname,icycle,iticks);
		this.cfinmethod(sname,sfunc);
	}
	/****************************************************************/
	caddobjsfun(string ssnd, int ifrom, int ito, string ssig, string sfunc)	{
		while( ifrom <= ito )	{
			<ssnd+ifrom>.addmethod( ssig, sfunc+ifrom );
			ifrom++;
		}
	}
	caddobjsfunfin(string ssnd, int ifrom, int ito, string sfunc)	{
		this.caddobjsfun( ssnd, ifrom, ito, "onfinish", sfunc );
	}
	/****************************************************************/
	newancounter(string scounter, string sname, string sfile, int z, int ile)	{
		this.newanimas( sname, sfile, z, ile);
		new classancounter <scounter>;
		<scounter>.set( sname, ile );
	}
	newancounterh(string scounter, string sname, string sfile, int z, int ile)	{
		this.newancounter( scounter, sname, sfile, z , ile );
		for( int i=0; i<ile; i++)	<sname+i>.hide();
	}
	newancounterf(string scounter, string sname, string sfile, int z, int ile, string sfun)	{
		this.newancounter( scounter, sname, sfile, z , ile );
		for( int i=0; i<ile; i++)	<sname+i>.addmethod("onfinish", sfun);
	}
	newancounterhf(string scounter, string sname, string sfile, int z, int ile, string sfun)	{
		this.newancounter( scounter, sname, sfile, z , ile );
		for( int i=0; i<ile; i++)	{
			<sname+i>.addmethod("onfinish", sfun);
			<sname+i>.hide();
		}
	}
	cnewanimafin(string sname, string sfile, int z, string sfunc)	{
		this.newanima(sname, sfile, z);
		<sname>.addmethod("onfinish", sfunc );
	}
	ccopyanimafin(string sname, string snew, string sfunc)	{
		this.copyanima(sname, snew);
		<snew>.addmethod("onfinish", sfunc );
	}
	/****************************************************************/
	cloadwavs(string sdb, string sfile)	{
		this.newdb( sdb, sfile );
		int id = 0;
		int ile = <sdb>.getrowsno();
		int i[6], string s[5];
		while( id < ile )	{
			i1 = <sdb>.getcolsno(id);
			i2 = 0;
			s1 = <sdb>.get( id, i2 );	i2++;
			if( s1.getb(0,1)!="#" )	{
				s3 = <sdb>.get( id, i2 );	i2++;
				if( s1=="wav" || s1=="sfx" )	{
					s2 = <sdb>.get( id, i2 );	i2++;
					if( s1=="sfx")	{
						this.newsfx( s3, s2 );
					} else { this.newsnd( s3, s2 ); }
					if( i2 < i1 )	{
						s1 = <sdb>.get( id, i2 );	i2++;
						s2 = <sdb>.get( id, i2 );	i2++;
						if( s1=="method" )	{
							<s3>.addmethod("onfinish", s2 );
						} else if (s1.gete(0,4)=="play")	{
							this.<"c"+s1.gete(4,10)+"playonfin">(s3, s2);
						} else if ( s1=="vol" )	{
							<s3>.setvol( s2 );
						}
					}
				} else if (s1=="group")	{
					s2 = <sdb>.get( id, i2 );	i2++;
					i3 = <sdb>.get( id, i2 );	i2++;
					i4 = <sdb>.get( id, i2 );	i2++;
					if( i2 < i1 )	{		// jest method
						s1 = <sdb>.get( id, i2 );	i2++;
						if( s1=="method" )	{
							s4 = <sdb>.get( id, i2 );	i2++;
							this.cnewsndsfin( s3, i3, s2, i3, i4, s4 );
						}
					} else {
						this.newsnds( s3, i3, s2, i3, i4 );
					}
				} else if (s1=="bank")	{
					s2 = <sdb>.get( id, i2 );	i2++;
					i0 = <sdb>.get( id, i2 );	i2++;
					i3 = <sdb>.get( id, i2 );	i2++;
					i4 = <sdb>.get( id, i2 );	i2++;
					i5 = <sdb>.get( id, i2 );	i2++;
					new classsndbank <s3>;
					<s3>.load( s2, i0, i3, i4, i5);
					if( i2<i1)	{
						s1 = <sdb>.get( id, i2 );	i2++;
						if( s1=="method")	{
							s4 = <sdb>.get( id, i2 );	i2++;
							<s3>.addmethod( "onfinish", s4 );
						} else if (s1=="vol")	{
							<s3>.setvol( <sdb>.get( id, i2 ) );
						}
					}
				} else if ( s1=="method" )	{
					s2 = <sdb>.get( id, i2 );	i2++;
					i3 = <sdb>.get( id, i2 );	i2++;
					i4 = <sdb>.get( id, i2 );	i2++;
					while( i3<=i4)	{
						<s2+i3>.addmethod("onfinish", s3);
						i3++;
					}
				} else if ( s1=="singlebank")	{
					s2 = <sdb>.get( id, i2 );	i2++;
					i3 = <sdb>.get( id, i2 );	i2++;
					new classsndbank <s3>;
					<s3>.loadsingle( s2, i3 );
				} else if ( s1=="bgr" )	{
					this.csndbgr( s3 );
					if( i2 < i1 )	{
						if( <sdb>.get( id, i2 )=="vol" )	{
							i2++;
							sndbgr.setvol( <sdb>.get( id, i2 ) );
							i2++;
						}
					}
				} else if ( s1=="music" )	{
					this.playmusic( s3 );
					if( i2 < i1 )	{
						if( <sdb>.get( id, i2 )=="vol" )	{
							i2++;
							sndbgr.setvol( <sdb>.get( id, i2 ) );
							i2++;
						}
					}
				}
			}
			id++;
		}
	}
	/****************************************************************/
	crestart()	{	gameapi.play( gameapi.getgamename() );	}
	/****************************************************************/
	cgetscreenshoot(string sfile, real rzoom)	{
		if( igmenablesave )	{
			new img _imgsavebkg;
			_imgsavebkg.create(iResX,iResY,.white,255);
			_imgsavebkg.setz(2000);
			_imgsavebkg.blitscreen;
			
			if( rzoom!=1.0 )	{
				new filter _ftbg;
				_ftbg.link("_imgsavebkg");
				_ftbg.setsmooth(1);
				_ftbg.setzoom(rzoom);
			}
			_imgsavebkg.setpos(0,0);
			
			new img _im_1;
			_im_1.create(rzoom*iResX, rzoom*iResY, .white,255);
			_im_1.setpos(_imgsavebkg.getpx, _imgsavebkg.getpy);
			_im_1.blit("_imgsavebkg");
			
			_im_1.save(sfile);
			
			delete _im_1;
			if( rzoom!=1.0 )	{
				_ftbg.unlink;
				delete _ftbg;
			}
			delete _imgsavebkg;
		}
	}
}


/***************************************************************************/

class clfindfunc	{
	init()	{}
	int _stdfindfunc(string sobj, int ifirst, int ilast, string sname, string sfunc)	{	
		while(ifirst<=ilast)	{
			if( <sobj + ifirst>.<sfunc>() ==sname )	return ifirst;
			ifirst++;
		}
		-1;
	}
	int _stdfindfunc2(string sobj, int iile, string sname, string sfunc)	{	
		._stdfindfunc(sobj, 0, iile-1, sname, sfunc);
	}
	/****************************************************************/
	cfindandeval2(string sobj, int iile, string sname, string sfunc, string seval)	{	
		.cfindandeval(sobj, 0, iile-1, sname, sfunc, seval);
	}
	cfindandeval(string sobj, int ifirst, int ilast, string sname, string sfunc, string seval)	{	
		int pos = ._stdfindfunc(sobj, ifirst, ilast, sname, sfunc);
		if(pos>=0)	<sobj+pos>.<seval>();
	}
}



/*****************************************************************/
class classbutton 	{
	init()	{
		new string san = "anbut";
		new string sbut = "but";
		new int iilebut = 0;
		new string sfxmon = null;
	}
	_cbuildbutname(string sname)	{	new string _sbutname=sname; }
	string cgetbutname()	{ return _sbutname; }
	build(string sfile, int z, string smouse)	{this.build2(sfile,z,smouse,null);	}
	build2(string sfile, int z, string smouse, string sgrp)	{	// wczytuje animacje i buduje z niej przyciski
		string smain = "_" + san;
		new anima <smain>;
		<smain>.load( sfile );
		<smain>.setz(z);
		int ile = <smain>.nofactions();
		int j;	int k;
		int iliczans = 0;
		string sn1, string sn2, string sn3;
		string spom;
		for(int i=0; i<ile; i++)	{
			sn1 = null;	sn2 = null;	sn3 = null;
			j = <smain>.nofframes(i);
			for(k=1; k<=j; k++)	{
				spom = san + iliczans;
				if(k==1)	{	sn1=spom; } 
				else if (k==2)	{ sn2 = spom; }
				else if (k==3)	{ sn3 = spom; }
				newvars::copyanima( smain, spom );
				<spom>.setframe( i, k-1 );
				iliczans++;
			}
			if( sgrp!=null && <sgrp>.contains( <smain>.nameofaction(i)) ) {
				<sn1>.setz(z-1);
			} else this.addbut(sn1, sn2, sn3, smouse);
		}
		<smain>.hide();
	}
	/***************************** \/ \/ \/ \/ \/ wewnetrzne \/ \/ \/ \/ \/ *************************************************/
	_buildfuncclick( string sname )	{	new string _sfunclick = sname; }
	_stdbutclick()	{	this.<_sfunclick>( this.getbutname() );		}
	_buildfuncrel( string sname )	{	new string _sfuncrel = sname; }
	_stdbutrel()	{	this.<_sfuncrel>( this.getbutname() );	}
	_buildfuncmovon( string sname )	{	new string _sfunmovon = sname; }
	_stdbutmovon()	{
		if( sfxmon!=null )	<sfxmon>.play();
		this.<_sfunmovon>( this.getbutname() );
	}
	_buildfuncmovoff( string sname )	{	new string _sfunmovoff = sname; }
	_stdbutmovoff()	{	this.<_sfunmovoff>( this.getbutname() );	}
	butsigfun(string sb, string sfunc, string ssig, string sfun1, string sfun2)	{
		if( sfunc==null )	return;
		<sb>.addmethod(sfun1, sfun1);
		<sb>.<sfun1>( sfunc );
		<sb>.addmethod(ssig, sfun2);
	}
	sigfunc(string sfunc, string ssig, string sfun1, string sfun2)	{
		for(int i=0; i<iilebut; i++)	this.butsigfun(sbut + i, sfunc, ssig, sfun1, sfun2);
	}
	print()	{for(int i=0; i<iilebut; i++)	engine.print( <sbut+i>.getbutname() );}
	setrect()	{
		string s;
		for( int i=0; i<iilebut; i++)	{
			s = <sbut+i>.getimg;
			<sbut+i>.setrect( <s>.getpx, <s>.getpy, <s>.getex, <s>.getey );
		}
	}
	setflags(bool bvis, bool balph)	{	for(int i=0; i<iilebut; i++)	<sbut+i>.setflags(bvis,balph);	}
	/***************************** /\ /\ /\ /\ /\ wewnetrzne /\ /\ /\ /\ /\ ************************************************/
	sfxonmovon(string ssnd)	{	sfxmon=ssnd;	}
	clickfunc(string sfunc)	{this.sigfunc(sfunc,"onclick", "_buildfuncclick", "_stdbutclick");	}
	relfunc(string sfunc)	{this.sigfunc(sfunc,"onrel", "_buildfuncrel", "_stdbutrel");	}
	movonfunc(string sfunc)	{this.sigfunc(sfunc,"onmoveon", "_buildfuncmovon", "_stdbutmovon");	}
	movofffunc( string sfunc)	{this.sigfunc( sfunc,"onmoveoff", "_buildfuncmovoff", "_stdbutmovoff");}
	/*****************************************************************/
	int ilebuts()	{	return iilebut;	}
	/*****************************************************************/
	int ifind(string sname)	{return clfindfunc::_stdfindfunc2(sbut, iilebut, sname, "getbutname");	}
	string sfind(string sname)	{
		int pos = clfindfunc::_stdfindfunc2(sbut, iilebut, sname, "getbutname");
		return pos>=0 ? sbut+pos : null;
	}
	/*****************************************************************/
	_cbutfun(string sname, string sfunc)	{
		clfindfunc::cfindandeval2(sbut, this.ilebuts(), sname, "getbutname", sfunc );
	}
	_callbutfunc(string sfunc)	{	for(int i=0; i<iilebut; i++)	<sbut+i>.<sfunc>();	}
	_cibutfunc(string sfunc, int ile)	{
		if( ile > iilebut )	ile = iilebut;
		for(int i=0; i<ile; i++)	<sbut+i>.<sfunc>();
	}
	ienable( int ile )	{	this._cibutfunc("enable", ile);	}
	benableall()	{	this.resumeall();	this.enableall();	}
	pauseall()	{	this._callbutfunc("pause");	}
	resumeall()	{	this._callbutfunc("resume");	}
	enableall()	{	this._callbutfunc("enable");	}
	disableall()	{	this._callbutfunc("disable");	}
	disabled	{	<sbut+0>.disabled;	}
	
	benable(string sname)	{	this.resume(sname);	this.enable(sname);	}
	disable(string sname)	{	this._cbutfun( sname, "disable");	}
	enable(string sname)	{	this._cbutfun( sname, "enable");	}
	pause(string sname)	{	this._cbutfun( sname, "pause");	}
	resume(string sname)	{	this._cbutfun( sname, "resume");	}
	
	resetall()	{	for(int i=0; i<iilebut; i++)	<sbut+i>.setcursorpos(0, 0);	}
	setcursorpos(int x, int y)	{	for(int i=0; i<iilebut; i++)	<sbut+i>.setcursorpos(x, y);	}
	/*****************************************************************/
	string getimg(string sname)	{
		string s= this.sfind(sname);
		return s!=null ? <s>.getimg() : null;	
	}
	callimgfun(string sname, string sfun)	{	<.getimg(sname)>.<sfun>;	}
	/*****************************************************************/
	newmouse(string sname, string snewmouse)	{
		string s = this.sfind(sname);
		if(s!=null)	<s>.setmouse( snewmouse );
	}
	addbut(string san1, string san2, string san3, string smouse)	{
		string spom = sbut + iilebut;
		newvars::newbutan( spom, san1, san2, san3, smouse);
		<spom>.addmethod("getbutname","cgetbutname");
		<spom>._cbuildbutname( <san1>.actionname() );	// nazwa buttonu to nazwa akcji
		iilebut++;
	}
	/*****************************************************************/
	_addfunc(string s, string sfclick, string sfrel, string sfmvon, string sfmvoff)	{
		if( s== null)	return;
		this.butsigfun( s, sfclick, "onclick", "_buildfuncclick", "_stdbutclick");
		this.butsigfun( s, sfrel, "onrel", "_buildfuncrel", "_stdbutrel");
		this.butsigfun( s, sfmvon, "onmoveon", "_buildfuncmovon", "_stdbutmovon");
		this.butsigfun( s, sfmvoff, "onmoveoff", "_buildfuncmovoff", "_stdbutmovoff");
	}
	addfuncto(string sname, string sfclick, string sfrel, string sfmvon, string sfmvoff)	{
		this._addfunc( this.sfind(sname), sfclick, sfrel, sfmvon, sfmvoff);
	}
	addfunctolast(string sfclick, string sfrel, string sfmvon, string sfmvoff)	{
		this._addfunc( sbut + (iilebut-1) , sfclick, sfrel, sfmvon, sfmvoff);
	}
	/*****************************************************************/
	_transmet(string sob, string sfunc, string smet, string s)	{
		new string <"_sob" + s> = sob;
		new string <"_sf" + s> = sfunc;
		this.<smet>( "_trf"+s );
	}
	transclickfunc(string sob, string sfunc)	{this._transmet( sob, sfunc, "clickfunc", "cl" );	}
	transrelfunc(string sob, string sfunc)	{this._transmet( sob, sfunc, "relfunc", "rl" );	}
	transmovonfunc(string sob, string sfunc){this._transmet( sob, sfunc, "movonfunc", "mn" );	}
	transmovofffunc(string sob, string sfunc){this._transmet( sob, sfunc, "movofffunc", "mf" );	}
	_trfcl(string s)	{	<_sobcl>.<_sfcl>(s);		}
	_trfrl(string s)	{	<_sobrl>.<_sfrl>(s);		}
	_trfmn(string s)	{
		if( sfxmon!=null )	<sfxmon>.play();
		<_sobmn>.<_sfmn>(s);
	}
	_trfmf(string s)	{	<_sobmf>.<_sfmf>(s);		}
}


/*****************************************************************/

class classmask : classbutton	{
	init()	{
		classbutton::init();
	}
	buildmask(string sfile, string smouse)	{
		this.build(sfile, 0, smouse);
		int ile = this.ilebuts();
		for(int i=0; i<ile; i++)	{
			<sbut+i>.setflags(false, false);
			<sbut+i>.hide();
		}
	}
	buildmaskfunc(string sfile, string smouse, string sfunc)	{
		this.buildmask(sfile, smouse);
		this.clickfunc(sfunc);
	}
	addmask(string sanim, string sname, string smouse, int bhide)	{		// dodanie np. ludka jako maski
		string spom = sbut + iilebut;
		newvars::newbutan( spom, sanim, null, null, smouse);
		<spom>.addmethod("getbutname","cgetbutname");
		sname==null ? <spom>._cbuildbutname(<sanim>.actionname()) : <spom>._cbuildbutname(sname);
		if(bhide)	{
			<spom>.setflags(false, false);
			<spom>.hide();
		}
		iilebut++;
	}
	addadvmask(string sanim, string sname, string smouse, string sfuncclick)	{
		this.addmask( sanim, sname, smouse, false );
		this.addfunctolast( sfuncclick, null, null, null);	
	}
}

/*****************************************************/
public _stdanloop()	{	this.play(-1); }
public _stdanhide()	{	this.hide();	}
public _stdsndloop()	{	this.play(); }
public __std_finish()	{	this.<this+"_FINISH">();	}
public looponfinish(string san)	{	<san>.addmethod("onfinish", "_stdanloop");	}
public hideonfinish(string san)	{	<san>.addmethod("onfinish", "_stdanhide");	}
/*****************************************************/
public string strsube(int ile)	{	this.getb( 0, this.length()-ile );	}
public string strsubb(int ile)	{	this.getb( ile, this.length() - ile );	}
public string strsubbs(string s)	{	this.strsubb( s.length() );	}
public string strsubes(string s)	{	this.strsube( s.length() );	 }
public string strgetto(string schar)	{
	@id = .find(schar);
	id<0 ? .get : .getb(0, id);
}
public string strgeteto(string schar)	{
	@id = .rfind(schar);
	id<0 ? .get : .getb(id+1, .length);
}
public bool streq(string s)	{	.get == s.getb(0, .length);	}
public string strgetfromto(int ipos, string schar)	{	this.getb(ipos, this.find(schar));	}
public string strgetfrom(string schar)	{	.getb(.find(schar)+schar.length, .length );	}
public strremove(string s)	{	.set( .strgetto(s) + .strgetfrom(s) ); }
public bool strisbetween(int b1, int b2)	{
	int ib;
	for(int i=0; i<.length; i++)	{
		ib = .getbyte(i);
		if( ib<b1 || ib>b2 )	return false;
	}
	true;
}
public bool strisint		{	.strisbetween(BYTE0, BYTE9);	}
public bool strisbin	{	.strisbetween(BYTE0, BYTE0+1);	}
public bool strisalpha	{	.strisbetween(BYTEa, BYTEz);	}
public streach(string sfun)	{
	string s;
	for( int i=0; i<.length; i++) {
		s = .getb(i,1);
		<s>.<sfun>(i);
	}
}
public string strdotpos(int pos)	{	.strgetto(".") + "." + .strgetfrom(".")->getb(0,pos);}
/*****************************************************/
public swap(string s1, string s2)	{
	[s1];
	<s1> = [s2];
	<s2> = _;
}
public bool stats(int ile)	{	(ile <= 0) ? false : ( 100->rand <= ile );}
public def between(def i1, def i, def i2)	{	( i < i1 ) ? i1 : (i>i2) ? i2 : i;}
public def max(def val1, def val2)	{	val1>val2 ? val1 : val2;	}
public def min(def val1, def val2)		{	val1<val2 ? val1 : val2;	}
public inextrol(int id, int ile)	{
	int i = id + .get;
	if( i < 1 ) .set(ile);
	else if ( i > ile ) .set(1);
	else .set(i);
}
/*************** do wykorzystania na obiektach!! ***********************************/
public movoffsetr	{	.move(igmoffsetx,0);	}
public movoffsetl	{	.move(-igmoffsetx,0);	}
public imgprint	{
	(this+": pos="+.getposx+","+.getposy+" xy="+.getpx+","+.getpy+" wh="+.getw + ","+.geth + 
		" exy="+.getex +","+.getey+" lod="+.lodx+","+.lody+" z="+.getz)->print;
}
public imgborders(int w, int r, int g, int b, int a)	{	.imgborderss(w,r,g,b,a,"1111"); }
public imgborderss(int w, int r, int g, int b, int a, string sbor)	{
	new img _img_bor;
	_img_bor.create(.getw, w, r,g,b,a);
	_img_bor.setpos(.getpx, .getpy );
	if(sbor.getb(3,1)=="1")
		.blit("_img_bor");
	_img_bor.move(0, .geth-w);
	if(sbor.getb(1,1)=="1")
		.blit("_img_bor");
	_img_bor.create(w,.geth,r,g,b,a);
	_img_bor.setpos(.getpx, .getpy);
	if(sbor.getb(0,1)=="1")
		.blit("_img_bor");
	_img_bor.move(.getw-w, 0);
	if(sbor.getb(2,1)=="1")
		.blit("_img_bor");
	delete _img_bor;
}
public imgroundborder(int w, int r, int g, int b, int a)	{
	.imgborders(w,r,g,b,a);
	.imgerasecorners;
}
public imgerasecorners	{
	@x = .getpx;
	@y = .getpy;
	.putrgba(x,y,.transparent);
	.putrgba(.getex-1,y,.transparent);
	.putrgba(.getex-1,.getey-1,.transparent);
	.putrgba(x,.getey-1,.transparent);
}
public real imgdrawline(string sbrush, int xstart, int ystart, int xstop, int ystop, real istep, real rdy)	{
	.imgfuncline("blit",sbrush,xstart,ystart,xstop,ystop,istep,rdy);
}
public real imgeraseline(string sbrush, int xstart, int ystart, int xstop, int ystop, real istep, real rdy)	{
	.imgfuncline("erase",sbrush,xstart,ystart,xstop,ystop,istep,rdy);
}
public imgputoncenter(string simg)	{	.setpos( <simg>.getcx-.getw/2, <simg>.getcy-.geth/2);	}
public real imgfuncline(string sfun, string sbrush, int xstart, int ystart, int xstop, int ystop, real istep, real rdy)	{
	@dx = xstop-xstart;
	@dy = ystop-ystart;
	real r;
	if( dx==0 )	{
		if( dy<0 )	{
			r = rdy+ystart;
			while( r>=ystop )	{
				<sbrush>.setpos(xstart, r);
				.<sfun>(sbrush);
				r-=istep;
			}
			ystop-r;
		} else if (dy>0)	{
			r = rdy+ystart;
			while( r<=ystop )	{
				<sbrush>.setpos(xstart, r);
				.<sfun>(sbrush);
				r+=istep;
			}
			r-ystop;
		} else rdy;
	} else {
		r = rdy.length(dx, dy);
		real rd;
		while( rdy<=r )	{
			rd = 1.0 - (r-rdy)/r;
			<sbrush>.setpos( (rd*dx)+xstart, (rd*dy)+ystart );
			.<sfun>(sbrush);
			rdy+=istep;
		}
		rdy-r;
	}
}
public anresizemets()	{	anima_pack::resizemethods(this.getname());	}
//public def anfirstnontr	{	classansearcher::firstnotrx1y(this);	}
public def anfirstnontr	{	classansearcher::_findnotr(this,.getpx, .getpy, 1, 0);	}
public anloopfin()	{	this.addmethod("onfinish", "_stdanloop");	}
public anloopplay(int iact)	{	this.anloopfin();	this.play(iact);	}
public anloopsplay(string sact)	{	this.anloopfin();	this.play(sact);	}
public anhidefin()	{	this.addmethod("onfinish","_stdanhide");	}
public anputgr()	{	this.setz( this.getey() );	}
public anputy(int ypos)	{	this.move(0, ypos - this.geth() - this.getpy());	}
public anputx(int xpos)	{	this.move(0, xpos - this.geth() - this.getpy());	}
public ansetposgr(int x, int y)	{	this.setpos(x,y);	this.anputgr();	}
public anplayz(int id, int z)	{	this.setz(z);	this.play(id);	}
public anplaygr(int id)	{	this.play(id);	this.anputgr();	}
public anplayzpos(int id, int z, int x, int y)	{	this.setpos(x,y);	this.anplayz(id,z);	}
public anplaypos(int x, int y)	{	this.setpos(x,y);	this.play(-1);	}
public anplayposgr(int x, int y)	{	this.ansetposgr(x,y);	this.play(-1);	}
public anplaypos2(int x, int y, string sact)	{	this.setpos(x,y);	this.play(sact);	}
public anplaypos3(int x, int y, int iact)	{	this.setpos(x,y);	this.play(iact);	}
public anhide()	{	this.stop(false);	this.hide();	}
public andownpos(int x, int y)	{	this.setpos( x, y-this.geth() );	}
public ansetbpos(int x, int y)	{	this.setpos( x-this.lodx(), y-this.lody() );	}
public ansetcpos(int x, int y)	{	.ansetbpos( x - .getw/2, y - .geth/2 );	}
public ancenterscreen {       .ansetcpos( igmappw/2, igmapph/2 ); }
public ancenterimg(string simg)	{	.ansetcpos( <simg>.getpx+<simg>.getw/2, <simg>.getpy+<simg>.geth/2 );	}
public imgfit(int x, int y, int ex, int ey)	{
	if( .getpx < x ) .move( x-.getpx, 0 );
	if( .getpy < y ) .move( 0, y-.getpy );
	if( .getex > ex ) .move( ex-.getex, 0 );
	if( .getey > ey ) .move( 0, ey-.getey );
}
public imgfitscreen	{	.imgfit( igmoffsetx, igmoffsety, iResX+igmoffsetx, iResY+igmoffsety );	}
public ansetframe(int id)	{	this.setframe( this.actionnr(-1), id );	}
public ansetsframe(def d, string s)	{
	.setframe(d,0);
	int id = 0;
	while( id < .nofframes(-1) && .framename!=s )	{
		id++;
		.setframe(-1,id);
	}
}
public ansetlastframe(def act)	{	.setframe( act, .nofframes(act)-1 );	}
public int anonscreen()	{	clsurf.inscreen(this.getcx(), this.getcy(), this.getw()/2, this.geth()/2);	}
public objplayfin(string sfun)	{	this.addmethod("onfinish", sfun);	this.play();	}
public objloop()	{	this.addmethod("onfinish","_stdsndloop");	}
public objplayloop()	{	this.objloop;	this.play();	}
public anplayfin(def act, string sfun)	{	this.addmethod("onfinish", sfun);	this.play(act);	}
public anplaysmoothfin(def act, string sfun)	{	.addmethod("onfinish", sfun);	.playsmooth(act);	}
public anplayif(def act)	{ if( .isplaying(act)==false ) .play(act);	}
public anytoz()	{	this.setz(this.getposy());	}
public anposz(int x, int y, int z)	{	.setpos(x,y);	.setz(z);	}
public string annextaction(string sact)	{ this.nameofaction( (this.actionnr(sact)+1)%this.nofactions() );}
public int annextact	{ (.actionnr(-1)+1)%.nofactions; }
public ansetnextact	{	.setframe( (.actionnr(-1)+1)%.nofactions, 0 ); }
public ansetnextfr		{	.setframe( -1, (.framenr+1)%.nofframes(-1)); }
public ansetrandfr	{	.setframe(-1, .nofframes(-1)->rand);	}
public anhasaction(string sac)	{	.actionnr(sac) != .nofactions;}
public anaddfilter()	{	classanfilter::build(this.getname());	}
public anaddfx	{	AnimaFx::build( this );	}
public anputc(int x1, int y1, int x2, int y2)	{
	.ansetbpos(x1,y1);
	.move( (x2-x1-.getw)/2, (y2-y1-.geth)/2 );
}
public aninlod(int itoler)	{	itoler.length( .getpx - .lodx, .getpy - .lody ) <= itoler; }
public angetcpos	{	return .getcx, .getcy;	}
public anactnr	{	.actionnr(-1);	}
public angetcrgba	{	.getrgba(.getcx, .getcy);	}
public anisin(int x, int y, bool bv, bool ba)	{
	for( int i=0; i<.nofactions; i++)	{
		.setframe(i, 0);
		if( .isin(x,y,bv,ba) ) return i;
	}
	-1;
}
public anreload(string sfile)	{
	int id = .actionnr(-1);
	int fr = .framenr;
	bool bplay = .isplaying(-1)!=false;
	|int x, int y| = .getpos;
	int z = .getz;
	.load( .getpath(sfile) );
	.setpos(x, y);
	.setz(z);
	if( id < .nofactions ) {
		if( bplay ) .play(id);
		.setframe(id ,fr );
	} else .setframe(0 ,0);
}
public anclipob(string sob)	{	.clip(<sob>.getpx, <sob>.getpy, <sob>.getex, <sob>.getey);	}
public anclipscreen		{	.clip(0,0,igmappw,igmapph);	}
public ancopy(string san)	{	// 4.06.2014 zmienione z ancopyan
	.setframe( <san>.actionnr(-1), <san>.framenr );
	<san>.isvisible ? .show : .hide;
	.setpos( <san>.getpos );
}
public anconstmove(int delay, int x, int y)	{
	.vars2(A, "mvx", x, "mvy", y);
	.setdelay(delay);
	.anplayfin(-1, func { .play(-1); .move(mvx, mvy); });
}
//---------------- sounds --------------------
public fxplayifgr(string ssnd,int istart, int iend)	{
	while( <ssnd+istart>.isplaying && istart < iend )	{
		istart++;
	}
	<ssnd+istart>.playif;
}
//--------------- scale ----------------
public scmove(int x, int y)	{	.move( rgmscalex*x, rgmscaley*y );	}
public scpos(int x, int y)	{	.setpos( rgmscalex*x, rgmscaley*y );	}
public int igetsc		{
	if( .get < 0 ) (rgmscalex*.get-0.5)->to_i;
	else (rgmscalex*.get + 0.5)->to_i;
}
public int igetsc1		{
	@id = .igetsc;
	(id.abs<1 ? id.sgn : id);
}
public real rgetsc		{	rgmscalex * .get;	}
/***************** text ****************/
public txtset(string s)	{	.set(s);	.create;	}
public txtsetcol(string s, int r, int g, int b)	{	.set(s);	.createtxt(r,g,b);	}
public txtshadow(int w, string sfont)	{
	if( !.hasvar("txts") )	{
		new text txts;
		txts.setfont(sfont);
	}
	txts.set(.get);
	txts.setpos(.getpx+w, .getpy+w);
	txts.setz(.getz-1);
	txts.show;
	txts.createtxt(0,0,0);
}
public txthides	{	.hide; if(.hasvar("txts")) txts.hide; }
public txtshows	{	.show; if(.hasvar("txts")) txts.show; }
public txtisin(int x, int y)	{
	x>=.getpx && x<.getpx+.getw && y>=.getpy && y<=.getpy+.geth;
}
public txtcenter(string sob)	{	.setpos( <sob>.getcx - .getw/2, <sob>.getcy - .geth/2 );}
public txtright(string sob)	{	.setpos( <sob>.getex - .getw, <sob>.getcy - .geth/2 );}
public txtcenterscreen		{	.setpos( (igmappw-.getw)/2, (igmapph-.geth)/2 );	}
public imgfittxt( string stxt, string simg, string simgtxt, int stepy, bool bcreate )	{
	if( bcreate )	{
		.create( <simg>.getw, <simg>.geth + 2*stepy, .transparent );
		.setpos( <simg>.getpx, <simg>.getpy );
	}
	
	new vector _vtmplin;
	_vtmplin.type("string");
	_vtmplin.vecbuildfromstring(stxt, " ");
	string s = "", string s2, string s3;
	int x, int y, int ex, int ey;
	bool bnewline, bool bnextline;
	string snewline = "\\n";
	
	int yp = <simg>.getpy;
	|x, y| = classansearcher::_findnotr(simg, <simg>.getpx, yp, 1, 0);
	|ex, ey| = classansearcher::_findnotr(simg, <simg>.getex-1, yp, -1, 0);
	for( int i=0; i< _vtmplin.size; i++)	{
		s2 = s;
		s3 = _vtmplin.get(i);
		
		if( s3.contains(snewline) )	{
			string st1 = s3.strgetto(snewline);
			string st2 = s3.strgetfrom(snewline);
			if( st1.length > 0 ) {
				s3 = st1;
			} else s3 = "";
			if( st2.length > 0 )	{
				_vtmplin.vecaddat(i+1, st2);
			}
			bnewline=true;
		} else bnewline = false;
		s += s3 + " ";
		<simgtxt>.txtset(s);
		<simgtxt>.setpos( x, yp );
		if( <simgtxt>.getpx + <simgtxt>.getw > ex || bnewline )	{
			if( <simgtxt>.getpx + <simgtxt>.getw <= ex )	{
				s2 = "";
			} else if ( bnewline && i+1<_vtmplin.size)	{
				_vtmplin.set(i+1, snewline + _vtmplin.get(i+1));
			}
			if( s2!="" ) {
				<simgtxt>.txtset(s2);
				s = s3 + " ";
				s2 = s;
			} else {
				s = "";
				s2 = "";
			}
			.blit( simgtxt );
			yp += stepy;
			if( yp < <simg>.getey )	{
				|x, y| = classansearcher::_findnotr(simg, <simg>.getpx, yp, 1, 0);
				|ex, ey| = classansearcher::_findnotr(simg, <simg>.getex-1, yp, -1, 0);
			}
		}
	}
	if( s!="" ) {
		<simgtxt>.txtset(s);
		<simgtxt>.setpos( x, yp );
		.blit(simgtxt);
	}
	delete _vtmplin;
}
/***************** vector ****************/
public vecinc(int pos)	{	this.set( pos, this.get(pos)+1 );	}
public vecdec(int pos)	{	this.set( pos, this.get(pos)-1 );		}
public vecnewint(int ile)	{
	this.free();
	if( ile>0 )	for( int i=0; i<ile; i++)	{	this.add(i);	}
}
public veccopy(string svec)	{
	this.free();
	for( int i=0; i< <svec>.size(); i++ )	this.add( <svec>.get(i) );
}
public int vecnextid(def val)	{
	int id = .find(val);
	if( id>=0 )	id = (id+1)%.size;
	id;
}
public int vecprevid(def val)	{
	int id = .find(val);
	if( id>0 )	id--;
	else if (id==0)	id = .size-1;
	id;
}
public def vecget(int id)	{
	( id>=0 && id<.size) ? .get(id) : null;
}
public def vecnext(def val)	{	.vecget( .vecnextid(val) );	}
public def vecprev(def val)	{	.vecget( .vecprevid(val) );	}
public def veclast()	{
	int ile = this.size();
	ile>0 ? this.get(ile-1) : null;
}
public def vecpop()	{
	@x = .last;
	.removeat( .size - 1 );
	x;
}
public veclimes(int ile)	{	while( .size > ile )	_ = .vecpop;	}
public def vecpopfront()	{
	def x = this.get(0);
	this.removeat( 0 );
	x;
}
public vecreplace(def d1, def d2)	{
	@id = .find(d1);
	if( id>=0 )	.set(id,d2);
}
public insertsort(int ile, string sgetfun, string scomparefun, string sswapfun)	{
	if( ile<=1 )	{	return;	}
	def s[2], int id, int i, int j;
	for( i=0; i<ile; i++)	{
		s0 = this.<sgetfun>(i);
		id = i;
		for( j=i+1; j<ile; j++)	{
			s1 = this.<sgetfun>(j);
			if( this.<scomparefun>(s1,s0) )	{
				s0 = s1;
				id = j;
			}
		}
		this.<sswapfun>(i,id);
	}
}
public obbuildfromstring(string s, string separator, string sfunadd)	{
	int pos = s.find(separator);
	while( pos>-1 )	{
		this.<sfunadd>( s.getb(0,pos) );
		s = s.strsubb(pos+1);
		pos = s.find(separator);
	}
	if( s.length()>0 )	{	this.<sfunadd>(s);	}
}
public obbuildfromstring2(string s, string separator, string sfunadd)	{
	int pos = s.find(separator);
	while( pos>-1 )	{
		if( pos>0 )	this.<sfunadd>( s.getb(0,pos) );
		s = s.strsubb(pos+1);
		pos = s.find(separator);
	}
	if( s.length()>0 )	{	this.<sfunadd>(s);	}
}
public vecsort(string scomparefun)	{ .insertsort( .size, "get", scomparefun,"swap" ); }
public string vecbuildfromstring(string s, string separator)	{
	this.free();
	this.obbuildfromstring(s,separator,"add");
}
public string vecbuildfromstring2(string s, string separator)	{
	this.free();
	this.obbuildfromstring2(s,separator,"add");
}
public vecremoveto(int ito)		{	for( int i=0; i<ito; i++ ) this.removeat(0);		}
public vecremovefrom(int ifrom)	{	while( ifrom<this.size() ) this.removeat(ifrom);	}
public vecfindfrom(int ifrom, def d)	{
	while (ifrom<.size)	{
		if( .get(ifrom)==d ) return ifrom;
		else ifrom++;
	}
	-1;
}
public vecposfromto(int i1, int i2)	{
	if( i1==i2 || .size==0 )	return;
	def x = .get(i1);
	if( i1>i2 )	for( int i=i1; i>i2; i--)	{	.set(i, .get(i-1));		}
	else if (i1<i2)	for( int i=i1; i<i2; i++)	{	.set(i, .get(i+1));	}
	.set(i2,x);
}
public vecposfirst( def x )	{
	int id = .find(x);
	if( id>=0 )	.vecposfromto(id, 0);
	else	.addbegin(x);
}
public vecposlast( def x )	{
	int id = .find(x);
	if( id>=0 )	.vecposfromto(id, .size-1);
	else	.addbegin(x);
}
public vecset(def x, def d2)	{
	int id = .find(x);
	if( id>=0 )	.set(id,d2);
}
public bool veceq(string svec)	{
	int id = .size;
	if( id != <svec>.size  )	return false;
	for( int i=0; i< id; i++)	if( .get(i)!=<svec>.get(i) ) return false;
	true;
}
public vecbuild	{	.withlist("addbegin");}
public bool veceq2	{
	new vector ___v;
	___v.type(.getvectype);
	___v.vecbuild;
	bool b = .veceq("___v");
	delete ___v;
	b;
}
public veccopydbrow(string sdb, int irow)	{	.free;	 .vecadddbrow(sdb,irow);	}
public vecadddbrow(string sdb, int irow)	{	for( int i=0; i< <sdb>.getcolsno(irow); i++)	.add( <sdb>.get(irow,i) );	}
public def vecchecknext(int id)	{
	id++;
	id < .size ? .get(id) : null;
}
public vecaddat(int pos, def val)	{
	if( pos>=0 && pos <= .size )	{
		.add(val);
		for( int i=.size-1; i>pos; i-- )	{
			.set(i, .get(i-1));
		}
		.set(pos,val);
	}
}
public def vecsumto(int ile)	{
	if( ile<0 || .size==0 ) {
		return 0;
	} else if( ile > .size ) {
		ile = .size;
	}
	def sum = .get(0);
	for( int i=1; i<ile; i++)	{
		sum+=.get(i);
	}
	sum;
}
public def vecsum	{	.vecsumto(.size);	}
public int vecclosest(def val)	{
	int ile = .size;
	if( ile <= 0 ) return -1;
	int id = 0;
	def ipom = (val - .get(0))->abs;
	for( int i=1; i<ile; i++)	{
		def ipom2 = (val - .get(i))->abs;
		if( ipom2<ipom )	{
			id = i;
			ipom = ipom2;
		}
	}
	id;
}
public vecloadargs	{
	@s = _;
	while(s!=A)	{
		.addbegin(s);
		@s = _;
	}
}
public vecbuildlines(string stxt, int charlimit)	{
	.free;
	.type("string");
	if( charlimit <= 0 ) return;
	new vector _vtmplin;
	_vtmplin.type("string");
	_vtmplin.vecbuildfromstring(stxt, " ");
	string s = "";
	for( int i=0; i< _vtmplin.size; i++)	{
		s+=_vtmplin.get(i) + " ";
		if( s.length >= charlimit )	{
			.add(s);
			s = "";
		}
	}
	if( s!="" ) .add(s);
	delete _vtmplin;
}
/************** db ************************/
public dbbuild(int icol)	{
	if( icol<=0 )	return;
	icol--;
	.free;
	string s = _, int id;
	for( int i = 0; s!=A; )	{
		if( i==0 )	id = this.addbeginrow() - 1;
		this.addbegin(0,s);
		s = _;
		i = (i<icol)? i+1 : 0;
	}
}
public dbbuild2	{
	.free;
	string s = _;
	while( s!=A )	{
		if( s==null )	_ = .addbeginrow;
		else .addbegin(0,s);
		s = _;
	}
}
public dbaddvec(string svec)	{
	@id = .addrow-1;
	for( int i=0; i< <svec>.size; i++)	.add(id, <svec>.get(i));
}
public dbcopy(string sdb)	{	.dbcopyfromto(sdb, 0, <sdb>.getrowsno);}
public dbcopyrow(string sdb, int irow)	{	.dbcopyfromto(sdb,irow,irow+1);	}
public dbcopyfromto(string sdb, int i1, int i2)	{
	.free;
	.dbaddrowfromto(sdb,i1,i2);
}
public dbaddrowfromto(string sdb, int i1, int i2)	{
	int i, int j, int row;
	for( i =i1; i< i2; i++)	{
		row = .addrow-1;
		for( j=0; j< <sdb>.getcolsno(i); j++)	{
			.add( row, <sdb>.get(i,j) );
		}
	}
}
public dbadddbrowtorow(int myrow, string sdb, int row)	{
	for( int i=0; i< <sdb>.getcolsno(row); i++)	{
		.add( myrow, <sdb>.get(row,i) );
	}
}
public dbremovecol(int col)	{	for(int i=0; i<.getrowsno; i++) if( .getcolsno(i)>col ) .removeat(i,col);	}
public dbcopyfromtos(string sdb, string sfrom, string sto)	{
	.dbcopyfromto(sdb, <sdb>.findbyrow(sfrom)+1, <sdb>.findbyrow(sto));
}
public dbremovelast()	{
	.removerow( .getrowsno-1 );
}
public dbcuttosize(int isize)	{
	if( isize>0 ) while( .getrowsno > isize )	.dbremovelast;
	else	.free;
}
public dbaddlast(string svar)	{	this.add( this.getrowsno()-1, svar );	}
public dbaddstringrow(string s, string separator)	{
	_ = this.addrow();
	this.obbuildfromstring(s,separator,"dbaddlast");
}
public dbrowtostring(int row, int colstart, int colend, string separator)	{
	string s="";
	int ile = .getcolsno(row)-1;
	if( colend<0 || colend > ile )
		colend = ile;
	for( ; colstart<=colend; colstart++) s+= .get(row,colstart) + separator;
	s;
}
public dbgetstringrow(int row)	{	.dbrowtostring(row, 0, -1, "");	}
public dbaddrow	{
	@id = .addrow - 1;
	@s = _;
	while(A!=s)	{
		.addbegin(id, s);
		@s = _;
	}
}
public dbaddrowfrom(string sdb, int irow, int icol)	{
	if( <sdb>.rowinrange(irow) && icol>=0)	{
		int id = this.addrow()-1;
		int ile = <sdb>.getcolsno(irow);
		while( icol < ile )	{
			this.add( id, <sdb>.get( irow, icol ) );
			icol++;
		}
	}
}
public string dbchecknext(int irow, int icol)	{
	icol++;
	icol < this.getcolsno(irow) ? this.get(irow,icol) : null;
}
public string dbgets(string s, int icol)	{
	@id = .findbyrow(s);
	if( id>=0 && .getcolsno(id)>icol ) .get(id,icol);
	else null;
}
public string dbget(string s)	{ @id=.findbyrow(s); id>=0 ? .get( id, 1 ) : null; }
public int dbgetint(string s)	{ @id=.findbyrow(s); id>=0 ? .get( id, 1 )->to_i : 0; }
public def dbgetdef(string s, def val)	{ @id=.findbyrow(s); id>=0 ? .get( id, 1 ) : val; }
public real dbgetscr(string s)	{ @id=.findbyrow(s); id>=0 ? .get( id, 1 )->to_r*rgmscalex : 0.0; }
public int dbinsertless(int i1)	{
	int id = this.addrow()-1;
	this.add(id,i1);
	this.dbsort("cmpless");
	while( id>=0 )	{
		if( i1==this.get(id,0) )	return id;
		id--;
	}
	-1;
}
public bool dbdelvar(int irow, string svar)	{ this.dbdelvarn(irow,svar,1);}
public bool dbdelvarn(int irow, string svar, int n)	{
	int id = this.dbfindinrow(irow,svar);
	if( id>=0 )	{
		this.removen(irow,id,n);
		return true;
	}
	false;
}
public int dbfindinrow(int irow, string svar)	{
	if( this.rowinrange(irow) )	{
		for( int i=0; i<this.getcolsno(irow); i++)	if( this.get(irow,i)==svar )	return i;
	}
	-1;
}
public int dbfindbycol(int icol, string svar)	{
	for( int i=0; i<this.getrowsno(); i++)	{if( this.get(i,icol)==svar ) return i;}
	-1;
}
public bool dbrowcontains(int irow, string svar)	{	this.dbfindinrow(irow,svar)!=-1;	}
public string dbfirst(int id)		{	this.get(id,0);	}	
public bool cmpless(int i1, int i2)	{	i1<i2;	}
public bool cmpabove(int i1, int i2)	{	i1>i2;	}
public bool dbfirstless(int i1, int i2)	{	.get(i1,0) < .get(i2,0);	}
public dbsort(string scomparefun)	{	.insertsort( .getrowsno, "dbfirst",scomparefun, "swap" ); }
public dbsetall(string svar)	{	for( @i=0; i<.getrowsno; i++)	for(@j=0; j<.getcolsno(i); j++)	.set(i,j,svar);	}
public dbeach_row(string sfun)	{	for( @i=0; i<.getrowsno; i++) .<sfun>(i);	}
public dbeq(string sdb)	{
	if( .getrowsno != <sdb>.getrowsno ) return false;
	int ile, int j;
	for( int i=0; i<.getrowsno; i++)	{
		ile = .getcolsno(i);
		if( ile!=<sdb>.getcolsno(i) ) return false;
		for( j=0; j<ile; j++)	{
			if( .get(i,j)!=<sdb>.get(i,j) ) return false;
		}
	}
	true;
}
/************** int ************************/
public int randdiff(int zakres, int odjakiej)	{
	if( zakres<=1 )		return -1;
	for( int i1 = zakres.rand; i1==odjakiej; i1= zakres.rand )	{}
	i1;
}
public int bin_to_i	{
	string s = .get;
	int idwa = 1;
	int iout = 0;
	for( int i=s.length-1; i>=0; i--)	{
		if( s.getb(i,1)=="1") iout+=idwa;
		idwa*=2;
	}
	iout;
}
//----------------- timer ------------
public timsetmstick(int ims)	{	.settick(ims.imstotick);	}


//---------------- sygnaly --------------

public std_anfadeout_finish	{
	.unlink_internal_filter;
	.hide;
}

public delete_internals	{
	<gameapi.getgamename>.vardelif(<"__ft" + this>.getfullname);
	.vardelif("__ft" + this);
	.vardelif("__tim" + this);
}
//------------- funkcje ------------

public string internal_filter	{
	@s = "__ft" + this;
	if( !.hasvar(s) ) {
		new filter <s>;
		<s>.buildfullname;
	}
	<s>.link(this);
	<s>.getfullname;
}

public string internal_timer	{
	@s = "__tim" + this;
	if( !.hasvar(s) ) {
		new timer <s>;
		<s>.setcycle(1);
		<s>.vars2(A, "sfunc", null, "sfilter", null, "rstep", 0.0, "ropacity", 0.0, "rstepzoom", 0.0, "rzoom", 0.0,
			"rzoomsmall", 0.0, "rzoombig", 1.0, "ralfamin", 0.0, "ralfamax", 255.0);
	}
	s;
}
public unlink_internal_filter	{
	@s = .internal_timer;
	if( .hasvar(s) ) <s>.stop(false);
	<.internal_filter>.unlink;
}
public anhideonsetframe	{
	.var("bhideonsf");
	if( !.hasvar("bopacityfr") )	{
		.addmethod("onsetframe", "_stdanhide" );
	}
}

public anopacityframe	{
	.var("bopacityfr");
	.addmethod("onsetframe", func {
		@s = .framename;
		if( s.getb(0,2)=="op" )	{
			<.internal_filter>.setopacity( s.strsubb(2)->to_r/100.0 * 255 );
		} else <.internal_filter>.setopacity(255);
		if( .hasvar("bhideonsf") )
			.hide;
		} );
}

public anrandfrplay	{
	.var("brandfrplay");
	.addmethod("onendframe", "ansetrandfr");
}

public ansetopacity(int iop)	{
	<.internal_filter>.setopacity(iop);
}
public anzoom(real fzoom)	{
	@s = .internal_filter;
	<s>.setpivottype(1);
	<s>.setsmooth(1);
	<s>.setzoom(fzoom);
}
public anzoomxy(real fzoomx, real fzoomy)	{
	@s = .internal_filter;
	<s>.setpivottype(1);
	<s>.setsmooth(1);
	<s>.setzoomxy(fzoomx, fzoomy);
}
public anzoomin(int ms, string sfun)	{
	.ansetopacity(255);
	.anzoomfadeinout(ms,1,0,sfun);
}
public anzoomout(int ms, string sfun)	{
	.ansetopacity(255);
	.anzoomfadeinout(ms,-1,0,sfun);
}
public anfadein(int ms, string sfun)	{
	.anzoomfadeinout(ms,0,1,sfun);
}
public anzoomfadein(int ms, string sfun)	{
	.anzoomfadeinout(ms,1,1,sfun);
}
public anzoomfadeout(int ms, string sfun)	{
	.anzoomfadeinout(ms,-1,-1,sfun);
}
public anfadeout(int ms, string sfun)	{
	.anzoomfadeinout(ms,0,-1,sfun);
}
public anzoomfadeinout(int ms, int zoomdir, int dir, string sfun)	{
	._anzoomfadeinout(ms, zoomdir, dir, sfun, 0,255, 0.0,1.0 );
}
public _anzoomfadeinout(int ms, int zoomdir, int dir, string sfun, real alfamin, real alfamax, real rzoomsmall, real rzoombig)	{
	if( dir>0 ) dir=1;
	else if (dir<0) dir=-1;
	
	if(zoomdir>0 ) zoomdir=1;
	else if(zoomdir<0) zoomdir=-1;
	
	.show;
	@sf = .internal_filter;
	@st = .internal_timer;
	<sf>.link(this);
	<st>.sfunc = (sfun);
	
	ms = ms / engine.getloopdelay;
	if( ms<=0 )	{
		if( dir>0 )	.ansetopacity(alfamax);
		else	.ansetopacity(alfamin);
		if( sfun!=null ) .<sfun>;
		return;
	}
	
	real step = (alfamax-alfamin)/ms;
	if( step<1.0 ) step = 1.0;
	real stepzoom = (rzoombig - rzoomsmall)/ms;
	//<st>.vars2(A, "sfilter", sf, "rstep", step * dir, "ropacity", 0.0, "rstepzoom", stepzoom*zoomdir, "rzoom", 0.0);
	<st>.sfilter = (sf);
	<st>.rstep = ( step * dir );
	<st>.ropacity = ( alfamin );
	<st>.rstepzoom = ( stepzoom * zoomdir );
	<st>.rzoom = ( 0.0 );
	<st>.rzoomsmall = (rzoomsmall);
	<st>.rzoombig = (rzoombig);
	<st>.ralfamin = (alfamin);
	<st>.ralfamax = (alfamax);
	if( dir )	{
		<sf>.setopacity( dir==1 ? alfamin : alfamax );
		<st>.ropacity = ( <sf>.getopacity );
	}
	if( zoomdir )	{
		<sf>.setzoom( zoomdir==1 ? rzoomsmall+stepzoom : rzoombig );
		<st>.rzoom = ( <sf>.getzoomx );
	}
	<st>.addmethod("onfinish", func {
		ropacity += rstep;
		rzoom += rstepzoom;
		if( (ropacity>=ralfamax && rstep>0.0) || (rzoom>=rzoombig && rstepzoom>0.0) )	{
			if( rstepzoom>0.0 ) {
				<sfilter>.setzoom( rzoombig );
			}
			if( rstep>0.0 )	<sfilter>.setopacity(ralfamax);
			if( sfunc!=null ) <.getbuildername>.<sfunc>;
		} else if ( (ropacity<=ralfamin && rstep<0.0) || (rstepzoom<0.0 && rzoom < rzoomsmall-rstepzoom) )	{
			/*if( rstepzoom<0.0 ) <.getbuildername>.hide;
			if( rstep<0.0 )	<sfilter>.setopacity(0);*/
			if( (rstepzoom<0.0 && rzoomsmall==0.0) || (rstep<0.0 && ropacity<=ralfamin) )	{
				<sfilter>.unlink;
				<.getbuildername>.hide;
			}	// gdy rzoomsmall != 0, zostaw widoczny
			if( sfunc!=null ) <.getbuildername>.<sfunc>;
		} else {
			if( rstep !=0.0 )
				<sfilter>.setopacity(ropacity);
			if( rstepzoom!=0.0 )
				<sfilter>.setzoom(rzoom);
			.play;
		}
		} );
	<st>.play;
}

public imgbuildfromlist	{
	new vector __vtmp;
	__vtmp.type("string");
	__vtmp.vecloadargs;
	.imgbuildfromvec("__vtmp");
	delete __vtmp;
}
public imgbuildfromvec(string svec)	{
	if( <svec>.empty ) return;
	string s = <svec>.first;
	int x = <s>.getpx;
	int y = <s>.getpy;
	int ex = <s>.getex;
	int ey = <s>.getey;
	for( int i=1; i < <svec>.size; i++ )	{
		s = <svec>.get(i);
		if( x > <s>.getpx ) x = <s>.getpx;
		if( y > <s>.getpy ) y = <s>.getpy;
		if( ex < <s>.getex ) ex = <s>.getex;
		if( ey < <s>.getey ) ey = <s>.getey;
	}
	.create( ex-x, ey-y, .transparent );
	.setpos(x, y);
	for( i=0; i< <svec>.size; i++)	{
		.blit(<svec>.get(i));
	}
}

public anfadeoutloop	{	.anfadeout(ifadedelay,"anfadeinloop");	}
public anfadeinloop	{	.anfadein(ifadedelay,"anfadeoutloop");	}
public imgstopoverlay	{
	@s = .imgetoverlay;
	<s>.unlink_internal_filter;
	<s>.hide;
}
public imgetoverlay	{	"imgoverlay_"+this;	}
public imgstartoverlay	{	<.imgetoverlay>.anfadeinloop;	}
public _imgbuildoverlay(string sover, int r, int g, int b, int a, int delay)	{
	if( !<GAME>.hasvar(sover) )
		<GAME>.varnew("img", sover);
	//<sover>.clone(this);
	/*<sover>.create( .getw, .geth, .transparent );
	<sover>.setpos( .getpx, .getpy );
	<sover>.blit(this);
	<sover>.setz( .getz );*/
	<sover>.imgclone(this);
	<sover>.paint(r,g,b,a,0);
	if( delay>0 && !<sover>.hasvar("ifadedelay") )	{
		<sover>.var2("ifadedelay", delay);
		<sover>.anfadeinloop;
	}
}
public imgbuildoverlay(int r, int g, int b, int a, int delay)	{	._imgbuildoverlay(.imgetoverlay,r,g,b,a,delay);	}
public imgsetoverlay(int r, int g, int b, int a)	{	.imgbuildoverlay(r,g,b,a,0);	}

public imgclonesize(string simg)	{
	.create( <simg>.getw, <simg>.geth, .transparent );
	.setpos( <simg>.getpx, <simg>.getpy );
}
public imgclonesizecol(string simg, int r, int g, int b, int a)	{
	.create( <simg>.getw, <simg>.geth, r,g,b,a );
	.setpos( <simg>.getpx, <simg>.getpy );
}
public imgclone(string simg)	{
	.imgclonesize(simg);
	.blit(simg);
	.setz( <simg>.getz );
	<simg>.isvisible ? .show : .hide;
}

public imgclonezoom(string simg, real rzoom)	{
	<simg>.anzoom(rzoom);
	.imgclone(simg);
	<simg>.unlink_internal_filter;
}

public imgloadzoom(string sfile, real rzoom)	{
	.newimg("_imtmpload", sfile, 0);
	.imgclonezoom("_imtmpload",rzoom);
	delete _imtmpload;
}

/***************************************************************************/
class classgamepause	{
	init()	{
		new button butpause;
		butpause.setrect( 0, 0, iResX, iResY );
		butpause.addmethod("onclick", "resume");
		butpause.disable();
	}
	resume()	{
		butpause.disable();
		gameapi.resume();
	}
	pause()	{
		gameapi.pause();
		butpause.enable();
		butpause.resume();
	}
}

class TicksCounter	{
	init()	{
		new int istart;
	}
	start()	{	istart = engine.getticks();	}
	stop()	{	istart = engine.getticks() - istart;	}
	get()		{	return istart;	}
	int stopget()	{	this.stop();	return this.get();	}
	print(string s)	{	engine.print(s+" delay: "+this.stopget()+" ms");	}
	put()	{	.print("");	}
}


class ObjController	{
	init()	{
		<GAME>.addgmobj(this);
	}
	removefromgame	{	<GAME>.removegmobj(this); }
}
class LObjController : ObjController, classlocker	{
	init()	{
		ObjController::init;
		classlocker::init;
	}
}

class gmbankvec : gmobjvec	{
	init	{
		gmobjvec::init;
		.var2("iid", -1);
	}
	startrand	{	if(.size>0) iid=.size->rand;	}
	play()	{
		this.stop(false);
		int ile = this.size();
		if( ile==0 ) return;
		iid = (iid+1)%ile;
		<this.get(iid)>.play();
	}
	onfinish()	{}
	stop(bool bfin)	{
		if( this.isplaying() )	{
			<this.getplay()>.stop(bfin);
			if( bfin ) this.onfinish();
		}
	}
	isplaying	{	( iid>=0 )	? <.getplay>.isplaying : false;	}
	getplay()	{	this.get(iid);	}
}

class ClassGameController	{
	init	{
		new gmobjvec __grobj;
		new string GAME = this;
	}
	public addgmobj(string s)	{	__grobj.add(s);		}
	public removegmobj(string s)	{	__grobj.remove(s);	}
	public isgmobj(string s)	{	__grobj.contains(s);	}
	public deletegmobj(string s)	{
		if( .hasvar(s) )	{
			.removegmobj(s);
			delete <s>;
		}
	}
	setpriority(string sob1, string sob2)	{
		int id1 = __grobj.find(id1);
		int id2 = __grobj.find(id2);
		if( id1>=0 && id2>=0 && id1>id2 )	{
			__grobj.swap(id1,id2);
		}
	}
	mousemove	{
		__grobj.eval("onmousemove");
		.mouse_move;
	}
	mouselclick	{
		__grobj.eval("onmouselclick");
		.mouse_lclick;
	}
	mouserclick	{
		__grobj.eval("onmouserclick");
		.mouse_rclick;
	}
	mouselrel	{
		__grobj.eval("onmouselrel");
		.mouse_lrel;
	}
}

class GameController : ClassGameController, classlocker {
	init(string ssndbase)	{
		ClassGameController::init;
		classlocker::init();
		//new gmobjvec __grobj;
		
		new db _dbsnd;
		_dbsnd.setseparator("|");
		new string _sndbase = ssndbase;
		
		new timer __dblclick;
		__dblclick.delay(250);
		__dblclick.settick(1);
		
		new int _itimersnddelay = 50;
		new bool _b_ismoddbg = engine.varexist("moddbg");
		
		new bool _b_skip_mouselclick = false;
	}
	public game_exit()	{
		//.stdexportsnd;
	}
	/*************************************************/
	public setsndbase(string sb)	{	_sndbase=sb;	}
	public say(string styp, string stxt)	{	this.sayf(styp,stxt,null);	}
	public sayf(string styp, string stxt, string sfun)	{
		string s = this.getsndtxt(stxt);
		<s>.setstartstopflag(false,true);
		this.cplayf(styp, s, sfun);
	}
	public string getsndtxt(string stxt)	{
		string ssnd = "snd" + _sndbase + _dbsnd.getrowsno();
		this.addsnd( ssnd, stxt );
		ssnd;
	}
	_sndtimerstart()	{
		int id = _dbsnd.dbfindbycol(1,this.getname());
		if( id>=0 )	engine.print( _dbsnd.get( id,2) );
		else 		engine.print( this.getname() + " not in _dbsnd");
		engine.print("");
	}
	public addsndf(string ssnd, string stxt, string sfun)	{
		this.addsnd(ssnd,stxt);
		if( sfun!=null )	{
			if( ssnd.getb(0,1)==":" ) ssnd = ssnd.strsubb(1);
			<ssnd>.addmethod("onfinish", sfun );
		}
	}
	public asf(string ssnd, string stxt)	{	this.addsndff( "snd" + ssnd, stxt, "end" + ssnd);	}
	public addsndff(string ssnd, string stxt, string sfun)	{
		this.addsndf(ssnd,stxt,sfun);
		//<ssnd>.setstartstopflag(false,true);
	}
	gmconsnd(string ssnd, string swav)	{
		new snd <ssnd>;
		<ssnd>.setstartstopflag(false,true);
		<ssnd>.load( .getsndpath+swav );
		if( igmsubtitle )	{
			subtitle.register(ssnd, .getsndpath+swav);
		}
	}
	public addsnd(string ssnd, string stxt)	{
		int id = _dbsnd.addrow()-1;
		string swav;
		if( ssnd.getb(0,1)==":" )	{
			ssnd = ssnd.strsubb(1);
			swav = _sndbase + "_" + ssnd + id;
		} else swav = _sndbase + id;
		if( engine.fileexist( .getsndpath + swav + ".ogg" ) )
			swav += ".ogg";
		else swav += ".wav";
		string sg = gameapi.getgamename();
		if( igmsoundson && engine.fileexist( this.getsndpath() + swav ) )	{
			<sg>.gmconsnd( ssnd, swav );
		} else {
			<sg>.newtimer( ssnd, stxt.length()*_itimersnddelay, 1);
			<ssnd>.addmethod("onstart", "_sndtimerstart");
			<ssnd>.addmethod("setstartstopflag", func { (bool b1, bool b2) ; });
		}
		_dbsnd.add(id, swav);
		_dbsnd.add(id, ssnd);
		_dbsnd.add(id, stxt);
	}
	public addbank(string sbank, string sfunc)	{
		new gmbankvec <sbank>;
		string s = _;
		string s2;
		while( s!=A )	{
			s2 = this.getsndtxt(s);
			<sbank>.addbegin( s2 );
			if( sfunc!=null ) <s2>.addmethod("onfinish", sfunc );
			s = _;
		}
	}
	public exportbank(string sbase)	{
		if( igmenablesave ) {
			new db <"__db"+sbase> (sbase)	{ (@sbase)
				.dbbuild(1);
				.setseparator("|");
				.dbeach_row( func { (@id)
					@s = this->strsubbs("__db");
					.addbegin(id, "snd"+s+id);
					.addbegin(id, s+id+".wav");
					} );
				if( igmdebug )
					.save("exports/"+sbase+".dlg");
			};
			delete <"__db"+sbase>;
		}
	}
	public importbank(string sbank, string sbase, string sfun)	{
		new gmbankvec <sbank>;
		.importgroupto(sbase, sfun, null, sbank);
	}
	public exportsnd(string sfile)	{	if( igmdebug ) _dbsnd.save(sfile);	}
	public stdexportsnd()	{	this.exportsnd( "exports/" + _sndbase + ".dlg" );	}
	public sounds=()	{	.buildsnds;	}
	public sounds_from(string sbase)	{
		new db __tmpdb;
		@stmpbase = _sndbase;
		.setsndbase(sbase);
		__tmpdb.load("exports/"+sbase+".dlg");
		_dbsnd.free;
		@s = _;
		int id, string sf;
		while( A!=s )	{
			@s1 = _;
			id = __tmpdb.dbfindbycol(1, s1);
			if( id>=0 )	{
				sf = .getsndpath + __tmpdb.get(id,0);
				if( engine.fileexist( sf ) )	{
					<GAME>.gmconsnd( s1, __tmpdb.get(id,0) );
					<s1>.addmethod("onfinish", s );
				} else	.addsndf( s1, __tmpdb.get(id,1), s );
			}
			@s = _;
		}
		_dbsnd.free;
		delete __tmpdb;
		.setsndbase(stmpbase);
	}
	public buildsnds()	{
		_dbsnd.free;
		new db __dbsnd;
		__dbsnd.dbbuild(3);
		.buildfromdb("__dbsnd");
		delete __dbsnd; 
	}
	public buildfromdb(string sdb)	{
		for( int i=0; i< <sdb>.getrowsno; i++)	{
			.addsndf( <sdb>.get(i,0), <sdb>.get(i,1), <sdb>.get(i,2) );
		}
		.stdexportsnd;
	}
	public importsnd(string sbase, string sfun)	{	this.importgroup(sbase, sfun, null );	}
	public importgroup(string sbase, string sfun, string sgr)	{	.importgroupto(sbase,sfun,sgr,null);	}
	public importgroupto(string sbase, string sfun, string sgr, string sgrto)	{
		new db __tmpdb;
		@stmpbase = _sndbase;
		.setsndbase(sbase);
		__tmpdb.load("exports/"+sbase+".dlg");
		_dbsnd.free();
		string s;
		for( int i=0; i<__tmpdb.getrowsno(); i++)	{
			s = __tmpdb.get(i,1);
			if( sgr==null || <sgr>.contains(s) )	{
				.addsndf( s, __tmpdb.get(i,2), sfun );
				if( sgrto!=null ) <sgrto>.add(s);
			}
		}
		_dbsnd.free();
		__tmpdb.free();
		delete __tmpdb;
		.setsndbase(stmpbase);
	}
	public freesnd()	{	_dbsnd.free();	}
	/*************************************************/
	/*public addgmobj(string s)		{	__grobj.add(s);		}
	public removegmobj(string s)	{	__grobj.remove(s);	}
	public isgmobj(string s)	{	__grobj.contains(s);	}
	public deletegmobj(string s)	{
		if( .hasvar(s) )	{
			.removegmobj(s);
			delete <s>;
		}
	}*/
	public lockall()		{
		__grobj.eval("lock");
		this.lock();	
	}
	public unlockall()		{
		__grobj.eval("unlock");
		this.unlock();
	}
	public gmunlockall	{	<GAME>.unlockall;	}
	public gmlockall	{	<GAME>.lockall;	}
	public lock=(bool b)	{	b ? .gmlockall : .gmunlockall; }
	gmcontrol_mousemove	{
		__grobj.eval("onmousemove");
		this.mouse_move();
		if( _b_ismoddbg ) moddbg.msmove();
	}
	public skipmouselclick	{	_b_skip_mouselclick=true;	}
	gmcontrol_mouselclick	{
		__grobj.eval("onmouselclick");
		if( _b_skip_mouselclick )	{
			_b_skip_mouselclick = false;
			.mouse_unskipped_lclick;
		} else {
			this.mouse_lclick();
		}
		if( __dblclick.isplaying )	.mouse_dblclick;
		else __dblclick.play;
		if( _b_ismoddbg ) moddbg.mslclick();
	}
	is_dblclick	{	__dblclick.isplaying;	}
	reset_dblclick	{	__dblclick.play;	}
	gmcontrol_mouserclick()	{
		__grobj.eval("onmouserclick");
		this.mouse_rclick();
	}
	gmcontrol_mouselrel()	{
		__grobj.eval("onmouselrel");
		this.mouse_lrel();
		if( _b_ismoddbg ) moddbg.mslrel();
	}
	gmcontrol_mouserrel()	{
		__grobj.eval("onmouserrel");
		this.mouse_rrel();
	}
	gmcontrol_keydown()	{
		__grobj.eval("onkeydown");
		this.key_down();
		if( _b_ismoddbg ) moddbg.dbkeydown;
	}
	mousemove	{	.gmcontrol_mousemove;	}
	mouselclick	{	.gmcontrol_mouselclick;	}
	mouselrel	{	.gmcontrol_mouselrel;	}
	mouserclick	{	.gmcontrol_mouserclick;	}
	mouserrel	{	.gmcontrol_mouserrel;	}
	keydown		{	.gmcontrol_keydown;	}
}

/* classadv : klasa do przygodowek	*/

new int PrzygodaNumer = 1;
new int PrzygodaMode = .readcfg("PrzygodaMode:", 0);
new bool AdventureGame;

new classfullsave clsave("save.txt");
new string sgmlastscene = null;
new string sgmglobpath = null;	// dla gier, ktore sa w innym katalogu niz ich nazwa
new string sgmgame = null;		// jezeli .adv inaczej sie nazywa niz game

new CutScene ccs(0, 0, igmappw, igmapph);
ccs.setz(2000);

class classadv : classgame, GameController {
	init(string s)	{
		engine.setloopdelay(igmdelay);
		classgame::init();
		.setwavpath(SNDPATH);
		GameController::init(s);
		
		new string _s_game_path;
		new bool bmslock = false;
		
		new bool _b_ismodadvglob = engine.varexist("modadvglob");
		
		new Music music;
		new Button butgame;
		
		igmstate = 0;
		sgmstate = "state_init";
	}
	butenable	{	butgame.addbut(this);		}
	butdisable	{	butgame.removebut(this);	}
	butrefresh	{	butgame.onmousemove;	}
	//--------------- zgodnosc advcontroller z bangui
	advmslock			{	bmslock=true;	}
	advmsunlock			{	bmslock=false;	}
	advgetlock			{	bmslock;	}
	advmssetlock(bool block)	{	block ? .advmslock : .advmsunlock;	}
	//-------------------
	switch_path(string spath)	{
		_s_game_path = <gameapi.getgamename>.getgraphpath;
		<gameapi.getgamename>.setgraphpath(spath);
	}
	restore_path	{	<gameapi.getgamename>.setgraphpath(_s_game_path);	}
	/**************************************************************************/
	newclpathf(string spt, string san, string sfile, int x, int y, real rstep, int ityp)	{
		new classpathf <spt>;
		<spt>.build(san, this.getgraphpath() + sfile, x, y, rstep, ityp);
	}
	newclpathfcopy(string spt, string san, string sptf, real rstep)	{
		new classpathf <spt>;
		<spt>.buildfrom( san, sptf, rstep );
	}
	newpathf(string spathf, string sfile, int x, int y)	{
		new path <spathf>;
		<spathf>.build( this.getgraphpath() +sfile, x, y, 2.0, 1 );
	}
	/**************************************************************************/
	newclbut(string sbut, string sfile, int z, string smouse)	{
		new classbutton <sbut>;
		<sbut>.build( this.getgraphpath() + sfile, z, smouse );
	}
	newclmask(string sm, string sfile, string smouse)	{
		new classmask <sm>;
		<sm>.buildmask( this.getgraphpath() + sfile, smouse );
	}
	newclmaskfunc(string sm, string sfile, string smouse, string sfunc)	{
		new classmask <sm>;
		<sm>.buildmaskfunc( this.getgraphpath() + sfile, smouse, sfunc );
	}
	//---------------------- SAVE ----------------------
	advsaveonstart	{
		clsave.set("GAME_game", gameapi.getgamename);
		clsave.set("GAME_sgmgame", sgmgame);
		clsave.set("GAME_sgmglobpath", sgmglobpath);
		clsave.set("GAME_sgmlastscene", sgmlastscene);
		clsave.set("GAME_ccs", ccs.isvisible);
		.advautosave;
	}
	advautosave	{
		clsave.save("autosave.txt");
		if( _b_ismodadvglob )
			modadvglob.savepck("autosave");
	}
	advautoload	{	._advload("autosave");	}
	advcacheload	{	._advload("cache");	}
	advcachesave	{	._advsave("cache");	}
	_advload(string s)	{
		modadvglob.delheros;
		modadvglob.loadpck(s);
		
		clsave.load(s+".txt");
		sgmgame = clsave.get("GAME_sgmgame");
		sgmglobpath = clsave.get("GAME_sgmglobpath");
		sgmlastscene = clsave.get("GAME_sgmlastscene");
		if( clsave.bis("GAME_ccs") ) ccs.show; else ccs.hide;
		gameapi.play( clsave.get("GAME_game") );
	}
	_advsave(string s)	{
		if( igmenablesave )	{
			new classfullsave _saver(s + ".txt");
			_saver.load("autosave.txt");
			_saver.stdsave;
			delete _saver;
			new vector _vcsave;	_vcsave.type("string");
			new vector _vcsv2;	_vcsv2.type("string");
			if( .saveexist("grpck_autosave.txt") )
				_vcsave.vecload("grpck_autosave.txt");
			_vcsave.vecsave("grpck_"+s+".txt");
			@s2;
			for( int i=0; i<_vcsave.size; i++)	{
				s2 = _vcsave.get(i);
				_vcsv2.vecload(s2 + "autosave_name.txt" );
				_vcsv2.vecsave(s2 + s + "_name.txt" );
				_vcsv2.vecload(s2 + "autosave_file.txt" );
				_vcsv2.vecsave(s2 + s + "_file.txt" );
			}
			delete _vcsave;
			delete _vcsv2;
	// 		arPocket.save( "saves/" + this+sfilepref + "_name.txt" );
	// 		arPocketFile.save( "saves/" + this+sfilepref + "_file.txt" );
		}
	}
	getsavename	{	"save"+PrzygodaNumer;	}
	advload_game	{	._advload(.getsavename);	}
	advsave_game	{	._advsave(.getsavename);	}
	//-------------- STAN GRY --------------
	advstdstate		{	sgmstate=="state_std";	}
	advsetstdstate		{	.advsetstate("state_std");	}
	advsetstate(string s)	{	sgmstate = s;	}
	advisstate(string s)	{	sgmstate==s;	}
	//-------------- przejscia -----------
	stdexitdefadv(string spath, string sgame)	{
		clsave.set("GAME_snextgame", sgame);
		clsave.set("GAME_snextgamepath", spath);
		clsave.set("GAME_snextgametype", "-def");
		.stdexitgame;
	}
	stdexitadvadv(string spath, string sgame)	{
		clsave.set("GAME_snextgame", sgame);
		clsave.set("GAME_snextgamepath", spath);
		clsave.set("GAME_snextgametype", "-adv");
		.stdexitgame;
	}
	stdexit(string sgame)	{
		if( sgame=="exit" )
			ccs.benableloading=(false);
		clsave.set("GAME_snextgame", sgame);
		clsave.set("GAME_snextgamepath", null);
		clsave.set("GAME_snextgametype", "-mg");
		.stdexitgame;
	}
	stdexitgame	{
		if( sgmstate!="state_end" ) 	{
			if( clsave.bis("GAME_fadeout_music") )	{
				clsave.set("GAME_fadeout_music",false);
				music.fadeout(1000);
			}
			//ccs.buildfromscreen;
			sgmstate = "state_end";
			ccs.close( func {
				string sNextGame = clsave.get("GAME_snextgame");
				match(clsave.get("GAME_snextgametype"))	{
					"-def" => .gotoadv(clsave.get("GAME_snextgamepath"), sNextGame);
					"-adv" => .gotoadv2(clsave.get("GAME_snextgamepath"), sNextGame);
					? => gameapi.play(sNextGame);
				}
				} );
		}
	}
	fadescreen(string sfunc)	{
		ccs.buildfromscreen;
		sgmstate = "state_fadescreen";
		ccs.enter(sfunc);
	}
	gotoadv(string spath, string sgame)	{
		sgmlastscene = gameapi.getgamename;
		sgmglobpath = spath;
		sgmgame = sgame;
		gameapi.play("gameadvdef");
	}
	gotoadv2(string spath, string sgame)	{
		sgmlastscene = gameapi.getgamename;
		sgmglobpath = spath;
		sgmgame = null;
		gameapi.play(sgame);
	}
	//-------------------
	onmusicfin      {	music.play;	}
	//virtual game_exit	{}
	exit	{
		.game_exit;
		if( igmsubtitle )	{
			subtitle.reset;
		}
		if( _b_ismodadvglob )
			modadvglob.onexit;
	}
	appdeactivate   {	gameapi.pause;	}
	appactivate	{	gameapi.resume;	}
}


/***************************************************************************/

public winsave(string sval)	{
	if( igmenablesave )	{
		new db _db_win;
		_db_win.load("output.db");
		@id = _db_win.addrow-1;
		_db_win.add(id, sval);
		_db_win.save("output.db");
		delete _db_win;
	}
}

/***************************************************************************/

public saveexist(string sfile)	{	engine.fileexist( .getsavepath + sfile );	}

public vecsave(string sfile)	{	if( igmenablesave ) .save(.getsavepath + sfile);	}

public vecload(string sfile)	{	.load( .getsavepath + sfile );	}

class classfullsave	{
	init(string sfile)	{
		new db dbsav;
		dbsav.setseparator("|");
		new string sstdfile;
		.setfile(sfile);
		//.var2("saveonset",0);
		new bool saveonset = 0;
	}
	public save(string sfile)	{
		if( igmenablesave )
			dbsav.save( .getsavepath + sfile );
	}
	
	_load(string sfile)	{
		if( engine.fileexist(sfile) )	{
			dbsav.free;
			dbsav.load(sfile);
		}
	}
	public load(string sfile)	{	._load( .getsavepath + sfile );	}
	public print()	{	dbsav.print();	}
	public printvar(string svar)	{	engine.print(this + ".var: "+svar+" = " +.get(svar));	}
	public setfile(string sf)	{	sstdfile = sf;	}
	public stdload()	{	this.load(sstdfile);	}
	public stdsave()	{	this.save(sstdfile); }
	public free()	{	dbsav.free();	}
	public set(string sname, string svar)	{
		int id = dbsav.findbyrow(sname);
		if( id>=0 )	{
			dbsav.set(id,1,svar);
		} else {
			id = dbsav.addrow()-1;
			dbsav.add( id, sname );
			dbsav.add( id, svar );
		}
		if( saveonset )
			this.stdsave();
	}
	public bset(string sname)	{	this.set(sname,true);	}
	public bunset(string sname)	{	this.set(sname,false);	}
	public string get(string sname)	{
		int id = dbsav.findbyrow(sname);
		id>=0?dbsav.get(id,1):null;
	}
	public bool is(string sname, string svar)	{
		int i = dbsav.findbyrow(sname);
  		i>=0?dbsav.get(i,1)==svar:false;
	}
	//public bool bis(string sname)	{	return this.is(sname,true);	}
	public bool bis(string sname)	{
		int i = dbsav.findbyrow(sname);
		i>=0?dbsav.get(i,1)!=false:false;
	}
	public bool sbis(string sname)	{
		if( sname.getb(0,1)=="!" ) !.bis(sname.strsubb(1));
		else .bis(sname);
	}
	public bool bislist(string s)	{
		new vector vtmp;
		vtmp.type("string");
		vtmp.vecbuildfromstring(s," ");
		bool b = false;
		if( vtmp.size )	{
			b = .sbis(vtmp.first);
			int i = 1;
			while( i<vtmp.size )	{
				match(vtmp.get(i))	{
					"&" => {
						b = b && .sbis(vtmp.get(i+1));
						i+=2;
					}
					"|" => {
						b = b || .sbis(vtmp.get(i+1));
						i+=2;
					}
					? => i++;
				}
			}
		}
		delete vtmp;
		b;
	}
	public bool bisand2(string spref, int iend)	{	.bisand(spref,1,iend,"");	}
	public bool bisand(string spref, int istart, int iend, string ssuf)	{
		bool b = true;
		while( istart <= iend )	{
			b = b && .bis( spref + istart + ssuf );
			istart++;
		}
		b;
	}
	public bool has(string sname)	{ dbsav.findbyrow(sname) >= 0; }
	public bool bgo(string sname)	{
		if( !.bis(sname) )	{
			.bset(sname);
			true;
		} else false;
	}
	public saveonset=(bool b)	{	saveonset=b;	}
	public remove(string sname)	{
		int i = dbsav.findbyrow(sname);
		if( i>=0 ) {
			dbsav.removerow(i);
			if( saveonset )
				this.stdsave();
		}
	}
	public replace(string snamedest, string snamesrc)	{
		if( .has(snamesrc) )	{
			.set(snamedest,.get(snamesrc));
		} else .remove(snamedest);
	}
	public add(string sname, int val)	{
		if( !.has(sname) )
			.set(sname, val);
		else .set( sname, val + .get(sname) );
	}
	public inc(string sname)	{	.add(sname,1);	}
	public dec(string sname)	{	.add(sname,-1);	}
	public string getdef(string sname, string sval)	{
		int id = dbsav.findbyrow(sname);
		id>=0?dbsav.get(id,1):sval;
	}
}



class StringChecker	{
	init()	{}
	/*bool isdigit(string s)	{	s.to_i == s;	}
	int getint(string s)	{	return s.to_i();	}
	real getreal(string s)	{	return s.to_r();	}	
	bool isreal(string s)	{	return this.isdigit(s)&&s.contains(".");	}
	bool isstring(string s) {	return s.getb(0,1)=="\"";	}
	string getstring(string s)	{	return s.strsubb(1);	}*/
	bool isdigit(string s)		{	s.to_i()!=0 || s.getb(0,1)=="0";	}
	int getint(string s)		{	s.to_i();	}
	real getreal(string s)		{	s.to_r();	}	
	bool isreal(string s)		{	this.isdigit(s) && s.contains(".");	}
	bool isstring(string s) 	{	s.getb(0,1)=="\"";	}
	string getstring(string s)	{	s.strsubb(1);	}
}

class Script	{
	init(string sfile)	{
		new db __dbcode;
		new string __sdb;
		new int __irow;
		new int __icol;
		new string __sreads;
		
		new vector __vec;
		__vec.type("string");
		
		new string __sarg;
		new int __iarg;
		new real __rarg;
		
		new StringChecker __csc;
		new map2 __mp("int");		// odnosniki do funkcji
		for( int i=0; i<10; i++)	new string <"ARG"+i>;
		
		this.load(sfile);
	}
	public ARG=(int id, string s)	{ <"ARG"+id> = s; }
	public ARG(int id)	{ ["ARG"+id]; }
	public load(string sfile)	{
		if( sfile==null )	return;
		if( sfile.contains(".") )	{		// znaczy sie plik jest
			__sdb = "__dbcode";
			__dbcode.loadbeh(sfile);
		} else {
			__sdb = sfile;		// odwolanie przez inna baze
		}
		__mp.free();
		for( int i=0; i < <__sdb>.getrowsno(); i++)	{
			if( <__sdb>.get(i,0)=="func" )
				__mp.add( <__sdb>.get(i,1), i );
		}
		this.call("init");
	}
	public def get(string svar)	{	[svar];	}
	bool isvar(string s)		{	s.getb(0,1)=="$";	}
	string getvar(string s)	{
		s = s.strsubb(1);
		if( !engine.varexist(s) )
			new def <s>;
		s;
	}
	bool isfunc(string s)	{	(s.contains(".") && !__csc.isreal(s)) || (s.contains("::"));	}
	getfunc(string sfun)	{
		__vec.free();
		if( sfun.contains(".") )	{
			__vec.add( sfun.strgetto(".") );
			__vec.add( sfun.strgetfrom(".") );
		} else {
			__vec.add( sfun.strgetto("::") );
			__vec.add( sfun.strgetfrom("::") );
		}
	}
	string _get()	{
		__icol++;
		<__sdb>.get(__irow,__icol-1);
	}
	bool isnext()	{
		if( __icol < <__sdb>.getcolsno(__irow) )	{
			__sreads=<__sdb>.get(__irow,__icol);
			true;
		} else
			false;
	}
	perror(bool expr, string sout)	{
		if( expr )
			engine.print("error: " + sout);
	}
	interpcall(string scal)	{
		this.getfunc(scal);
		string sob = __vec.get(0);
		if( sob.getb(0,1)=="*" ) sob=[sob.strsubb(1)];
		string sfun = __vec.get(1);
		if( sfun.getb(0,1)=="*" ) sob=[sfun.strsubb(1)];
		__vec.free();
		__icol++;	// omin '('
		string s = this._get();
		while( s!=")" )	{
			this.getexpr(s);	// odloz na stos argumenty
			s = this._get();
		}
		if( scal.contains("::") )	{
			<sob>::<sfun>;
		} else {
			if( sob=="this" ) sob=null;
			this.callfun(sob,sfun);
		}
	}
	string getvname(string s)	{
		if( this.isvar(s) )	{
			s=this.getvar(s);
		} else if(__csc.isreal(s))	{
			__rarg = s.to_r();
			s = "__rarg";
		} else if( __csc.isdigit(s) ) {
			__iarg = s;
			s = "__iarg";
		} else if( __csc.isstring(s) ) {
			__sarg = __csc.getstring(s);
			s = "__sarg";
		}
		s;
	}
	bool isscriptfun(string s)	{	s.contains("->");	}
	string getscriptfun(string s)	{	s.strsubb(2);	}
	getexpr(string sexpr)	{
		if( __csc.isstring(sexpr) )	{
			<this.getvname(sexpr)>.get();
		} else if( this.isfunc(sexpr) )	{
			this.interpcall(sexpr);
		} else if(this.isscriptfun(sexpr))	{
			int r = __irow;
			int c = __icol;
			this.call( this.getscriptfun(sexpr) );
			__irow = r;
			__icol = c;
		} else {
			<this.getvname(sexpr)>.get();
		}
	}
	bool cmp()	{
		bool bodp=false;
		def d0 = this.getexpr(this._get());
		string s2 = this._get();		// typ porownania
		def d1 = this.getexpr( this._get() );
		match(s2)	{
			"==" =>	{	bodp = d0 == d1;	}
			"!=" =>	{	bodp = d0 != d1;	}
			"<" =>	{	bodp = d0 < d1;		}
			">" =>	{	bodp = d0 > d1;		}
			"<=" =>	{	bodp = d0 <= d1;	}
			">=" =>	{	bodp = d0 >= d1;	}
			? => ;
		}
		s2 = this._get();
		if( s2=="||" )	
			bodp || this.cmp();
		else if (s2=="&&")
			bodp && this.cmp();
		else	bodp;
	}
	public containsfun(string sfun)	{	__mp.contains(sfun);	}
	public addscript(string sob, string smethod, string sfunscript)	{
		<sob>.vars2(A, "_script_eval", this, "_smetscript_"+smethod, sfunscript);
		<sob>.addmethod( smethod, func {
			<_script_eval>.call( ["_smetscript_"+.methodname] );
			} );
	}
	public call(string sfun)	{
		if( !__mp.contains(sfun) )	return;
		
		__irow = __mp.get( sfun );
		__irow++;
		__icol=0;
		
		bool bgo = true;
		bool bif = false, bool bifexp, bool bwhile=false;
		bool belif=false;
		int iwhilerow;
		string s[3], int i[3];
		while( bgo )	{
			__icol=0;
			s0 = this._get();
			match(s0)	{
				"new"=>{
					s0 = this._get();
					s1 = this._get();
					s1 = s1.strsubb(1);	// pozbadz sie $
					if( this.isnext() )	{
						if( __sreads=="[" )	{
							__icol++;
							i0 = this._get();
							for(i1=0; i1<i0; i1++)	{
								new <s0> <s1+i1>;
							}
						} else {		// powinien byc "(" dla konstruktora
							__icol++;
							while( this.isnext() && __sreads!=")" )	this.getexpr( this._get() );
							new <s0> <s1>;
						}
					} else {
						new <s0> <s1>;
					}
					__irow++;
				}
				"delete" =>	{	delete <this.getvar(this._get())>;	__irow++;	}
				(s0=="if" || belif || bwhile)?s0:"" => {
	// 				belif ? this.perror(!bif,"else without if") : this.perror(bif,"if within if");
					__icol++;		// '('
					bifexp = this.cmp();
					if(s0=="if") bif=true;
					belif=false;
					bwhile = false;
					__irow++;
					if( !bifexp )	{
						i1=1;
						while(i1)	{
							s0 = <__sdb>.get(__irow,0);
							if( s0=="else"||s0=="elif"||s0=="fi"||s0=="done") i1=0;
							else	__irow++;
						}
					}
				}"else" => { 	this.perror(!bif,"else without if");
					__irow++;
					if( bifexp )	{
						while(<__sdb>.get(__irow,0)!="fi")
							__irow++;
					}
				} "fi" =>	{	this.perror(!bif,"fi without if");
					bif=false;
					bifexp = false;
					belif=false;
					__irow++;
				} "elif"=>	{
					if( bifexp )	{
						__irow++;
						while(<__sdb>.get(__irow,0)!="fi")
							__irow++;
					} else {
						belif = true;
					}
				} "end" =>	bgo=false;
				"while" =>	{
					iwhilerow = __irow;
					bwhile = true;
				}"done" =>	{
					if( bifexp )	{
						__irow = iwhilerow;
					} else {
						__irow++;
					}
				}"print" =>	{
					s0 = "";
					while( this.isnext() )
						s0 += this.getexpr( this._get() ); 
					engine.print( s0 );
					__irow++;
				}"return" => 	{
					if( this.isnext() )	{
						this.getexpr( __sreads );
					}
					return;
				} ? => { 
					if (s0.getb(0,1)=="$")	{
						s0 = this.getvar( s0 );
						__icol++;		// olej <<
						<s0> = this.getexpr(this._get());
						while( this.isnext() )	{
							__icol++;		// omin znak dzialania
							def d2 = this.getexpr( this._get() );
							match(__sreads)	{
								"+"	=>	<s0> += d2;
								"-"	=> 	<s0> -= d2;
								"*"	=>	<s0> *= d2;
								"/"	=>	<s0> /= d2;
								"%"	=>	<s0> %= d2;
								?	=>	;
							}
						}
					} else
						this.getexpr( s0 );
					__irow++; 
				}
			}
			if( __irow >= <__sdb>.getrowsno() )	{
				this.perror(1,"function "+sfun+" not finished!");
				bgo=false;
			}
		}
	}
}

/*
	klasy obslugujace plany tla oraz kamere 
*/

class classbgplan : gmobjvec {
	init() {
		gmobjvec::init;
		new real rpx;
		new real rpy;
		new real scalex;
		new real scaley;
		new int _ix;
		new int _iy;
	}
	public setscale(real rsx, real rsy)	{	|scalex, scaley| = rsx, rsy;	}
	public move(real x, real y)	{
		rpx+=x;	rpy+=y;
		int ix = rpx, int iy = rpy;
		rpx-=ix;	rpy-=iy;
		if( ix || iy )	{
			_ix += ix;
			_iy += iy;
			gmobjvec::move(ix,iy);
		}
	}
	public movebgr(real x, real y)	{	.move( scalex*x, scaley*y );	}
	int getpx	{	_ix;	}
	int getpy	{	_iy;	}
	public shift(int x, int y)	{
		gmobjvec::move(x,y);
	}
}

class classgrplans : gmobjvec	{
	init()	{
		gmobjvec::init();
		new real _rxp;
		new real _ryp;
	}
	public move(real x, real y)	{
		_rxp += x;	_ryp += y;
		this.eval2("movebgr",x,y);
	}
	public real getposx()	{	_rxp;	}
	public real getposy()	{	_ryp;	}
	public shift(int x, int y)	{
		//_rxp+=x;	_ryp+=y;
		//this.eval2("move",x,y);
		
		.eval2("shift",x,y);
	}
}

class CameraPos	{
	init(real x, real y)	{
		new real _x;
		new real _y;
		.setpos(x,y);
	}
	setpos(real x, real y)	{ _x=x; _y=y;	}
	getposx	{	_x;	}
	getposy	{	_y;	}
}

class classadvcamera	{
	init()	{
		new classgrplans grbgrs;
		new string sancamera=null;
		new string smsmvfun = null;
		|new real _rxmod, new real _rymod| = 0.05, 0.05;
		|new real rleft, new real rtop, new real rright, new real rbottom| = 0.0, 0.0, igmappw-1, igmapph-1;
		|new int icamx, new int icamy| = igmappw/2, igmapph/2;
		|new real rborx, new real rbory| = igmappw-1, igmapph-1;
		new real _lastx = 0;
		new real _lasty = 0;
		new string _sfunxedge = null;
		new string _sfunyedge = null;
		new CameraPos _campos(0,0);
		
		new timer timcamera;
		timcamera.settick(1);
		timcamera.setcycle(1);
		timcamera.addmethod("onfinish","_camerafin");
	}
	_camerafin()	{
		this.checkcamera();
		this.play();
	}
	public setscreen(int x1, int y1, int x2, int y2)	{
		rleft=x1;	rtop=y1;
		rright=x2;	rbottom = y2;
		rborx = x2;
		rbory = y2;
		_lastx = x1;
		_lasty = y1;
		icamx = (x1+x2)/2;
		icamy = (y1+y2)/2;
		//grbgrs.startpos(x1,y1);
	}
	public pause	{	timcamera.pause;	}
	public resume	{	timcamera.resume;	}
	public remove(string sob)	{	for( int i=0; i< grbgrs.size; i++)	<grbgrs.get(i)>.remove(sob);	}
	public funxedge(string sfun)	{	_sfunxedge=sfun;	}
	public funyedge(string sfun)	{	_sfunyedge=sfun;	}
	public setcenter(int x, int y)	{	| icamx, icamy | = x, y;	}
	public setcenterscreen		{	.setcenter( igmappw/2, igmapph/2 );	}
	public setborders(int x, int y){	|rright, rbottom| = x-1, y-1;	}
	public countcenter	{	.setcenter( rleft+(rright-rleft)/2, rtop+(rbottom-rtop)/2 );	}
	public real getposx()	{	grbgrs.getposx();	}
	public real getposy()	{	grbgrs.getposy();	}
	public setmetonmsmove(string s)	{	smsmvfun=s;	}
	public start()	{	timcamera.play();	}
	public stop()	{	timcamera.stop(false);	}
	public setactor(string sactor)	{	sancamera=sactor;	}
	public setcampos(int x, int y)	{
		_campos.setpos(x,y);
		.setactor("_campos");
	}
	public bool isactor(string sob)	{	sob==sancamera;	}
	public string getactor()	{	sancamera;	}
	public scalemodifiers(real rx, real ry)	{
		| _rxmod, _rymod | = rx, ry;	
	}
	public newbgr(string sbgr, real rscalex, real rscaley)	{
		new classbgplan <sbgr>;
		this.addbgr(sbgr,rscalex,rscaley);
	}
	public addbgr(string sbgr, real rscalex, real rscaley)	{
		<sbgr>.setscale(rscalex,rscaley);
		grbgrs.add(sbgr);
	}
	public findinbgr(string sob)	{
		for( int i=0; i< grbgrs.size; i++ )	{
			if( <grbgrs.get(i)>.contains(sob) )
				return grbgrs.get(i);
		}
		null;
	}
	public removefrombgr(string sob)	{
		for( int i=0; i< grbgrs.size; i++ )	{
			<grbgrs.get(i)>.remove(sob);
		}
	}
	public addtobgr(string sbgr, string sob)	{	<sbgr>.add(sob);	}
	public setscene()	{	this._setscene(1.0,1.0);	}
	_setscene(real _rx, real _ry)	{
		if( sancamera==null ) return;
		real x = icamx - <sancamera>.getposx();
		x*=_rx;
		real y = icamy - <sancamera>.getposy();
		y*=_ry;
		real ix = this.getposx()+x;
		real iy = this.getposy()+y;
		if( ix >= rleft )	x = -this.getposx();
		else if (ix+rright<=rborx)	x = rborx - (this.getposx()+rright);
		
		/*if( iy >= rtop )	y = -this.getposy();
		else if (iy+rbottom<=rbory)	y = rbory - (this.getposy()+rbottom);*/
		if( iy > rtop )	{
			y = rtop - .getposy;
		} else if (iy+rtop+rbottom<=rbory)	{
			y = rbory - (this.getposy()+rtop+rbottom);
		}
		
		if( x||y )	{
			grbgrs.move(x,y);
			if( smsmvfun!=null )	this.<smsmvfun>();
		}
		if( x==0 && _lastx!=0 && _sfunxedge!=null )	.<_sfunxedge>;
		if( y==0 && _lasty!=0 && _sfunyedge!=null )	.<_sfunyedge>;
		_lastx = x;
		_lasty = y;
	}
	public checkcamera()	{
		if( sancamera!=null )
			this._setscene( _rxmod, _rymod );
	}
	public moveplans(int x, int y)	{
		rleft+=x;	rright+=x;
		rtop+=y;	rbottom+=y;
		rborx+=x;
		rbory+=y;
		icamx+=x;	icamy+=y;
		grbgrs.shift(x,y);
	}
}


public animaloader_load(string sdbfile)	{
	new db _dbanl;
	_dbanl.loadbeh( .getpath(sdbfile) );
	string s[3], string san, string sord;
	int col;
	int i[2];
	real r[2];
	for( int i=0; i< _dbanl.getrowsno; i++) 	{
		if( _dbanl.getcolsno(i) > 0 )	{
			col = 0;
			match(_dbanl.get(i,col))	{
				"an:" => {
					col++;
					s0 = _dbanl.get(i,col); col++;
					if( s0.contains(".pyz") )	{
						san = "an" + s0.strsubes(".pyz");
						.newanima(san, s0, 0);
					} else {
						.copyanima( _dbanl.get(i,col) , s0 );
						col++;
					}
					for( int j=col; j<_dbanl.getcolsno(i); j++)	{
						sord = _dbanl.get(i,j);
						match( sord )	{
							"-z" => {
								j++;
								<san>.setz( _dbanl.get(i,j) );
							}
							"-hide" => <san>.hide;
							"-opacityframe" => <san>.anopacityframe;
							"-nplay" => {
								j++;
								<san>.play( _dbanl.get(i,j)->to_i );
							}
							"-play" => {
								j++;
								<san>.play( _dbanl.get(i,j) );
							}
							"-delay" => {
								j++;
								<san>.setdelay( _dbanl.get(i,j) );
							}
							"-drawmode" => {
								s0 = _dbanl.get(i,j);	j++;
								if( s0=="lineardodge" )	{
									<san>.setdrawmode(1);
								}
							}
							"-hideonstart" => {
								<san>.anhideonsetframe;
							}
							"-buildroto", "-buildrotorle" => {
								j++;
								real rkatl = _dbanl.get(i,j);	j++;	// kat dodatni
								real rkatr = _dbanl.get(i,j);	j++;	// kat ujemny
								real speed = _dbanl.get(i,j);	j++;	// speed - minus startuj w lewo, plus w prawo
								int delay = _dbanl.get(i,j);
								.gmbuildroto(san, rkatl, rkatr, speed, delay, ( sord == "-buildrotorle" ? true : false ));
							}
							? => j = .animaloader_an(san, "_dbanl", i, j);
						}
					}
				}
				? => ;
			}
		}
	}
}

public animaloader_an(string san, string sdb, int row, int col)	{
	col;
}

public gmbuildroto(string san, real rkatl, real rkatr, real speed, int delay, bool brle)	{
	int i0 = <san>.getpx;
	int i1 = <san>.getpy;
	<san>.setframe(1,0);
	<san>.ansetbpos(i0, i1);
	string s[2];
	
	real r3 = 0.0;
	speed = speed.abs;
	i0 = 0;
	string sprev = null;
	for( real r2 = rkatr; r2<=rkatl; r2+=r3 )	{
		real r4 = ((r2-rkatr)/(rkatl-rkatr))->abs;
		
		if( r4._rin1(0.1) ) r3 = 0.4*speed;
		else if ( r4._rin1(0.2) ) r3 = 0.8*speed;
		else r3 = speed;
		
		s1 = "_imgroto"+i0+san;
		new img <s1>;
		<s1>.buildrotozoom(san, r2, 1.0, 1.0);
		while( sprev!=null && <s1>.getw==<sprev>.getw && <s1>.geth==<sprev>.geth &&
			<s1>.getpx==<sprev>.getpx && <s1>.getpy==<sprev>.getpy )	{
			r4 = 0.2;
			r2 += r4*r3;
			r3 *= (r4 + 1.0);
			<s1>.buildrotozoom(san, r2, 1.0, 1.0);
		}
		<s1>.setz( <san>.getz );
		<s1>.hide;
		if( brle ) <s1>.rle;
		
		sprev = s1;
		i0++;
	}
	s0 = "_timroto"+san;
	.cycle = (s0, func {
		<slastimg>.hide;
		slastimg = "_imgroto"+idimg+san;
		<slastimg>.show;
		idimg = idimg+dir;
		if( idimg < 0 )	{
			idimg=0;
			dir = 1;
		} else if( idimg >= ileimgs ) {
			idimg = ileimgs-1;
			dir = -1;
		}
		.play;
		} );
	<s0>.setcycle(delay);
	<s0>.vars2(A, "san", san, "ileimgs", i0, "slastimg", s1, "idimg", 0, "dir", 1);
	<san>.hide;
	<"_imgroto0"+san>.show;
	<s0>.play;
}

public transparent	{	return 0,0,0,0;	}
public red			{	return 255,0,0;	}
public green		{	return 0,255,0;	}
public blue			{	return 0,0,255;	}
public white		{	return 255,255,255; }
public black		{	return 0,0,0;		}
public grey(int c)	{	return c,c,c;		}
public yellow		{	return 255,255,0;	}

class Color	{
	init	{
		.vars(A,"r","g","b","a");
	}
	operator=(string scol)	{	this.set( <scol>.get() );	}
	img=(@simg)	{
		|r,g,b,a| = <simg>.getrgba( classansearcher::firstnotrx1y(simg) );
	}
	get			{	return r,g,b,a;	}
	set(int r2, int g2, int b2, int a2)	{	|r,g,b,a| = r2,g2,b2,a2;	}
	rgb=(int r2, int g2, int b2)	{	|r,g,b|=r2,g2,b2;	}
	rgb	{	return r,g,b;	}
	print	{	engine.print("Color::" + this + " (r,g,b,a) = ("+r+","+g+","+b+","+a+")");	}
}

/***************************************************************************/

class classasker : newvars	{
	init()	{
		newvars::init();
		new string sfuncyes = null;
		new string sfuncno = null;
		new string ssndask;
		new string ssndyes;
		new string ssndno;
		new classsound clsnd;
	}
	reset()	{
		sfuncyes=null;	sfuncno=null;
		buts.resetall();
	}
	setfuncs(string syes, string sno)	{
		sfuncyes = syes;
		sfuncno = sno;
	}
	fxonmovon(string ssnd)	{	buts.sfxonmovon(ssnd);	}
	setmouse(string smouse)	{
		buts.newmouse("yes", smouse);
		buts.newmouse("no", smouse);
	}
	load(string sfile, int z)	{
		new classbutton buts;
		buts.build(sfile, z, null);
		buts.transclickfunc( engine.actclassname(), "butclick");
		buts.transmovonfunc( engine.actclassname() , "butmovon");
		buts.disableall();
	}
	ask( string sask, string syes, string sno, string sf1, string sf2 )	{
		this.setfuncs(sf1,sf2);
		this.ask2( sask, syes, sno );
	}
	ask2( string sask, string syes, string sno )	{
		ssndask=sask;
		ssndyes = syes;
		ssndno = sno;
		gameapi.pause();
		buts.benableall();
		buts.pause("bkg");
		clsnd.creset();
		clsnd.cbplay( sask );
		.<this+"_ask">;
	}
	/**********************************************/
	butmovon(string sc)	{
		/*if( ssndask!=null )	{
			if( <ssndask>.isplaying()==true )	{
				return;
			}
		}*/
		if( sc=="yes" )	{
			<ssndask>.stop(false);
			clsnd.cbplay( ssndyes );
		} else if (sc=="no")	{
			<ssndask>.stop(false);
			clsnd.cbplay( ssndno );
		}
	}
	butclick(string sc)	{
		if( sc=="bkg" )	return;
		gameapi.resume();
		buts.disableall();
		clsnd.cactsndstop(false);
		if( sc=="yes" && sfuncyes!=null)	{
			this.<sfuncyes>();
			.<this+"_yes">;
		} else if( sc=="no" && sfuncno!=null)	{
			this.<sfuncno>();
			.<this+"_no">;
		}
	}
	disabled	{	buts.disabled;	}
	setcursorpos(int x, int y)	{	buts.setcursorpos(x,y);	}
}

/***************************************************************************/
class classplacepointer	{
	init()	{
		new anima anpointer;
		anpointer.addmethod("onfinish", func { this.play(-1); } );
		new int _iz = 1000;
	}
	public load(string sfile)	{
		anpointer.load(sfile);
		this.setz(_iz);
		anpointer.hide();
	}
	public setz(int iz)	{
		_iz = iz;
		anpointer.setz(iz);
	}
	public stop()	{	anpointer.stop(false);	}
	public stoph()	{	anpointer.stop(false);	anpointer.hide();	}
	public show(int x, int y, string sdir)	{
		anpointer.setpos(x,y);
		anpointer.play(sdir);
	}
	move(@x, @y)	{	anpointer.move(x,y);	}
	public showob(string sob, string sdir)	{	this.show(<sob>.getcx(), <sob>.getcy(), sdir);	}
	public showpob(string sob, string sdir)	{	this.show(<sob>.getpx(), <sob>.getpy(), sdir);	}
}

class SimpleCounter	{
	init(int ilength)	{
		.var2("length", ilength );
		new int iid = 0;
	}
	int next()	{	iid = (iid+1)%length;		iid;	}
	set(int i)	{	iid=i;	}
	reset()	{	iid=0;	}
	get()	{	iid;	}
}

/******************************************/

module clstrdigit	{
	init()	{}
	public string getdigit(int idigit, int ilepozycji)	{
		string s = idigit;
		while( s.length() < ilepozycji )	s = "0" + s;
		s;
	}
	public string gettime(int itime, string smod)	{
		this.getstime( this.geth(itime), this.getm(itime), this.gets(itime), 
			smod.contains("h"), smod.contains("m"), smod.contains("s") );
	}
	public string getstime(int ih, int im, int is, bool bh, bool bm, bool bs)	{
		string s = "";
		if( bh ) s+= ih;
		if( bm ) s+= (bh?":":"") + this.getdigit(im,2);
		if( bs ) s+= ((bh||bm)?":":"") + this.getdigit(is,2);
		s;
	}
	public int geth(int itime)	{	itime/3600;	}
	public int getm(int itime)	{	(itime/60)%60;	}
	public int gets(int itime)	{	itime%60;	}
	public string getns(int itime, int n)	{	this.getdigit( this.gets(itime),n );	}
	public string getnm(int itime, int n)	{	this.getdigit( this.getm(itime),n );	}
	string getbinary(int ival)	{
		string s = "";
		while(ival>0)	{
			s = "" + (ival%2) + s;
			ival/=2;
		}
		s;
	}
	string bintohex(string sval)	{
		string s;
		match(sval.length%4)	{
			3=>"0"; 2=> "00"; 1=> "000";
			? => "";
		}
		s = _;
		sval = s + sval;
		s = "";
		for( int i=0; i<sval.length; i+=4)	{
			match(sval.getb(i,4))	{
				"0000" => "0";	"0001" => "1";	"0010" => "2";	"0011" => "3";
				"0100" => "4";	"0101" => "5";	"0110" => "6";	"0111" => "7";
				"1000" => "8";	"1001" => "9";	"1010" => "A";	"1011" => "B";
				"1100" => "C";	"1101" => "D";	"1110" => "E";	"1111" => "F";
				? => ;
			}
			s += _;
		}
		s;
	}
}

public string getbinary			{	clstrdigit::getbinary(.get);		}
public string getdigit(int ile)		{	clstrdigit::getdigit(.get,ile);		}
public string getbindigit(int ile)	{	clstrdigit::getdigit( .getbinary,ile);	}

class Text	{
	init(string sfont, int ifontsize, int ifr, int ifg, int ifb, int x, int y, int z)	{
		if( sfont==null )	sfont = sgmfontfile;
		if( sfont.contains(".ttf") )	{
			new font _fnt;
			_fnt.load( sfont, ifontsize );
			sfont = "_fnt";
		}
		new int iR = ifr;
		new int iG = ifg;
		new int iB = ifb;
		new int iFontSize = ifontsize;
		new text txt;
		txt.setfont(sfont);
		txt.setz(z);
		txt.setpos(x,y);
		txt.show;
		
		new text txtbg;
		txtbg.hide();
	}
	public hide()	{	txt.hide;	}
	public show()	{	txt.show;	}
	public setpos(int x, int y)	{	txt.setpos(x,y);	}
	public set(string s)	{
		txt.set( s );
		txt.createtxt( iR, iG, iB );
	}
	public string get()	{	return txt.get;	}
	public setbg(int ir, int ig, int ib, int ia)	{
		txtbg.setbkg(txt.getpx()-iFontSize/2, txt.getpy()-iFontSize/2,
			txt.getw()+iFontSize, iFontSize*2, ir, ig, ib, ia );
		txtbg.setborders(1,255,255,255,128);
		txtbg.show();
	}
	operator=(string val)	{	this.set(val);	}
	move(int x, int y)	{	txt.move(x,y);	}
}

class Cypher : Text	{
	init(string sfont, int ifontsize, int ifr, int ifg, int ifb, int x, int y, int z)	{
		Text::init(sfont, ifontsize, ifr, ifg, ifb, x, y, z );
		this.set(0);
	}
	add(int dt)	{	this.set( dt + this.get );	}
	iget()		{	this.get->to_i;		}
	operator+(int val)	{	this.add(val);	}
	operator++()	{	this.add(1);	}
	operator--()	{	this.add(-1);	}
	operator-(int val)	{	this.add(-val);	}
	operator=(int val)	{	this.set(val);	}
	operator==(int val)	{	.get==val;	}
	operator!=(int val)	{	.get!=val;	}
	operator>(int val)	{	.get>val;	}
	operator<(int val)	{	.get<val;	}
}

class SecCounter	{
	init(string sdigits, int starttime, int dt)	{
		new string sdigit = sdigits;
		.vars2(A, "istarttime", starttime, "idtime", dt, "itime", 0);
		this.reset();
		this.cnewtimerfin("timcyk",1000,1, func { .play; <.getbuildername>.tick; } );
	}
	public play()	{	timcyk.play();	}
	public stop()	{	timcyk.stop(false);}
	public string sgettime()	{	return clstrdigit.gettime(itime, sdigit);	}
	public int gettime()	{	return itime;	}
	public tick	{	.update(idtime);	}
	public reset()	{
		//this.update(-itime);
		itime = istarttime;
	}
	public update(int isec)	{
		itime+=isec;
	}
}

class TextTimeCounter : Text, SecCounter	{
	init(string sfont, int ifontsize, int ifr, int ifg, int ifb, int x, int y, int z, string sdigits, int starttime, int dt)	{
		Text::init(sfont, ifontsize, ifr, ifg, ifb, x, y, z);
		SecCounter::init(sdigits, starttime, dt);
		.reset;
		.update(0);
	}
	public update(int isec)	{
		SecCounter::update(isec);
		this.set( this.sgettime() );
		if( itime<=0 && idtime<0 )	{
			.<this + "_finish">;
		}
	}
}

class gfxObject	{
	init(string sob)	{	new string sgfxobj = sob; }
	setpos		{	<sgfxobj>.setpos;	}
	move		{	<sgfxobj>.move;	}
	getpos		{	<sgfxobj>.getpos;	}
	getposx		{	<sgfxobj>.getposx;	}
	getposy		{	<sgfxobj>.getposy;	}
	getpx		{	<sgfxobj>.getpx;	}
	getpy		{	<sgfxobj>.getpy;	}
	getw			{	<sgfxobj>.getw;	}
	geth			{	<sgfxobj>.geth;	}
	getcx		{	<sgfxobj>.getcx;	}
	getcy		{	<sgfxobj>.getcy;	}
	getex		{	<sgfxobj>.getex;	}
	getey		{	<sgfxobj>.getey;	}
	lodx			{	<sgfxobj>.lodx;	}
	lody			{	<sgfxobj>.lody;	}
	setz			{	<sgfxobj>.setz;		}
	getz			{	<sgfxobj>.getz;	}
	show		{	<sgfxobj>.show;	}
	hide			{	<sgfxobj>.hide;	}
	isvisible		{	<sgfxobj>.isvisible;	}
	bool isin		{	<sgfxobj>.isin;		}
}

class gfxSquare : Color, gfxObject	{
	init(int x1, int y1, int w1, int h1)	{
		Color::init;
		.vars(A, "w", "h");
		w=w1; h=h1;
		new img imggfx;
		imggfx.setpos(x1,y1);
		gfxObject::init("imggfx");
	}
	build	{	imggfx.create(w,h,r,g,b,a);	}
	shadow(int dx, int dy, int alpha)	{
		|@x,@y| = imggfx.getpos;
		imggfx.setpos(0,0);
		new img _img1;
		new img _img2;
		if( imggfx.getw>0 )	{
			_img1.create(w,h,.transparent);
			_img1.blit("imggfx");
		} else _img1.create(w,h,.get);
		_img2.create(w,h,.black,alpha);
		if( dx<0 )	{
			_img1.move(-dx, 0);
			x+=dx;
		} else	_img2.move( dx, 0 );
		if( dy<0 )	{
			_img1.move(0,-dy);
			y+=dy;
		} else	_img2.move( 0, dy );
		w += dx.abs;
		h += dy.abs;
		imggfx.create(w, h, .transparent);
		imggfx.blit("_img2");
		imggfx.blit("_img1");
		delete _img1;
		delete _img2;
		imggfx.move(x,y);
	}
	blackborder(int width, int a2)	{	.border(width,width, .black,a2);	}
	border(int width, int height, int r2, int g2, int b2, int a2)	{
		|@x,@y| = imggfx.getpos;
		imggfx.setpos(0,0);
		new img _img;
		if( imggfx.getw>0 )	{
			_img.create(w,h,.transparent);
			_img.blit("imggfx");
		} else _img.create(w,h,.get);
		_img.move(width,height);
		w += 2*width;
		h += 2*width;
		imggfx.create(w,h,r2,g2,b2,a2);
		imggfx.blit("_img");
		delete _img;
		imggfx.move(x,y);
	}
}

class Rect	{
	init(int _x, int _y, int _w, int _h)	{
		.vars(A, "x", "y", "w", "h");
		.set(_x, _y, _w, _h);
		new vector vecgr; vecgr.type("string");
		vecgr.add("gmimgvec");
	}
	x2	{	x+w;	}
	y2	{	y+h;	}
	set(int _x, int _y, int _w, int _h)	{ x=_x; y=_y; w=_w; h=_h; }
	setborders(int _x, int _y, int _x2, int _y2)	{
		x=_x; y=_y; w=_x2-_x; h=_y2-y;
	}
	fit(string simg)	{
		if( vecgr.contains( <simg>.gettype) ) {
			@dx = x-<simg>._getpx;
			if( dx>0 ) <simg>.move(dx,0);
			@dy = y-<simg>._getpy;
			if( dy>0 ) <simg>.move(0,dy);
		} else {
			@dx = x-<simg>.getpx;
			if( dx>0 ) <simg>.move(dx,0);
			@dy = y-<simg>.getpy;
			if( dy>0 ) <simg>.move(0,dy);
		}
		dx = .x2-<simg>.getex;
		if( dx<0 ) <simg>.move(dx,0);
		dy = .y2-<simg>.getey;
		if( dy<0 ) <simg>.move(0,dy);
	}
	fitrand(string simg)	{	<simg>.ansetbpos( x+(w-<simg>.getw)->rand, y+(h-<simg>.geth)->rand);	}
	fitgrouprand(string sgr)	{	for( int i=0; i< <sgr>.size; i++) .fitrand( <sgr>.get(i) );	}
	fitgroup(string sgr)	{	for( int i=0; i< <sgr>.size; i++) .fit( <sgr>.get(i) );	}
	bool isin(int _x, int _y)	{	_x>=x && _x<x+w && _y>=y && _y<y+h;	}
}

class ImgRect	{
	init	{
		.vars2(A, "ix",0, "iy",0, "iw",0, "ih",0, "bvis",1, "iz",0, "ilodx",0, "ilody",0);
	}
	create(int w, int h)	{	iw=w; ih=h;	}
	setpos(int x, int y)	{	ix=x; iy=y;	}
	move(int x, int y)	{	ix+=x; iy+=y;	}
	getpos			{	return ix,iy;	}
	getposx			{	ix;		}
	getposy			{	iy;		}
	getpx			{	ix;		}
	getpy			{	iy;		}
	getw			{	iw;		}
	geth			{	ih;		}
	getcx			{	ix+iw/2;	}
	getcy			{	iy+ih/2;	}
	getex			{	ix+iw;		}
	getey			{	iy+ih;		}
	lodx			{	ilodx;		}
	lody			{	ilody;		}
	setz(int z)		{	iz=z;		}
	getz			{	iz;		}
	show			{	bvis = true;	}
	hide			{	bvis = false;	}
	isvisible		{	bvis;		}
	bool isin(int x, int y, bool bv, bool ba)	{
		if( bv==false || .isvisible )
			x>=ix && x<ix+iw && y>=iy && y<iy+ih;
		else false;
	}
	setrect(int x, int y, int x2, int y2)	{
		ix=x; iy=y; iw=x2-x; ih=y2-y;
	}
	print	{
		("x: "+ix+", y: "+iy+", w: "+iw+", h: "+ih)->print;
	}
	operator=(string srec)	{
		|ix,iy,iw,ih,iz,bvis| = <srec>.getpx, <srec>.getpy, <srec>.getw, <srec>.geth, <srec>.getz, <srec>.isvisible;
	}
}

/***************************************************************************/

class classfadeinout		{
	init()	{
		new timer timf;
		new string _sob;
		new int _istep;
		new int _ival;
		new int _ib1;
		new int _ib2;
		new string _sfun;
		new string _sfunfin;
		new string _sobfin;
		timf.addmethod("onfinish", "_ctimffin");
	}
	/***************\/\/\/\/\/ wewnetrzne \/\/\/\/\/\/************************************/
	_cfinito(int v)	{
		<_sob>.<_sfun>( v );
		if( _sfunfin!=null)	{
			if( _sobfin==null )
				this.<_sfunfin>();
			else <_sobfin>.<_sfunfin>;
		}
	}
	_ctimffin()	{
		_ival+=_istep;
		if( _ival > _ib2 )	{
			this._cfinito( _ib2 );
		} else if( _ival<_ib1 )	{
			this._cfinito( _ib1 );
		} else {
			<_sob>.<_sfun>( _ival );
			this.play();
		}
	}
	_play( int icycle, int istep, string sob, string sfun, int ib1, int ib2, string sob2, string sfun2 )	{
		_sobfin = sob2;
		_sfunfin = sfun2;
		_ib1 = ib1;
		_ib2 = ib2;
		int i = istep.abs();
		if( icycle <= 0 || i==ib1 || i>ib2 )	return;
		_sfun = sfun;
		timf.setcycle( icycle );
		_sob = sob;
		if( istep>0 )	_ival = _ib1;
		else if( istep<0 )	_ival=_ib2;
		else return;
		<sob>.<sfun>( _ival );
		_istep = istep;
		timf.play();
	}
	/******************* /\/\/\/\/\/\/\ wewnetrzne /\/\/\/\ ****************************/
	imgtransparency(int icycle, int istep, string simg, string sfun)	{
		this._play( icycle, istep, simg, "transparency", 0, 255, null, sfun );
	}
	setopacity(int icycle, int istep, string simg, string sfun)	{
		this._play( icycle, istep, simg, "setopacity", 0, 255, null, sfun );
	}
	sndvolume(int icycle, int istep, string ssnd, string sfun)	{
		this._play( icycle, istep, ssnd, "setvol", 0, 100, null, sfun );
	}
	/***************************************************/
	isplaying	{	timf.isplaying;	}
}

class CutScene : gfxObject	{
	init(int x1, int y1, int x2, int y2)	{
		new int X1;	new int Y1;
		new int X2;	new int Y2;
		new img _gsq;
		.build(x1, y1, x2, y2);
		gfxObject::init("_gsq");
		new string _sfunc1;
		new string _sob1;
		new string _sfunc2;
		new string _sob2;
		new int _idelay = 10;
		new classfadeinout _clfio;
		new bool benableloading = false;
	}
	benableloading=(bool b)	{	benableloading=b;	}
	build(int x1, int y1, int x2, int y2)	{
		|X1, Y1, X2, Y2| = x1, y1, x2, y2;
		_gsq.create(X2-X1,Y2-Y1,.black,255);
		_gsq.setpos(X1,Y1);
		_gsq.hide;
		_gsq.transparency(0);
	}
	buildblack	{	.build(X1,Y1,X2,Y2);	}
	buildfromfile(string sfile)	{
		@z = .getz;
		new img _imtmp;
		_imtmp.load(sfile);
		_gsq.transparency(255);
		_gsq.blit("_imtmp");
		delete _imtmp;
		_gsq.hide;
		_gsq.transparency(0);
	}
	buildfromscreen	{
		_gsq.transparency(255);
		_gsq.blitscreen;
		_gsq.hide;
		_gsq.transparency(0);
	}
	cloneto(string simg)	{
		<simg>.clone("_gsq");
	}
	delay(int n)	{	_idelay=n;	}
	transparency(int n)	{	_gsq.transparency(n);	}
	playfin(string sfunc1, string sfunc2)	{	.playobfin(null,sfunc1, null, sfunc2);	}
	playobfin(string sob1, string sfunc1, string sob2, string sfunc2)	{
		_sob1 = (sob1==null) ? gameapi.getgamename : sob1;
		_sfunc1 = sfunc1;
		_sob2 = (sob2==null) ? gameapi.getgamename : sob2;
		_sfunc2 = sfunc2;
		_gsq.show;
		_gsq.transparency(0);
		_clfio._play( 1, _idelay, this, "transparency", 0, 255, this, func {
			.callfun(_sob1, _sfunc1);
			_gsq.show;
			_clfio._play( 1, -_idelay, this, "transparency", 0, 255, this, "_callfun2" );
			} );
	}
	close(string sfunc1)	{
		if( benableloading ) .showloading;
		.obclose(gameapi.getgamename, sfunc1);	
	}
	obclose(string sob, string sfunc1)	{
		_sob1 = sob;
		_sfunc1 = sfunc1;
		_gsq.transparency(0);
		_gsq.show;
		_clfio._play( 1, _idelay, this, "transparency", 0, 255, this, func {
			_gsq.hide;
			.callfun(_sob1, _sfunc1);
			} );
	}
	enter(string sfunc2)	{
		if( benableloading ) .hideloading;
		.obenter(gameapi.getgamename, sfunc2);
	}
	obenter(string sob, string sfunc2)	{
		_sob2 = sob;
		_sfunc2 = sfunc2;
		_gsq.transparency(255);
		_gsq.show;
		_clfio._play( 1, -_idelay, this, "transparency", 0, 255, this, "_callfun2" );
	}
	_callfun2	{
		_gsq.hide;
		.callfun(_sob2, _sfunc2);
	}
	isplaying	{	_clfio.isplaying;	}
	show	{
		_gsq.transparency(255);
		_gsq.show;
	}
	loadloading(string s)	{
		new img txtloading;
		txtloading.load(s);
		txtloading.setz( .getz + 1 );
		txtloading.ancenterscreen;
		txtloading.addmethod("txtshow", func { .show; } );
		txtloading.addmethod("txthides", func { .hide; } );
	}
	showloading	{
		if( !.hasvar("txtloading") )	{
			if( engine.fileexist("scripts/common/loading.png") )	{
				.loadloading("scripts/common/loading.png");
			} else {
				@sfont = .stdfont(64->igetsc);
				.newtext("txtloading", "Loading", sfont, .grey(222) );
				txtloading.setz( .getz + 1 );
				txtloading.txtcenterscreen;
				txtloading.txtshadow(1, sfont);
			}
		}
		txtloading.txtshow;
	}
	hideloading	{
		if( .hasvar("txtloading") )
			txtloading.txthides;
	}
}


public string allchars	{	"a0 t_!@#$%^&*()_+-=[]\\|}{;':\",./<>?`~"; }

class TextTyper : classlocker, gfxObject {
	init(string sfont, int isize, int ir, int ig, int ib, string schars, int ilimit)	{
		classlocker::init();
		sfont = .checkfont(sfont, isize);
		new int iR = ir;
		new int iG = ig;
		new int iB = ib;
		new string sChars = schars;
		new int iLimit = ilimit;		// 0 - unlimited
		
		.vars2(A,"Sdir","left", "W", 0, "iFontSize", isize, "X", 0, "Y", 0, "insystem",false);
		
		new text txt1;
		txt1.setfont(sfont);
		txt1.set("");
		new text txt2;
		txt2.setfont(sfont);
		txt2.set("_");
		txt2.createtxt(iR,iG,iB);
		txt2.hide();
		
		new text txtpass;
		txtpass.setfont(sfont);
		txtpass.hide;
		new bool bpass = false;
		
		new string _sob=null;
		new string _sfun=null;
		
		this.cnewtimerfin("timcyk",300,1,"fintimcyk");
		
		gfxObject::init("txt1");
	}
	setaspasswd	{
		bpass = true;
		txt1.hide;
		txtpass.setz( txt1.getz );
		txtpass.show;
		.copytopass;
	}
	copytopass	{
		@id = txt1.get->length;
		string s = "";
		for( int i=0; i<id; i++)	s += "*";
		txtpass.txtset(s);
		txtpass.setpos( txt1.getpx, txt1.getpy );
	}
	setastext	{
		bpass = false;
		txt1.show;
		txtpass.hide;
	}
	public isin(int x, int y, bool bv, bool ba)	{	txt1.isin(x,y,bv,ba);	}
	getcol	{	return iR,iG,iB;	}
	fintimcyk()	{
		if( this.getlock() )	return;
		this.updatecyk();
		this.play();
	}
	updatecyk()	{
		if( txt2.isvisible() )	{
			txt2.hide();
		} else {
			txt2.setpos( txt1.getex(), txt1.getpy() );
			txt2.show();
		}
	}
	public enable()	{
		this.unlock();
		this.updatecyk();
		timcyk.play();
		if( insystem )	{
			if( <GAME>.isgmobj(sTextBoxTyperSys) && sTextBoxTyperSys!=this )	<sTextBoxTyperSys>.deactivate;
			sTextBoxTyperSys = this;
		}
	}
	public deactivate	{	.disable;	}
	public disable()	{
		txt2.hide();
		timcyk.stop(false);
		this.lock();
	}
	public onenter(string sob, string sfun)	{	_sob=sob;	_sfun=sfun;	}
	public setpos(int x, int y)	{
		X = x;
		Y = y;
		//txt1.setpos(x,y);
		.updatetxt(.get);
	}
	public move(int x, int y)	{	.setpos(X+x, Y+y); }
	public setz(int z)	{	txt1.setz(z);txt2.setz(z);	}
	public get()	{
		string s = txt1.get();
		( s.length()>0 ) ? s : "";
	}
	getpx	{	txt1.getpx;	}
	getpy	{	txt1.getpy;	}
	getcx	{	txt1.getcx;	}
	getcy	{	txt1.getcy;	}
	geth	{	txt1.geth;	}
	getey	{	txt1.getpy + iFontSize;	}
	clip(int x1, int y1, int x2, int y2)	{
		txt1.clip(x1,y1,x2,y2);
		txt2.clip(x1,y1,x2,y2);
	}
	public length	{	txt1.get->length;	}
	public set(string s)	{	txt1.set(s);	}
	public txtset(string s)	{	txt1.txtsetcol(s,.getcol);	}
	public limit=(int il)	{	iLimit=il;	}
	public onkeydown()	{
		if( this.getlock() )	return;
		.<this+"_ontype">;
		if( keyboard.iskeydown("enter") )	{
			this.disable();
			this.callfun(_sob,_sfun);
			.<this+"_onenter">;
			return;
		}
		string s;
		if( sChars.contains("t") && keyboard.iskey("tab") )	s = " ";
		else s = keyboard.getkey();
		string s2 = txt1.get();
		if( ( (keyboard.isalpha && sChars.contains("a") ) || ( keyboard.isdigit && sChars.contains("0") )
			|| sChars.contains(s) ) && (iLimit<=0 || iLimit>s2.length)  )	{
			//txt1.set( s2+s );
			//txt1.createtxt(iR,iG,iB);
			.updatetxt(s2+s);
			this.updatecyk();
		} else if (keyboard.iskey("backspace") && s2.length()>0)	{
			//txt1.set( s2.strsube(1) );
			//txt1.createtxt(iR,iG,iB);
			.updatetxt( s2.strsube(1) );
			this.updatecyk();
		}
		.<this+"_ontyped">;
	}
	updatetxt(string s)	{
		txt1.set(s);
		txt1.createtxt(iR, iG, iB);
		if( Sdir == "center" )	txt1.setpos( X+(W-txt1.getw)/2, Y );
		else if (Sdir=="right")	txt1.setpos( X+W-txt1.getw, Y );
		else txt1.setpos(X, Y);
		if( bpass )	.copytopass;
		.<this+"_onwrite">;
	}
}

class ConTextTyper : TextTyper, ObjController	{
	init()	{
		TextTyper::init();
		ObjController::init();
	}
}

new string sTextBoxTyperSys = null;
class TextBoxTyper : LObjController, ImagePos	{
	init(string sfont, int ish, int isw, int ir, int ig, int ib, string schars, int x, int y, int w, int h, int dy)	{
		LObjController::init;
		ImagePos::init;
		new @Font = .checkfont(sfont, ish);
		.vars2(A,"Cols", w/isw, "Rows", h/(ish+dy), "X", x, "Y", y, "Row", 0, "enablemove", true, "W", w,
			"insystem", false, "H", h, "isvisible", 1, "clipx1", x, "clipy1", y, "clipx2", 0, "clipy2", 0, "clipped", false );
		new @Size = ish;
		new @Dy = dy;
		new @Z = 0;
		string s;
		new gmimgvec grtt;
		new gmimgvec gren;
		for( int i=0; i<Rows; i++)	{
			s = "tt"+i;
			new TextTyper <s>(Font,ish,ir,ig,ib,schars,Cols);
			<s>.W = (w);
			<s>.Sdir = ("left");
			<s>.setpos( x, y+i*(ish+dy) );
			grtt.add(s);
		}
	}
	settyper(int id, string sfont, int ish, int isw, int ir, int ig, int ib, string schars, string sdir)	{
		int x;
		int y;
		string s;
		string stext = "";
		if( id<0 ) {
			x = <grtt.last>.X;
			y  = <grtt.last>.getey+Dy;
			id = grtt.size;
			grtt.add("tt"+id);
		} else {
			s = grtt.get(id);
			x = <s>.X;
			y = <s>.getpy;
			stext = <s>.get;
			grtt.movefrom( s, 0, ish - <s>.iFontSize );
			delete <s>;
		}
		s = "tt" + id;
		new TextTyper <s>(sfont,ish,ir,ig,ib,schars,W/isw);
		<s>.W = (W);
		<s>.Sdir = (sdir);
		<s>.updatetxt(stext);
		<s>.setz(Z);
		<s>.setpos( x, y );
	}
	move(int x, int y)	{	grtt.move(x,y); gren.move(x,y); X+=x; Y+=y;	}
	size	{	grtt.size;	}
	setz(int z)	{	Z = z; grtt.setz(z);	gren.setz(z); }
	getz	{	Z;	}
	show	{	isvisible=1; grtt.show;	}
	hide		{	isvisible=0;	grtt.hide;		}
	clip(int x1, int y1, int x2, int y2)	{
		clipped = true;
		clipx1=x1;	clipy1=y1;	clipx2=x2;	clipy2=y2;
		for( int i=0; i<grtt.size; i++) <grtt.get(i)>.clip(x1,y1,x2,y2);
	}
	getw	{	W;	}
	geth	{	H;	}
	enumerate(int dx)	{
		string s[2];
		for( int i=0; i<grtt.size; i++)	{
			s0 = "txte"+i;
			new text <s0>;
			gren.add(s0);
			<s0>.setz(Z);
			<s0>.setfont(Font);
			<s0>.txtsetcol(""+(i+1)+".", tt0.getcol);
			<s0>.setpos(X-<s0>.getw-dx,Y+i*(Size+Dy));
		}
	}
	cut(int id)	{	Rows=id;	}
	enable	{	.unlock;	.activateact;	}
	disable	{	.lock; grtt.eval("disable");	}
	actual	{	"tt"+Row;	}
	activate(int id)	{
		.unlock;
		if( id>=0 && id<Rows )	{
			if( insystem )	{
				if( <GAME>.isgmobj(sTextBoxTyperSys) && sTextBoxTyperSys!=this )	<sTextBoxTyperSys>.deactivate;
				sTextBoxTyperSys = this;
			}
			.deactivate;
			Row = id;
			<"tt"+ Row>.enable;
			.<this+"_activate">;
		}
	}
	activateact	{	.activate(Row);	}
	deactivate	{	<"tt"+Row>.disable;	}
	onkeydown	{
		if(.getlock)	return;
		.<this+"_boxontype">;
		if( keyboard.iskeydown("enter") )		{
			@s = .getid(Rows-1);
			s.clear;
			if( s.length==0 && enablemove )	{
				for( @i=Rows-1; i>Row+1; i--)	.setid( .getid(i-1), i);
				if( Row+1<Rows) .setid("", Row+1);
			}
			.activate(Row+1);
		} else if (keyboard.iskey("up") && Row>0) .activate(Row-1);
		else if (keyboard.iskey("down") && Row<Rows-1) .activate(Row+1);
		else if (keyboard.iskey("pgdown"))	{
			if(Row<Rows-10) .activate(Row+10);
			else .activate(Rows-1);
		} else if (keyboard.iskey("pgup"))	{
			if(Row>9) .activate(Row-10);
			else .activate(0);
		} else if ((keyboard.iskey("backspace") || keyboard.iskey("delete")) && <.actual>.length==0 ) {
			if( enablemove )	{
				for( @i=Row; i<Rows-1; i++)	.setid( .getid(i+1), i);
				.setid("",Rows-1);
			}
			if( keyboard.iskey("backspace") )
				.activate(Row-1);
		} else grtt.eval("onkeydown");
	}
	onmouselclick	{
		if(.getlock)	return;
		|int x, int y| = mouse.getpos;
		//if(  )	{
		if( (clipped && clsurf.isin(x,y,clipx1,clipy1,clipx2,clipy2)) || (!clipped && clsurf.isin2(x,y,X,Y,W,H)) )	{
			.deactivate;
			//.activate( ((y-Y)*Rows)/H );
			for( int i=0; i<.size; i++)	{
				if( <"tt"+i>.getey > y ) {
					.activate(i);
					return;
				}
			}
		} else {
			.<this+"_OUTSIDE">;
		}
	}
	int isin(int x, int y, bool bv, bool ba)	{
		if( bv && !isvisible ) return 0;
		clsurf.isin2(x,y,X,Y,W,H);
	}
	string getid(int id)	{	<"tt"+id>.get;	}
	string getact		{	<"tt"+Row>.get;	}
	int idpx(int id)	{	<"tt"+id>.getpx;	}
	int idpy(int id)	{	<"tt"+id>.getpy;	}
	//int getpy	{	.idpy(0);	}
	//int getpx	{	.idpx(0);	}
	int getpx	{	X;	}
	int getpy	{	Y;	}
	string get	{	.getfrom(0);	}
	string getfrom(int id)	{	.getlinesfrom(id,"");	}
	string getlinesfrom(int id, string send)	{
		string s = "";
		for( int i=id; i<grtt.size; i++) s += <"tt"+i>.get + send;
		s;
	}
	string getlines	{	.getlinesfrom(0," ");	}
	int nonempty(int id)	{
		string s;
		for( ; id<grtt.size; id++)	{
			s = <"tt"+id>.get;
			s.clear;
			if( s.length > 0 ) return id;
		}
		-1;
	}
	clear	{	grtt.txtreset;	}
	setid(string s, int id)	{	if( grtt.size>=id )	<"tt"+id>.txtset(s);	}
	settext(int ile)	{
		while(ile>0)	{
			ile--;
			.setid(_,ile);
		}
	}
	copytodb(string sdb)	{
		<sdb>.free;
		for( int i=0;i<grtt.size; i++)	{
			<sdb>.add( <sdb>.addrow-1, <grtt.get(i)>.get);
		}
	}
	copyfromdb(string sdb)	{	.copyfromdbii(sdb, 0, <sdb>.getrowsno);	}
	copyfromdbss(string sdb, string s1, string s2)	{	.copyfromdbii(sdb, <sdb>.findbyrow(s1)+1, <sdb>.findbyrow(s2) );	}
	copyfromdbii(string sdb, int row1, int row2)	{
		if( row1==-1 || row2==-1 ) return;
		.clear;
		if( row2-row1 > .size ) row2 = row1+.size;
		for( int i=row1; i<row2; i++)	{
			if( <sdb>.getcolsno(i) )
				.setid( <sdb>.get(i,0), i-row1 );
		}
	}
	copyfromdbrow(string sdb, int row, int startcol)	{
		int size = <sdb>.getcolsno(row);
		if( size>.size ) size = .size;
		for( int i=startcol; i<size; i++)
			.setid( <sdb>.get(row,i), i-startcol );
	}
	save(string sfile)	{
		if( igmenablesave )	{
			new db __tmpdb;
			.copytodb("__tmpdb");
			__tmpdb.setseparator("|");
			__tmpdb.save(sfile);
			delete __tmpdb;
		}
	}
	load(string sfile)	{
		new db __tmpdb;
		__tmpdb.load(sfile);
		.copyfromdb("__tmpdb");
		delete __tmpdb;
	}
	/*H	{
		if( grtt.size )	<grtt.last>.getey-<grtt.first>.getpy;
		else 0;
	}*/
}

class GUITextBoxTyper : TextBoxTyper	{
	init(string sfont, int ish, int isw, int ir, int ig, int ib, string schars, int x, int y, int w, int h, int dy)	{
		TextBoxTyper::init(sfont,ish,isw,ir,ig,ib,schars,x,y,w,h,dy);
		.vars2(A,"rewinder", null, "rewinderbg", null);
	}
	setrewinder(string s)	{
		rewinder = s;
		rewinderbg = s + "bg";
	}
	activate(int id)	{
		TextBoxTyper::activate(id);
		.updaterewactual;
	}
	updaterewactual	{	.updaterewpos(Row);	}
	updaterewpos(int id)	{
		if( rewinder!=null )	{
			@s = "tt"+id;
			if( <s>.getpy < <rewinderbg>.getpy )		<rewinder>.rewind( 0, <rewinderbg>.getpy - <s>.getpy );
			else if (<s>.getey > <rewinderbg>.getey)		<rewinder>.rewind( 0, <rewinderbg>.getey - <s>.getey );
		}
	}
}

/****************************************************************/
class DelayTaker	{
	init()	{
		new bool bonrel = false;
		new bool bstart = false;
		new bool bclickrel = true;
		this.cnewtimerfin("timwez",300,1, func { bonrel=true; } );
	}
	public setclickrel(bool b)	{	bclickrel=b;	}
	public setdelay(int idelay)	{	timwez.delay(idelay);	}
	public take()	{
		if( bclickrel )	{
			timwez.play();
			bonrel=false;
		} else bonrel=true;
		bstart=true;
		
	}
	public ret()	{
		bonrel=false;
		bstart=false;
		timwez.stop(false);
	}
	public bool isonclick()	{
		this.stoptimer();
		( bstart && !bonrel );
	}
	public bool isonrel()	{
		this.stoptimer();
		( bstart && bonrel );
	}
	public bool istaken()	{	bstart;	}
	public stoptimer()	{	timwez.stop(false);	}
}


class ImgMover	{
	init()	{
		new string smoved=null;
		new int ilastx;
		new int ilasty;
		new int irelx;
		new int irely;
	}
	public mssetobj(string s)	{	this.setobj(s,mouse.getpos);	}
	public setobj(string s, int x, int y)	{	this.set(s,x,y,0,0);	}
	public setcobj(string s)	{	.setobj(s, <s>.getcx, <s>.getcy);	}
	public setpobj(string s)	{	.setobj(s, <s>.getpx, <s>.getpy);	}
	public set(string s, int x, int y, int dx, int dy)	{
		ilastx = <s>.getposx()-dx;
		ilasty = <s>.getposy()-dy;
		irelx = x-<s>.getpx();
		irely = y-<s>.getpy();
		smoved = s;
	}
	public msmove()		{	this.move(mouse.getpos);	}
	public msftmove()	{	this.ftmove(mouse.getpos);	}
	public move(int x, int y)	{
		if( smoved!=null )	{
			<smoved>.setpos( x-<smoved>.lodx()-irelx, y-<smoved>.lody()-irely );
		}
	}
	public ftmove( int x, int y)	{	if( smoved!=null )	<smoved>.setpos( x, y );	}
	public retobj()	{	this.ret(0,0);	}
	public ret(int dx, int dy)	{
		<smoved>.setpos(ilastx+dx, ilasty+dy);
		this.free();
	}
	public put(int x, int y)	{
		<smoved>.setpos(x,y);
		this.free();
	}
	public free()			{	smoved=null;	}
	public string getmover()	{	smoved;	}
	public string getfree		{	@s = smoved; .free; s; }
	public bool moving()		{	smoved!=null;	}
	public setmoved(string s)	{	smoved=s;	}
}

class ConImgMover : ImgMover, ObjController	{
	init()	{
		ImgMover::init();
		ObjController::init();
	}
	onmousemove()	{	this.msmove();	}
	onmouselclick	{	.<this+"_GET">;	}
	onmouselrel	{	if( smoved!=null ) .<this+"_PUT">;	}
}

class DelayImgMover : classlocker, ImgMover	{
	init()	{
		classlocker::init;
		ImgMover::init();
		new DelayTaker cldt; 
		.var2("b2clicks",false);
	}
	public setclickrel(bool b)	{	cldt.setclickrel(b);	}
	public reset	{	cldt.ret;	}
	_put	{
		if( !b2clicks )
			cldt.ret;
		.<this+"_PUT">;
	}
	_get	{
		.<this+"_GET">;
	}
	set(string s, int x, int y, int dx, int dy)	{
		ImgMover::set(s,x,y,dx,dy);
		if( !b2clicks )
			cldt.take;
	}
	onmousemove()	{	this.msmove();	}
	onmouselclick()	{
		if( this.getlock() ) return;
		if( b2clicks )	{
			if( !.moving )	._get;
			else ._put;
		} else {
			if( cldt.isonclick() )	this._put();
			else if (!cldt.istaken())
				._get;
		}
	}
	onmouselrel()	{
		if( this.getlock() ) return;
		if( cldt.isonrel() && !b2clicks )
			this._put();
	}
}

class DelayMover : DelayImgMover, ObjController	{
	init()	{
		DelayImgMover::init();
		ObjController::init();
	}
}

class WaitImgMover : ImgMover, ObjController	{
	init()	{
		ImgMover::init;
		ObjController::init;
		new DelayTaker cldt; 
	}
	public setclickrel(bool b)	{	cldt.setclickrel(b);	}
	public reset	{	cldt.ret;	}
	set(string s, int x, int y, int dx, int dy)	{
		ImgMover::set(s,x,y,dx,dy);
		cldt.take;
	}
	onmousemove	{	.msmove;	}
	onmouselclick	{	.<this+"_GET">;	}
	onmouselrel	{
		if( cldt.isonrel )	{
			.reset;
			.<this+"_PUT">;
		} else if( .moving ) {
			.reset;
			.<this+"_SET">;
		}
	}
}

class Rewinder : classlocker	{
	init(int x1, int y1, int x2, int y2)	{
		classlocker::init();
		new string sarrowdir;
		new int ilenx;
		new int ileny;
		new string sgr;
		new string sorientation;
		new bool bvertical;
		new bool bfilteritem = false;
		
		// clip obiektow
		new int ibx1=0;
		new int ibx2=iResX;
		new int iby1=0;
		new int iby2=iResY;
		
		new int iodleg = 2;	// odleglosc pomiedzy przedmiotami
		
		new ImgMover clmv;
		
		this.cnewtimercyclefin("timtick", 1, 1, "timfin");
		
		// granice
		.vars2(A, "borx1", x1, "bory1", y1, "borx2", x2, "bory2", y2);
		
		new snd fxrew;
// 		fxrew.addmethod("onfinish", func { this.play(); } );
	}
	public movefilter()		{	bfilteritem=true;	}
	public movenormal()	{	bfilteritem=false;	}
	public setfxrew(string sfile)	{
		fxrew.load(this.getsndpath()+sfile);
	}
	public getitem(string s, int x, int y)	{
		/*clmv.set(s,x,y,<sgr>.getpx(),<sgr>.getpy());
		<s>.clip(0,0,800,600);
		<sgr>.movefrom(s, 0, -<s>.geth);
		<sgr>.remove(s);*/
		<s>.setz( <s>.getz+1 );
		clmv.set(s,x,y,<sgr>.getpx(),<sgr>.getpy());
		<s>.clip(0,0,iResX,iResY);
		if( sorientation=="up" || sorientation=="down")	{
			<sgr>.movefrom(s, -(<s>.getw+iodleg), 0 );
			<s>.move( <s>.getw,0 );
		} else {
			<sgr>.movefrom(s, 0, -(<s>.geth+iodleg));
			<s>.move(0, <s>.geth );
		}
		<sgr>.remove(s);
	}
	public bool pickup(int x, int y)	{
		if( <sgr>.isin(x,y,true,true) )	{
			this.getitem( <sgr>.getsfound(), x, y );
			return true;
		}
		return false;
	}
	public bool mspickup()	{	return this.pickup(mouse.getpos );	}
	public freeitem()	{	clmv.free();	}
	public moveitem()	{
		if( bfilteritem )		clmv.msftmove();
		else		clmv.msmove();
	}
	public retitem()	{
		string s = clmv.getmover();
		clmv.ret(<sgr>.getpx(),<sgr>.getpy());
		this.putitem(s);
	}
	public putitem(string s)	{
		if( sorientation=="up" || sorientation=="down")	{
			<s>.move( <sgr>.getex-<s>.getpx+iodleg, 0);
		} else {
// 			@dx = anupstd.getex - <s>.getw;
// 			<s>.setpos( dx - <s>.lodx, <sgr>.getey-<s>.lody);
			<s>.move( 0, <sgr>.getey-<s>.getpy+iodleg);
		}
		<sgr>.add(s);
		<s>.setz( <s>.getz-1 );
		<s>.clip(ibx1,iby1,ibx2,iby2);
	}
	public string getmoved()	{	return clmv.getmover();	}
	public int getbutw()	{	return anupstd.getw();	}
	public int getbuth()	{	return anupstd.geth();	}
	public movearrows(int x, int y)	{	grarrows.move(x,y);	}
	public build(string sfile, int z, string scursor, string sorient, int dt, string sgrelem)	{
		sgr = sgrelem;
// 		this.newanima("anupstd",sfile,z);
		new anima anupstd;
		anupstd.load(sfile);
		anupstd.setz(z);
		
		anupstd.setframe("up",0);
		this.copyanima("anupstd","anupact");
		anupact.setframe("up",1);
		this.copyanima("anupstd","andownact");
		andownact.setframe("down",1);
		this.copyanima("anupstd","andownstd");
		andownstd.setframe("down",0);
		this.newbutan("butup","anupstd","anupact",null,scursor);
		this.newbutan("butdown","andownstd","andownact",null,scursor);
		butup.addmethod("onmoveon","_rewbutmoveon");
		butdown.addmethod("onmoveon","_rewbutmoveon");
		butup.addmethod("onmoveoff","_rewstrzalkaoff");
		butdown.addmethod("onmoveoff","_rewstrzalkaoff");
		butup.addmethod("onclick","_rewbutclick");
		butdown.addmethod("onclick","_rewbutclick");
		butup.addmethod("onrel","_rewbutrel");
		butdown.addmethod("onrel","_rewbutrel");
		sorientation=sorient;
		new gmimgvec grarrows;
		_ = "grarrows" .+ "anupstd" .+ "anupact" .+ "andownact" .+ "andownstd";
		
		int dy, int dx, int ix, int iy;
		if( sorientation=="up" || sorientation=="down")	{
			bvertical = false;
			ilenx = dt;
			if( sorientation=="down")	{
				anupstd.setpos(borx1,bory2-anupstd.geth());
				anupact.setpos(borx1,bory2-anupact.geth());
				andownstd.setpos(borx2-andownstd.getw(),bory2-andownstd.geth());
				andownact.setpos(borx2-andownact.getw(),bory2-andownact.geth());
				dy = andownstd.getey();
			} else {
				anupstd.setpos(borx1,bory1);
				anupact.setpos(borx1,bory1);
				andownstd.setpos(borx2-andownstd.getw(),bory1);
				andownact.setpos(borx2-andownact.getw(),bory1);
				dy = bory1;
			}
			ibx1 = anupstd.getex()+iodleg;
			ibx2 = andownstd.getpx()-iodleg;
			dx = ibx1;
		} else {
			bvertical = true;
			ileny = dt;
			if( sorientation=="right")	{
				anupstd.setpos(borx2-anupstd.getw(),bory1);
				anupact.setpos(borx2-anupact.getw(),bory1);
				andownstd.setpos(borx2-andownstd.getw(),bory2-andownstd.geth());
				andownact.setpos(borx2-andownact.getw(),bory2-andownact.geth());
				dx = anupstd.getex();
			} else {
				anupstd.setpos(borx1,bory1);
				anupact.setpos(borx1,bory1);
				andownstd.setpos(borx1,bory2-andownstd.geth());
				andownact.setpos(borx1,bory2-andownact.geth());
				dx = borx1;
			}
			iby1 = anupstd.getey()+iodleg;
			iby2 = andownstd.getpy()-iodleg;
			dy = iby1;
		}
		butup._rewbuildbut(this.getname(),"up");
		butdown._rewbuildbut(this.getname(),"down");
		
		int ile = <sgrelem>.size();
		<sgrelem>._setpos(dx,dy);
		new int ilimx = dx;
		new int ilimy = dy;
		string s;
		for(int i=0; i<ile; i++)	{
			s = <sgr>.get(i);
			if( sorientation=="right")	{
				<s>.setpos( dx - <s>.getw() - <s>.lodx(), dy - <s>.lody() );
				dy += <s>.geth()+iodleg;
			} else if (sorientation=="left")	{
				<s>.setpos( dx - <s>.lodx(), dy - <s>.lody() );
				dy += <s>.geth()+iodleg;
			} else if (sorientation=="up")	{
				<s>.setpos( dx - <s>.lodx(), dy - <s>.lody() );
				dx += <s>.getw()+iodleg;
			} else if (sorientation=="down")	{
				<s>.setpos( dx - <s>.lodx(), dy - <s>.geth() - <s>.lody() );
				dx += <s>.getw()+iodleg;
			}
			<s>.clip(ibx1,iby1,ibx2,iby2);
		}
	}
	/*************************************/
	_rewbuildbut(string s, string s2)	{
		new string _sob = s;
		new string _sdir;
		if( s2=="up" )	{
			if(bvertical==false)	{	_sdir = "left";	}
			else {	_sdir = "up";	}
		} else if (s2=="down")	{
			if(bvertical==false)	{	_sdir = "right";	}
			else {	_sdir = "down";	}
		}
	}
	_rewbutmoveon()	{
		//this.mstrzalkaon(_sdir);
		this.<_sob+"_"+_sdir+"_MOVEON">();
	}
	_rewbutclick()	{
		this.mstrzalkaon(_sdir);
		this.<_sob+"_"+_sdir+"_CLICK">();
	}
	mstrzalkaon(string s)	{
		sarrowdir=s;
		timtick.play();
	}
	_rewbutrel	{
		sarrowdir=null;
		timtick.stop(false);
		fxrew.stop(false);
	}
	_rewstrzalkaoff()	{
		sarrowdir=null;
		timtick.stop(false);
		fxrew.stop(false);
		this.<_sob+"_"+_sdir+"_MOVEOFF">();
	}
	timfin()	{
		if( this.getlock() )	{	return;	}
		bool bok = false;
		if( sarrowdir!=null && !<sgr>.empty())	{
			if( sarrowdir=="up")	{
				if( <sgr>.getey() > andownstd.getpy() - ileny )	{
					<sgr>.move(0,-ileny);
					bok=true;
				}
			} else if (sarrowdir=="down") {
				if( <sgr>.getpy() < ilimy )	{
					<sgr>.move(0,ileny);
					bok=true;
				}
			} else if (sarrowdir=="left")	{
				if( <sgr>.getex() > andownstd.getpx() - ilenx )	{
					<sgr>.move(-ilenx,0);
					bok=true;
				}
			} else if (sarrowdir=="right") {
				if( <sgr>.getpx() < ilimx )	{
					<sgr>.move(ilenx,0);
					bok=true;
				}
			}
		}
		if( bok )	{
			if( !fxrew.isplaying() )	fxrew.play();
		} else {
			fxrew.stop(false);
		}
		this.play();
	}
}

class ConRewinder : Rewinder, ObjController {
	init()	{
		Rewinder::init();
		ObjController::init();
		new DelayTaker cldt; 
	}
	public getitem(string s, int x, int y)	{
		Rewinder::getitem(s,x,y);
		cldt.take();
	}
	_put()	{
		cldt.ret();
		this.<this + "_PUT">();
	}
	onmousemove()	{	this.moveitem();	}
	onmouselrel()	{
		if( this.getlock() )	return;
		if( cldt.isonrel() )	{	this._put();	}
	}
	onmouselclick()	{
		if( this.getlock() ) return;
		if( cldt.isonclick() )	{
			this._put();
		} else if ( !cldt.istaken() )	{
			this.<this+"_GET">();
		}
	}
}

class Button : LObjController	{
	init	{
		LObjController::init;
		.unlock;
		new gmimgvec grbuts;
		.vars2(A,"sobject", null, "sclicked",null,"bcheck2klik", 0);
		
		new int ipadclick = 0;
	}
	print		{	grbuts.print;		}
	sort		{	grbuts.sortimgs;	}
	addgroups	{	grbuts.addgroups;	grbuts.sortimgs;	}
	addgroup(string s)	{	grbuts.addgr(s);	grbuts.sortimgs;	}
	addlist		{	grbuts.addlist;		grbuts.sortimgs;	}
	add(string sob)	{	grbuts.add(sob);	grbuts.sortimgs;	}
	addonce(string sob)	{ grbuts.addonce(sob);	grbuts.sortimgs;	}
	addbut(string sob)	{ grbuts.addonce(sob);	grbuts.sortimgs;	}
	contains(string sob)	{ grbuts.contains(sob);	}
	addlocker(string sob)	{
		.add(sob);
		classlocker::setaslocker(sob);
	}
	removebutlist	{	.withlist("removebut"); }
	removebut(string sbut)	{
		grbuts.remove(sbut);
		bool b = (sobject!=null || sclicked!=null);
		if( sbut==sobject ) sobject=null;
		if( sbut==sclicked ) sclicked = null;
		if( b )	{
			.onmousemove;
		}
	}
	removebutmoveoff(string sbut)	{
		grbuts.remove(sbut);
		.checkmoveoff(sbut);
	}
	checkmoveoff(string sbut)	{
		if( sbut==sobject )	{
			.lastoff;
			.onmousemove;
		}
	}
	load(string sname, string sfile, string sfuninit) {
		<GAME>.varnew("gmimgvec", sname);
		sname .* sfile;
		<sname>.each( sfuninit );
		.addgroup(sname);
	}
	remove(string sname)	{
		if( <GAME>.hasvar(sname) )	{
			//for( int i=0; i < <sname>.size; i++ )	grbuts.remove( <sname>.get(i) );
			grbuts.removegr(sname);
		}
	}
	loadfrom(string sname, string spath, string sfile, string sfuninit) {
		@s = .getgraphpath;
		.setgraphpath(spath);
		.load(sname,sfile,sfuninit);
		.setgraphpath(s);
	}
	onmouselclick	{
		if( .getlock ) return;
		
		if( .checktouchpad && bcheck2klik )	{
			if( ipadclick )	{
				@s = sobject;
				//.onmousemove;
				if( s==sobject )	{
					ipadclick=0;
					._butmouselclick;
				} else if ( sobject==null )	{
					ipadclick=0;
				}
			} else {
				ipadclick=1;
				//.onmousemove;
			}
		} else {
			._butmouselclick;
		}
	}
	onmouserclick	{
		if( !.getlock ) {
			if (sobject!=null && <sobject>.hasaddedmet("butrclick") )
				<sobject>.butrclick; 
		}
	}
	_butmouselclick	{
		.<this + "_lclick">;
		if( sobject!=null)	{
			sclicked = sobject;
			if (<sobject>.hasaddedmet("butclick") )
				<sobject>.butclick;
		}
	}
	onmouselrel	{
		if( .getlock ) return;
		if( .checktouchpad )	{
			.lastoff;
		}
		.<this + "_lrel">;
		if( sclicked!=null && <sclicked>.hasaddedmet("butlrel") )	{
			<sclicked>.butlrel;
		} else sclicked=null;
	}
	onmousemove	{
		if( .getlock ) return;
		if( sclicked!=null )	{
			if( <sclicked>.hasaddedmet("butmoving") )	<sclicked>.butmoving;
		}
		|int x, int y| = mouse.getpos;
		if(grbuts.isinfunc(x,y,"isbutin") )	{
			@s = grbuts.getsfound;
			if( s!=sobject )	{
				.lastoff;
				sobject = s;
				.<this + "_moveon">;
 				if( <s>.hasaddedmet("butmoveon") )
					<s>.butmoveon;
			}
		} else {
			.lastoff;
		}
	}
	lastoff	{
		if( sobject!=null )	{
			.<this + "_moveoff">;
			if( <sobject>.hasaddedmet("butmoveoff") )
				<sobject>.butmoveoff;
			sobject = null;
		}
	}
	refresh	{
		.lastoff;
		.onmousemove;
	}
	/*
	virtual bool isbutin(int x, int y)	{ 0; }
	virtual butclick	{}
	virtual butmoveon {}
	virtual butmoveoff {}*/
}

public Button_isin		{	.addmethod("isbutin", func { (@x,@y) .isin(x,y,1,0); } );	}
public Button_isinvis		{	.addmethod("isbutin", func { (@x,@y) .isin(x,y,0,0); } );	}
public Button_isinalpha		{	.addmethod("isbutin", func { (@x,@y) .isin(x,y,1,1); } );	}
public Button_isinvisalpha	{	.addmethod("isbutin", func { (@x,@y) .isin(x,y,0,1); } );	}
public Button_moveon		{
	.addmethod("butmoveon", func {
		sndfxmoveonms.playif;
		advmouse.setbut;
		if( .nofframes(-1)>1 ) .setframe(-1,1);
	} );
}
public Button_moveonstate		{
	.addmethod("butmoveon", func {
		if( .advstdstate )	{
			sndfxmoveonms.playif;
			advmouse.setbut;
			if( .nofframes(-1)>1 ) .setframe(-1,1);
		}
	} );
}
public Button_moveonplay		{
	.addmethod("butmoveon", func {
		sndfxmoveonms.play;
		advmouse.setbut;
		if( .isplaying(-1)==false ) .play(-1);
	} );
}
public Button_moveoff		{	.addmethod("butmoveoff", func { advmouse.setstd; .setframe(-1,0);} );	}
public Button_moveonms		{	.addmethod("butmoveon", func { advmouse.setbut; } );			}
public Button_moveonfxms	{	.addmethod("butmoveon", func { advmouse.setbut; sndfxmoveonms.playif; } ); }
public Button_moveonfxmstate	{
	.addmethod("butmoveon", func {
		if( .advstdstate )	{
			advmouse.setbut; 
			sndfxmoveonms.playif; 
		}
		} );
	}
public Button_moveoffms		{	.addmethod("butmoveoff", func { advmouse.setstd; } );			}
public Button_std		{	.Button_isin; .Button_moveon; .Button_moveoff;				}
public Button_stdstate		{	.Button_isin; .Button_moveonstate; .Button_moveoff;				}
public Button_stdalpha		{	.Button_isinalpha; .Button_moveon; .Button_moveoff;			}
public Button_stdms		{	.Button_isinalpha; .Button_moveonms; .Button_moveoffms;			}
public Button_stdmstate		{	.Button_isinalpha; .Button_moveonmstate; .Button_moveoffms;			}
public Button_stdclick		{	.addmethod("butclick", "Button_butclick" );		}
public Button_addstd	{
	.Button_std;
	.Button_stdclick;
	butgame.add(this);
}
public Button_addstdalpha	{
	.Button_stdalpha;
	.Button_stdclick;
	butgame.add(this);
}
public Button_addstdstate	{
	.Button_stdstate;
	.addmethod("butclick", func {
		if( .advstdstate )	{
			sndfxbutclick1.playif;
			.Button_butclick;
		} else .<"butclick_nostdstate_"+this>;
		} );
	butgame.add(this);
}
public Button_butclick		{	.<"butclick_"+this>;	}
public Button_butmoveon		{	.<"butmoveon_"+this>;	}
public Button_butmoveoff	{	.<"butmoveoff_"+this>;	}

class Buttons : LObjController	{
	init(string sfile)	{
		LObjController::init;
		.unlock;
		new gmimgvec grbuts;
		new int __id = 0;
		new string sanbut = "anbut";
		.newanima(sanbut, sfile, 10);
		_ = .newanactionsgr(sanbut, sanbut, "grbuts");
		anbut.hide;
		grbuts.setz(10);
		grbuts.removeif( func {
			if( .actionname=="bkg" ) { .setz( .getz-1); true; }
			else false; 
			});
		new string slastb = null;
		.vars2(A,"sobject", null, "bvisible", true, "balpha", true);
		
		new int ipadclick = 0;
		.var2("bcheck2klik", false);
	}
	_release()	{
		if( .checktouchpad )	{
			ipadclick = 0;
		}
		<slastb>.setframe(-1,0);
		.copyobj;
		.<this + "_moveoff">();
		slastb = null;
		//bsms.setstd;
		advmouse.setstd;
	}
	getbut	{	grbuts.getsfound;	}
	onmousemove()	{
		if( .getlock ) return;
		grbuts.setframe(-1,0);
		def id =  grbuts.isin(mouse.getpos,bvisible,balpha);
		if( slastb!=null ) <slastb>.setframe(-1, 1);
		if( id ) {
			string s = grbuts.getsfound;
			if( s!=slastb )	{
				if( slastb!=null )	._release;
				slastb = s;
				<s>.setframe(-1,1);
				.copyobj;
				//bsms.setact;
				advmouse.setact;
				.<this + "_moveon">();
			}
		} else if( slastb!=null )	{
			._release;
		}
		//slastb==null ? bsms.setstd : bsms.setact;
	}
	copyobj()	{	sobject = <slastb>.actionname;	}
	onmouselclick()	{
		if( .getlock ) return;
		
		if( .checktouchpad && bcheck2klik )	{
			if( ipadclick )	{
				ipadclick=0;
				._butmouselclick;
			} else {
				ipadclick=1;
				.onmousemove;
			}
		} else {
			._butmouselclick;
		}
	}
	_butmouselclick	{
		if( slastb!=null )	{
			.copyobj;
			.<this + "_lclick">;
		}
	}
	onmouselrel	{
		if( .getlock ) return;
		if( slastb!=null )	{
			.copyobj;
			.<this + "_lrel">;
		}
	}
	disable	{
		.lock;
		grbuts.hide;
		if( slastb!=null )	{
			//bsms.setstd;
			advmouse.setstd;
			slastb=null;
		}
	}
	enable	{
		.unlock;
		grbuts.show;
	}
}

class TextDb : classlocker, ObjController, gfxObject {
	init(string sfont, int isize, string sdbfile, int r, int g, int b, int x, int y, int dy, int z, string sdir)	{
		classlocker::init;
		ObjController::init;
		new string sFont = sfont;
		new string sFontBold = null;
		new string sFontItalic = null;
		new string sFontBoldItalic = null;
		new bool bhtml = false;
		
		string s;
		int id, int i;
		if( sfont.contains("$") )	{
			bhtml = true;
			new vector vfont; vfont.type("string");
			vfont.vecbuildfromstring( sfont, "$" );
			
			for( i=0; i<vfont.size; i++)	{
				s = vfont.get(i);
				if( s.contains("_italic") && s.contains("_bold") )	{
					sFontBoldItalic = s;
				} else if ( s.contains("_italic") )	{
					sFontItalic = s;
				} else if ( s.contains("_bold") )	{
					sFontBold = s;
				} else sFont = s;
			}
			if( sFont.contains("$") )	{
				if( sFontItalic!=null ) sFont = sFontItalic;
				else if( sFontBold!=null ) sFont = sFontBold;
				else sFont = sFontBoldItalic;
			}
			sfont = sFont;
		} else sfont = .checkfont( sfont, isize );
		new int iFontSize = isize;
		
		.var2("Z",z);
		string skey = null;
		if( sdbfile.contains(":") )	{
			skey = sdbfile.strgetto(":") + ":";
		}
		if( sdbfile.contains(".db") )	{
			if( skey =="$path:" )	{
				new db dbtxt;
				dbtxt.load( sdbfile.strsubbs(skey) );
			} else .newdb( "dbtxt", sdbfile );
		} else {
			match(skey)	{
				"$lang:" => .lang_db("dbtxt", sdbfile.strsubbs(skey) );
				"$var:" => {
					new db dbtxt;
					dbtxt.dbcopy( sdbfile.strsubbs(skey) );
				}
				"$row:" => {
					new db dbtxt;
					s = sdbfile.strsubbs(skey)->strgetto(",");
					id = sdbfile.strgetfrom(",");
					for( i=0; i< <s>.getcolsno(id); i++)	{
						_ = dbtxt.addrow;
						dbtxt.add(i, <s>.get(id,i) );
					}
				}
				? => {
					new db dbtxt;
					dbtxt.dbaddlast( sdbfile );
				}
			}
		}
		int w = 0, int ile = dbtxt.getrowsno;
		
		if( sdir.getb(0,5)=="limit" )	{
			int lim = sdir.strsubbs("limit_");
			new vector vtmp; vtmp.type("string");
			new vector vtmp2; vtmp2.type("string");
			for( int i=0; i<dbtxt.getrowsno; i++)	{
				vtmp.vecbuildfromstring( dbtxt.get(i,0), " " );
				for( int j=0; j<vtmp.size; j++)
					vtmp2.add(vtmp.get(j));
			}
			dbtxt.free;
			string s = "";
			string s2;
			for( i=0; i<vtmp2.size; i++)	{
				s2 = vtmp2.get(i);
				if( (s+s2)->length < lim )	{
					s += s2 + " ";
				} else {
					j = dbtxt.addrow-1;
					dbtxt.add(j, s);
					s = s2 + " ";
				}
			}
			j = dbtxt.addrow-1;
			dbtxt.add(j, s);
			ile = dbtxt.getrowsno;
		}
		
		new gmimgvec grtxt;
		grtxt._setpos(x,y);
		for( i=0; i< ile; i++)	{
			s = "txt" + i;
			new text <s>;
			@s1 = dbtxt.get(i,0);
			if( bhtml )	{
				if( s1.contains("<b>") ) { sfont = sFontBold; s1.strremove("<b>"); }
				else if( s1.contains("<bi>") ) { sfont = sFontBoldItalic; s1.strremove("<bi>"); }
				else if( s1.contains("<i>") ) { sfont = sFontItalic; s1.strremove("<i>"); }
				else sfont = sFont;
			}
			<s>.setfont( sfont );
			
			<s>.set( s1 );
			<s>.setpos(x,y);
			y+=isize+dy;
			<s>.setz(z);
			<s>.createtxt(r,g,b);
			if( <s>.getw>w ) w = <s>.getw;
			grtxt.add(s);
		}
		.var2("Rows", ile);
		if( sdir == "right" || sdir =="center" )	{
			for( i=0; i<ile; i++)	{
				s = "txt" + i;
				if( sdir == "center" )	{
					<s>.move( (w-<s>.getw)/2, 0 );
				} else {
					<s>.move( w-<s>.getw, 0 );
				}
			}
		}
		.var2("W", w);
		gfxObject::init("grtxt");
	}
	stdshadow(int dt)	{	.setshadow(0,0,0,dt);	}
	setshadow(int r, int g, int b, int dt)	{
		string s[2];
		string sfont = ._checkfont(sFont, iFontSize, "_fntbrd");
		for( int i=0; i< dbtxt.getrowsno; i++)	{
			s0 = "txt" + i;
			s1 = "txts" + i;
			new text <s1>;
			<s1>.set( <s0>.get );
			<s1>.setfont( sfont );
			<s1>.setz( <s0>.getz-1 );
			<s1>.setpos( <s0>.getpx+dt, <s0>.getpy+dt );
			<s1>.createtxt(r,g,b);
			grtxt.add(s1);
		}
	}
	setz(int z)	{
		/*for( int i=0; i< dbtxt.getrowsno; i++)	{
			<"txt" + i>.setz(z);
			<"txts" + i>.setz(z-1);
		}*/
		Z = z;
		grtxt.setz(z);
	}
	getz	{ Z;	}
	isin(int x, int y, bool bv, bool ba)	{	grtxt.isin(x,y,bv,ba);	}
	view	{
		@s = _;
		string s2;
		while(A!=s)	{
			s2 = grtxt.get(s);
			<s2>.show;
			s2 = "txts" + s2.strsubbs("txt");
			if( engine.varexist(s2) ) <s2>.show;
			@s=_;
		}
	}
	blitto(string simg)	{
		string s;
		for( int i=0; i<grtxt.size; i++)	{
			s = grtxt.get(i);
			<s>.buildfullname;
			<simg>.blit(<s>.getfullname);
			<GAME>.vardel(<s>.getfullname);
		}
	}
	setcol(int r, int g, int b)	{
		for( int i=0; i<grtxt.size; i++) <grtxt.get(i)>.createtxt(r,g,b);
	}
	clip(int x1, int y1, int x2, int y2)	{
		for( int i=0; i<grtxt.size; i++) <grtxt.get(i)>.clip(x1,y1,x2,y2);
	}
	setpos(int x, int y)	{
		@dx = x-grtxt.getposx;
		@dy = y-grtxt.getposy;
		grtxt.move(dx, dy);
		//for( int i=0; i<grtxt.size; i++) <grtxt.get(i)>.setpos(x+,y1,x2,y2);
	}
}

class Lexer	{
	init	{}
	buildlex	{
		.vars(A,"id","found");
		new vector vconsts;
		vconsts.type("string");
		new vector vtmp1;
		vtmp1.type("string");
		new vector vtmp2;
		vtmp2.type("string");
		
		new int dot = "."->getbyte(0);
		new string _literal_char = "\"";
	}
	setliteralchar(string s)	{	_literal_char=s;	}
	getliteralchar	{	_literal_char;	}
	bool _isvar(int b1, int b2)	{
		int i = id;
		found = "";
		int ib;
		while(i<.length)	{
			ib = .getbyte(i);
			if( ib>=b1 && ib<=b2 )	{
				found += .getb(i,1);
				i++;
			} else {
				if( (ib>=BYTEa && ib<=BYTEz) || (ib>=BYTEA && ib<=BYTEZ) || ib==BYTE_ )	found="";
				i = .length;
			}
		}
		found.length;
	}
	bool isreal	{
		int i = id;
		found = "";
		int ib;
		bool kropka=true;
		while(i<.length)	{
			ib = .getbyte(i);
			if( (ib>=BYTE0 && ib<=BYTE9) || (ib==dot&&kropka) )	{
				if( ib==dot ) kropka=false;
				found += .getb(i,1);
				i++;
			} else i = .length;
		}
		if( kropka || found.getb(0,1)=="." || found.gete(0,1)=="." ) found="";
		found.length;
	}
	bool isident	{
		int i = id;
		found = "";
		int ib;
		while(i<.length)	{
			ib = .getbyte(i);
			if( (ib>=BYTEa && ib<=BYTEz) || (ib>=BYTEA && ib<=BYTEZ) || ib==BYTE_ ||
				(i>id && ib>=BYTE0 && ib<=BYTE9) )	{
				found += .getb(i,1);
				i++;
			} else i = .length;
		}
		found.length;
	}
	bool isliteral	{
		if( .check!=.getliteralchar )	return false;
		int i = id+1;
		found = "";
		string s;
		while(i<.length)	{
			s = .getb(i,1);
			if( s==.getliteralchar )	{
				//found += s;
				return true;
			} else {
				found += s;
				i++;
			}
		}
		false;
	}
	bool isconst	{
		string s0;
		bool b = .isident;
		for( int i=0; i< vconsts.size; i++)	{
			s0 = vconsts.get(i);
			if( b )	{
				if( s0 == found )	return true;
			} else {
				found = .getb(id, s0.length);
				if( s0 == found ) return true;
			}
		}
		false;
	}
	gettoken(string svec, bool bideal)	{
		<svec>.free;
		while( .notend )	{
			if (.check==" ")	id++;
			else if (.isconst)	{	<svec>.add("$const"); <svec>.add(.read);	}
			else if (.isreal )		{<svec>.add( "$real" );	.next; if( bideal ) <svec>.add( found );}
			else if (.isint )		{<svec>.add( "$int" );	.next; if( bideal ) <svec>.add( found );}
			else if (.isident )	{<svec>.add( "$alpha" );	.next; if( bideal ) <svec>.add( found );}
			else if (.isliteral )	{<svec>.add( "$literal" );	.next; id+=2; if( bideal ) <svec>.add( found );}
			else	{<svec>.add("$error"); id++; }
		}
	}
	int expectdb(string sdb, bool bideal)	{	// identyczne lub parse
		int j, string s;
		for( int i=0; i< <sdb>.getrowsno; i++)	{
			//vtmp2.veccopydbrow(sdb,i);
			vtmp2.free;
			for( j=0; j< <sdb>.getcolsno(i); j++)	{
				s = <sdb>.get(i,j);
				s.clear;
				if( s!="" ) vtmp2.add(s);
			}
			if( .expectvec("vtmp2", bideal) )	return i;
		}
		-1;
	}
	bool expectvec(string svecsrc, bool bideal)	{
		id = 0;
		.gettoken("vtmp1", bideal);
		/*vtmp1.print;
		<svecsrc>.print;*/
		vtmp1.veceq(svecsrc);
		/*bool b = vtmp1.veceq(svecsrc);
		if( !b ) {
			("wrong expect "+.get)->print;
			vtmp1.print;
			<svecsrc>.print;
		}
		b;*/
	}
	bool expects(string s, string ssep, bool bideal)	{
		vtmp2.vecbuildfromstring(s,ssep);
		.expectvec("vtmp2", bideal);
	}
	consts=	{	vconsts.withlist("addbegin");	}
	setas(string sob)	{
		<sob>.addmethod("buildlex", "buildlex");
		<sob>.buildlex;
		<sob>.addmethod("start",	func { (string s) .set(s);	id=0; } );
		<sob>.addmethod("notend",	func {	id<.length;	} );
		<sob>.addmethod("getnext",	func { if( id==.length ) return null;
					id++;	.getb(id-1,1);	} );
		<sob>.addmethod("next",	func { id+=found.length;	} );
		<sob>.addmethod("check",	func { if( id==.length ) return null; found=.getb(id,1); found; });
		<sob>.addmethod("ischar",	func { (string s) s.contains( .getb(id,1) ); } );
		<sob>.addmethod("isint",	func{	._isvar(BYTE0, BYTE9);	} );
		<sob>.addmethod("isreal", "isreal");
		<sob>.addmethod("isbinary",	func{	._isvar(BYTE0, BYTE0+1);	} );
		<sob>.addmethod("isident",	"isident" );
		<sob>.addmethod("isconst",	"isconst" );
		<sob>.addmethod("_isvar", "_isvar");
		<sob>.addmethod("read",	func { .next;	found;	} );
		<sob>.addmethod("isliteral", "isliteral");
		<sob>.addmethod("gettoken", "gettoken");
		<sob>.addmethod("expects", "expects");
		<sob>.addmethod("expectvec", "expectvec");
		<sob>.addmethod("expectdb", "expectdb");
		<sob>.addmethod("consts=", "consts=");
		<sob>.addmethod("setliteralchar", "setliteralchar");
		<sob>.addmethod("getliteralchar", "getliteralchar");
	}
}


class AnimaFx	{
	init {}
	build(string san)	{
		<san>.addmethod("_buildanfx", func {
			new db dbsnd;
			dbsnd.dbbuild(3);
			for( int i=0; i<dbsnd.getrowsno; i++) dbsnd.set(i,0, dbsnd.get(i,0)+"_"+dbsnd.get(i,1));
			} );
		<san>._buildanfx;
		<san>.addmethod("onsetframe", func {
			@id = dbsnd.findbyrow(.actionname+"_"+.framenr);
			if( id>=0 ) {
				<"fx"+dbsnd.get(id,2)>.play;
			}
			} );
	}
}

class Localize	{
	init	{}
	_lang_db(string sname, string sfile, string sfunload)	{
		new db <sname>;
		<sname>.<"load"+sfunload>( .lang_path(sfile) + ".db");
	}
	lang_db(string sname, string sfile)	{ ._lang_db(sname,sfile,"");	}
	lang_dbscript(string sname, string sfile)	{ ._lang_db(sname,sfile,"script");	}
	lang_dbbeh(string sname, string sfile)	{ ._lang_db(sname,sfile,"beh");	}
	lang_path(string sfile)	{ LANGDIR + gameapi.getgamename + "_" + sfile; }
}

class PyzCounter	{
	init(string sanima, int timestep)	{
		new int istart;
		new int istop;
		new int istep;
		new int idigits = 50;
		new int iactual;
		new string _sanima = sanima;
		.vars2(A, "idx",2, "itimestep", timestep);
		
		new gmimgvec grcnt;
		for( int i=0; i<idigits; i++ )	{
			string s = "pcc" + sanima + i;
			.copyanima(sanima, s);
			<s>.hide;
			grcnt.add(s);
		}
		.timer = ("timcnt", timestep, func {
			iactual += istep;
			.view(iactual);
			if( iactual==istop )	{
				<.getbuildername>.<.getbuildername+"_finish">;
			} else .play;
			} );
	}
	getcypher(int id)	{	"pcc" + _sanima + id;	}
	start(int start, int stop, int step)	{
		istart = start;
		istop = stop;
		istep = step;
		iactual = istart;
		.view(istart);
		timcnt.play;
	}
	showcypher(int i, int cypher)	{
		string s = .getcypher(i);
		<s>.setframe(0, cypher);
		<s>.show;
	}
	stop	{
		timcnt.stop(false);
	}
	view(int cnt)	{
		grcnt.hide;
		grcnt.setpos(0,0);
		if( cnt==0 )	{
			.showcypher(0,0);
		} else {
			for( int i=0; cnt > 0; i++ )	{
				.showcypher(i, cnt%10);
				cnt=cnt/10;
			}
			int w = 0;
			for( int j=i-1; j>=0; j-- )	{
				<.getcypher(j)>.move( w, 0 );
				w = w + <.getcypher(j+1)>.getw;
			}
		}
	}
}
/*************************************************************************/

public setasanmover	{
	new real _r_roadx;
	new real _r_roady;
	.addmethod("movereal", func { (real x, real y)
		_r_roadx += x;
		_r_roady += y;
		.move( _r_roadx, _r_roady );
		_r_roadx -= _r_roadx.to_i;
		_r_roady -= _r_roady.to_i;
		} );
}

class AnMover	{
	init(string san, real x, real y)	{
		new timer tmov;
		tmov.settick(1);
		tmov.setcycle(1);
		//new real rdx = x;
		//new real rdy = y;
		.vars2(A, "rdx", x, "rdy", y);
		new real rsx = 0;
		new real rsy = 0;
		new string sanima = san;
		tmov.addmethod("onfinish", func {
			.move;
			.builder_func("_finish");
			.play;
			} );
	}
	move	{
		rsx += rdx;
		rsy +=rdy;
		int x = rsx;
		int y = rsy;
		if( x || y ) {
			<sanima>.move(x,y);
			rsx-=x;
			rsy-=y;
		}
	}
	reset	{
		rsx=0;
		rsy=0;
	}
	play	{
		.reset;
		tmov.play;
	}
	stop	{	tmov.stop(false);	}
	enableroll	{	.addmethod( this + "_finish", func { .roll(0,0); } );	}
	roll(int dx, int dy)	{
		if( rdx < 0 && <sanima>.getex < 0 ) <sanima>.ansetbpos( igmappw + dx, <sanima>.getpy );
		else if ( rdx > 0 && <sanima>.getpx >= igmappw ) <sanima>.ansetbpos( dx - <sanima>.getw, <sanima>.getpy );
		if( rdy < 0 && <sanima>.getey < 0 ) <sanima>.ansetbpos( <sanima>.getpx, igmapph + dy );
		else if ( rdy > 0 && <sanima>.getpy >= igmapph ) <sanima>.ansetbpos( <sanima>.getpx, dy - <sanima>.geth );
	}
}

public SetAnMover_tmov_onfinish	{	<.getbuildername>.sam_move; .play;	}
class SetAnMover	{
	init	{}
	setas(string sanima, real x, real y)	{
		<sanima>.addmethod("setanmover", "setanmover");
		<sanima>.setanmover(x,y);
		<sanima>.addmethod("sam_move", "sam_move");
		<sanima>.addmethod("sam_copy", "sam_copy");
		<sanima>.addmethod("sam_addtimer", func {
			new timer tmov;
			tmov.settick(1);
			tmov.setcycle(1);
			tmov.addmethod("onfinish", "SetAnMover_tmov_onfinish" );
			} );
		<sanima>.addmethod("sam_playtimer", func { tmov.play; }		);
		<sanima>.addmethod("sam_stoptimer", func { tmov.stop(false); }	);
	}
	setanmover(real x, real y)	{
		new real rdx = x;
		new real rdy = y;
		new real rsx = 0;
		new real rsy = 0;
		.vars2(A, "sam_speed", 1.0, "moved_x", 0, "moved_y", 0);
	}
	sam_move	{
		rsx += (rdx*sam_speed);
		rsy += (rdy*sam_speed);
		moved_x = rsx;
		moved_y = rsy;
		if( moved_x || moved_y ) {
			.move(moved_x,moved_y);
			rsx-=moved_x;
			rsy-=moved_y;
			if( .hasvar("ansamcopy") )	{
				ansamcopy.move(moved_x,moved_y);
				if( rdx>0.0 )	{
					if( ansamcopy.getpx > rollerx )	{
						@dx = ansamcopy.getpx -.getw;
						ansamcopy.move( dx, 0 );
						.move( dx, 0 );
					}
				} else {
					if( ansamcopy.getex < rollerex )	{
						.move(.getw, 0);
						ansamcopy.move(.getw, 0);
					}
				}
			}
		}
	}
	sam_copy	{
		if( .gettype=="anima" )
			.copyanima(this, "ansamcopy");
		else	{
			new img ansamcopy;
			ansamcopy.copy(this);
		}
		ansamcopy.buildfullname;
		.vars2(A, "rollerx", 0, "rollerex", igmappw, "get_sam_copy", ansamcopy.getfullname);
		ansamcopy.show;
		if( rdx>0.0 )	{
			ansamcopy.ansetbpos( .getpx - .getw, .getpy );
			//("act: "+.actionname + ","+ansamcopy.actionname + " z: "+.getz+","+ansamcopy.getz+" x: "+.getpx+","+ansamcopy.getpx)->print;
		} else {
			ansamcopy.ansetbpos( .getex, .getpy );
		}
	}
}

/*************************************************************************/
class classlives	{
	init()	{}
	set(int ile, int idamage, int x, int y, int h, int r1, int g1, int b1, int a1, int r2, int g2, int b2, int a2, int z, string sside)	{
		new int iside;
		
		if( sside=="left")iside=-1;
		else	iside=1;
		
		new int iilezyc = ile;
		new int ibum	= idamage;
		int idl = iilezyc*ibum;
		new int iposxsila = x;
		new int iendxsila = x+idl;
		new int iposysila = y;
		newvars::newcanvas( "imgsilapodkladka",idl, h, r1, g1, b1, a1, z-1 );
		newvars::newcanvas( "imgsila",idl, h, r2, g2, b2, a2, z );
		imgsila.setpos( iposxsila, iposysila );
		imgsila.clip(iposxsila, 0,  imgsila.getex(), 600);
		imgsilapodkladka.setpos( iposxsila, iposysila );
	}
	reset()	{
		imgsila.setpos( iposxsila, iposysila );
	}
	damage(int idam)	{
		imgsila.move( iside*idam*ibum, 0);
	}
	int destroyed()	{
		if( iside<0)	return imgsila.getex() < iposxsila;
		return imgsila.getpx() > iendxsila;
	}
	heal(int idam)	{
		imgsila.move( -iside*idam*ibum, 0 );
		if( iside > 0 )	{
			if( imgsila.getpx() < iposxsila )	{
				imgsila.setpos( iposxsila, iposysila );
			}
		} else {
			if( imgsila.getpx() > iposxsila )	{
				imgsila.setpos( iposxsila, iposysila );
			}
		}
	}
}


class imganima : gmimgvec	{
	init	{
		gmimgvec::init;
		new int idgran = 0;
		new timer timan;
		timan.settick(1);
		timan.addmethod("onfinish", func {
			idgran++;
			@s = .getbuildername;
			if( idgran == <s>.size )	{
				<s>.<s+"_finish">;
			} else {
				.setframe(idgran);
				<s>.<s+"_endframe">;
				.play;
			}
			} );
	}
	load(string simg, string sfiletype, int istart, int istop, int icycle)	{
		timan.setcycle(icycle);
		for( int i=istart; i<istop; i++)	{
			@s = simg + i;
			.newimg("an" + s, s + "." + sfiletype, 0);
			.add("an" + s);
		}
		.setframe(0);
	}
	play	{
		.setframe(0);
		timan.play;
	}
	setframe(int id)	{
		.hide;
		idgran = id;
		<.get(id)>.show;
	}
}


class GuiItem	{
	init	{}
	/****************** rotujacy obiekt **************************/
	setasrototaker(string sanima, real ilerot, real ileobrotow)	{
		<sanima>.addmethod("_setasrototaker", func { (@ilerot, @ileobrotow)
			.vars2(A, "ilerotos",ilerot, "idrotos", 0.0, "ikatos", (ileobrotow*360.0)/ilerot,
				"rzoomx", 0.0, "rzoomy", 0.0, "rzoomstepx", 0.0, "rzoomstepy", 0.0,
				"rmovx", 0.0, "rmovy", 0.0, "istartalfa", 128,
				"iendx", 0.0, "iendy", 0.0,
				"irotodir", 1, "izoomdir", 0);
			new filter ftroto;
			ftroto.setpivottype(2);
			
			new timer timrotocenter;
			timrotocenter.setcycle(1);
			timrotocenter.addmethod("onfinish", func {
				if( <.getbuildername>.rototaker_setroto )
					.play;
				} );
			//SetAnMover::setas(this, 0.0, 0.0);
			} );
		<sanima>._setasrototaker(ilerot, ileobrotow);
		<sanima>.addmethod("rototaker_start", "rototaker_start");
		<sanima>.addmethod("rototaker_startwh", "rototaker_startwh");
		<sanima>.addmethod("rototaker_startact", "rototaker_startact");
		<sanima>.addmethod("rototaker_setroto", "rototaker_setroto");
		<sanima>.addmethod("rototaker_endroto", func { .<"rototaker_"+ this + "_endroto">; } );	// std funkcja, mozna podmienic
	}
	bool rototaker_setroto	{
		if( izoomdir )	{
			@r = idrotos/ilerotos;
			@rx = rzoomx + rzoomstepx*r;
			@ry = rzoomy + rzoomstepy*r;
			ftroto.rotatezoomxy( irotodir*ikatos, rx, ry );
		} else {
			@r = (ilerotos-idrotos);
			@rx = rzoomx + rzoomstepx*r;
			@ry = rzoomy + rzoomstepy*r;
			ftroto.rotatezoomxy( irotodir*ikatos, rx, ry );
			r = idrotos/ilerotos;
		}
		if( istartalfa<255 )	{
			real iop = istartalfa;
			ftroto.setopacity( iop + (255.0-iop) * r );
		}
		//.move(rmovx, rmovy);
		real r1 = (iendx - .getposx) * r * rx;
		real r2 = (iendy - .getposy) * r * ry;
		.move(r1, r2);
		idrotos++;
		if( idrotos<ilerotos ) true;
		else {
			ftroto.unlink;
			.rototaker_endroto;
			false;
		}
	}
	rototaker_startact(int endx, int endy, def sact)	{
		string sact2;
		if( sact.gettype!="string" )	{
			sact2 = .nameofaction(sact);
		} else sact2 = sact;
		.rototaker_start( .getpx, .getpy, endx, endy, .getw, .geth, sact2 );
	}
	rototaker_start(int startx, int starty, int endx, int endy, real startw, real starth, string sact)	{
		.setframe(sact,0);
		.setpos(startx,starty);
		.rototaker_startwh(endx, endy, startw, starth, .getw, .geth);
	}
	rototaker_startwh(int endx, int endy, real startw, real starth, real endw, real endh)	{
		iendx = endx;
		iendy = endy;
		rmovx = ( endx-.getcx)->to_r/ilerotos;
		rmovy = ( endy-.getcy)->to_r/ilerotos;
		
		if( endw>startw )	{
			rzoomx = startw/endw;
			rzoomstepx = (endw-startw)/endw;
			izoomdir=1;
		} else {
			izoomdir=0;
			rzoomx = endw/startw;
			rzoomstepx = (1.0-rzoomx)/ilerotos;
		}
		if( endh > starth )	{
			rzoomy = starth/endh;
			rzoomstepy = (endh-starth)/endh;
		} else {
			rzoomy = endh/starth;
			rzoomstepy = (1.0-rzoomy)/ilerotos;
		}
		
		ftroto.link(this);
		
		idrotos = 0;
		if( .rototaker_setroto )
			timrotocenter.play;
	}
}


class CalcFPS	{
	init	{
		new real rfps1;
		new real rfps2;
		new real rfps3;
		new real rsec = 1000.0;
		new real rstart = 1.0;
		.cycle = ("tickfps", func {	<.getbuildername>.tick; .play;	});
	}
	stdset(int size, int posx, int posy)	{	.set(.stdfont(size), .white, posx, posy, 1000);	}
	set(string sfont, int r, int g, int b, int posx, int posy, int z)	{
		.newtext("txtfps", 0, sfont, r,g,b);
		txtfps.setz(z);
		.setpos(posx,posy);
	}
	setpos(int x, int y)	{ txtfps.setpos(x,y);	}
	tick	{
		real rstop = engine.getticks;
		if( rstop>rstart )	{
			rfps1 = rfps2;
			rfps2 = rfps3;
			rfps3 = rsec/(rstop-rstart);
			//txtfps.txtset( rsec/(rstop-rstart) );
			txtfps.txtset( "delay: "+(rstop-rstart)+ " fps: "+ (rfps1+rfps2+rfps3)/3);
		} else txtfps.txtset( "inf" );
		rstart = rstop;
	}
	play	{	tickfps.play;	}
	stop	{	tickfps.stop(false);	}
}

class Film : gfxObject	{
	init	{
		new img imfilm;
		imfilm.buildfullname;
		gfxObject::init("imfilm");
		
		new string sfilmpath;
		new db dbfilm;
		new db dbfilm2;
		
		new int istartklatka;
		new int iklatka;
		new int iendklatka;
		new string sprefilm;
		new int ifilmcycle; 
		new string smusic;
		
		new int igameloopdelay = igmdelay;
		
		new gmobjvec grsfx;
		new gmimgvec grbuf;
		
		.vars2(A, "bcenter", 0, "bborders", 0, "musicclass", null, "bbuffer", 0, "sfileformat", "jpg" );
		
		.cycle = ("timfilm", func {
			.nextframe;
			if( iklatka<=iendklatka )	{
				timfilm.play;
			} else {
				.retfps;
				@s = .getbuildername;
				if( <s>.hasaddedmet("onfinish") )	{
					<s>.onfinish;
				}
			}
			} );
	}
	bufferfilm	{
		
	}
	retfps	{	engine.setloopdelay(igameloopdelay);	}
	setfilmfps	{
		igameloopdelay = engine.getloopdelay;
		int ifps = dbfilm.dbgetint("fps:");
		if( ifps>0 )
			engine.setfps(ifps);
	}
	setcycle(int icycle)	{
		timfilm.setcycle(icycle);
		ifilmcycle=icycle;
	}
	nextframe	{
		.<"film_onsetframe_"+iklatka>;
		.loadframe;
		iklatka++;
	}
	loadframe	{
		@id = dbfilm.findbyrow(iklatka);
		if( id>=0 )	{
			for( int i=1; i<dbfilm.getcolsno(id); i++)	{
				match( dbfilm.get(id,i) )	{
					"fadeout:" => {
						i++;
						if( musicclass!=null )
							<musicclass>.fadeout( dbfilm.get(id,i) );
					}
					? => {
						@s = dbfilm.get(id,i);
						<s>.setvol( dbfilm.<"volume_"+id+"_"+i> );
						<s>.play;
					}
				}
			}
		}
		@z = imfilm.getz;
		@x = imfilm.getpx;
		@y = imfilm.getpy;
		if( bbuffer )	{
			@s = grbuf.get(iklatka-istartklatka);
			<s>.createfrombuffer;
			imfilm.copy(s);
			<s>.hide;
			imfilm.show;
			if( iklatka>istartklatka )	{
				<grbuf.get(iklatka-istartklatka-1)>.free;
			}
		} else {
			imfilm.load( sfilmpath + sprefilm +iklatka+"."+sfileformat );
			imfilm.show;
		}
		imfilm.setz(z);
		if( bcenter )	imfilm.setpos( (igmappw-imfilm.getw)/2, (igmapph-imfilm.geth)/2 );
		else imfilm.setpos(x,y);
	}
	playfilm(string spath, string sdbfile)	{
		.load(spath, sdbfile);
		.play;
	}
	load(string spath, string sdbfile)	{
		if( .isplaying ) .free;
		sfilmpath = spath;
		
		dbfilm.load( spath + sdbfile + ".db" );
		
		istartklatka = dbfilm.dbgetint("start:");
		iklatka = istartklatka;
		iendklatka = dbfilm.dbgetint("end:");
		sprefilm = dbfilm.dbget("prefix:");
		smusic = dbfilm.dbget("music:");
		@id = dbfilm.findbyrow("format:");
		if( id>=0 ) sfileformat = dbfilm.get(id,1);
		
		bbuffer = dbfilm.dbgetint("buffer:");
		if( bbuffer )	{
			for( int i=istartklatka; i<=iendklatka; i++)	{
				@s = "imbuf"+i;
				new img <s>;
				<s>.loadbuffer( sfilmpath + sprefilm +i+"."+sfileformat );
				grbuf.add(s);
			}
		}
		
		for( int i=0; i<dbfilm.getrowsno; i++)	{
			@s = dbfilm.get(i,0);
			if( StringChecker::isdigit(s) )	{
				for( int j=1; j<dbfilm.getcolsno(i); j++)	{
					@s2 = dbfilm.get(i,j);
					match( s2 )	{
						"fadeout:" => {
							j++;
						}
						? => {
							s = "fx" + s2.strgetto(" ");
							int vol = 100;
							if( !.hasvar(s) )	{
								.sfx = (s2);
								vol = <s>.getvol;
							} else if ( s2.contains(" ") )	{
								vol = s2.strgetfrom(" ");
							}
							dbfilm.var2("volume_"+i+"_"+j, vol);
							dbfilm.set(i,j, s );
							grsfx.addonce(s);
						}
					}
				}
			}
		}
	}
	loadborders	{
		if( bborders && !.hasvar("imramkaup"))	{
			new img imramkaup;
			new img imramkadown;
			new img imramkaleft;
			new img imramkaright;
			int dh = 0.5 + (igmapph-imfilm.geth)->to_r/2.0;
			@z = .getz - 1;
			if( dh > 0 )	{
				imramkaup.create(igmappw, dh, .black, 255);
				imramkaup.setz(z);
				
				//imramkadown.create(igmappw, dh, .black, 255);
				imramkadown.copy("imramkaup");
				imramkadown.setpos(0, igmapph-dh);
			}
			int dw = 0.5 + (igmappw-imfilm.getw)->to_r/2.0;
			if( dw > 0 )	{
				imramkaleft.create(dw, igmapph, .black, 255);
				imramkaleft.setz(z);
				
				imramkaright.copy("imramkaleft");
				imramkaright.setpos( igmappw-dw, 0 );
			}
		}
	}
	play	{
		iklatka = istartklatka;
		.nextframe;
		.loadborders;
		if( smusic!=null && musicclass!=null )	{
			<musicclass>.playstr(smusic);
		}
		.setfilmfps;
		timfilm.play;
	}
	free	{
		imfilm.free;
		for( int i=0; i<grsfx.size; i++ )	{
			delete <grsfx.get(i)>;
		}
		for( i=0; i<grbuf.size; i++)
			delete <grbuf.get(i)>;
		grbuf.free;
		grsfx.free;
		.retfps;
	}
	showframe(int idframe)	{
		if( idframe < istartklatka ) idframe=istartklatka;
		else if (idframe > iendklatka ) idframe = iendklatka;
		iklatka = idframe;
		.loadframe;
	}
	showfirstframe	{	.showframe(istartklatka);	}
	showlastframe	{	.showframe(iendklatka);		}
	isplaying	{	timfilm.isplaying;	}
	stop(bool b)	{
		.retfps;
		if( b )	{
			iklatka=iendklatka;
		}
		timfilm.stop(b);
	}
	getimg	{	imfilm.getfullname;	}
}




// advpocket.dag
new snd _fx_pocket;
_fx_pocket.load("sounds/sfx/harfa.wav");

// buttons.dag
new snd sndfxmoveonms;
sndfxmoveonms.load("sounds/sfx/butmoveon.ogg");
sndfxmoveonms.setvol(30);

new snd sndfxmoveon2;
sndfxmoveon2.load("sounds/sfx/butmoveon2.ogg");
sndfxmoveon2.setvol(50);

new snd sndfxbutclick1;
sndfxbutclick1.load("sounds/sfx/butclick1.ogg");
sndfxbutclick1.setvol(50);


class GUI {
	init(string sgui, int ifontsize)	{
		.var2("sGui", sgui);
		if( sgui!=null && !<GAME>.hasvar(sgui))	{
			//<GAME>.varnew("Button",sgui);
			new Button <sgui>;
			<sgui>.addtogamevars(sgui);
			<sgui>.addmethod(sgui+"_lclick", func {
				grouter.eval("butouterclick");
				.<this+"_gui_lclick">;
				} );
		}
		new int istdwidth = 20->igetsc;
		new gmobjvec grouter;
		//LObjController::init;
		new Color wndcol;		wndcol.set(.grey(239),255);
		new Color wndconcave;		wndconcave.set(.grey(199),255);
		new Color wndact;		wndact.set(103,141,178,255);
		new Color wndtextcol;		wndtextcol.set(.white,255);
		
		new Color wndborder;		wndborder.set(.black,255);
		new Color wndborderL;		wndborderL.set(.white,255);	// wypukly
		
		new bool bround = false;
		
		new Color wndshadow;	wndshadow.set(.black,128);
		
		new Color wndbar;	wndbar.set(60, 132, 204, 255);
		new Color wndbarb;	wndbarb.set(32, 71, 110, 255);
		.vars2(A,"iwndshadow", 1, "swndshadow", "0110", "ititlebar", /*24->igetsc*/ (1.5*ifontsize)->to_i, "ibar", 4->igetsc1, "iytextlength", 2->igetsc1, "istdfont", ifontsize,
			 "iwndborder",1, "setstdfont", sgmfontfile, "setmonofont", sgmfontmono);
		
		new font stdfont;
		//stdfont.load(sgmfontfile,istdfont);
		stdfont.buildfullname;
		new font stdmonofont;
		//stdmonofont.load(sgmfontmono, istdfont);
		stdmonofont.buildfullname;
		new int monowidth;
		.setfontsize(ifontsize);
		
		new Color fontcol;	fontcol.set(.black,255);
		new font stitlefont;
		stitlefont.load(sgmfontbold,istdfont);
		new Color titlecol;	titlecol.set(.white,255);
		
		new img imgquit;
		imgquit.create(istdwidth, istdwidth, 93,152,211,255 );
		imgquit.imgroundborder(1,wndbarb.get);
		imgquit.hide;
		new img imgquitact;
		imgquitact.create(istdwidth, istdwidth, 143,202,251,255 );
		imgquitact.imgroundborder(1,.white,128);
		imgquitact.hide;
		new string squit = this+"quit";
		imgquit.addtogamevars(squit);
		imgquitact.addtogamevars(squit+"act");
		
		new img im3;
		im3.create(2,2,wndbarb.get);
		imgquit.drawX(1);
		imgquitact.drawX(1);
		im3.create(2,2,.white,255);
		imgquit.drawX(0);
		imgquitact.drawX(0);
		
		// build arrows
		.buildguibut("arrowleft", null, istdwidth, istdwidth, false);
		.buildguibut("arrowleftact", null, istdwidth, istdwidth, true);
		.buildguibut("arrowright", "imgarrowleft", 0, 0, 0);
		.buildguibut("arrowrightact", "imgarrowleftact", 0, 0, 0);
		.buildguibut("arrowup", null, istdwidth, istdwidth, false);
		.buildguibut("arrowupact", null, istdwidth, istdwidth, true);
		.buildguibut("arrowdown", "imgarrowleft", 0, 0, 0);
		.buildguibut("arrowdownact", "imgarrowleftact", 0, 0, 0);
		im3.create(1,1,.black,255);
		
		imgarrowleft.drawarrow("left");
		imgarrowleftact.drawarrow("left");
		imgarrowright.drawarrow("right");
		imgarrowrightact.drawarrow("right");
		imgarrowup.drawarrow("up");
		imgarrowupact.drawarrow("up");
		imgarrowdown.drawarrow("down");
		imgarrowdownact.drawarrow("down");
		
		new timer timbutclick;
		timbutclick.delay(100);
		timbutclick.settick(1);
		new string sButClick = null;
		timbutclick.addmethod("onfinish", func {
				if( sButClick!=null )	{
					@s = sButClick;
					sButClick = null;
					.<s+"_lclick">;
				}
			} );
		
		.reset;
	}
	isstdclicked	{	timbutclick.isplaying;	}
	calcmonowidth	{
		new text _txtpom;
		_txtpom.setfont("stdmonofont");
		_txtpom.txtset("a");
		monowidth = _txtpom.getw;
		delete _txtpom;
	}
	setfontsize(int isize)	{
		istdfont = isize;
		stdfont.load(setstdfont,istdfont);
		stdmonofont.load(setmonofont, istdfont);
		monowidth = isize;
	}
	drawarrow(string sdir)	{
		@x = .getcx;
		@y = .getcy;
		match(sdir)	{
			"left" => {
				_ = .imgdrawline("im3", x-2, y, x-1, y, 1, 0);
				_ = .imgdrawline("im3", x-1, y-1, x-1, y+1, 1, 0);
				_ = .imgdrawline("im3", x, y-2, x, y+2, 1, 0);
				_ = .imgdrawline("im3", x+1, y-3, x+1, y+3, 1, 0);
			} "right" => {
				_ = .imgdrawline("im3", x-1, y-3, x-1, y+3, 1, 0);
				_ = .imgdrawline("im3", x, y-2, x, y+2, 1, 0);
				_ = .imgdrawline("im3", x+1, y-1, x+1, y+1, 1, 0);
				_ = .imgdrawline("im3", x+1, y, x+2, y, 1, 0);
			} "up" => {
				_ = .imgdrawline("im3", x, y-2, x, y-1, 1, 0);
				_ = .imgdrawline("im3", x-1, y-1, x+1, y-1, 1, 0);
				_ = .imgdrawline("im3", x-2, y, x+2, y, 1, 0);
				_ = .imgdrawline("im3", x-3, y+1, x+3, y+1, 1, 0);
			} "down" => {
				_ = .imgdrawline("im3", x-3, y-2, x+3, y-2, 1, 0);
				_ = .imgdrawline("im3", x-2, y-1, x+2, y-1, 1, 0);
				_ = .imgdrawline("im3", x-1, y, x+1, y, 1, 0);
				_ = .imgdrawline("im3", x, y, x, y+1, 1, 0);
			}
			? => ;
		}
	}
	drawX(int dx)	{
		int dt = 4->igetsc;
		_ = .imgdrawline( "im3", .getpx+dt+dx, .getpy+dt+dx, .getex-dt-im3.getw+dx, .getey-dt-im3.geth+dx, 1, 0 );
		_ = .imgdrawline( "im3", .getex-dt-im3.getw+dx-1, .getpy+dt+dx, .getpx+dt+dx-1, .getey-dt-im3.geth+dx, 1, 0 );
	}
	buildguibut(string sname, string sfrom, int w, int h, bool bconcave)	{
		string s = "img" + sname;
		new img <s>;
		if( sfrom == null )	{
			if( bconcave ) 	{
				<s>.create(w, h, wndconcave.get );
				<s>.imgborderss(2, wndshadow.get, "1001");
				<s>.imgborderss(1, .black,255, "1001");
				<s>.imgborderss(1, .white,255, "0110");
			} else {
				<s>.create(w, h, wndcol.get );
				<s>.imgborderss(2, wndshadow.get, "0110");
				<s>.imgborderss(1, .black,255, "0110");
				<s>.imgborderss(1, .white,255, "1001");
			}
		} else <s>.clone(sfrom);
		<s>.hide;
		string s2 = "s" + sname;
		new string <s2>;
		<s2> = this+sname;
		<s>.addtogamevars( [s2] );
	}
	/************** sys ************************/
	addtogui	{
		if( sGui!=null )	{
			<sGui>.add(this);
		}
	}
	removefromgui	{
		if( sGui!=null )	{
			<sGui>.removebut(this);
		}
	}
	reset	{
		//advmouse.setstd;
	}
	dellist	{	.withlist("delobj");	}
	delobj(string sob)	{	.<"del"+ <sob>.guitype>(sob);	}
	/*********************************************/
	newwnd(string s, int w, int h)	{	._newwnd(s,w,h,"wndborder", "wndborder", "wndcol", iwndborder, swndshadow);	}
	newwndconvex(string s, int w, int h)	{	._newwnd(s,w,h,"wndborderL", "wndborder", "wndcol", iwndborder, swndshadow);	}
	newwndconcave(string swnd, int w, int h)	{	._newwnd(swnd,w,h,"wndborder", "wndborderL", "wndconcave", 2,"1001");	}
	newwndtext(string swnd, int w, int h)	{	._newwnd(swnd,w,h,"wndborder", "wndborderL", "wndtextcol", 2,"1001");	}
	_newwnd(string s, int w, int h, string swndsh0, string swndsh1, string swndcol, int iborder, string sshadow)	{
		new img <s>;
		<s>.addtogamevars(s);
		<s>.create(w,h,<swndcol>.get);
		<s>.var2("guitype","wnd");
		if( iborder )	{
			new img im1;
			im1.create(w,iborder,<swndsh0>.get);
			<s>.blit("im1");
			im1.create(w,iborder,<swndsh1>.get);
			im1.setpos(0, <s>.getey-iborder);
			<s>.blit("im1");
			im1.create(iborder,h,<swndsh0>.get);
			im1.setpos(0,0);
			<s>.blit("im1");
			im1.create(iborder,h,<swndsh1>.get);
			im1.setpos(<s>.getex-iborder,0);
			<s>.blit("im1");
			delete im1;
		}
		._mk_shadow(s, 0, iborder, iborder, w-2*iborder, iwndshadow, sshadow);
		._mk_shadow(s, 1, <s>.getex-iborder-iwndshadow, iborder, iwndshadow, h-2*iborder, sshadow);
		._mk_shadow(s, 2, iborder, <s>.getey-iborder-iwndshadow, w-2*iborder, iwndshadow, sshadow);
		._mk_shadow(s, 3, iborder, iborder, iwndshadow, h-2*iborder, sshadow);
	}
	_mk_shadow(string simg, int pos, int x, int y, int w, int h, string sshadow)	{
		bool b = sshadow.getb(pos,1);
		if( b && w && h )	{
			new img im1;
			im1.create(w, h, wndshadow.get);
			im1.setpos(x, y);
			<simg>.blit("im1");
			delete im1;
		}
	}
	newwndtitle(string s, string sico, string stitle, int w, int h)	{
		new img <s>;
		<s>.addtogamevars(s);
		<s>.var2("guitype","wnd");
		@w2 = 2*ibar+w;
		@h2 = ibar+ititlebar+h;
		<s>.create(w2, h2, wndcol.get);
		
		new img im1;
		im1.create(w2,ititlebar,wndbar.get);
		<s>.blit("im1");
		im1.create(w2,ibar,wndbar.get);
		im1.setpos(0,<s>.getey-ibar);
		<s>.blit("im1");
		im1.create(ibar,h2,wndbar.get);
		im1.setpos(0,0);
		<s>.blit("im1");
		im1.setpos(<s>.getex-ibar,0);
		<s>.blit("im1");
		
		<s>.putrgba(0,0,.transparent);
		<s>.putrgba(<s>.getex-1,0,.transparent);
		<s>.putrgba(<s>.getex-1,<s>.getey-1,.transparent);
		<s>.putrgba(0,<s>.getey-1,.transparent);
		
		im1.create(w2-2, 1, wndbarb.get);
		im1.setpos(1,0);
		<s>.blit("im1");
		im1.setpos(1,<s>.getey-1);
		<s>.blit("im1");
		im1.create(1,h2-2, wndbarb.get);
		im1.setpos(0,1);
		<s>.blit("im1");
		im1.setpos(<s>.getex-1,1);
		<s>.blit("im1");
		delete im1;
		
		if( sico!=null )	{
			<sico>.setpos(7->igetsc, 4->igetsc);
			<s>.blit(sico);
		}
		new text txt1;
		txt1.setfont("stitlefont");
		txt1.txtsetcol(stitle, wndbarb.rgb);
		int ypom = (ititlebar-istdfont)/2;
		if( ypom < 1 ) ypom = 1;
		txt1.setpos(33->igetsc,ypom);
		<s>.blit("txt1");
		//txt1.setpos(32,7);
		txt1.move(-1,-1);
		txt1.txtsetcol(stitle, titlecol.rgb);
		<s>.blit("txt1");
		delete txt1;
		
		<s> (squit) { (string s)
			new img imquit;
			imquit.copy(s);
			imquit.show;
			imquit.setpos(.getex-imquit.getw-5->igetsc, .getpx+3->igetsc);
			imquit.setz(.getz+1);
			new img imquitact;
			imquitact.copy(s+"act");
			imquitact.setpos( imquit.getpx, imquit.getpy );
			imquitact.setz(imquit.getz);
			imquitact.hide;
			.blit("imquit");	// zeby moc robic zoom in
		};
		<s>.stdlocker;
		<s>.addmethod("isbutin", func { (int x, int y)
			.unlocked && .isvisible && imquit.isin(x,y,0,0);
			} );
		<s>.addmethod("winmove", func { (int x, int y)
			.move(x,y);
			imquit.move(x,y);
			imquitact.move(x,y);
			} );
		<s>.addmethod("winshow", func {
			.show;
			imquit.show;
			imquitact.hide;
			} );
		<s>.addmethod("winhide", func {
			.hide;
			imquit.hide;
			imquitact.hide;
			} );
		.stdwinsetpos(s);
		<s>.addmethod("winsetz", func { (int z)	.setz(z); imquit.setz(z); imquitact.setz(z); <sGui>.sort; } );
		<s>.addmethod("butmoveon", func {
			if( .unlocked && .isvisible ) {
				imquit.hide;
				imquitact.show; 
			} 
			} );
		<s>.addmethod("butmoveoff", func {
			if( .unlocked && .isvisible ) {
				imquit.show;
				imquitact.hide; 
			}
			} );
		//<s>.addmethod("butclick", "stdclick");
		<s>.addmethod("butclick", func {
			if( .unlocked && sButClick==null )	{
				.<this+"_lclick">;
			}
			} );
		<s>.addtogui;
	}
	stdwinsetpos(string s)	{	<s>.addmethod("winsetpos", func { (int x, int y)	.winmove(x-.getpx, y-.getpy);	});	}
	stdwinmove(string s)	{	<s>.addmethod("winmove", func { (int x, int y) .move(x,y);	} );	}
	stdwinsetz(string s)	{	<s>.addmethod("winsetz", func { (int z) .setz(z); <sGui>.sort;	} );	}
	printcenter(string sob, string stekst)	{
		.getstdtext(stekst);
		txt1.txtcenter(sob);
		<sob>.blit("txt1");
		delete txt1;
	}
	print(string sob, int x, int y, string stekst)	{
		.getstdtext(stekst);
		txt1.setpos(<sob>.getpx+x, <sob>.getpy+y);
		<sob>.blit("txt1");
		delete txt1;
	}
	getstdtext(string stekst)	{
		new text txt1;
		txt1.setfont("stdfont");
		txt1.txtsetcol(stekst, fontcol.rgb);
	}
	/************************ buttons **************************************/
	stdlocker	{	classlocker::setaslocker(this);	.unlock;	}
	stdbutin(int x, int y)	{	.unlocked && .isin(x,y,1,0);	}
	stdclick	{
		if( .unlocked && sButClick==null)	{
			sButClick = this;
			timbutclick.play;
		}
	}
	stdmoveon	{	.<this+"_moveon">;	}
	stdmoveoff	{	.<this+"_moveoff">;	}
	newbutton(string sbut, string stxt, int w, int h)	{
		.newwndconvex(sbut, w, h);
		.getstdtext(stxt);
		txt1.txtset(stxt);
		txt1.txtcenter(sbut);
		<sbut>.blit("txt1");
		@s = sbut+"clicked";
		.newwndconcave(s, w, h);
		<s>.blit("txt1");
		<s>.hide;
		delete txt1;
		
		<sbut>.stdlocker;
		<sbut>.addmethod("isbutin", "stdbutin" );
		<sbut>.addmethod("butmoveon", "stdmoveon");
		<sbut>.addmethod("butmoveoff", "stdmoveoff");
		<sbut>.vars2(A,"butstate","std","guitype","button");
		<sbut>.addmethod("butclick", func {
			if( .unlocked && sButClick==null)	{
				if( butstate=="std") 	{
					sButClick = this;
					.hide;
					@s = sButClick+"clicked";
					<s>.setpos(.getpx, .getpy);
					<s>.setz(.getz);
					<s>.show;
					butstate="clicked";
					timbutclick.play;
				} else if (butstate=="clicked")	{
					butstate = "clickclicked";
					sButClick = this;
					timbutclick.play;
				}
			}
			} );
		<sbut>.addmethod("unclick", func { .show; <this+"clicked">.hide; butstate="std"; });
		<sbut>.addmethod("clicked", func { butstate=="clicked"; });
		<sbut>.addmethod("unclicked", func { butstate=="clickclicked"; });
		.stdwinsetz(sbut);
		<sbut>.addtogui;
	}
	delbutton(string sbut)	{
		<sbut>.removefromgui;
		<GAME>.vardel(sbut);
		<GAME>.vardel(sbut+"clicked");
		delete <sbut>;
		delete <sbut+"clicked">;
	}
	delwnd(string swnd)	{
		<swnd>.removefromgui;
		<GAME>.vardel(swnd);
		delete <swnd>;
	}
	newmenubut(string sbut, int w, int h, string stekst)	{
		new img <sbut>;
		<sbut>.create(w, h, wndcol.get);
		<sbut>.var2("slabel", stekst);
		
		@s = sbut + "act";
		new img <s>;
		.getstdtext(stekst);
		txt1.txtcenter(sbut);
		<sbut>.blit("txt1");
		<s>.create(w, h, wndact.get);
		<s>.blit("txt1");
		<s>.hide;
		delete txt1;
	}
	newsubmenu(string smenu, int wbut, int hbut, string svecname, string sdir)	{
		._newmenu(smenu,wbut,hbut,svecname,sdir);
		<smenu>.stdlocker;
		<smenu>.vars2(A,"active", null,"movedon",null, "idclicked", -1, "iwbut", wbut, "ihbut", hbut, 
			"dir", sdir, "idmoved", -1, "hideonouter",false);
		<smenu> (svecname) { (string svec)
			new vector vsubmenu;
			vsubmenu.type("string");
			vsubmenu.resize( <svec>.size, null );
		};
		<smenu>.addmethod("hidesubmenus", func {
			@s;
			for( int i=0; i<vsubmenu.size; i++) {
				s = vsubmenu.get(i);
				if( s!=null ) <s>.hide;
			}
			} );
		<smenu>.addmethod("viewsubmenu", func { (int id)
			@s = vsubmenu.get(id);
			if( s!=null )	{
				.hidesubmenus;
				//<s>.unlock;
				<s>.show;
				true;
			} else false;
			} );
		<smenu>.addmethod("isbutin", func { (int x, int y)
			if( .getlock ) return;
			@s = .get(0);
			.removeat(0);
			@b = .stdbutin(x,y);
			if( b )	{
				movedon = .getsfound;
				idmoved = .getfound;
				//if( movedon.gete(0,3)=="act" ) movedon=movedon.strsube(3);
				.activate( movedon );
			} else .deactivate;
			.addbegin(s);
			b;
			} );
		<smenu>.addmethod("deactivate", func {
			if( active!=null )	{
				//<active>.show;
				<active+"act">.hide;
				active=null;
			}
			} );
		<smenu>.addmethod("activate", func { (string s)
			if( s!=active )	{
				.deactivate;
				active = s;
				//<s>.hide;
				@s2 = s+"act";
				<s2>.show;
				<s2>.setpos( <s>.getpx, <s>.getpy );
				<s2>.setz(<s>.getz+1);
			}
			} );
		//<smenu>.addmethod("butmoveon", func { .activate(movedon); } );
		//<smenu>.addmethod("butmoveoff", func { if( .unlocked ) .deactivate; } );
		<smenu>.addmethod("butmoveon", "stdmoveon");
		<smenu>.addmethod("butmoveoff", "stdmoveoff");
		<smenu>.addmethod("butclick", func {
			if( movedon!=null )
				idclicked=idmoved;
			if( !.viewsubmenu(idclicked) )
				.stdclick;
			} );
		grouter.add(smenu);
		<smenu>.addmethod("butouterclick", func {
			.deactivate;
			if( hideonouter ) .hide;
			} );
		<smenu>.addtogui;
	}
	_newmenu(string smenu, int wbut, int hbut, string svecname, string sdir)	{
		new gmimgvec <smenu>;
		<smenu>.addtogamevars(smenu);
		int x = iwndborder+iwndshadow;
		int y = x;
		@s = smenu+"bkg";
		int ile = <svecname>.size;
		if( sdir == "horizontal" )
			.newwnd(s, ile*wbut+2*x, hbut+2*y);
		else .newwnd(s, wbut+2*x, ile*hbut+2*y);
		<smenu>.add(s);
		for( int i=0; i<ile; i++)	{
			s = smenu+"_"+i;
			.newmenubut(s, wbut, hbut, <svecname>.get(i));
			<s>.setpos(x, y);
			<smenu>.add(s);
			//<smenu>.add(s+"act");
			if( sdir=="horizontal" )	x+=wbut;
			else y+=hbut;
		}
	}
	addsubmenu(string smainmenu, int id, string smenu, string svecname)	{
		@sdir = <smainmenu>.dir=="horizontal" ? "vertical" : "horizontal";
		@w = <smainmenu>.iwbut;
		@h = <smainmenu>.ihbut;
		.newsubmenu(smenu, w, h, svecname, sdir);
		<smainmenu> (smenu, id) { (@smenu, @id)
			vsubmenu.set(id, smenu);
		};
		<smenu>.hideonouter = (true);
		if( sdir == "horizontal" )	<smenu>.move( <smainmenu>.getpx+id, <smainmenu>.getpy+id*h );
		else <smenu>.move( <smainmenu>.getpx+id*w, <smainmenu>.getpy+h );
		<smenu>.setz( <smainmenu>.getz );
		<smenu>.hide;
	}
	newtextline(string sbox, string schars, int w, int h)	{
		@swnd = sbox+"wnd";
		@dw = iwndborder+iwndshadow;
		.newwndtext(swnd, w+2*dw, h+2*dw);
		new ConTextTyper <sbox>(stdmonofont.getfullname, istdfont, fontcol.rgb, schars, w/monowidth-1);
		<sbox>.move( monowidth/2, (<swnd>.geth-istdfont)/2 );
		<sbox>.addtogamevars(sbox);
		<sbox>.addmethod("winsetz", func { (int z) .setz(z); <this+"wnd">.setz(z); <sGui>.sort; } );
		<sbox>.addmethod("winmove", func { (int x, int y) .move(x,y); <this+"wnd">.move(x,y); } );
		.stdwinsetpos(sbox);
		<sbox>.var2("guitype","textbox");
		<sbox>.addmethod("winhide", func { .hide; <this+"wnd">.hide; } );
		<sbox>.addmethod("winshow", func { .show; <this+"wnd">.show; } );
		<sbox>.unlock;
	}
	newtextbox(string sbox, string schars, int w, int h)	{
		@swnd = sbox+"wnd";
		@dw = iwndborder+iwndshadow;
		.newwndtext(swnd, w+2*dw, h+2*dw);
		
		new TextBoxTyper <sbox>( stdmonofont.getfullname, istdfont, monowidth, fontcol.rgb, schars, dw+1, dw+1, w, h, iytextlength );
		<sbox>.insystem = (true);
		<sbox>.addtogamevars(sbox);
		<sbox>.addmethod("winsetz", func { (int z) .setz(z); <this+"wnd">.setz(z); <sGui>.sort; } );
		<sbox>.addmethod("winmove", func { (int x, int y) .move(x,y); <this+"wnd">.move(x,y); } );
		.stdwinsetpos(sbox);
		<sbox>.var2("guitype","textbox");
		<sbox>.addmethod("winhide", func { .hide; <this+"wnd">.hide; } );
		<sbox>.addmethod("winshow", func { .show; <this+"wnd">.show; } );
		<sbox>.unlock;
	}
	deltextline(string stxtline)	{	.deltextbox(stxtline);	}
	deltextbox(string sbox)	{
		<GAME>.deletegmobj(sbox);
		delete <sbox>;
		.delwnd(sbox+"wnd");
	}
	newsqltable(string stab, string sdb, string stxtdir)	{
		if( <sdb>.getrowsno==0 || <sdb>.getcolsno(0)==0 ) return;
		new AlgImg alg1;
// 		public textbox(string sdest, int x, int y, string stxt, string stext, int ilimit, int fontsize, int dy, string stxtdir);
// 		public def counttextrows(string stext, int ilimit)	{
		int h;
		int i[3];
		new vector vh;
		new vector vw;
		int cols = <sdb>.getcolsno(0);
		int rows = <sdb>.getrowsno;
		int dy = 2;
		int brzeg = (iwndshadow+iwndborder)*2;
		for( i0=0; i0<cols; i0++)	{
			vw.add( 0.6*istdfont * <sdb>.get(0,i0) + brzeg );
		}
		for( int i=1; i<rows; i++)	{
			h = 0;
			for( i0=0; i0<cols; i0++)	{
				i1 = alg1.counttextrows( <sdb>.get(i, i0), <sdb>.get(0,i0) );
				if( h<i1 ) h = i1;
			}
			vh.add(h*istdfont + (h-1)*dy + brzeg );
		}
		.newwnd(stab, vw.vecsum + brzeg, vh.vecsum + brzeg);
		int xstart = iwndborder + iwndshadow;
		int x = xstart;
		int y = xstart;
		new text txt1;
		txt1.setfont("stdfont");
		txt1.createtxt(.black);
		for( i0=0; i0<cols; i0++)	{
			alg1.textbox(stab, x, y, "txt1", <sdb>.get(1,i0), <sdb>.get(0,i0), istdfont, 0.6*istdfont, dy, stxtdir);
			x+=vw.get(i0);
		}
		y += vh.get(0);
		string s = stab + "tab";
		for( i=2; i<rows; i++)	{
			h = vh.get(i-1);
			x = xstart;
			for( i0=0; i0<cols; i0++)	{
				.newwndtext( s, vw.get(i0), h );
				alg1.textbox( s, 2, 2, "txt1", <sdb>.get(i,i0), <sdb>.get(0,i0), istdfont, 0.6*istdfont, dy, stxtdir);
				<s>.setpos( x, y );
				<stab>.blit(s);
				.delobj(s);
				x+=vw.get(i0);
			}
			y += vh.get(i-1);
		}
		delete txt1;
		delete vh;
		delete vw;
		delete alg1;
		
		.stdwinsetz(stab);
		.stdwinmove(stab);
		.stdwinsetpos(stab);
	}
	getbrzeg	{	iwndshadow + iwndborder;	}
	newrewinder(string srew, int x, int y, real w, real h, string swnd)	{
		string sbg = srew + "bg";
		int brzeg = .getbrzeg;
		bool bw = w!=0 && w < <swnd>.getw;
		bool bh = h!=0 && h < <swnd>.geth;
		if( !bw ) w = <swnd>.getw;
		if( !bh ) h = <swnd>.geth;
		.newwnd(sbg, w, h);
		
		new img <srew>;
		<srew>.addtogamevars(srew);
		<srew>.vars2(A,"guitype","rewinder", "srewinded", swnd,"bisw",bw,"bish",bh, "imover", 10);
		string s[2];
		if( bw )	{
			string sreww = srew+"w";
			.newwndconcave(sreww, w, istdwidth);
			<sreww>.move(0, h);
			
			real w2 = <swnd>.getw;
			<srew>.var2("rwmover", w2/w);
			if( <srew>.rwmover<1 ) <srew>.rwmover = (1);
			real w3 = (w/w2)*(w - 40.0);
			if( w3 > w2 ) w3 = w2;
			else if (w3<1) w3 = 1+brzeg;
			s0 = srew + "tmpsuw";
			.newwndconvex(s0, w3, <sreww>.geth);
			<s0>.move(0, h);
		} else s0=null;
		if( bh )	{
			string srewh = srew+"h";
			.newwndconcave(srewh, istdwidth, h);
			<srewh>.move(w,0);
			
			real h2 = <swnd>.geth;
			<srew>.var2("rhmover", h2/h);
			if( <srew>.rhmover<1 ) <srew>.rhmover = (1);
			real h3 = (h/h2)*(h - 40.0);
			if( h3 > h2 ) h3 = h2;
			else if (h3<1) h3 = 1+brzeg;
			s1 = srew + "tmpsuwh";
			.newwndconvex(s1, <srewh>.getw, h3);
			<s1>.move(w, 0);
		} else s1=null;
		<srew> (s0, s1) { (string ssuw, string suwh)
			new gmimgvec grels;
			grels.add(this+"bg");
			string s;
			.vars2(A,"bsuwakx", false, "bsuwaky", false, "suwakx",0,"suwaky",0,"ssuwed",null);
			if( bisw )	{
				s = this + "w";
				.var2("reww",s);
				grels.add(s);
				new img imgleft;
				imgleft.copy(sarrowleft);
				imgleft.show;
				imgleft.setpos( <s>.getpx, <s>.getpy );
				grels.add("imgleft");
				new img imgleftact;
				imgleftact.copy(sarrowleftact);
				imgleftact.hide;
				imgleftact.setpos( imgleft.getpx, imgleft.getpy);
				grels.add("imgleftact");
				new img imgright;
				imgright.copy(sarrowright);
				imgright.show;
				grels.add("imgright");
				imgright.setpos( <s>.getex-imgright.getw, <s>.getpy );
				new img imgrightact;
				imgrightact.copy(sarrowrightact);
				imgrightact.hide;
				imgrightact.setpos( imgright.getpx, imgright.getpy );
				grels.add("imgrightact");
				new img imgsuwak;
				imgsuwak.clone(ssuw);
				imgsuwak.setpos(imgleft.getex, imgleft.getpy);
				grels.add("imgsuwak");
				new real wsuw = imgright.getpx - imgleft.getex;
			}
			if( bish )	{
				s = this + "h";
				.var2("rewh",s);
				grels.add(s);
				new img imgup;
				imgup.copy(sarrowup);
				imgup.show;
				imgup.setpos( <s>.getpx, <s>.getpy );
				grels.add("imgup");
				new img imgupact;
				imgupact.copy(sarrowupact);
				imgupact.setpos( imgup.getpx, imgup.getpy );
				imgupact.hide;
				grels.add("imgupact");
				new img imgdown;
				imgdown.copy(sarrowdown);
				imgdown.show;
				grels.add("imgdown");
				imgdown.setpos( imgup.getpx, <s>.getey-imgdown.geth );
				new img imgdownact;
				imgdownact.copy(sarrowdownact);
				imgdownact.hide;
				imgdownact.setpos( imgdown.getpx, imgdown.getpy );
				grels.add("imgdownact");
				
				new img imgsuwaky;
				imgsuwaky.clone(suwh);
				imgsuwaky.setpos(imgup.getpx, imgup.getpy);
				grels.add("imgsuwaky");
				new real hsuw = imgdown.getpy - imgup.getey;
			}
		};
		if( s0!=null ) .delwnd(s0);
		if( s1!=null ) .delwnd(s1);
		
		.cycle = (srew+"tim", func {
			<this->strsubes("tim")>.winrewind;
			.play;
			} );
		<srew>.stdlocker;
		<srew>.addmethod("isbutin", func { (int x, int y)
			.unlocked && grels.isin(x,y,1,0);
			} );
		<srew>.addmethod("winmove", func { (int x, int y)
			.move(x,y);
			grels.move(x,y);
			@s = this+"bg";
			/*<srewinded>.clip( (bisw ? <reww>.getpx+.getbrzeg : 0), (bish ? <rewh>.getpy+.getbrzeg : 0),
				(bisw ? <reww>.getex-.getbrzeg : iResX), (bish ? <rewh>.getey-.getbrzeg : iResY) );*/
			<srewinded>.clip(<s>.getpx+.getbrzeg, <s>.getpy+.getbrzeg, <s>.getex-.getbrzeg, <s>.getey-.getbrzeg);
			} );
		.stdwinsetpos(srew);
		<srew>.addmethod("winmoveall", func { (int x, int y)
			if( <srewinded>.hasaddedmet("winmove") )	<srewinded>.winmove(x,y);
			else <srewinded>.move(x,y);
			.winmove(x,y);
			} );
		<srew>.addmethod("winsetallpos", func { (int x, int y) .winmoveall(x-.getpx, y-.getpy); } );
		<srew>.winmove( x, y );
		<srew>.addmethod("winsetz", func { (int z)	.setz(z); grels.setz(z); <sGui>.sort; } );
		<srew>.addmethod("setactsuw", func { (string s)
			ssuwed = s;
			<s>.hide;	<s+"act">.show;
			<this+"tim">.play;
			} );
		<srew>.addmethod("butclick", func {
			match( grels.getsfound )	{
				"imgleft" =>		.setactsuw("imgleft");
				"imgright" =>	.setactsuw("imgright");
				"imgsuwak" => {	bsuwakx = true; suwakx = mouse.getposx-imgsuwak.getpx;	}
				"imgup" => 		.setactsuw("imgup");
				"imgdown" => 	.setactsuw("imgdown");
				"imgsuwaky" => {	bsuwaky = true; suwaky = mouse.getposy-imgsuwaky.getpy;	}
				? => ;
			}
			} );
		<srew>.addmethod("butlrel", func {
			<this+"tim">.stop(false);
			if( ssuwed!=null )	{
				<ssuwed+"act">.hide;
				<ssuwed>.show;
				ssuwed = null;
			}
			bsuwakx = false;
			bsuwaky = false;
			} );
		<srew>.addmethod("winrewind", func {
			if( bisw )	{
				if( imgleftact.isvisible )	{
					<srewinded>.move(imover,0);
				} else if (imgrightact.isvisible )	{
					<srewinded>.move(-imover,0);
				}
			}
			if ( bish )	{
				if( imgupact.isvisible )	{
					<srewinded>.move(0,imover);
				} else if (imgdownact.isvisible )	{
					<srewinded>.move(0, -imover);
				}
			}
			.stabilizerew;
			.setrewinded;
			} );
		<srew>.addmethod("rewind", func { (int dx, int dy)
			if( bisw )	<srewinded>.move(dx,0);
			if( bish )	<srewinded>.move(0,dy);
			.stabilizerew;
			.setrewinded;
			} );
		<srew>.addmethod("stabilizerew", func {
			if( bisw )	{
				if( <srewinded>.getpx > <reww>.getpx+.getbrzeg ) <srewinded>.setpos( <reww>.getpx + .getbrzeg, <srewinded>.getpy );
				else if (<srewinded>.getex < <reww>.getex-.getbrzeg ) <srewinded>.move( <reww>.getex-.getbrzeg-<srewinded>.getex, 0);
			}
			if( bish )	{
				if( <srewinded>.getpy > <rewh>.getpy+.getbrzeg ) <srewinded>.setpos( <srewinded>.getpx, <rewh>.getpy + .getbrzeg );
				else if (<srewinded>.getey < <rewh>.getey-.getbrzeg ) <srewinded>.move( 0, <rewh>.getey-.getbrzeg-<srewinded>.getey);
			}
			} );
		<srew>.addmethod("butmoving", func {
			if( bsuwakx )	{
				real x = imgsuwak.getpx;
				imgsuwak.setpos( mouse.getposx-suwakx, imgsuwak.getpy );
				<srewinded>.move( rwmover*(x-imgsuwak.getpx), 0 );
				.stabilizerew;
				.setrewinded;
			} else if (bsuwaky)	{
				real y = imgsuwaky.getpy;
				imgsuwaky.setpos( imgsuwaky.getpx, mouse.getposy-suwaky );
				<srewinded>.move( 0, rhmover*(y-imgsuwaky.getpy) );
				.stabilizerew;
				.setrewinded;
			}
			} );
		<srew>.addmethod("setrewinded", func {
			if( bisw )	{
				real dx = (<reww>.getpx-<srewinded>.getpx)->to_r/<srewinded>.getw->to_r;
				//real dx = (imgleft.getex-<srewinded>.getpx)->to_r/(imgright.getpx-imgleft.getex)->to_r;
				imgsuwak.setpos( imgleft.getex+dx*wsuw, imgsuwak.getpy );
				dx = imgright.getpx - imgsuwak.getex;
				if( dx<0 ) imgsuwak.move(dx, 0);
			}
			if( bish )	{
				real dy = (<rewh>.getpy-<srewinded>.getpy)->to_r/<srewinded>.geth->to_r;
				//real dx = (imgleft.getex-<srewinded>.getpx)->to_r/(imgright.getpx-imgleft.getex)->to_r;
				imgsuwaky.setpos( imgsuwaky.getpx, imgup.getey+dy*hsuw );
				dy = imgdown.getpy - imgsuwaky.getey;
				if( dy<0 ) imgsuwaky.move(0, dy);
			}
			} );
		<srew>.setrewinded;
		<srew>.addtogui;
	}
	delrewinder(string srew)	{
		if( <srew>.bisw )	.delobj(srew+"w");
		if( <srew>.bish )	.delobj(srew+"h");
		<srew>.removefromgui;
		<GAME>.deletegmobj(srew);
		<GAME>.deletegmobj(srew+"bg");
		delete <srew>;
		delete <srew+"bg">;
		delete <srew+"tim">;
	}
	newcheckbox(string sbox)	{
		.newwndtext(sbox,15,15);
		<sbox> {
			new img imcheck;
			imcheck.create(15,15,.transparent);
			new img im1;
			im1.create(2,2,.black,255);
			_ = imcheck.imgdrawline("im1", 4, 7, 6, 9, 1, 0);
			_ = imcheck.imgdrawline("im1", 6, 9, 10, 5, 1, 0);
			delete im1;
			imcheck.hide;
		};
		<sbox>.stdlocker;
		<sbox>.addmethod("butclick", func {
			if( .getlock ) return;
			.checked ? .uncheck : .check;
			} );
		<sbox>.addmethod("check", func { imcheck.show;	} );
		<sbox>.addmethod("uncheck", func { imcheck.hide;	} );
		<sbox>.addmethod("checked", func { imcheck.isvisible;	} );
		<sbox>.addmethod("winmove", func { (int x, int y)
			.move(x,y);
			imcheck.move(x,y);
			} );
		.stdwinsetpos(sbox);
		<sbox>.addmethod("winsetz", func { (int z) .setz(z); imcheck.setz(z); } );
		<sbox>.addmethod("isbutin", "stdbutin");
		<sbox>.addtogui;
	}
	/*******************************************/
	/*load(string sfile)	{
		new db dbl;
		dbl.loadbeh( .getpath(sfile) );
		int i[3], string s[3];
		for( int i=0; i < dbl.getrowsno; i++)	{
			
		}
		delete dbl;
	}*/
}

class classmoddbg : classlocker	{
	init()	{
		classlocker::init();
		
		new string sstate = "init";
		new int ilastx;
		new int ilasty;
		new text txtpos;
		txtpos.setz(5000);
		txtpos.setpos( 0, 0 );
		txtpos.setbkg(0,0,64,16, 0,0,0,192);
		
		new text txtmsg;
		
		txtmsg.setz(5000);
		txtmsg.setpos(220+igmoffsetx,10);
		txtmsg.setbkg(0,0,500,16, 0,0,0,192);
		txtmsg.hide;
		new timer timmsg;
		timmsg.setdelay(4000);
		timmsg.addmethod("onfinish", func { txtmsg.hide; } );

		new text txtpod;
		txtpod.setz(5000);
		txtpod.setbkg(0,0,128,16, 0,0,0,192);
		
		new img impod;
		new string slastimpod = null;
		
		this.disable();

	}
	public enable()	{
		this.unlock();
		txtpos.show();
		txtpod.show();
	}
	public disable()	{
		this.lock();
		txtpos.hide();
		txtpod.hide();
		impod.hide;
	}
	public updatetxtpos(int x, int y)	{
		if( engine.varexist("clcamera") )
			txtpos.set("" + ( x-clcamera.getposx() ) + "," + ( y-clcamera.getposy() ));
		else txtpos.set("" + x + "," + y);
		txtpos.setpos(x-txtpos.getw-advmouse.lodx,y-txtpos.geth-advmouse.lody);
		txtpod.setpos(x-txtpod.getw-advmouse.lodx,y-2*txtpod.geth-advmouse.lody);
		string s = engine.getimg(x,y,true,true,-2000,2000);
		txtpod.set( s );
		if( s==null || s=="imgbkg" ) impod.hide;
		else if( engine.varexist(s))	{
			if( s!=slastimpod || (s==slastimpod && !impod.isvisible) || <s>.getw != impod.getw || <s>.geth != impod.geth )	{
				impod.create( <s>.getw, <s>.geth, 255,255,0,64 );
				impod.show;
				impod.setz(2010);
				slastimpod = s;
			}
			impod.setpos( <s>.getpx, <s>.getpy );
		}
		y = txtpos.getey - iResY;
		if( y>0 )	{	txtpos.move(0,-y); txtpod.move(0,-y);	}
		x = txtpod.getex - iResX;
		if( x>0 )	{	txtpos.move(-x,0); txtpod.move(-x,0);	}
		x = -txtpod.getpx;
		if( x>0 )	{	txtpos.move(x,0); txtpod.move(x,0);	}
	}
	msminit(int x, int y)	{	this.updatetxtpos(x,y);	}
	msmmove(int x, int y)	{
		if( engine.varexist("clcamera") )
			clcamera.moveplans(x-ilastx, y-ilasty);
		this.updatetxtpos(x,y);
	}
	public msmove()	{
		if( this.getlock() )	{	return;	}
		int x = mouse.getpx();
		int y = mouse.getpy();
		this.<"msm"+sstate>(x,y);
		ilastx=x;
		ilasty=y;
	}
	public mslclick()	{
		if( this.getlock() )	{	return;	}
		if( keyboard.iskeydown("space") )	{
			sstate="move";
		}
	}
	public mslrel()	{
		if( this.getlock() )	{	return;	}
		sstate = "init";
	}
	msrclick()	{
		int x = mouse.getpx();
		int y = mouse.getpy();
		int id = grbuts.isin(x,y,true,true);
		if( id!=false )	{
			string s = grbuts.get(id-1);
			s.print();
		} 
//		txtpod.set( engine.getimg(x,y,true,true,-1000,1000));
	}
	msg(string s)	{
		txtmsg.show;
		txtmsg.set(s);
		txtmsg.setpos(igmoffsetx+100,10);
		timmsg.play;
	}
	dbkeydown(){
		if( !igmdebug ) return;
		if( keyboard.iskeydown("lctrl") ) {
			if( keyboard.iskey("l") )	{
				@s = "cache";
				if( keyboard.iskeydown("1") ) s+="1";
				else if (keyboard.iskeydown("2") ) s+="2";
				else if (keyboard.iskeydown("3") ) s+="3";
				else if (keyboard.iskeydown("4") ) s+="4";
				else if (keyboard.iskeydown("5") ) s+="5";
				else if (keyboard.iskeydown("6") ) s+="6";
				else if (keyboard.iskeydown("7") ) s+="7";
				else if (keyboard.iskeydown("8") ) s+="8";
				else if (keyboard.iskeydown("9") ) s+="9";
				._load_game(s);
				.msg("game loaded from "+s);
			} else if( keyboard.iskey("s") )	{
				@s = "cache";
				if( .can_save )	{
					if( keyboard.iskeydown("1") ) s+="1";
					else if (keyboard.iskeydown("2") ) s+="2";
					else if (keyboard.iskeydown("3") ) s+="3";
					else if (keyboard.iskeydown("4") ) s+="4";
					else if (keyboard.iskeydown("5") ) s+="5";
					else if (keyboard.iskeydown("6") ) s+="6";
					else if (keyboard.iskeydown("7") ) s+="7";
					else if (keyboard.iskeydown("8") ) s+="8";
					else if (keyboard.iskeydown("9") ) s+="9";
					._save_game(s);
					.msg("game saved to "+s);
				} else {
					.msg("could not save game to "+s+" , sgmstate=" + sgmstate);
				}
			} else if( keyboard.iskey("b") )	{
				<gameapi.getgamename>.cgetscreenshoot("saves/cache.bmp", 1);
				.msg("screenshoot in saves/cache.bmp");
			} else if( keyboard.iskey("p") )	{
				.dprint("debugger: ");
			}
		}
		if( keyboard.iskey("d") )	{
			if(.getlock)	{
				this.enable();
				.msg("debug mode on: ^c-b: screenshoot, ^c-s: save, ^c-l: load, d: debug on/off");
			} else {
				this.disable();
				.msg("debug mode off");
			}
		}
	}
}

new classmoddbg moddbg;
/************ template game Painter **************/
class TPainter {
	init()	{}
	tinit(string sndbase, string spath, string sfilebg, string sfilebrush, string sfile, string sfarby, @dir, string ssavefile)	{
		if( sndbase!=null )
			GameController::init(sndbase);
		this.unlock();
		if( spath!=null )
			this.setgraphpath(spath);
		
		if( sfilebg!=null )
			this.newanima("anbkg",sfilebg,0);
			
		new int paintmode = 0;
		
		this.newanima("anbrush1", sfilebrush, 3000);
		this.copyanima("anbrush1","anbrush2");
		anbrush2.setframe(0,1);
		anbrush2.setz(anbrush1.getz-1);
		anima_pack::resizemethods("anbrush1");		// galka
		anima_pack::resizemethods("anbrush2");		// pedzel
		int x, int y;
		match( dir )	{
			"ru" => { x = anbrush2.getex;
				y = anbrush2.getpy; }
			"rd" => { x = anbrush2.getex;
				y = anbrush2.getey; }
			"ld" => { x = anbrush2.getpx;
				y = anbrush2.getey; }
			? => { x = anbrush2.getpx;
				y = anbrush2.getpy; }
		}
		anbrush1.saverelpos(x, y);	// lewy dolny rog - kursor myszy
		anbrush2.saverelpos(x, y);	// lewy dolny rog - kursor myszy
		mouse.hide();
		
		this.newanima("anfg", sfile, 100);
		anfg.setframe("foreground",0);
		
		new gmimgvec grdraw;
		_ = this.newanframesgr("anfg", "andraw", anfg.actionnr("draw"), "grdraw");
		grdraw.setz(10);
		
		if( sfarby.contains(".pyz") )	{
			new gmimgvec grpaleta;
			"grpaleta" ..< sfarby;
			grpaleta.setz(20);
		} else if( sfarby != "grpaleta" ) {
			<sfarby>.addtogamevars("grpaleta");
		}
		
		new int _ibrx = anbrush2.getpx();
		new int _ibry = anbrush2.getpy();
		while( !anbrush2.isin(_ibrx, _ibry, false, true) )	{
			_ibrx++;
			if( _ibrx==anbrush2.getex() ) {
				_ibrx = anbrush2.getpx();
				_ibry++;
			}
		}
		_ibrx-=anbrush2.getpx();
		_ibry-=anbrush2.getpy();
		TPainter::tp_mouse_move;		// ustawienie pedzla w pozycji myszy
		
		if( ssavefile!=null )	{
			new string savefile = ssavefile;
			new db dbkolory;
// 			if( engine.fileexist(s) )	{
			if( .saveexist(ssavefile) )	{
				dbkolory.vecload(ssavefile);
				grdraw.each( func { (@id)
					.paint( dbkolory.get(id,0), dbkolory.get(id,1), dbkolory.get(id,2), 255, paintmode);
					} );
			} else {
				grdraw.each( func { (@id)
					.paint(.white,255,paintmode);
					dbkolory.dbaddstringrow("255 255 255"," ");
					} );
				.tp_savekols;
			}
		}
	}
	game_exit()	{
		mouse.show();
		GameController::game_exit();
	}
	tp_exit	{
		mouse.show;
	}
	tp_mouse_move()	{
		anbrush1.mssetrelpos();
		anbrush2.mssetrelpos();
	}
	tp_mouse_lclick()	{
		if( !this.getlock() )	{
			|int x, int y| = mouse.getpos();
			if( grdraw.isin(x,y,true,true) )	{
				<grdraw.getsfound()>.paint( anbrush2.getrgba(anbrush2.getpx()+_ibrx,anbrush2.getpy()+_ibry), paintmode );
				.onpaint;
			} else if ( grpaleta.isin(x,y,false,true) )	{
				|@c[4]| = <grpaleta.getsfound()>.getrgba(x,y);
				c3 = 255;
				anbrush2.paint( c0, c1, c2, c3, paintmode );
				.onsetbrush;
			}
		}
	}
	tp_savekols	{
		if( !<GAME>.hasvar("dbkolory") ) return;
		grdraw.each( func { (@id)
			int c[4];
			//|c0, c1| = .anfirstnontr;
			int ex = .getex , int ey = .getey;
			int x = .getpx, int y=.getpy;
			while( x!=ex && y!=ey )	{
				if( .isin(x,y,false,true) ) { c0=x; c1=y; x=ex; }
				else x++;
			}
			|c0,c1,c2,_| = .getrgba(c0,c1);
			dbkolory.set(id,0,c0);
			dbkolory.set(id,1,c1);
			dbkolory.set(id,2,c2);
			} );
		dbkolory.vecsave( savefile );
	}
	tp_default_erase	{	.tp_erase(.white,255);	}
	tp_erase(int r, int g, int b, int a)	{
		for( int i=0; i< grdraw.size; i++)	{
			<grdraw.get(i)>.paint(r,g,b,a,paintmode);
			dbkolory.set(i,0,255);
			dbkolory.set(i,1,255);
			dbkolory.set(i,2,255);
		}
		.tp_savekols;
	}
}

class TPainterCon : TPainter, GameController	{
	init	{}
}
new int iMemoTryb=1;	// 0 - player na czas, 1 - player vs computer, 2 - player vs player
new int iMemoW;
new int iMemoH;
new int iMemoAI = 0;	// poziom trudnosci

class TMemo 	{
	init()	{}
	public tinit(string sbkg, string stafle, string snakl, int dt)	{
		
		if( sbkg.gete(0,3)=="pyz") .newanima("anbkg", sbkg, 0);
		else .newimg("anbkg", sbkg, 0);
		
		.newanima("antaf", stafle, 20);
		.newanima("annak", snakl, 20);
		
		new int ipredkosc = 50;
		new gmimgvec grtaf;
		new gmimgvec grnak;
		new vector vecaction;
		new vector vecframe;
		new vector vecid;
		int id = 0;
		for( int i=0; i<antaf.nofactions; i++ )	{
			for( int j=0; j<antaf.nofframes(i); j++ )	{
				vecaction.add(i);
				vecframe.add(j);
				vecid.add(id);
				id++;
			}
		}
		vecid.hash;
		string s, int i[3], int j;
		i0 = 0;
		for( int i=0; i<iMemoW; i++)	{
			for( j=0; j<iMemoH; j++)	{
				new anima <"antaf"+i0>(i0) {
					(int i)
					.copy("antaf");
					int id = vecid.get(i/2);
					.setframe( vecaction.get(id), vecframe.get(id) );
					.anaddfilter;
					.unlink;
					grtaf.add( this );
				};
				new anima <"annak"+i0> (i0) { (int i)
					.copy("annak");
					.anaddfilter;
					.unlink;
					grnak.add(this);
				};
				i0++;
			}
		}
		antaf.hide;
		annak.hide;
		grtaf.hash;
		i0=0;
		i1 = antaf.getw + dt;
		i2 = antaf.geth + dt;
		for( i=0; i<iMemoW; i++)	{
			for( j=0; j<iMemoH; j++)	{
				s = grtaf.get(i0);
				<s>.ansetbpos( i1*i, i2*j );
				<s>.ansetbpos( i1*i, i2*j );
				<s>.vars2(A, "col", i, "row", j);
				<s>.setz(10 + 2*i0-1);
				<grnak.get(i0)>.setz(10+2*i0);
				i0++;
			}
		}
		grtaf.eval("link");
		grnak.eval("link");
		i1 = (igmappw-grtaf.getw())/2;
		i2 = (igmapph-grtaf.geth())/2;
		grtaf.move( i1, i2 );
		grnak.move( i1, i2 );
		new int iplayer=1;
		new int icompplayer = 0;	// 1v2
		new classfadeinout clfio;
		new classfadeinout clfio2;
		new int imemostate=0;
		new string staf1;
		new string staf2;
		new string snak1;
		new string snak2;
		new int ileai = .between(1, .between(5, iMemoW*iMemoH*0.2, 10) + iMemoAI, 20);
		int limit = (iMemoW*iMemoH)/2;
		if( ileai > limit ) ileai = limit;
		new string sset1;
		new string sset2;
		new vector vecai	{
			.mresize;
			.type("string");
		};
		new int iaistate = 0;
		.newtimer("timwait", 500, 1);
		timwait.mresize;
		.cnewtimerfin("timpoka", 500, 1, "endset22");
	}
	tm_start()	{
		imemostate = 1;
		if( iMemoTryb==1 )	{
			icompplayer=2;
		}
	}
	/******************************************************/
	aigo()	{
		imemostate=11;
		.tclicks( sset1 );
	}
	aigo2()	{
		.tclicks( sset2 );
	}
	int aifind1(string sob, int i,  int ile)	{
		if( sob==null )	return -1;
		int iac = <sob>.actionnr(-1);
		int ifr = <sob>.framenr;
		string s;
		for (; i<ile; i++)	{
			s = .get(i);
			if( s!=null && s!=sob && iac==<s>.actionnr(-1) && ifr==<s>.framenr && .tstats(i))	return i;
		}
		-1;
	}
	bool tstats(int id)	{	.stats(100-id*10);	}
	startai(string sfun)	{
		if( iplayer==icompplayer )	{
			int ile = .min(vecai.size, ileai);
			if( sfun=="aigo" )	{
				imemostate = 11;
				int i[3];
				i2 = -1;
				for(i0=0; i0<ile; i0++)	{
					i2 = vecai.aifind1( vecai.get(i0), i0+1, ile );
					if( i2>=0 && .tstats(i0))	{
						i1 = i0;
						i0 = ile;
					} else
						i2=-1;
				}
				if( i2>=0 )	{		// znalazl pare
					sset1 = vecai.get(i1);
					sset2 = vecai.get(i2);
				} else {
					sset1 = grtaf.rand;
					sset2 = null;
				}
			} else {
				if( sset2 == null )	{
					int id = vecai.aifind1( sset1, 0, ile );
					if (id>=0 && .tstats(id))	sset2 = vecai.get(id);
					else 	sset2 = grtaf.randdiff( sset1 );
				}
			}
			"timwait" ..< sfun;
			timwait.play;
		}
	}
	/******************************************************/
	endset3()	{
		imemostate=1;
		if( iMemoTryb>0 )	{
			.tnextplayer;
			.startai("aigo");
		}
	}
	endset2	{	timpoka.play;	}
	endset22	{
		imemostate=3;
		<snak2>.hide;
		if( <staf1>.actionnr(-1) == <staf2>.actionnr(-1) && <staf1>.framenr == <staf2>.framenr )	{
			_ = "grnak" .- snak1 .- snak2;
			_ = "grtaf" .- staf1 .- staf2;
			vecai.set( vecai.find( staf1 ), null );
			vecai.set( vecai.find( staf2 ), null );
			if( grtaf.empty )	{
				imemostate = 5;
				clfio.setopacity(1, -ipredkosc, staf1, null );
				clfio2.setopacity(1, -ipredkosc, staf2, null );
				.tfinish;
			} else {
				clfio.setopacity(1, -ipredkosc, staf1, func {
						<staf1>.hide;	<staf2>.hide;
						if( iplayer!=icompplayer) imemostate=1;
						.startai("aigo");
					});
				clfio2.setopacity(1, -ipredkosc, staf2, null );
				.tpoint;
			}
		} else {
			<snak1>.show;
			<snak2>.show;
			clfio.setopacity(1, ipredkosc, snak1, "endset3");
			clfio2.setopacity(1, ipredkosc, snak2, null );
			.terror;
		}
	}
	tclicks(string sob)	{	.tclick(<sob>.getcx, <sob>.getcy);	}
	tclick(int x, int y)	{
		if( grnak.isin( x, y, true, true ) )	string s = grnak.getsfound;
		else return;
		.tchoose;
		//engine.setdebugstate(true);
		if( imemostate==1 || imemostate==11 ) {
			imemostate--;
			snak1 = s;
			staf1 = grtaf.getimg(<s>.getcx, <s>.getcy, true, true );
			vecai.vecset( staf1, null );
			vecai.addbegin( staf1 );
			vecai.veclimes(30);
			clfio.setopacity(1, -ipredkosc, s, func {
				<snak1>.hide;
				imemostate+=2;
				.startai("aigo2");
				});
		} else if (imemostate==2 || imemostate==12)	{
			imemostate-=2;
			snak2 = s;
			staf2 = grtaf.getimg(<s>.getcx, <s>.getcy, true, true );
			vecai.vecset(staf2,null);
			vecai.addbegin( staf2 );
			vecai.veclimes(30);
			clfio.setopacity(1, -ipredkosc, s, "endset2");
		}
	}
	tnextplayer	{	iplayer = iplayer==1 ? 2 : 1;	}
	tfitinsurf(int x, int y, int idx, int idy)	{
		grtaf.eval("unlink");
		grnak.eval("unlink");
		@w = x/iMemoW;
		@h = y/iMemoH;
		@dw = <grtaf.first>.getw;
		@dh = <grtaf.first>.geth;
		@dy = h - dh;
		@dx = w - dw;
		@i0 = 0;
		
		for( int i=0; i< iMemoW; i++)	{
			for( int j=0; j<iMemoH; j++)	{
				@s = grtaf.get(i0);
				<s>.ansetbpos(w*i, h*j);
				if( dx<0 && i%2 ) <s>.move(0, dy/2);
				<grnak.get(i0)>.ansetbpos( <s>.getpx, <s>.getpy );
				i0++;
			}
		}
		x = (igmappw-grnak.getex)/2;
		y = (igmapph-grnak.getey)/2;
		grnak.move( x+idx, y+idy );
		grtaf.move( x+idx, y+idy );
		grtaf.eval("link");
		grnak.eval("link");
	}
	/*********************/
	tm_mouselclick	{
		if( imemostate.in(A,1,2))	.tclick( mouse.getpos );
	}
	virtual tfinish	{}
	virtual tpoint		{}
	virtual terror		{}
	virtual tchoose	{}
}

new string sAskerGame;
new int idymekdelay = 300;
new bool bHorizon = .readcfg("bHorizon:",true);

class StdGame : classadv, Localize	{
	init(string s)	{
		AdventureGame = false;
		classadv::init(s);
		Localize::init;
		.path = (s);
		
		advmouse.setstd;
		
		if( PrzygodaMode )	{
			.advsaveonstart;
			.advsave_game;
		}
	}
	//-------------- adv -------------------------------
	loadasker	{
		if( bHorizon )
			._loadasker("$scripts/common/asker.pyz");
		else
			._loadasker("$scripts/common/asker_pion.pyz");
	}
	_loadasker(string sfile)	{	._loadasker2(sfile,"anasker");	}
	_loadasker2(string sfile, string san)	{
		.newanima(san+"bg", sfile, 1990);
		<san+"bg">.hide;
		.copyanima(san+"bg", san+"yes");
		<san+"yes">.setframe("yes",0);
		.copyanima(san+"bg", san+"no");
		<san+"no">.setframe("no",0);
		<san+"yes">.Button_std;
		<san+"yes">.addmethod("butclick", func {
			.<"preclick_"+this>;
			if( sgmstate=="state_askexit" )	{
				if( sAskerGame!=null ) {
					if( sAskerGame=="exit" ) {
						sgmstate = "state_exitgame";
						ccs.benableloading=(false);
						.closexit;
					} else {
						.stdexit(sAskerGame);
					}
				} else .Button_butclick;
			}
			} );
		<san+"no">.Button_std;
		<san+"no">.addmethod("butclick", func {
			.<"preclick_"+this>;
			if( sgmstate=="state_askexit" )	{
				if( <GAME>.hasmet("butclick_"+this) )
					@sfun = "Button_butclick";
				else @sfun = "advsetstdstate";
				@san = this->strsube(2);
				<san+"bg">.anzoomout(idymekdelay,null);
				<san+"yes">.anzoomout(idymekdelay,null);
				<san+"no">.anzoomout(idymekdelay,sfun);
			}
			} );
		butgame.add(san+"yes");
		butgame.add(san+"no");
	}
	closexit	{
		ccs.buildblack;
		ccs.close( func { gameapi.exit; } );
	}
	showasker	{	._showasker("anasker");	}
	_showasker(string san)	{
		sgmstate = "state_askexitstart";
		<san+"bg">.anzoomin(idymekdelay, func { sgmstate = "state_askexit"; .<"asker_"+this->strsubes("bg")+"_shown">; } );
		<san+"yes">.anzoomin(idymekdelay,null);
		<san+"no">.anzoomin(idymekdelay,null);
	}
	askfor(string s)      {
		sAskerGame=s;
		.showasker;
	}
	skipenter	{	clsave.bset("GAME_skipenter");	}
	stdenter	{
		if( clsave.bis("GAME_skipenter") )	{
			clsave.bunset("GAME_skipenter");
			.refreshstdstate;
		} else
			ccs.enter( "refreshstdstate" );
	}
	refreshstdstate	{
		.advsetstdstate;
		butgame.refresh;
	}
	timfinito	{
		if( !<GAME>.hasvar("_timfinito") )	{
			<GAME>.timer = ("_timfinito", 1000, func {
				if( .advstdstate ) .mend;
				} );
		}
		_timfinito.play;
	}
	//--------------------- buttons ------------------------
	Button_stdoff	{
		.addmethod("butmoveoff", func {
			if( .advstdstate )
				advmouse.setstd;
			} );
	}
	buildfadebut(bool balpha)	{
		@s = this + "_copy";
		<GAME>.copyanima(this, s);
		<s>.setframe(-1,1);
		<s>.hide;
		if( balpha ) .Button_isinalpha;
		else .Button_isin;
		.var2("sanbutcopy", s);
		.addmethod("butmoveon", func {
			if( .advstdstate )	{
				advmouse.setact;
				<sanbutcopy>.anfadein(300, null );
			}
			.Button_butmoveon;
			} );
		.addmethod("butmoveoff", func {
			advmouse.setstd;
			if( <sanbutcopy>.isvisible )
				<sanbutcopy>.anfadeout(300, "hide");
			.Button_butmoveoff;
			} );
		.Button_stdclick;
		butgame.add(this);
	}
	//-------------- helpful -------------------------------
	crect(int wleft, int hup, int wright, int hdown)	{
		new Rect rec( igmoffsetx+wleft.igetsc, igmoffsety+hup.igetsc, igmoffsetx+iResX-wright.igetsc, igmoffsety+iResY-hdown.igetsc);
	}
	mkchmura(string san, real rdx)	{
		@s = "canmov"+san;
		new AnMover <s>( san, rdx, 0);
		<s>.enableroll;
		<s>.play;
	}
	mkfxset(string sfx, int ile, int vol)	{
		for( int i=0; i<ile; i++ )	{
			@s = "fx" + sfx + i;
			.newsfx(s, sfx);
			<s>.setvol(vol);
		}
		new int <"_icnt" + sfx> = 0;
		new int <"_ilecnt" + sfx> = ile;
	}
	fxsetplay(string s)	{
		string scnt = "_icnt" + s;
		<"fx"+s+[scnt]>.play;
		<scnt> = ( [scnt]+1 )% ["_ilecnt" + s];
	}
	newtxtbut(string sbut, string stext)	{
		new img <sbut>;
		.newfont("_fntbutpom", sgmfontfile, 14->igetsc);
		//public imgborders(int w, int r, int g, int b, int a)
		.newtext("_txtbutpom", stext, "_fntbutpom", .grey(16));
		<sbut>.create( 1.2*_txtbutpom.getw, 1.2*_txtbutpom.geth, .grey(192), 255 );
		@sbut2 = sbut + "_clicked";
		new img <sbut2>;
		<sbut2>.imgclone(sbut);
		<sbut>.imgborderss(2, .white, 128,"1001");
		<sbut>.imgborderss(2, .black, 128,"0110");
		<sbut2>.imgborderss(2, .black, 128,"1001");
		<sbut2>.imgborderss(2, .white, 128,"0110");
		_txtbutpom.txtcenter(sbut);
		<sbut>.blit("_txtbutpom");
		<sbut>.Button_isin;
		<sbut>.addmethod("butlrel", func {
			butgame.sclicked = (null);
			if( !<this+"_timer">.isplaying )
				<this+"_clicked">.hide;
			} );
		<sbut>.addmethod("butclick", func {
			@stim = this+"_timer";
			if( !<stim>.isplaying )	{
				<stim>.play;
				@sbut2 = this+"_clicked";
				<sbut2>.setpos(.getpx,.getpy);
				<sbut2>.show;
				<sbut2>.setz(.getz);
				.Button_butclick;
			}
			} );
		_txtbutpom.move(1,1);
		<sbut2>.blit("_txtbutpom");
		<sbut2>.hide;
		@stim = sbut + "_timer";
		.timer=(stim,250, func {
			if( butgame.sclicked != sbutton )
				<sbutton2>.hide;
			});
		<stim>.vars2(A, "sbutton",sbut, "sbutton2", sbut2);
		butgame.add(sbut);
		delete _txtbutpom;
		delete _fntbutpom;
	}
	//-------------- sys -------------------------------
	key_down	{
		if( igmdebug && keyboard.iskeydown("lctrl") && keyboard.iskey("r") )	.crestart;
	}
}



new classgamepause clpause;


class classplacepointer2 : classplacepointer    {
	init()  {
		classplacepointer::init();
		this.load("scripts/common/strzalka.pyz");
	}
}

gameapi.play("MainLoader");
game MainLoader : StdGame       {
	init    {
		StdGame::init("mainloader");
		
		//_fxtakeitem.load( .getsndpath + "getitem" );
		
		// ADV
		if( engine.varexist("modadv") )	{
			modadv.load("scripts/scripts/defaults.adv");
			modadv.loadsounds("scripts/scripts/sounds.db");
			modadv.settalktype("snd");
			modadv.loadscript("scripts/scripts/initscript.dsc");
		}
		clsave.load("global.txt");
		sgmlastscene = this;
		
		gameapi.play( dbconf.dbget("startgame:") );
	}
}


new bool bMusic = true;
new string sgmpuzpref = sgmproject.to_l;
new string sgmtype = sgmproject.strgetto("_");
new string sgmname = sgmproject.strgetfrom("_");

new bool bPlayMusic = true;

if( igmandroid )
	ccs.delay(30);

new int igmmusicvol = 100;
new string sgmmainmusic;

new string sMenuButOk = "MenuTrybPuzzle";
new string sMenuButExit = "OutroStd";
new string sMenuImgPref = "mg_puzzle/imgs/p_puz";
new real rMenuZoom = 516.0/736.0;
new string sIntroGame = "IntroStd";
new string sIntroStdGame = null;
new string sMenuImgStd = "MenuImgStd";
new string sPuzBajImgPref = "";
new string sMainMenuMemo = "OutroStd";
new string sMemoSize = "lms";
bHorizon = true;

ccs.benableloading=(true);

match( sgmproject )	{
	"Kololo_Nela1" => {
		sgmmainmusic = "nela1";
		igmmusicvol = 50;
		bHorizon = false;
		
		sMenuButOk = "KoloPion";
		sMenuImgPref = "menu_wybor/imgsmenu/kol";
	}
	"AnimalPuzCol_Asia1" => {
		sIntroGame = "IntroAsia1";
	}
	"Puzzle_Nelapuz" => {
		sgmmainmusic = "nela1";
		igmmusicvol = 50;
	}
	"Artist_Nelaart" => {
		sgmmainmusic = "nela1";
		igmmusicvol = 50;
		igmenablesave = false;
		
		sMenuButOk = "ColoKolo";
		sMenuImgPref = "kolo/imgscol/colcol_";
		rMenuZoom = 516.0/912.0;
	}
	"Artist_VehArt" => {
		sgmmainmusic = "vehicles";
		igmmusicvol = 50;
		igmenablesave = false;
		
		sMenuButOk = "ColoKolo";
		sMenuImgPref = "kolo/imgscol/colcol_";
		rMenuZoom = 516.0/912.0;
	}
	"Puzzle_CartoonPuz" => {
		sgmmainmusic = "cartoon";
		igmmusicvol = 50;
	}
	"Artist_Nelaart2", "Artist_Nelaart3" => {
		igmenablesave = false;
		
		sMenuButOk = "ColoKolo";
		sMenuImgPref = "kolo/imgscol/colcol_";
		rMenuZoom = 516.0/912.0;
	}
	"Puzzle_ForestPuz" => {
		sgmmainmusic = "bgrlas1";
		igmmusicvol = 50;
		
		ccs.loadloading("scripts/" + sgmpuzpref + "/common/loading.png");
	}
	"Puzzle_MountPuz", "Puzzle_FlowersPuz" => {
		ccs.loadloading("scripts/" + sgmpuzpref + "/common/loading.png");
	}
	"Arcade_NelaShip" => {
		sIntroGame = "IntroNelaShip";
		sgmmainmusic = "bgrspace";
		igmmusicvol = 20;
	}
	"Bajka_Baj3Swinki", "Bajka_BajCalineczka", "Bajka_Baj7Kozlakow" => {
		ccs.benableloading=(false);
		sIntroGame = "IntroBaj3Swinki";
		sgmmainmusic = "bgrlas1";
		igmmusicvol = 30;
	}
	"Arcade_NelaZoo" => {
		sIntroGame = "IntroNelaZoo";
	}
	"App_CarIns" => {
		ccs.benableloading=(false);
	}
	"Arcade_NelaSnow" => {
		sMenuImgStd = "MainMenuNelaSnow";
		sgmmainmusic = "cartoon";
		igmmusicvol = 40;
	}
	/*"Puzzle_KapturekPuz", "Puzzle_3SwinkiPuz", "Puzzle_HalloweenPuz", "Puzzle_NelaSafariPuz",
	"Puzzle_CarnivalPuz", "Puzzle_NelaFarmPuz", "Puzzle_GrecjaPuz", "Puzzle_XmasPuz" => {
	}*/
	"Puzzle_7KozlakowPuz" => {
		sMenuImgPref = "mg_puzzle/imgs/koz";
	}
	"Moda_NelaBal", "Moda_NelaPiknik", "Moda_NelaPlac", "Moda_NelaTurystka" => {
		sMenuImgStd = "MainMenuModa";
	}
	"PuzBaj_CatMouse" => {
		sIntroStdGame = "MainMenuPuzBaj";
	}
	"Memo_Animals" => {
		sIntroStdGame = "MainMenuMemo";
	}
	"PuzBaj_Kroliki" => {
		sIntroStdGame = "MenuPuzBaj";
		sMenuImgPref = "mg_puzzle/imgs/";
		ccs.loadloading("scripts/" + sgmpuzpref + "/common/loading.png");
	}
	? => ;
}

public playmainmusic	{
	music.smixer = ("engine");
	if( sgmmainmusic != null )
		music.playstr( sgmmainmusic + " -l -v " + igmmusicvol );
}

new int iImgId = 1;
new int iIleImgs = .readcfg("iIleImgs"+sgmproject+":",iImgId);

SNDPATH = "sounds/" + LANG + "/" + sgmpuzpref + "/";

class MermaidStd : StdGame	{
	init(string s)	{
		StdGame::init(s);
		.setpath2(s);
	}
	cfontpath	{	"configs/fonts/seren1.ttf";	}
	newsfx(string sname, string sfile)	{
		if( sfile.contains(".") )	{
			sfile = sfile.strgetto(".");
		}
		string s2 = SFXPATH + sgmpuzpref + "/";
		if( engine.fileexist(s2 + sfile+".wav") ) ._newsnd(sname,s2+sfile+".wav",false);
		else if( engine.fileexist(s2 + sfile+".ogg") ) ._newsnd(sname,s2+sfile+".ogg",false);
		else ._newsnd(sname, SFXPATH + sfile, false);	
	}
	issfx(string s)	{	engine.fileexist(SFXPATH+sgmpuzpref+"/"+s+".ogg") || engine.fileexist(SFXPATH+sgmpuzpref+"/"+s+".wav") || engine.fileexist(SFXPATH+s+".ogg") || engine.fileexist(SFXPATH+s+".wav"); }
	setpath2(string s)	{	.path = (sgmpuzpref + "/" + s);	}
	getgamepath	{	"scripts/" + sgmpuzpref + "/";	}
	int calcfiles(string spath, string spref, string styp)	{
		int ile = 0;
		while( engine.fileexist( spath + spref + (ile+1) + styp ) )	{
			ile++;
		}
		ile;
	}
	int calcgmfiles(string spref, string styp)	{	.calcfiles(.getpath(""),spref,styp);	}
	cwideversion	{	true;	}
	getcommon(string s)	{
		@s2 = .getgamepath + "common/" + s;
		engine.fileexist(s2) ? s2 : "scripts/common/"+ s;
	}
	getcommon2(string s)	{	"$" + .getcommon(s);	}
	loadasker	{
		if( bHorizon )
			._loadasker(.getcommon2("asker.pyz"));
		else
			._loadasker(.getcommon2("asker_pion.pyz"));
	}
	cbutexit	{
		if( !bHorizon )	{
			.newanima("anbutexit", .getcommon2("butexit_pion.pyz"), 300);
			anbutexit.ansetbpos( .getxoffset + 5->igetsc, igmapph - 2*anbutexit.geth );
		} else {
			.newanima("anbutexit", .getcommon2("butexit.pyz"), 300);
			if( igmandroid )	{
				anbutexit.ansetbpos( .getxoffset + 5->igetsc, igmoffsety );
			} else
				anbutexit.ansetbpos( igmoffsetx + iResX - 20->igetsc - anbutexit.getw, igmoffsety );
		}
		anbutexit.Button_addstdstate;
	}
	cbutexitoverlay	{
		.cbutexit;
		.cblinkbutexit;
	}
	cblinkbutexit	{
		if( !igmandroid )
			anbutexit.imgbuildoverlay(.yellow,64,1200);
	}
	cbuthelp	{
		.newanima("anbuthelp", .getcommon2("help.pyz"), 300);
		//anbuthelp.ansetbpos( igmoffsetx +iResX - anbuthelp.getw - 20->igetsc, igmoffsety );
		if( igmandroid )
			anbuthelp.ansetbpos( anbutexit.getex + 5->igetsc, igmoffsety );
		else
			anbuthelp.ansetbpos( anbutexit.getpx - anbuthelp.getw - 5->igetsc, igmoffsety );
		anbuthelp.Button_addstdstate;
	}
	cbutmusicif	{	if( sgmmainmusic != null ) .cbutmuz;	}
	cbutmusic	{	.cbutmuz;	}
	cbutmuz		{
		@s = "anbutexit";
		if( engine.varexist("anbuthelp") ) s = "anbuthelp";
		
		if( !bHorizon )	{
			.newanima("anbutmuz", .getcommon2("butmuz_pion.pyz"), 300);
			anbutmuz.ansetbpos( .getxoffset+5->igetsc, <s>.getpy - 5->igetsc - anbutmuz.geth );
		} else {
			.newanima("anbutmuz", .getcommon2("butmuz.pyz"), 300);
			if( igmandroid )
				anbutmuz.ansetbpos( <s>.getex + 5->igetsc, igmoffsety );
			else
				anbutmuz.ansetbpos( <s>.getpx - anbutmuz.getw - 5->igetsc, igmoffsety );
		}
		anbutmuz.Button_addstdstate;
		anbutmuz.setframe( bMusic ? "on" : "off", 0 );
	}
	butclick_anbutmuz	{
		if( bMusic )	{
			bMusic = false;
			music.fadeout(500);
			anbutmuz.setframe("off",0);
		} else {
			bMusic = true;
			anbutmuz.setframe("on",0);
			.butmuz_playmusic;
		}
	}
	butmuz_playmusic	{	.playmainmusic;	}
	cloadboki(int z)	{
		.newanima("an1366bokl", "$scripts/common/boki.pyz", z);
		.copyanima("an1366bokl", "an1366bokr");
		an1366bokr.setframe(1,0);
	}
	caddymek	{
		<GAME>.copyanima(this, this+"2");
		for( int i=0; i < .nofactions-2; i++ )	{
			@saniko = this+"iko"+i;
			<GAME>.copyanima(this, saniko);
			<saniko>.hide;
			<saniko>.setz( .getz + 1 );
			<saniko>.setframe(i+2,0);
			.var2("saniko"+i, saniko);
		}
		.vars2(A, "ilesaniko", i, "sancopy", this + "2");
		<sancopy>.hide;
		.addmethod("isbutin", func { (int x, int y)
			<sancopy>.isin(x,y,0,0);
			} );
		.addmethod("butmoveon", func {
			if( .advstdstate )	{
				advmouse.setact;
				.play(1);
				for( int i=0; i<ilesaniko; i++ )	{
					< ["saniko"+i] >.anzoomin((10.0+i)/10.0*idymekdelay,null);
				}
				.Button_butmoveon;
			}
			} );
		.addmethod("butmoveoff", func {
			if( .advstdstate )	{
				advmouse.setstd;
				.play(0);
				for( int i=0; i<ilesaniko; i++ )	{
					< ["saniko"+i] >.anzoomout((10.0+i)/10.0*idymekdelay,null);
				}
			}
			} );
		.addmethod("butclick", func {
			if( .advstdstate )
				.Button_butclick;
			} );
		butgame.add(this);
		.play(0);
	}
	cbuildbzyczek(string san)	{	<GAME>.cbzyczek(san, <san>.getpx, <san>.getpy);	}
	cplaybzyczek(string san)	{	.cbuildbzyczek(san); <san>.play(-1);	}
	anplaybzyczek	{	.cplaybzyczek(this);	}
	cbzyczek(string san, int xstart, int ystart)	{
		<san>.ansetbpos( xstart, ystart );
		@s = "ftbzyk"+san;
		new filter <s>;
		<s>.link(san);
		<san>.var2("iliczbzyk",0);
		<san>.addmethod("onendframe", func {
			iliczbzyk++;
			if( iliczbzyk==1 )	{
				@s = "ftbzyk"+this;
				iliczbzyk=0;
				real kat = 12-21->rand;
				real dt = 5;
				real kat2 = <s>.getangle;
				real x = kat2->sin * dt;
				real y = kat2->cos * dt;
				<s>.rotate(kat);
				.move(-x,-y);
			}
			} );
	}
	cloadrecord(string sfile, string sname)	{
		new classfullsave csave(sfile);
		csave.stdload;
		csave.saveonset=(true);
		new bool bisrekord = false;
		if( csave.has(sname) )	{
			bisrekord = csave.get(sname);
			new string sprintrecord = clstrdigit::gettime(bisrekord, "ms");
		}
		new int ifontrecordsize = 40->igetsc;
		.newfont("fntsecrecord", .cfontpath, ifontrecordsize);
		new int icurtime = 0;
		.newtext("txtime", "", "fntsecrecord", .red);
		txtime.setz(100);
		.cprintcurtime(icurtime);
		.timer = ("timsecrecord", 1000, func {
			.csettime(1);
			.play;
			} );
	}
	cprintcurtime(int itime)	{
		if( bisrekord )
			txtime.txtset("Record: " + sprintrecord + " , " + clstrdigit::gettime(itime, "ms"));
		else
			txtime.txtset(clstrdigit::gettime(itime, "ms"));
	}
	csettime(int id)	{
		icurtime+=id;
		.cprintcurtime(icurtime);
	}
}




game MenuImgStd : MermaidStd	{
	init	{
		MermaidStd::init("menu_wybor");
		
		.imgs = (A, "wyborbg.jpg", "butok.pyz 30", "butnext.pyz 30", "butprev.pyz 30", "cien.pyz 10");
		
		if( bHorizon )
			.newanima("ancyfry", .getcommon2("cyfry.pyz"), 30);
		else
			.newanima("ancyfry", .getcommon2("cyfry_pion.pyz"), 30);
		
		.cbutexit;
		.loadasker;
		.cbutmusicif;
		
		new classfullsave csave("menuimgstd.db");
		csave.saveonset=(true);
		csave.stdload;
		iImgId = csave.get(sgmproject);
		if( iImgId<1 ) iImgId=1;
		
		if( igmandroid && bHorizon )	{
			int dx = 17->igetsc;
			int dy = 83->igetsc;
			ancien.move(dx, dy);
			anbutnext.move(dx, dy);
			anbutprev.move(dx, dy);
			anbutok.move(dx, dy);
		}
		
		new gmimgvec grnr;
		int ile = .mputnumber(null,iIleImgs);
		
		if( bHorizon )	{
			int w = 1.1 * ancyfry.getw;
			for( int i=0; i<ile; i++ )	{
				@s = "anilepuz"+i;
				.copyanima("ancyfry", s);
				<s>.setpos( anbutok.getpx - w*(i+1), ancien.getey + 10->igetsc );
				s = "annr"+i;
				.copyanima("ancyfry", s);
				<s>.setpos( anbutok.getpx - w*(i+ile+2), ancien.getey + 10->igetsc );
				<s>.hide;
				grnr.add(s);
			}
			_ = .mputnumber("anilepuz", iIleImgs);
			ancyfry.setframe(1,0);
			ancyfry.setpos( anbutok.getpx - w*(ile+1), ancien.getey + 10->igetsc );
		} else {
			int h = 1.1 * ancyfry.geth;
			@x = anbutok.getpx;
			@y = ancien.getpy;
			for( int i=0; i<ile; i++ )	{
				@s = "anilepuz"+i;
				.copyanima("ancyfry", s);
				<s>.setpos( x, y + h*(i+1) );
				s = "annr"+i;
				.copyanima("ancyfry", s);
				<s>.setpos( x, y + h*(i+ile+2) );
				<s>.hide;
				grnr.add(s);
			}
			_ = .mputnumber("anilepuz", iIleImgs);
			ancyfry.setframe(1,0);
			ancyfry.setpos( x, y + h*(ile+1) );
		}
		
		new img imgpic1;
		new img imgpic2;
		new string spic1 = "imgpic1";
		new string spic2 = "imgpic2";
		<spic1>.mload;
		.mustawnr;
		new int ispeed;
		
		if( bHorizon )	{
			.cycle=("timrew", func {
				<spic1>.move( 0, ispeed );
				<spic2>.move( 0, ispeed );
				@dy = <spic2>.getpy;
				if( (ispeed<0 && dy<0 ) || (ispeed>0 && dy>0) )	{
					<spic1>.hide;
					<spic2>.mustaw;
					@s = spic1;
					spic1 = spic2;
					spic2 = s;
					.advsetstdstate;
					ancien.show;
					.mustawnr;
				} else .play;
			} );
		} else {
			.cycle=("timrew", func {
				<spic1>.move( ispeed, 0 );
				<spic2>.move( ispeed, 0 );
				@dx = <spic2>.getpx - ancien.getpx;
				if( (ispeed<0 && dx<0 ) || (ispeed>0 && dx>0) )	{
					<spic1>.hide;
					<spic2>.mustaw;
					@s = spic1;
					spic1 = spic2;
					spic2 = s;
					.advsetstdstate;
					ancien.show;
					.mustawnr;
				} else .play;
				} );
		}
		
		anbutnext.Button_addstdstate;
		anbutprev.Button_addstdstate;
		
		anbutok.Button_addstdstate;
		
		.stdenter;
	}
	butclick_anbutnext	{	<GAME>.mnext(1);	}
	butclick_anbutprev	{	<GAME>.mnext(-1);	}
	butclick_anbutok	{	.stdexit(sMenuButOk);	}
	mustaw	{	.ansetcpos( ancien.getcx-1, ancien.getcy-1 );	}
	mload	{
		.load( "scripts/" + sgmpuzpref + "/" + sMenuImgPref + iImgId + ".jpg" );
		if( rMenuZoom != 1.0 )
			.anzoom( rMenuZoom );
		.setz( 20 );
		.anclipob("ancien");
		.show;
		.mustaw;
	}
	mnext(int id)	{
		iImgId += id;
		if( iImgId < 1 ) iImgId = iIleImgs;
		else if ( iImgId > iIleImgs ) iImgId = 1;
		csave.set(sgmproject, iImgId);
		<spic2>.mload;
		if( bHorizon )	{
			ispeed = 0.4*<spic1>.geth;
			int dy = 5;
			if( id>0 ) {
				ispeed = -ispeed;
				<spic2>.move( 0, <spic1>.geth + dy );
			} else {
				<spic2>.move( 0, - <spic2>.geth - dy );
			}
		} else {
			ispeed = 0.15*<spic1>.getw;
			int dx = 5;
			if( id>0 ) {
				ispeed = -ispeed;
				<spic2>.move( <spic1>.getw, 0 );
			} else {
				<spic2>.move( -<spic2>.getw, 0 );
			}
		}
		sgmstate = "state_rewind";
		//ancien.hide;
		timrew.play;
	}
	int mputnumber(string spref, int number)	{
		int id = 0;
		while( number>0 )	{
			if( spref!=null )	{
				@s = spref + id;
				<s>.setframe( 0, number%10 );
				<s>.show;
			}
			number = number/10;
			id++;
		}
		id;
	}
	mustawnr	{
		grnr.hide;
		_ = .mputnumber("annr", iImgId);
	}
	butclick_anbutexit	{
		if( sMenuButExit=="OutroStd" )
			.askfor(sMenuButExit);
		else .stdexit(sMenuButExit);
	}
}

game Intro {
	init	{
		gameapi.play(sIntroGame);
	}
}

game IntroStd : MermaidStd	{
	init	{
		MermaidStd::init("intro");
		.img = ("introbg.jpg");
		.playmainmusic;
		
		if( sIntroStdGame==null )
			sIntroStdGame = sMenuImgStd;
		
		new int iileppuz = 1;
		if( .mispuz(iileppuz) )	{
			new img imgzaslona;
			imgzaslona.create( igmappw, igmapph, .black, 128 );
			imgzaslona.hide;
			
			.newimg("imgtekst", .getcommon2("puzzlecollect.png"), 20);
			imgtekst.hide;
			imgtekst.setpos( (igmappw-imgtekst.getw)/2, 0 );
			
			new img imgpuzad;
		}
		
		ccs.enter(func {
			if( <GAME>.hasvar("imgtekst") )	{
				.timplay("timend", 1500, func {
					imgtekst.show;
					imgzaslona.show;
					if( .mispuz(iileppuz) )	{
						.setdelay(2000);
						.mloadpuz;
						iileppuz++;
						.play;
						if( !imgtekst.isvisible )	{
							imgtekst.show;
							
						}
					} else
						.mend;
					} );
			} else
				.timplay("timend", 3000, "mend");
			} );
	}
	mloadpuz	{
		imgpuzad.load( .getpath(.mgetpuz(iileppuz)) );
		imgpuzad.setpos( (igmappw-imgpuzad.getw)/2, imgtekst.getey );
	}
	mispuz(int id)	{
		engine.fileexist(.getpath(.mgetpuz(id) ) );
	}
	mgetpuz(int id)	{
		"p_puz"+id+".jpg";
	}
	mend	{
		timend.stop(false);
		.stdexit(sIntroStdGame);	
	}
	mouse_lclick	{	.mend;	}
}

game OutroStd : MermaidStd	{
	init	{
		MermaidStd::init("outro");
		.img = ("bgoutro.jpg");
		
		ccs.enter(func {
			.timplay("timend", 5000, "mend");
			} );
	}
	mend	{
		.stdexit("exit");
	}
	mouse_lclick	{	.mend;	}
}


new int idBgKol = 1;

game KoloPion : MermaidStd	{
	init	{
		MermaidStd::init("kolo");
		
		.sfxs=(A,"pedzel", "pedzel2");
		
		new int paintmode = 0;
		
		.imgs = (A, "kolobg.jpg", "obwodka.pyz 25", "butleft.pyz 120", "butright.pyz 120");
		
		.cbutexit;
		.loadasker;
		.cbutmusic;
		anbutleft.Button_addstdstate;
		anbutright.Button_addstdstate;
		
		this.newanima("anfg", "imgs/kol"+iImgId+".pyz", 100);
		anfg.setframe("foreground",0);
		
		new gmimgvec grdraw;
		_ = this.newanframesgr("anfg", "andraw", anfg.actionnr("draw"), "grdraw");
		grdraw.setz(10);
		
		new gmimgvec grpaleta;
		"grpaleta" ..< "farby.pyz";
		grpaleta.setz(20);
		
		new int iCol0;
		new int iCol1;
		new int iCol2;
		new int iactcol = 0;
		.mputobwodka;
		
		new img imgbgkol;
		
		string ssavefile = "kol"+iImgId+".vec";
		if( ssavefile!=null )	{
			new string savefile = ssavefile;
			new db dbkolory;
			@s = ssavefile;
			//if( engine.fileexist(s) )	{
			if( .saveexist(s) )	{
				dbkolory.vecload(s);
				grdraw.each( func { (@id)
					.paint( dbkolory.get(id,0), dbkolory.get(id,1), dbkolory.get(id,2), 255, 0);
					} );
			} else {
				.mresetcols;
				for( int i=0; i<grdraw.size; i++ )
					dbkolory.dbaddstringrow("255 255 255"," ");
				.tp_savekols;
			}
		} else {
			.mresetcols;
		}
		
		.mputbg(0);
		
		.stdenter;
	}
	mputbg(int id)	{
		idBgKol.inextrol(id, 3);
		imgbgkol.load( .getgraphpath + "imgsbg/bg"+idBgKol+".jpg" );
		//imgbgkol.setpos( anfg.getex - imgbgkol.getw, (igmapph - imgbgkol.geth)/2 );
		//imgbgkol.ancenterscreen;
		@x = imgbgkol.getpx + imgbgkol.getw/3;
		anbutleft.ansetbpos( x, imgbgkol.getey-anbutleft.geth );
		anbutright.ansetbpos( x, imgbgkol.getpy );
		imgkolobg.setpos( imgbgkol.getex, 0 );
	}
	mresetcols	{
		grdraw.eval( func { .paint(.white,255,0); } );
	}
	mputobwodka	{
		@s = grpaleta.get(iactcol);
		|iCol0, iCol1, iCol2, _| = <s>.getrgba(<s>.getcx, <s>.getcy);
		anobwodka.ancenterimg(s);
	}
	tp_savekols	{
		if( !<GAME>.hasvar("dbkolory") ) return;
		grdraw.each( func { (@id)
			int c[4];
			//|c0, c1| = .anfirstnontr;
			int ex = .getex , int ey = .getey;
			int x = .getpx, int y=.getpy;
			while( x!=ex && y!=ey )	{
				if( .isin(x,y,false,true) ) { c0=x; c1=y; x=ex; }
				else x++;
			}
			|c0,c1,c2,_| = .getrgba(c0,c1);
			dbkolory.set(id,0,c0);
			dbkolory.set(id,1,c1);
			dbkolory.set(id,2,c2);
			} );
		dbkolory.vecsave( savefile );
	}
	tp_default_erase	{	.tp_erase(.white,255);	}
	tp_erase(int r, int g, int b, int a)	{
		for( int i=0; i< grdraw.size; i++)	{
			<grdraw.get(i)>.paint(r,g,b,a,paintmode);
			dbkolory.set(i,0,255);
			dbkolory.set(i,1,255);
			dbkolory.set(i,2,255);
		}
		.tp_savekols;
	}
	but1_lclick	{	if( sobject!=null ) .savekols;	}
	clbuts_reset_butclick	{
		fxpedzel.play;
		.tp_default_erase;
	}
	mouse_lclick	{
		if( .advstdstate )	{
			|int x, int y| = mouse.getpos();
			if( grdraw.isin(x,y,true,true) )	{
				<grdraw.getsfound>.paint( iCol0, iCol1, iCol2, 255, paintmode );
				fxpedzel.play;
			} else if ( grpaleta.isin(x,y,false,true) )	{
				iactcol = grpaleta.getfound;
				.mputobwodka;
				fxpedzel2.play;
			}
		}
	}
	game_exit	{
		.tp_exit;
		.tp_savekols;
	}
	butclick_anbutexit	{	.askfor("MenuImgStd");	}
	butclick_anbutleft	{	.mputbg(-1);	}
	butclick_anbutright	{	.mputbg(1);	}
}


new int iMenuPuzid = 1;
//new int iIlePuz = .readcfg("iIlePuz:",iMenuPuzid);
new int iIlePuz = iIleImgs;

new int iPuzRow = 5;
new int iPuzCol = 6;
new int iPuzCiecie = 0;
new bool bPuzRotate = false;
new bool bPuzHint = true;

new string sMenuPuzzleExit = "MenuImgStd";

game MenuTrybPuzzle : MermaidStd	{
	init	{
		MermaidStd::init("menu_tryb");
		
		.imgs = (A, "tryby.jpg", "butile.pyzG 10", "butok.pyz 20", "buthint.pyz 20", "butroto.pyz 20", "yesno.pyz 30");
		anyesno.addtogamevars("anmodehint");
		.copyanima("anyesno", "anmoderoto");
		.copyanima("anyesno", "anmodeile");
		
		anmodehint.setpos( anbuthint.getcx, anbuthint.getey );
		anmoderoto.setpos( anbutroto.getcx, anbutroto.getey );
		.msetmodes;
		
		.cbutexit;
		.cbutmusicif;
		if( !.checktouchpad )
			anbutok.imgbuildoverlay(.yellow,64,1200);
		
		new string smodeile = null;
		grbutile.eval( func {
			.Button_std;
			.addmethod("butmoveon", func {
				sndfxmoveonms.play;
				advmouse.setact;
				if( this==smodeile )	{
					.setframe( -1, 3 );
				} else .setframe( -1, 1 );
				} );
			.addmethod("butmoveoff", func {
				advmouse.setstd;
				if( this==smodeile )	{
					.setframe( -1, 2 );
				} else .setframe( -1, 0 );
				} );
			.addmethod("butclick", func {
				if( .advstdstate )	{
					sndfxbutclick1.play;
					.msetile(this);
				}
				} );
			butgame.add(this);
			} );
		.msetile(grbutile.get(iPuzCiecie));
		
		anbutroto.Button_addstdstate;
		anbuthint.Button_addstdstate;
		
		anbutok.Button_addstdstate;
		
		.stdenter;
	}
	butclick_anbutroto	{	bPuzRotate = !bPuzRotate; .msetmodes;	}
	butclick_anbuthint	{	bPuzHint = !bPuzHint;	.msetmodes;	}
	butclick_anbutok	{
		match ( <smodeile>.actionname ) 	{
			"12" => { iPuzRow = 3; iPuzCol = 4; }
			"20" => { iPuzRow = 4; iPuzCol = 5; }
			"30" => { iPuzRow = 5; iPuzCol = 6; }
			"48" => { iPuzRow = 6; iPuzCol = 8; }
			? => ;
		}
		.stdexit("PuzzleB");
	}
	msetile(string s)	{
		if( smodeile!=null )	{
			<smodeile>.setframe(-1,0);
		}
		smodeile = s;
		iPuzCiecie = <smodeile>.actionnr(-1);
		<smodeile>.setframe(-1,3);
	}
	msetmodes	{
		anmodehint.setframe( -1, (bPuzHint ? 0 : 1) );
		anmoderoto.setframe( -1, (bPuzRotate ? 0 : 1) );
	}
	butclick_anbutexit	{	.stdexit(sMenuPuzzleExit);	}
}

game OutroPuzzle : MermaidStd	{
	init	{
		MermaidStd::init("outro");
		.img = ("bgoutro.jpg");
		ccs.enter(func {
			.timplay("timend", 5000, "mend");
			} );
	}
	mend	{	.stdexit("exit");	}
	mouse_lclick	{	.mend;	}
}


class gmimgvecpuz : gmimgvec	{
	init()	{
		gmimgvec::init();
	}
	setpos(int x, int y)	{	.imsetpos(x,y);	}
	imsetpos(int x, int y)	{
		_ix = x;
		_iy = y;
		.eval2("imsetpos", x, y);
	}
	ilodx	{ 0; }
	ilody	{ 0; }
}

class TPuzzle2	{
	init	{}
	tinit(string sbkg, string sels, int row, int col, int dx, int dy)	{
		new int iCols = col;
		new int iRows = row;
		if( sbkg.contains(".") )
			.newimg("imgbkg", sbkg, 0);
		
		if( sels.contains(".pyz") )	{
			new gmimgvec grel;
			"grel" ..< sels;
		} else if( sels != "grel" )	{
			<sels>.addtogamevars("grel");
		}
		new gmimgvec grend;
		grel.hash;
		grel.each( func { (@id) .setz(10+id); } );
		new string spuztyp = <grel.first>.gettype;
		
		new int ibadajl = .between(10, 25->igetsc, 25);
		new string sactpuz;
		new int iblitopacity = 192;
		new int PuzzleState = 0;
		
		new string ssetpuz = null;
		
		if( bPuzRotate )
			new WaitImgMover cmov;
		else	{
			new DelayMover cmov;
			cmov.setclickrel(false);
		}
		new SimpleCounter cnt(200);
		
		new int iX = dx;
		new int iY = dy;
		grel.move( iX, iY );
	}
	setpuzstate(int istate)	{
		PuzzleState=istate;
		if( PuzzleState==1)	{
			new gmimgvec grblit;
			@s = _;
			"grblit" ..< s;
			grblit.hide;
		}
	}
	cmov_GET	{
		fxrewind1.stop(false);
		if( sgmstate=="state_rotobut" )	{
			.advsetstdstate;
		} else if (.advstdstate ) {
			if( ssetpuz!=null )	{
				.hideoverlay;
				.retpuzel(ssetpuz);
				ssetpuz = null;
			}
			if( grel.isincut( mouse.getpos, true, true ) )	{
				string s = grel.getsfound;
				<s>.setz(900);
				.mssetobj( s );
				.tpuzzle_get;
			}
		}
	}
	hideoverlay	{
		if( ssetpuz!=null )	{
			< <ssetpuz>.imgetoverlay>.hide;
			anbutroto.hide;
		}
	}
	showoverlay	{
		if( ssetpuz!=null )	{
			<ssetpuz>.imgbuildoverlay(.red,64,0);
			@sover = <ssetpuz>.imgetoverlay;
			<sover>.setz( <ssetpuz>.getz + 1 );
			<sover>.ansetbpos( <ssetpuz>.getpx, <ssetpuz>.getpy );
			<sover>.show;
			rec2.fit(sover);
			if( !anbutroto.isvisible )
				anbutroto.setpos( <ssetpuz>.getex, <ssetpuz>.getpy );
			anbutroto.show;
		}
	}
	bool cwithin(string s)	{
		int i;
		if( .gettype!=spuztyp )	{
			for( i=0; i < .size; i++)	{if( <.get(i)>.cwithin( s ) )	return true;}
			return false;
		} else {
			if( <s>.gettype==spuztyp )	{
				if( bPuzRotate && puzangle!=0 )
					return false;
				int id = .framenr;
				int im = id%iCols;
				A;
				if( im>0 )			id-1;
				if( im<iCols-1 )	id+1;
				im = id/iCols;
				if( im>0 )			id-iCols;
				if( im<iRows-1)	id+iCols;
				return <s>.framenr->in;
			} else {
				for( i=0; i< <s>.size; i++)		{if( .cwithin( <s>.get(i) ) )	return true;}
				return false;
			}
		}
	}
	cposlen(string s1, string s2)	{
		int ilx = (<s1>.getposx-<s1>.ilodx) - (<s2>.getposx-<s2>.ilodx);
		int ily = (<s1>.getposy-<s1>.ilody) - (<s2>.getposy-<s2>.ilody);
		ilx.length( ilx, ily );
	}
	cblit(string s)	{
		if( <s>.gettype==spuztyp )	{
			if( PuzzleState==1 )	{
				<s>.imsetpos(iX, iY);
				<s>.hide;
				s = grblit.get(<s>.framenr);
			}
			<s> {
				.setz(1);
				.show;
				
				if( bPuzRotate )	{
					<"ftrot"+this>.unlink;
				}
				
				.imsetpos(iX, iY);
				
				imgbkg.blit( this );
				.hide;
				
				/*int x = .getpx;
				int y = .getpy;
				.anaddfilter;
				.setopacity(iblitopacity);
				.setpos(x,y);
				imgbkg.blit( this );
				.unlink;
				.setpos(iX,iY);
				.hide;*/
			};
		} else	for( int i=0; i< <s>.size; i++ )		.cblit( <s>.get(i) );
	}
	cmov_PUT	{	<GAME>.cput;	}
	retpuzel(string s)	{
		<s>.setz(100+cnt.next);
		grel.sortimgs;
		grel.each( func { (int i) .setz(10+i); } );
	}
	cput	{
		.tpuzzle_put;
		string s = cmov.getfree;
		.retpuzel(s);
		string s1 = s, string s2;
		sactpuz = s;
		while(<s>.gettype != spuztyp)	s=<s>.get(0);
		bool bcanjoin = (!bPuzRotate || <s>.puzangle==0 );
		if( bcanjoin && (ibadajl.length( <s>.ilodx+iX-<s>.getpx, <s>.ilody+iY-<s>.getpy ) < ibadajl) ) {
			sactpuz = null;
			.cblit(s1);
			grel.remove(s1);
			grend.add(s1);
			.tpuzzle_blit;
			if( grel.empty )	{
				grend.show;
				.tpuzzle_end;
			}
		} else if( bcanjoin ) {
			grel.remove(s1);
			for( int i=0; i<grel.size; i++)	{
				s = grel.get(i);
				if( .cposlen(s,s1)<ibadajl && <s1>.cwithin(s) )	{
					int x, int y;
					if( <s>.gettype==spuztyp)	{
						x = <s>.getposx - <s>.ilodx;
						y = <s>.getposy - <s>.ilody;
					} else {
						|x,y| = <s>.getpos;
					}
					if( <s>.gettype==spuztyp)	{
						.mwyjmij(s);
						if( <s1>.gettype==spuztyp )	{
							s2 = "gr" + s;
							new gmimgvecpuz <s2>;
							<s2>.add(s);
							<s2>.add(s1);
						} else {
							<s1>.add(s);
							s2 = s1;
						}
						grel.remove(s);
						grel.add(s2);
					} else {
						if( <s1>.gettype==spuztyp )	{
							<s>.add(s1);
						} else {
							<s>.addgr(s1);
						}
						s2 = s;
					}
					<s2>.imsetpos(x,y);
					<s2>.setz( <s1>.getz );
					grel.sortimgs;
					sactpuz = s2;
					.tpuzzle_join;
					return;
				}
			}
			grel.add(s1);
		}
		.tpuzzle_putbad;
	}
	virtual tpuzzle_end {}
	virtual tpuzzle_get {}
	virtual tpuzzle_blit {}
	virtual tpuzzle_join {}
	virtual tpuzzle_put {}
	virtual tpuzzle_putbad {}
	virtual mwyjmij(string s)	{}
	rotopuz	{
		puzangle = (puzangle+1)%4;
		<"ftrot"+this>.setrotate( puzangle * 90 );
	}
}

new bool bnewpuz = true;
//sgmpuzpref.in(A, "nestor", "puzzle_nelapuz");

new int iPuzzleType = 0;
new img imgPuzel;
new string sPuzzleExit = "MenuImgStd";

public przygotuj_matryce(string smatryca, string smaska, string simgpuz, string sgr, int ishadow)	{
	int dy = 65->igetsc;			// obnizone pod reklamy
	int dx = -((1366-1280)/2)->igetsc;	// zmiana z 1366x800 na androida 1280x768

	new gmimgvec grmat;
	"grmat" ..< (smatryca+".pyz");
	if( bnewpuz )
		grmat.move(dx, dy);
	new gmimgvec grmask;
	if( smaska!=null && engine.fileexist( .getgraphpath + smaska + ".pyz")  )	{
		"grmask" ..< (smaska+".pyz");
		if( bnewpuz )
			grmask.move(dx, dy);
		if( bPuzHint )
			grmask.blitto("imgbkg");
	}
	
	new gmimgvec <sgr>;
	
	if( iPuzzleType==0 )	{
		.newimg("impuz", simgpuz, 0);
	} else if (iPuzzleType==1)	{
		imgPuzel.addtogamevars("impuz");
		impuz.show;
	}
	
	impuz.setpos( <grmat.first>.getpx, <grmat.first>.getpy );
	
	new filter ft2;
	
	for( int i=0; i<grmat.size; i++)	{
		string s1 = "im" + sgr + "_" + i;
		new img <s1>;
		<s1>.var2("framenr", i);
		<s1>.addmethod("imsetpos", func { (int x, int y)
			.setpos(x+ilodx, y+ilody);
			} );
		string s = grmat.get(i);
		
		<s1>.create( <s>.getw + ishadow, <s>.geth + ishadow, .transparent );
		<s1>.setpos( <s>.getpx, <s>.getpy );
		<s1>.vars2(A, "ilodx", <s1>.getpx, "ilody", <s1>.getpy);
		
		if( ishadow > 0 )	{
			<s>.move(ishadow,ishadow);
			ft2.link(s);
			ft2.setmaskalpha(1);
			ft2.setopacity(92);
			<s1>.blit(s);
			ft2.unlink;
			<s>.move(-ishadow,-ishadow);
		}
		
		<s1>.blitmask( "impuz", s );
		
		if( i<grmask.size )	{
			<s1>.blit( grmask.get(i) );
		}
		
		if( bPuzRotate )	{
			s = "ftrot" + s1;
			new filter <s>;
			<s>.link(s1);
			<s>.setpivottype(1);
			<s>.setsmooth(0);
			<s1>.var2("puzangle",4->rand);
			<s1>.rotopuz;
		}
		
		<sgr>.add(s1);
	}
	grmask.hide;
	
	delete ft2;
	grmat.deleteallgm;
	delete grmat;
	
	impuz.setz(1);
	impuz.hide;
}

game PuzzleB : MermaidStd, TPuzzle2	{
	init	{
		MermaidStd::init("mg_puzzle");
		//.cloadboki(1);
		
		.sfxs = (A, "getpuz 60", "putpuz 60", "ok 40", "podnies1", "zwyciestwo2", "rewind1 70", "pageflip1 80");
		
		.newimg("imgbkg", "bgpuzzle.jpg", 0);
		
		.przygotuj_matryce("matryca_"+iPuzRow+"_"+iPuzCol, "maska_"+iPuzRow+"_"+iPuzCol,
			"$scripts/" + sgmpuzpref+ "/" + sMenuImgPref + iImgId + ".jpg", "grel", 0);
		
		.tinit("imgbkg", "grel", iPuzRow, iPuzCol, 0, 0);
		
		if( bnewpuz )	{
			.imgs = (A, "down.pyz 200", "up.pyz 200", "butroto.pyzH 950");
			anup.addtogamevars("anleft");
			andown.addtogamevars("anright");
		} else	{
			.imgs = (A, "left.pyz 200", "right.pyz 200", "butroto.pyzH 950");
			@y = igmoffsety + iResY - anleft.geth - 30->igetsc;
			int dx = 30->igetsc;
			anleft.ansetbpos( igmoffsetx + dx, y );
			anright.ansetbpos( igmoffsetx + iResX - anright.getw - dx , y );
		}
		
		anbutroto.Button_addstd;
		
		anleft.Button_std;
		anright.Button_std;
		butgame.add("anleft");
		butgame.add("anright");
		new int strzalkax = 5;
		
		if( !.checktouchpad )	{
			anleft.imgbuildoverlay(.white,64,1500);
			anright.imgbuildoverlay(.white,64,1500);
			//anbutexit.imgbuildoverlay(.yellow,64,1200);
		}
		
		new int rewindspeed = 20;
		.cycle = ("timleft", func {
			if( .advstdstate && grpes.size )	{
				@s = grpes.first;
				if( bnewpuz )	{
					grpes.move( 0, rewindspeed );
					<s>.munlink;
					if( <s>.getpy > anleft.getey + strzalkax )
						grpes.move( 0, (anleft.getey+strzalkax)-<s>.getpy );
				} else {
					grpes.move( rewindspeed, 0 );
					<s>.munlink;
					if( <s>.getpx > anleft.getex + strzalkax )
						grpes.move( (anleft.getex+strzalkax)-<s>.getpx, 0 );
				}
				<s>.mlink;
				.play;
			}
			} );
		.cycle = ("timright", func {
			if( .advstdstate && grpes.size )	{
				@s = grpes.last;
				if( bnewpuz )	{
					grpes.move( 0, -rewindspeed );
					<s>.munlink;
					if( <s>.getey < anright.getpy - strzalkax )
						grpes.move( 0, (anright.getpy-strzalkax)-<s>.getey );
				} else {
					grpes.move( -rewindspeed, 0 );
					<s>.munlink;
					if( <s>.getex < anright.getpx - strzalkax )
						grpes.move( (anright.getpx-strzalkax)-<s>.getex, 0 );
				}
				<s>.mlink;
				.play;
			}
			} );
		@dx = 6->igetsc;
		@dx2 = 54->igetsc;
		if( bnewpuz )
			new Rect rec2(dx, dx2, anleft.getcx, igmapph-dx);
		else
			new Rect rec2(dx, dx2, igmappw-dx, anleft.getcy);
		rec2 { vecgr.add("gmimgvecpuz"); };
		new gmimgvec grpes;
		new int ipuzheight = <grel.first>.geth/2;
		
		for( int i=0; i<grel.size; i++ )
			.mwstaw(grel.get(i));
		
		.cbutexit;
		.cbutmusicif;
		/*if( igmreklamy )	{
			anbutmusic.ansetbpos( anbutexit.getex+0.2*anbutexit.getw, anbutexit.getpy );
		}*/
		
		if( bPlayMusic )	{
			.play_music;
		}
		
		.cutscene;
		ccs.enter( func {
			.unlockall;
			.advsetstdstate;
			} );
	}
	play_music	{
		//mus.playstr( "puzzle.ogg -v 50 -l");*/
	}
	stop_music	{
		//mus.fadeout(1000);
	}
	munlink	{
		if( bPuzRotate) <"ftrot"+this>.unlink;	
	}
	mlink	{
		if( bPuzRotate )	{
			@s = "ftrot"+this;
			<s>.link(this);
			<s>.setsmooth(0);
			<s>.setrotate( puzangle * 90 );
		}
	}
	mwstaw(string s)	{
		int dy = 5;
		int xpos, int ypos;
		<s>.setpos(0,0);
		//<s>.munlink;
		
		if( bnewpuz )	{
			if( grpes.size )	{
				ypos = <grpes.last>.getpy + <grpes.last>.geth;
			} else {
				ypos = anleft.getey;
			}
			@x = anleft.getcx - <s>.getw/2;
			if( x+<s>.getw > igmappw - dy )
				x = igmappw-dy - <s>.getw;
			<s>.munlink;
			<s>.setpos( x, ypos + strzalkax );
			<s>.mlink;
			<s>.clip( 0, anleft.getey + strzalkax, igmappw, anright.getpy-strzalkax );
		} else {
			if( grpes.size )	{
				xpos = <grpes.last>.getpx + <grpes.last>.getw;
			} else {
				xpos = anleft.getex;
			}
			//<s>.ansetbpos( xpos + strzalkax, iResY-dy - <s>.geth );
			@y = anleft.getcy - <s>.geth/2;
			if( y+<s>.geth > igmapph - dy )
				y = igmapph-dy - <s>.geth;
			<s>.munlink;
			<s>.setpos( xpos + strzalkax, y );
			<s>.mlink;
			<s>.clip( anleft.getex + strzalkax, 0, anright.getpx-strzalkax, igmapph );
		}
		grpes.add(s);
	}
	mwyjmij(string s)	{
		int id = grpes.find(s);
		if( id<0 ) return;
		<s>.clip(0,0,igmappw,igmapph);
		grpes.remove(s);
		if( bnewpuz )	{
			for( int i=id; i < grpes.size; i++ )	{
				<grpes.get(i)>.move( 0, -<s>.geth-strzalkax );
			}
		} else {
			for( int i=id; i < grpes.size; i++ )	{
				<grpes.get(i)>.move( -<s>.getw-strzalkax, 0 );
			}
		}
		if( grpes.empty )
			fxrewind1.stop(false);
	}
	tpuzzle_get	{
		fxgetpuz.play;
		.mwyjmij(grel.getsfound);
	}
	tpuzzle_putbad	{	fxputpuz.play;		}
	tpuzzle_blit	{	fxpodnies1.play;		}
	tpuzzle_join	{	fxpodnies1.play;	}
	tpuzzle_end	{
		fxok.play;
		grend.hide;
		sgmstate = "state_won";
		
		impuz.show;
		fxzwyciestwo2.play;
	}
	cmov_PUT	{
		<GAME>.cput;
		if( sactpuz!=null )	{
			if( <sactpuz>.gettype==spuztyp && (( !bnewpuz && <sactpuz>.getcy > anleft.getpy )
				|| (bnewpuz && <sactpuz>.getcx > anleft.getpx )) )	{
				fxrewind1.play;
				.mwstaw(sactpuz);
			} else {
				rec2.fit(sactpuz);
			}
		}
		
	}
	cmov_SET	{
		ssetpuz = .getmover;
		if( <ssetpuz>.gettype!=spuztyp )	{
			ssetpuz = null;
			.cmov_PUT;
		} else {
			.free;
			.showoverlay;
			rec2.fit(ssetpuz);
			sndfxmoveon2.play;
			.mwyjmij(ssetpuz);
		}
	}
	mouse_lclick	{
		if( sgmstate=="state_won" ) sgmstate = "state_exit";
		else if (sgmstate=="state_exit")	{
			.mtomenu;
		}
		
		|int x, int y| = mouse.getpos;
		if( .advstdstate && grpes.size )	{
			if( anleft.isin(x,y,1,1) ) {
				fxrewind1.playloop;
				timleft.stop(true);
			} else if (anright.isin(x,y,1,1) ) {
				fxrewind1.playloop;
				timright.stop(true);
			}
		}
	}
	mouse_lrel	{
		//if( .advstdstate )	{
			if( timleft.isplaying ) {
				timleft.stop(false);
				fxrewind1.stop(false);
			} if( timright.isplaying ) {
				timright.stop(false);
				fxrewind1.stop(false);
			}
		//}
	}
	mtomenu	{
		imgPuzel.hide;
		.stdexit(sPuzzleExit);
	}
	mouse_rclick	{
		//if( igmdebug ) .tpuzzle_end;
		//if( igmdebug ) grpes.print;
	}
	butclick_anbutroto	{
		if( .advstdstate || sgmstate=="state_rotobut" )	{
			int x = <ssetpuz>.getcx;
			int y = <ssetpuz>.getcy;
			<ssetpuz>.rotopuz;
			rec2.fit(ssetpuz);
			x -= <ssetpuz>.getcx;
			y -= <ssetpuz>.getcy;
			<ssetpuz>.move( x, y );
			.showoverlay;
			< <ssetpuz>.imgetoverlay>.move( x,y );
			sgmstate = "state_rotobut";
			fxpageflip1.play;
		}
	}
	butclick_anbutexit	{
		.mtomenu;
	}
	key_down	{
		if( igmdebug && keyboard.iskey("s") )	{
			if( ssetpuz!=null )	{
				<ssetpuz>.imgprint;
			}
		}
	}
}



new string sChosenAnimal = "panda";


if( sgmproject.in(A, "AnimalPuzCol_Asia1", "Arcade_NelaZoo") )	{
	new img imglobg;
	imglobg.load("scripts/"+sgmpuzpref+"/menu/bgmenu.jpg");
	new anima anbutstmp;
	anbutstmp.load("scripts/"+sgmpuzpref+"/menu/buts.pyz");
	for( int i=0; i<anbutstmp.nofactions; i++ )	{
		anbutstmp.setframe(i,0);
		imglobg.blit("anbutstmp");
	}
	delete anbutstmp;
	new img imgbg2;
	imgbg2.create(igmappw, igmapph, 129,181,10, 128);
	imgbg2.setpos(imglobg.getpx, imglobg.getpy );
	imglobg.blit("imgbg2");
	delete imgbg2;
	imglobg.hide;
}

game MenuAnimals : MermaidStd	{
	init	{
		imglobg.hide;
		MermaidStd::init("menu");
		
		.imgs = (A, "bgmenu.jpg", "buts.pyzG 10", "butkolo.pyzH 30", "butpuz.pyzH 30");
		.sfxs = (A, "lasergunshot1 40");
		
		anbutpuz.Button_addstdalpha;
		anbutkolo.Button_addstdalpha;
		
		grbuts.eval( func {
			if( .actionname->in(A, "slon", "malpa", "wielblad", "wol", "panda", "tygrys", "tukan", "rys",
				"orangutan", "waran", "szop", "ges") )	{
				.Button_stdalpha;
				.addmethod("butclick", func {
					if( .advstdstate )	{
						sChosenAnimal = .actionname;
						//.imgsetoverlay(.yellow,128);
						//.stdexit("WyborAnimal");
						<GAME> {
							imgbgmenu.hide;
							grbuts.hide;
							imglobg.show;
							.newanima("anzwierz", "$"+.getgamepath + "puzle/puz_"+sChosenAnimal+".pyz", 20);
							.advsetstate("state_showbuts");
							anzwierz.anzoomin(idymekdelay, func {
								.advsetstate("state_checkgametype");
								fxlasergunshot1.play;
								anbutpuz.anzoomin(idymekdelay,null);
								anbutkolo.anzoomin(idymekdelay,null);
								} );
						};
					}
					} );
				butgame.add(this);
				}
			} );
		
		.cbutexit;
		.loadasker;
		.stdenter;
	}
	butclick_anbutexit	{	.askfor("OutroAnimals");	}
	butclick_nostdstate_anbutexit	{
		if( .advisstate("state_checkgametype") )
			gameapi.play("MenuAnimals");
	}
	butclick_anbutpuz	{
		if( .advisstate("state_checkgametype") ) {
			sPuzleAnimalsExit = "MenuAnimals";
			.stdexit("PuzleAnimals"); 
		}
	}
	butclick_anbutkolo	{
		if( .advisstate("state_checkgametype") ) {
			sKoloAnimalsExit = "MenuAnimals";
			.stdexit("KoloAnimals"); 
		} 
	}
}


game IntroAsia1 : MermaidStd	{
	init	{
		MermaidStd::init("intro");
		
		music.smixer = ("engine");
		music.playstr("bgrlas1 -l -v 30");
		
		.img = ("bgintro.jpg");
		ccs.enter(func {
			.timplay("timend", 3000, "mend");
			} );
	}
	mend	{	.stdexit("MenuAnimals");	}
	mouse_lclick	{	.mend;	}
}

game OutroAnimals : MermaidStd	{
	init	{
		MermaidStd::init("outro");
		.img = ("bgoutro.jpg");
		ccs.enter(func {
			.timplay("timend", 5000, "mend");
			} );
	}
	mend	{	.stdexit("exit");	}
	mouse_lclick	{	.mend;	}
}


new string sPuzleAnimalsExit = "MenuAnimals";

game PuzleAnimals : MermaidStd, TPuzzle2	{
	init	{
		MermaidStd::init("puzle");
		
		new bool bPuzRotate = false;
		
		.newanima("anzwierz", "puz_"+sChosenAnimal, 10);
		.copyanima("anzwierz", "anzw");
		
		.sfxs = (A, "getpuz 60", "putpuz 60", "ok 40", "podnies1", "zwyciestwo2", "rewind1 70", "pageflip1 80", "brawa1 80");
		
		imglobg.show;
		new img imgbkg;
		imgbkg.imgclone("imglobg");
		imglobg.hide;
		
		new img imbg;
		imbg.imgclonesizecol("anzwierz", .white, 64);
		
		int dx = 0.1*igmappw;
		int dy = 0.1*igmapph;
		@dy2 = 40->igetsc;
		new Rect rec2( dx, dy+dy2, igmappw-2*dx, igmapph-2*dy-dy2);
		rec2 { vecgr.add("gmimgvecpuz"); };
		
		new gmimgvec grels;
		int ktory = anzw.nofframes(1)->rand;
		for( int i=0; i<anzw.nofframes(1); i++)	{
			@s = "imgz"+i;
			new img <s>;
			anzw.setframe(1,i);
			<s>.imgclonesize("anzw");
			<s>.blit("anzwierz");
			
			if( i==ktory )	{
				<s>.imgsetoverlay( .grey(128), 128 );
				new string soveralyed = <s>.imgetoverlay;
			}
			<s>.var2("framenr", i);
			<s>.addmethod("imsetpos", func { (int x, int y)
				.setpos(x+ilodx, y+ilody);
				} );
			<s>.vars2(A, "ilodx", <s>.getpx, "ilody", <s>.getpy);
			grels.add(s);
			<s>.setpos( igmappw->rand, igmapph->rand );
			rec2.fit(s);
		}
		anzw.hide;
		anzwierz.hide;
		
		// malpa, tukan, waran, rys, wielblad, tygrys, orangutan 2x3
		// slon 3x2
		int rows = 2;
		int cols = 3;
		if( sChosenAnimal=="slon" ) {
			rows = 3;
			cols = 2;
		}
		.tinit("imgbkg", "grels", rows, cols, 0, 0);
		//iblitopacity = 222;
		
		.cbutexit;
		.loadasker;
		ccs.enter( func {
			.unlockall;
			.advsetstdstate;
			} );
	}
	mupdate	{
		grels.sortz(15);
	}
	butclick_anbutexit	{
		if( grels.empty ) .stdexit(sPuzleAnimalsExit);
		else	.askfor(sPuzleAnimalsExit);
	}
	tpuzzle_get	{	fxgetpuz.play;	}
	tpuzzle_putbad	{	fxputpuz.play;		}
	tpuzzle_blit	{
		fxpodnies1.play;
		<soveralyed>.hide;
	}
	tpuzzle_join	{	fxpodnies1.play;	}
	tpuzzle_end	{
		fxok.play;
		fxzwyciestwo2.play;
		fxbrawa1.play;
		<soveralyed>.hide;
		imbg.hide;
	}
	cmov_PUT	{
		<GAME>.cput;
		if( sactpuz!=null )	{
			rec2.fit(sactpuz);
		}
	}
}




new string sKoloAnimalsExit = "MenuAnimals";

game KoloAnimals : MermaidStd {
	init	{
		if( igmandroid )
			MermaidStd::init("koloandro");
		else
			MermaidStd::init("kolo");
		
		imglobg.show;
		
		.imgsgr = (A, "light.pyz 15", /*"ramka.pyzG 10",*/ "brush.pyzG 15", "paint.pyzH 50",
			"specbrush.pyz 20", "czysc.pyz 20", "save.pyz 20", "eraser.pyz 20", "dec.pyz 20", "inc.pyz 20", "size.pyz 15",
			"napisy.pyzG 30", "imgpos.pyzH",
			"grall");
		
		
		.cbutexit;
		.loadasker;
		
		.sfxs = (A, "lira2", "pedzel", "pedzel2");
		
		new gmimgvec grf;
		"grf" ..< "farby.pyz";
		if( !igmandroid )	{
			grf.move( 0, -16->igetsc );
		}
		
		anczysc.hide;
		ansave.hide;
		<grnapisy.getsac("clear")>.hide;
		<grnapisy.getsac("save")>.hide;
		
		new int xbrush;
		new int ybrush;
		new img imbrush;
		new img imbrush2;
		new bool bcandraw = true;
		new int ibrushsize = 50;
		.newtext("txtsize", "", .stdfont(12->igetsc), .white);
		txtsize.setz( 25 );
		new string slastcol = null;
		
		grf.eval( func {
			.setz(20);
			.Button_stdms;
			.addmethod("butclick", func {
				if( .advstdstate )	{
					bcandraw = false;
					.msetfarba(this);
					fxpedzel.play;
				}
				} );
			butgame.add(this);
			} );
		<grf.last>.paint(.white,255,0);
		
		grbrush.eval( func {
			.Button_stdms;
			.addmethod("butclick", func {
				if( .advstdstate )	{
					bcandraw = false;
					.msetbrush(this);
					fxpedzel2.play;
				}
				} );
			butgame.add(this);
			} );
		
		aninc.Button_stdms;
		aninc.addmethod("butclick", func {
			if( .advstdstate )	{
				bcandraw = false;
				.mbrushsize(10);
				sndfxmoveon2.play;
			}
			} );
		butgame.add("aninc");
		andec.Button_stdms;
		andec.addmethod("butclick", func {
			if( .advstdstate )	{
				bcandraw = false;
				.mbrushsize(-10);
				sndfxmoveon2.play;
			}
			} );
		butgame.add("andec");
		
		aneraser.Button_stdms;
		aneraser.addmethod("butclick", "mnewbrushclick" );
		butgame.add("aneraser");
		
		anspecbrush.Button_stdms;
		anspecbrush.addmethod("butclick", "mnewbrushclick" );
		butgame.add("anspecbrush");
		
		/*.newimg("ancol1", "$scripts/"+sgmkolopref+"/imgsbw/colbw_" + iKoloId + ".jpg", 7);
		ancol1.move(animgpos.getpx,animgpos.getpy);
		.newimg("ancol2", "$scripts/"+sgmkolopref+"/imgscol/colcol_" + iKoloId + ".jpg", 7);
		ancol2.move(animgpos.getpx,animgpos.getpy);
		ancol2.hide;*/
		.newanima("anzwierz", "p_"+sChosenAnimal, 10);
		new img ancol1;
		ancol1.imgclonesizecol("anzwierz", .white, 255);
		ancol1.blit("anzwierz");
		anzwierz.hide;
		.newanima("anzcol", "$"+.getgamepath + "puzle/puz_"+sChosenAnimal, 20);
		anzcol.hide;
		new img ancol2;
		ancol2.imgclonesizecol("anzcol", .white, 255);
		ancol2.blit("anzcol");
		anzcol.hide;
		ancol2.hide;
		
		
		new img implotno;
		if( .mcansave && engine.fileexist(.mgetfile) )	{
			implotno.create( ancol1.getw, ancol1.geth, .transparent );
			implotno.loadnoscale( .mgetfile );
		} else {
			implotno.create( ancol1.getw, ancol1.geth, .transparent );
		}
		implotno.setpos( ancol1.getpx, ancol1.getpy );
		implotno.setz( 8 );
		
		new bool bclicked = false;
		.cycle = ("timpaint", func {
			if( .advstdstate &&  bclicked ) {
				real x = imbrush.getpx;
				real y = imbrush.getpy;
				real len = x.length( x-xbrush, y-ybrush );
				int ile = len / (imbrush.getw/2);
				if( ile < 1 ) ile=1;
				real rx = xbrush;
				real ry = ybrush;
				real dx = (x-rx)/ile;
				real dy = (y-ry)/ile;
				for( int i=1; i<=ile; i++ )	{
					if( i==ile )	{
						xbrush = x;
						ybrush = y;
					} else {
						rx += dx;
						ry += dy;
						xbrush = rx;
						ybrush = ry;
					}
					imbrush.setpos( xbrush, ybrush );
					if( anspecbrush.framenr )
						implotno.paintfromsrc("ancol2", "imbrush");
					else if( aneraser.framenr )
						implotno.erase("imbrush");
					else implotno.paintfromgrey("ancol1", "imbrush");
				}
			}
			.play;
			} );
		
		
		.msetbrush( grbrush.first );
		.msetfarba( grf.first );
		timpaint.play;
		
		.checkbrushpos;
		
		.stdenter;
	}
	mgetfile	{
		.getsavepath + "kolo_"+sChosenAnimal+".k16";
	}
	mcansave	{	igmenablesave && 0;	}
	msavefile	{
		if( .mcansave )	{
			int x = implotno.getpx;
			int y = implotno.getpy;
			implotno.setpos(igmoffsetx,igmoffsety);
			implotno.save( .mgetfile );
			implotno.setpos(x,y);
		}
	}
	mnewbrushclick	{
		if( .advstdstate )	{
			bcandraw = false;
			if( this=="aneraser" ) {
				anspecbrush.setframe(-1,0);
				sndfxmoveon2.play;
			} else {
				aneraser.setframe(-1,0);
				fxlira2.play;
			}
			if( .framenr )	{
				.setframe(-1,0);
				//.mupdatecol;
				.mretcol;
			} else {
				.setframe(-1, 1 );
				.mresetcol;
			}
		}
	}
	mbrushsize(int id)	{
		ibrushsize = .between(10, ibrushsize+id, 100);
		imbrush2.imgclone("anpaint");
		imbrush2.anzoom( 0.01 * ibrushsize );
		imbrush.imgclone("imbrush2");
		imbrush2.hide;
		imbrush.show;
		txtsize.txtset( "" + ibrushsize + "%" );
		txtsize.imgputoncenter( "ansize" );
		.mupdatecol;
		.setbrushpos;
	}
	mouse_lclick	{
		if( .advstdstate )	{
			if( bcandraw )	{
				bclicked = true;
				.setbrushpos;
				xbrush = imbrush.getpx;
				ybrush = imbrush.getpy;
			} else {
				bcandraw = true;
			}
		}
	}
	mouse_lrel	{
		bclicked = false;
		.checkbrushpos;
	}
	msetfarba(string s)	{
		aneraser.setframe(0,0);
		anspecbrush.setframe(0,0);
		anlight.setframe( <s>.actionnr(-1), 0 );
		anlight.ancenterimg( s );
		anlight.show;
		slastcol = s;
		.mupdatecol;
	}
	mretcol	{	.msetfarba(slastcol);	}
	mupdatecol	{
		if( aneraser.framenr || anspecbrush.framenr )
			.mresetcol;
		else if( slastcol!=null )
			imbrush.paint( <slastcol>.getrgb( <slastcol>.getcx, <slastcol>.getcy ), 255, 0 );
	}
	mresetcol	{
		anlight.hide;
		imbrush.paint( .black, 255, 0 );
	}
	mouse_move	{
		.setbrushpos;
	}
	setbrushpos	{
		if( .checktouchpad )
			imbrush.setpos(mouse.getpx-imbrush.getw/2, mouse.getpy-imbrush.geth/2);
		else
			imbrush.setpos(mouse.getpx-imbrush.getw, mouse.getpy-imbrush.geth);
	}
	msetbrush(string s)	{
		grbrush.setframe(-1,0);
		<s>.setframe(-1,1);
		anpaint.setframe( 0, <s>.actionnr(-1) );
		.mbrushsize(0);
	}
	checkbrushpos	{
		if( igmandroid )	{
			imbrush.scpos(1140, 520);
			imbrush.move( -imbrush.getw/2, -imbrush.geth/2 );
		} else if( .checktouchpad )	{
			imbrush.scpos(970, 650);
			imbrush.move( -imbrush.getw/2, -imbrush.geth/2 );
		}
	}
	butclick_anbutexit	{
		bcandraw = false;
		.msavefile;
		.askfor(sKoloAnimalsExit);
	}
}




game ColoKolo : MermaidStd {
	init	{
		MermaidStd::init("kolo");
		
		.imgsgr = (A, "bkg.jpg", "light.pyz 15", "ramka.pyzG 10", "brush.pyzG 15", "paint.pyzH 50",
			"specbrush.pyz 20", "czysc.pyz 20", "save.pyz 20", "eraser.pyz 20", "dec.pyz 20", "inc.pyz 20", "size.pyz 15",
			"napisy.pyzG 30", "imgpos.pyzH",
			"grall");
		
		
		.cbutexit;
		.loadasker;
		
		new int iKoloId = iImgId;
		
		.sfxs = (A, "lira2", "pedzel", "pedzel2");
		
		new gmimgvec grf;
		"grf" ..< "farby.pyz";
		if( !igmandroid )	{
			grf.move( 0, -16->igetsc );
		}
		
		anczysc.hide;
		ansave.hide;
		<grnapisy.getsac("clear")>.hide;
		<grnapisy.getsac("save")>.hide;
		
		new int xbrush;
		new int ybrush;
		new img imbrush;
		new img imbrush2;
		new bool bcandraw = true;
		new int ibrushsize = 50;
		.newtext("txtsize", "", .stdfont(24->igetsc), .white);
		txtsize.setz( 25 );
		new string slastcol = null;
		
		grf.eval( func {
			.setz(20);
			.Button_stdms;
			.addmethod("butclick", func {
				if( .advstdstate )	{
					bcandraw = false;
					.msetfarba(this);
					fxpedzel.play;
				}
				} );
			butgame.add(this);
			} );
		<grf.last>.paint(.white,255,0);
		
		grbrush.eval( func {
			.Button_stdms;
			.addmethod("butclick", func {
				if( .advstdstate )	{
					bcandraw = false;
					.msetbrush(this);
					fxpedzel2.play;
				}
				} );
			butgame.add(this);
			} );
		
		aninc.Button_stdms;
		aninc.addmethod("butclick", func {
			if( .advstdstate )	{
				bcandraw = false;
				.mbrushsize(10);
				sndfxmoveon2.play;
			}
			} );
		butgame.add("aninc");
		andec.Button_stdms;
		andec.addmethod("butclick", func {
			if( .advstdstate )	{
				bcandraw = false;
				.mbrushsize(-10);
				sndfxmoveon2.play;
			}
			} );
		butgame.add("andec");
		
		aneraser.Button_stdms;
		aneraser.addmethod("butclick", "mnewbrushclick" );
		butgame.add("aneraser");
		
		anspecbrush.Button_stdms;
		anspecbrush.addmethod("butclick", "mnewbrushclick" );
		butgame.add("anspecbrush");
		
		.newimg("ancol1", "/imgsbw/colbw_" + iKoloId + ".jpg", 7);
		ancol1.move(animgpos.getpx,animgpos.getpy);
		.newimg("ancol2", "/imgscol/colcol_" + iKoloId + ".jpg", 7);
		ancol2.move(animgpos.getpx,animgpos.getpy);
		ancol2.hide;
		
		new img implotno;
		if( igmenablesave && engine.fileexist(.mgetfile) )	{
			implotno.create( ancol1.getw, ancol1.geth, .transparent );
			implotno.loadnoscale( .mgetfile );
		} else {
			implotno.create( ancol1.getw, ancol1.geth, .transparent );
		}
		implotno.setpos( ancol1.getpx, ancol1.getpy );
		implotno.setz( 8 );
		
		new bool bclicked = false;
		.cycle = ("timpaint", func {
			if( .advstdstate &&  bclicked ) {
				real x = imbrush.getpx;
				real y = imbrush.getpy;
				real len = x.length( x-xbrush, y-ybrush );
				int ile = len / (imbrush.getw/2);
				if( ile < 1 ) ile=1;
				real rx = xbrush;
				real ry = ybrush;
				real dx = (x-rx)/ile;
				real dy = (y-ry)/ile;
				for( int i=1; i<=ile; i++ )	{
					if( i==ile )	{
						xbrush = x;
						ybrush = y;
					} else {
						rx += dx;
						ry += dy;
						xbrush = rx;
						ybrush = ry;
					}
					imbrush.setpos( xbrush, ybrush );
					if( anspecbrush.framenr )
						implotno.paintfromsrc("ancol2", "imbrush");
					else if( aneraser.framenr )
						implotno.erase("imbrush");
					else implotno.paintfromgrey("ancol1", "imbrush");
				}
			}
			.play;
			} );
		
		
		.msetbrush( grbrush.first );
		.msetfarba( grf.first );
		timpaint.play;
		
		.checkbrushpos;
		
		.stdenter;
	}
	mgetfile	{
		.getsavepath + "kolo"+iKoloId+".k16";
	}
	msavefile	{
		if( igmenablesave )	{
			int x = implotno.getpx;
			int y = implotno.getpy;
			implotno.setpos(igmoffsetx,igmoffsety);
			implotno.save( .mgetfile );
			implotno.setpos(x,y);
		}
	}
	mnewbrushclick	{
		if( .advstdstate )	{
			bcandraw = false;
			if( this=="aneraser" ) {
				anspecbrush.setframe(-1,0);
				sndfxmoveon2.play;
			} else {
				aneraser.setframe(-1,0);
				fxlira2.play;
			}
			if( .framenr )	{
				.setframe(-1,0);
				//.mupdatecol;
				.mretcol;
			} else {
				.setframe(-1, 1 );
				.mresetcol;
			}
		}
	}
	mbrushsize(int id)	{
		ibrushsize = .between(10, ibrushsize+id, 100);
		imbrush2.imgclone("anpaint");
		imbrush2.anzoom( 0.01 * ibrushsize );
		imbrush.imgclone("imbrush2");
		imbrush2.hide;
		imbrush.show;
		txtsize.txtset( "" + ibrushsize + "%" );
		txtsize.imgputoncenter( "ansize" );
		.mupdatecol;
		.setbrushpos;
	}
	mouse_lclick	{
		if( .advstdstate )	{
			if( bcandraw )	{
				bclicked = true;
				.setbrushpos;
				xbrush = imbrush.getpx;
				ybrush = imbrush.getpy;
			} else {
				bcandraw = true;
			}
		}
	}
	mouse_lrel	{
		bclicked = false;
		.checkbrushpos;
	}
	msetfarba(string s)	{
		aneraser.setframe(0,0);
		anspecbrush.setframe(0,0);
		anlight.setframe( <s>.actionnr(-1), 0 );
		anlight.ancenterimg( s );
		anlight.show;
		slastcol = s;
		.mupdatecol;
	}
	mretcol	{	.msetfarba(slastcol);	}
	mupdatecol	{
		if( aneraser.framenr || anspecbrush.framenr )
			.mresetcol;
		else if( slastcol!=null )
			imbrush.paint( <slastcol>.getrgb( <slastcol>.getcx, <slastcol>.getcy ), 255, 0 );
	}
	mresetcol	{
		anlight.hide;
		imbrush.paint( .black, 255, 0 );
	}
	mouse_move	{
		.setbrushpos;
	}
	setbrushpos	{
		if( .checktouchpad )
			imbrush.setpos(mouse.getpx-imbrush.getw/2, mouse.getpy-imbrush.geth/2);
		else
			imbrush.setpos(mouse.getpx-imbrush.getw, mouse.getpy-imbrush.geth);
	}
	msetbrush(string s)	{
		grbrush.setframe(-1,0);
		<s>.setframe(-1,1);
		anpaint.setframe( 0, <s>.actionnr(-1) );
		.mbrushsize(0);
	}
	checkbrushpos	{
		if( igmandroid )	{
			imbrush.scpos(1140, 520);
			imbrush.move( -imbrush.getw/2, -imbrush.geth/2 );
		} else if( .checktouchpad )	{
			imbrush.scpos(970, 650);
			imbrush.move( -imbrush.getw/2, -imbrush.geth/2 );
		}
	}
	butclick_anbutexit	{
		bcandraw = false;
		.msavefile;
		.askfor("MenuImgStd");
	}
}



game IntroNelaShip : MermaidStd	{
	init	{
		MermaidStd::init("intros");
		.img = ("bgintro.jpg");
		ccs.enter(func {
			.timplay("timend", 3000, "mend");
			} );
		.playmainmusic;
	}
	mend	{	.stdexit("MenuPlayerNelaShip");	}
	mouse_lclick	{	.mend;	}
}

game OutroNelaShip : MermaidStd	{
	init	{
		MermaidStd::init("intros");
		.img = ("bgoutro.jpg");
		ccs.enter(func {
			.timplay("timend", 3000, "mend");
			} );
	}
	mend	{	.stdexit("exit");	}
	mouse_lclick	{	.mend;	}
}

new string sNelaShipPlayer = "player1";

game MenuPlayerNelaShip : MermaidStd	{
	init	{
		MermaidStd::init("menus");
		.imgs = (A, "bghero.jpg", "players.pyzG 10", "buttop.pyz 10");
		grplayers.eval( func {
			.Button_stdalpha;
			.addmethod("butclick", func {
				if( .advstdstate )	{
					sNelaShipPlayer = .actionname; 
					.stdexit("MenuLevelNelaShip");
				}
				} );
			butgame.add(this);
			} );
		anbuttop.Button_addstdstate;
		.cbutexit;
		.loadasker;
		
		.stdenter;
	}
	butclick_anbutexit	{
		.askfor("OutroNelaShip");
	}
	butclick_anbuttop	{
		.stdexit("MenuTopNelaShip");
	}
	key_down	{
		if( igmdebug )	{
			if( keyboard.iskey("m") )
				gameapi.play("ShipMaps");
		}
	}
}

game MenuTopNelaShip : MermaidStd	{
	init	{
		MermaidStd::init("menus");
		.imgs = (A, "bglevel.jpg", "topkola.pyzG 10", "toplistwy.pyzG 5", "topplayer.pyzH 15");
		
		new classfullsave csave("arcade_nela_top.db");
		csave.saveonset=(true);
		csave.stdload;
		
		@sfilefont = "configs/fonts/seren1.ttf";
		@size = 50->igetsc;
		.newfont("fntrek", sfilefont, size);
		@sfont = "fntrek";
		
		new bool binput = iNelaShipPoints > 0;
		if( binput )	{
			int pos = 6;
			for( int p=1; p<=5; p++ )	{
				@s = csave.get("points"+p);
				if( s==null || s.to_i < iNelaShipPoints )	{
					for( int p2=5; p2>p; p2-- )	{
						@p3 = p2-1;
						csave.replace( "points"+p2, "points"+p3 );
						csave.replace( "player"+p2, "player"+p3 );
						csave.replace( "playername"+p2, "playername"+p3 );
					}
					csave.set("points"+p, iNelaShipPoints);
					csave.set("player"+p, sNelaShipPlayer);
					csave.set("playername"+p, "");
					pos = p;
					p = 6;
				}
			}
		}
		for( int i=1; i<=5; i++ )	{
			@s = csave.get("player"+i);
			if( s!=null )	{
				@sp = "anplayer"+i;
				.copyanima("antopplayer",sp);
				<sp>.setframe(s,0);
				<sp>.show;
				<sp>.ancenterimg(grtopkola.get(i-1));
				@st = "txtp"+i;
				.newtext(st, csave.get("points"+i), sfont, .red);
				<st>.setz( 20 );
				@sl = grtoplistwy.get(i-1);
				<st>.setpos( <sl>.getpx + 80->igetsc - <st>.getw/2, <sl>.getcy-<st>.geth/2 );
				@sn = "txtnom"+i;
				.newtext(sn, csave.get("playername"+i), sfont, .red);
				<sn>.setpos( <sl>.getpx + 200->igetsc, <sl>.getcy-<st>.geth/2 );
				<sn>.setz( 20 );
			}
		}
		if( binput )	{
			if( pos<=5 )	{
				@slistwa = grtoplistwy.get(pos-1);
				
				@dx = 5->igetsc1;
				@startx = 920->igetsc - ((BYTEZ-BYTEA)*(size+dx))/4;
				@x = startx;
				int pol = (BYTEZ+BYTEA)/2;
				if( pos<5 )
					@y = <slistwa>.getey;
				else @y = <grtoplistwy.get(3)>.getpy;
				@starty = y;
				new gmimgvec grtx;
				new int iposplayer = pos;
				int w;
				new string stxtplayer = "txtnom"+pos;
				for( int i=BYTEA; i<=BYTEZ; i++ )	{
					@s = "txta"+i;
					@st = "a";
					st.setbyte(0,i);
					.newtext(s, st, sfont, .red);
					<s>.setz( 26 );
					<s>.setpos( x, y );
					if( i>pol )	{
						pol = BYTEZ;
						x = startx;
						y += 1.5*size;
						w = <s>.getex;
					} else 
						x+=<s>.getw+dx;
					grtx.add(s);
					<s>.Button_stdms;
					<s>.addmethod("butclick", func {
						if( .advstdstate )	{
							@s = <stxtplayer>.get;
							if( s.length < 10 )	{
								<stxtplayer>.txtset( s+.get );
							} else <stxtplayer>.txtset( s.strsube(1) + .get );
							.mupdateplayer;
						}
						} );
					butgame.add(s);
				}
				.newtext("txdel", "<", sfont, .red);
				txdel.setpos( w+dx, starty );
				txdel.setz( 24 );
				txdel.Button_stdms;
				txdel.addmethod("butclick", func {
					if( .advstdstate )	{
						@s = <stxtplayer>.get;
						if( s.length > 0 )	{
							<stxtplayer>.txtset( s.strsube(1) );
						}
						.mupdateplayer;
					}
					} );
				butgame.add("txdel");
				@h = <grtx.last>.getey;
				grtx.add("txdel");
				w = txdel.getex;
				new img imbgtxt;
				
				imbgtxt.create( (w-startx) + 2*dx, (h - starty) + 2*dx, .grey(32), 192 );
				imbgtxt.setz( 22 );
				imbgtxt.setpos( startx-dx, starty-dx );
				
				new int ipikaczu = pos;
				.timplay("timpik", 500, func {
					if( <"anplayer"+ipikaczu>.isvisible )	{
						<"anplayer"+ipikaczu>.hide;
						<"txtnom"+ipikaczu>.hide;
						<"txtp"+ipikaczu>.hide;
					} else {
						.showpikaczu;
					}
					.play;
					} );
			}
			iNelaShipPoints = 0;
		}
		
		.cbutexit;
		
		.stdenter;
	}
	mupdateplayer	{
		csave.set("playername"+iposplayer, <stxtplayer>.get);
		sndfxmoveon2.play;
	}
	showpikaczu	{
		<"anplayer"+ipikaczu>.show;
		<"txtnom"+ipikaczu>.show;
		<"txtp"+ipikaczu>.show;
	}
	butclick_anbutexit	{
		.stdexit("MenuPlayerNelaShip");
	}
}

new int iNelaShipLevel = 1;
new int iIleNelaShipLevels = 12;
new int iNelaShipPoints = 0;
game MenuLevelNelaShip : MermaidStd	{
	init	{
		MermaidStd::init("menus");
		.imgs = (A, "bglevel.jpg", "levels.pyzG 10");
		
		new classfullsave csave("arcade_nela.db");
		csave.saveonset=(true);
		csave.stdload;
		csave.bset("enable_level1");
		
		grlevels.each( func { (@id)
			.Button_stdalpha;
			
			//if( csave.bis("enable_level"+(id+1)) )	{
				.addmethod("butclick", func {
					if( .advstdstate )	{
						iNelaShipLevel = .actionnr(-1)+1; 
						iNelaShipPoints = 0;
						music.fadeout(1000);
						.stdexit("NelaShipRaid");
					}
					} );
			//} else .imgsetoverlay(.white, 128);
			butgame.add(this);
			} );
		.cbutexit;
		
		.stdenter;
	}
	butclick_anbutexit	{
		.stdexit("MenuPlayerNelaShip");
	}
}


class NelaShipCommon : MermaidStd	{
	init(string s)	{
		new int iiletor = 30;
		MermaidStd::init(s);
	}
	isspecship(string s)	{
		s=="en1" || s=="en2" || s=="en3" || s=="en4" || s=="en5" || s=="en6" || s=="kam1" || s=="kam2" || s=="kam3" ||
		s=="fire1" || s=="fire2" || s=="fire3" || s=="fire4" || s=="fire5" || s=="fire6";
	}
}

game NelaShipRaid : NelaShipCommon	{
	init	{
		NelaShipCommon::init("mg_raid");
		
		.sfxs = (A, "laser 20", "askerups 50", "rekord 50");
		.mkfxset("bum", 3, 50);
		.mkfxset("eksplozja", 2, 50);
		.mkfxset("cios", 4, 30);
		.mkfxset("step2", 4, 30);
		.mkfxset("butmoveon2", 8, 30);
		.mkfxset("bat", 4, 30);
		
		.cbutexit;
		.loadasker;
		._loadasker2("restart.pyz", "anrestart");
		.newimg("imgpasek", "pasek.png", 200);
		
		new string sfilefont = "configs/fonts/seren1.ttf";
		.newfont("fntseren", sfilefont, 25->igetsc);
		.newtext("txtinfo", "", "fntseren", .red);
		txtinfo.setpos( anbutexit.getex + 50->igetsc, imgpasek.getcy - txtinfo.geth );
		new int iPoints = iNelaShipPoints;
		txtinfo.setz( imgpasek.getz + 10 );
		
		new db dblev;
		dblev.load( .getpath("level"+iNelaShipLevel+".db") );
		.newimg("imgbg1", "tlo_gry"+dblev.dbgetdef("bkg:",1)+".jpg", 0 );
		.imgs = (A, /*"bg1.jpg", */"bg_sun.pyz 5", "bg_planetsG.pyz 10");
		
		new classfullsave csave("arcade_nela.db");
		csave.saveonset=(true);
		csave.stdload;
		
		new bool bmouselrel = true;
		
		new gmobjvec grpause;
		
		new classadvcamera camera;
		grpause.add("camera");
		camera.setborders(imgbg1.getw, imgbg1.geth);
		//camera.countcenter;
		camera.setcenterscreen; 
		//camera.setactor("mouse");
		new int icameraposy = imgpasek.geth;
		
		/*@dy = 50->igetsc;
		camera.setscreen(0, dy, imgbg1.getw, imgbg1.geth);
		camera.setcenter(igmappw/2, (igmapph/2)+dy);*/
		
		new classbgplan plan0;
		camera.addbgr("plan0", 0.3, 0.3);
		//plan0.add("imgbg1");
		SetAnMover::setas("imgbg1", -1, 0);
		imgbg1.sam_copy;
		//plan0.add( imgbg1.get_sam_copy );
		
		new classbgplan plan1;
		camera.addbgr("plan1", 0.5, 0.5);
		plan1.add("anbg_sun");
		new int id_planet = 0;
		new real rstartx = 0.8;
		new real rstarty = 0.8;
		for( int i=0; i<grbg_planets.size; i++ )
			.addnextp;
		new string slastplan = "planplan"+(id_planet-1);
		
		//camera.scalemodifiers(0.02, 0.02);
		
		int x = igmappw - anbg_sun.getpx;
		anbg_sun.move(x,0);
		grbg_planets.move(x,0);
		new bool bcheckplanets = true;
		
		.cycle=("timniebo", func {
			imgbg1.sam_move;
			if( bcheckplanets )	{
				int x = imgbg1.moved_x;
				if( x )	{
					anbg_sun.move(x,0);
					grbg_planets.move(x,0);
					if( anbg_sun.getex < -anbg_sun.getw )	{
						bcheckplanets = false;
						camera.remove("plan1");
						anbg_sun.hide;
						for( int i=0; i<grbg_planets.size; i++ )	{
							camera.remove("planplan"+i);
							<grbg_planets.get(i)>.hide;
						}
					}
				}
			}
			.play;
			} );
		timniebo.play;
		grpause.add("timniebo");
		
		.newanima("anship", "ship1.pyz", 100);
		.copyanima("anship", "anstest");
		anstest.hide;
		anship.play(0);
		anship.move( -anship.getex, 0 );
		grpause.add("anship");
		
		.newanima("anbulet", "bulet.pyz", 100);
		anbulet.hide;
		int ilecnt = 50;
		new SimpleCounter cntbul(ilecnt);
		new int ibuletspeed = 15->igetsc;
		if( ibuletspeed<1 ) ibuletspeed = 1;
		
		.newanima("anfire", "fire.pyz", 110);
		new SimpleCounter cntfire(ilecnt);
		new int ifirespeed = -ibuletspeed;
		anfire.hide;
		
		.newanima("anels", "els.pyz", 110);
		new SimpleCounter cntbum(ilecnt);
		.newanima("anbums", "bums.pyz", 110);
		anbums.hide;
		new map2 vship("int");
		new gmobjvec grspec;
		for( int i=0; i<anels.nofactions; i++ )	{
			@s = anels.nameofaction(i);
			if( .isspecship(s) && s.getb(0,4)!="fire" )	{
				vship.add(s,0);
				grspec.add(s);
			}
		}
		
		for( int i=0; i<ilecnt; i++ )	{
			@s = "anbulet"+i;
			.copyanima("anbulet", s);
			grpause.add(s);
			<s>.addmethod("onfinish", func {
				if( grels2.isin(.getcx, .getcy,1,1) )	{
					@s = grels2.getsfound;
					@sac = <s>.actionname;
					match(sac)	{
						// met star sat glaz p1 p2 hole p3 en1 en2
						"en1","en2","en3","en4","en5","en6","kam1","kam2","kam3","fire1","fire2","fire3","fire4","fire5","fire6" => {
							.anhide;
							<s>.lives = (<s>.lives - 1);
							if( <s>.lives<=0 )	{
								<s>.anhide;
								.moutel(s);
								@s2 = "anbums"+cntbum.next;
								<s2>.play(sac);
								<s2>.ancenterimg(s);
								string sac2 = (sac.getb(0,4)=="fire" ? "en" + sac.gete(0,1) : sac);
								vship.calc(sac2,"+",1);
								iPoints += sac.gete(0,1);
								.mprintstatus;
								if( sac.gete(0,1)->to_i > 3 )	{
									.fxsetplay("eksplozja");
								} else {
									.fxsetplay("bum");
								}
							} else {
								.fxsetplay( sac.getb(0,1)=="k" ? "step2" : "cios" );
							}
						}
						"hole","sat","star","p1","p2","p3" => ;
						? => .anhide;
					}
				}
				if( .isvisible )	{
					.move(ibuletspeed, 0);
					if( .getpx >= igmappw )	{
						.anhide;
					}
					.play(0);
				}
				} );
			
			s = "anbums"+i;
			.copyanima("anbums",s);
			
			s = "anfire"+i;
			.copyanima("anfire",s);
			grpause.add(s);
			<s>.addmethod("onfinish", func {
				if( anship.isin(.getpx,.getcy,1,1) )	{
					.anhide;
					.mshipbum;
				} else {
					.move(ifirespeed, 0);
					if( .getex < 0 )	{
						.anhide;
					} else
						.play(-1);
				}
				} );
		}
		
		new int xship;
		new int yship;
		new gmimgvec grels;
		new gmimgvec grels2;
		new int ienemyspeed = 6->igetsc1;
		new int idroga = 0;
		new real rshipspeed = 10.0->rgetsc;
		.cycle = ("timship", func {
			if( .advisstate("state_shipgo") )	{
				real destx = mouse.getpx;
				real desty = mouse.getpy;
				if( desty < icameraposy+yship ) desty=icameraposy+yship;
				real x = destx - (anship.getpx + xship);
				real y = desty - (anship.getpy + yship);
				real rlen = x.length(x,y);
				if( rlen>0 ) {
					if( rlen <= rshipspeed )	{
						//anship.ansetbpos(destx+xship, desty+yship);
						if( bmouselrel )
							.advsetstdstate;
					} else
						anship.move( x/rlen*rshipspeed, y/rlen*rshipspeed );
				}
			} else if (.advisstate("state_starting") )	{
				anship.move(rshipspeed, 0);
			}
			int i = 0;
			idroga -= ienemyspeed;
			while( i < grels.size )	{
				@s = grels.get(i);
				if( (<s>.getpx+idroga+<slastplan>.getpx) < igmappw )	{
					<s>.move(idroga+ienemyspeed+<slastplan>.getpx,<slastplan>.getpy + icameraposy);
					<slastplan>.add(s);
					grels2.add(s);
					grels.removeat(i);
					if( <s>.actionname->getb(0,4)=="fire" )	{
						<s>.addmethod("onfinish", func {
							.play(-1);
							if( 5->rand==0 )	{
								@s = "anfire"+cntfire.next;
								<s>.play(.actionname);
								<s>.setpos(.getposx,.getposy);
								.fxsetplay("bat");
							}
							} );
						<s>.play(-1);
					}
				} else {
					i = grels.size;
				}
			}
			i=0;
			while( i < grels2.size )	{
				@s = grels2.get(i);
				<s>.move( -ienemyspeed, 0 );
				if( <s>.getex < 0 )	{
					.moutel(s);
					if( grels.empty && grels2.empty && anship.isvisible )	{
						<GAME>.mfinish;
					}
				} else {
					// badanie uderzen
					if( <s>.bboomer )	{
						for( int j=0; j<anstest.nofframes(1); j++ )	{
							anstest.setframe(1, j);
							anstest.setpos( anship.getposx, anship.getposy );
							if( <s>.isin( anstest.getcx, anstest.getcy, 1, 1 ) && anship.isvisible )	{
								j = anstest.nofframes(1);
								i = grels2.size;
								.mshipbum;
							}
						}
					}
					i++;
				}
			}
			.play;
			} );
		timship.play;
		grpause.add("timship");
		.timer = ("timbulet", 500, func {
			@s = "anbulet"+cntbul.next;
			<s>.setpos( anship.getposx, anship.getposy );
			//<s>.ansetbpos( anship.getpx, anship.getpy );
			<s>.play(0);
			.play;
			fxlaser.play;
			} );
		grpause.add("timbulet");
		
		real rlenx = imgbg1.getw * iiletor;
		real rleny = imgbg1.geth;
		int col;
		new classbgplan planels;
		camera.addbgr("planels", 1, 1);
		slastplan = "planels";
		for( i=0; i<dblev.getrowsno; i++ )	{
			@sac = dblev.get(i,0);
			if( sac!="bkg:" )	{
				@san = "anels"+i;
				.copyanima("anels",san);
				
				if( .isspecship(sac) )	{
					<san>.play(sac);
					<san>.ansetrandfr;
					<san>.var2("lives", sac.gete(0,1)->to_i);
					col=1;
				} else {
					<san>.setframe(sac, dblev.get(i,1) );
					<san>.show;
					col=2;
				}
				<san>.var2("bboomer", !<san>.actionname->in(A,"hole","sat","star","p1","p2","p3"));
				<san>.ansetbpos( dblev.get(i,col)->to_r*rlenx + igmappw, dblev.get(i,col+1)->to_r*rleny );
				if( sac.in(A,"hole","sat","star","p1","p2","p3") )
					<san>.setz( anship.getz-5 );
				else <san>.setz( anship.getz+5 );
				grels.add(san);
				//<slastplan>.add(san);
			}
		}
		anels.hide;
		grpause.add("grels2");
		
		new int campos;
		camera.moveplans(0,icameraposy);
		campos.addmethod("getposx", func { anship.getcx; } );
		campos.addmethod("getposy", func { anship.getcy; } );
		camera.setactor("campos");
		//camera.setscene;
		
		camera.scalemodifiers(0.02, 0.02);
		
		plan0.add("imgbg1");
		plan0.add(imgbg1.get_sam_copy);
		
		camera.start;
		
		.mprintstatus;
		
		ccs.enter( func {
			.advsetstate("state_starting");
			timbulet.play;
			//timlevel.play;
			.timplay("timstart", 1000, "advsetstdstate");
			} );
	}
	mshipbum	{
		.advsetstate("state_fail");
		anship.anhide;
		timbulet.stop(false);
		camera.stop;
		@s2 = "anbums"+cntbum.next;
		<s2>.addmethod("onfinish", func {
			if( sgmstate=="state_fail" )	{
				._showasker("anrestart");
				fxaskerups.play;
			}
			} );
		<s2>.play("en1");
		<s2>.ancenterimg("anship");
		.fxsetplay("eksplozja");
	}
	mprintstatus	{
		txtinfo.txtset("Level "+iNelaShipLevel + "   Points: "+iPoints);
	}
	mfinish	{
		if( iNelaShipLevel < iIleNelaShipLevels )	{
			csave.bset("enable_level"+(iNelaShipLevel+1));
		}
	
		fxlaser.setvol(2);
		._loadasker2("points.pyz", "anpoints");
		.copyanima("anpointsbg", "anpointsdim");
		anpointsdim.setframe("wymiar",0);
		anpointsdim.hide;
		@dy = anpointsdim.geth/7;
		@y = anpointsdim.getpy+3->igetsc1;
		@ika = 1;
		@ien = 1;
		@xka = anpointsdim.getpx + 10->igetsc;
		@xen = anpointsdim.getcx + 10->igetsc;
		@xtka = xka + 110->igetsc;
		@xten = xen + 110->igetsc;
		//@sfont = .stdfont(18->igetsc);
		
		@sfont = "fntseren";
		new string sTxtPoints = "Total Points: ";
		new string stxtrecord = "Current Record: ";
		new string stxtbonus = "Bonus Points: ";
		new int iLevelPoints = 0;
		new int iCurPoints = 0;
		new int iCurRecord = csave.get("record"+iNelaShipLevel);
		new int iBonus = iNelaShipLevel*20;
		@z = anpointsbg.getz + 1;
		new gmimgvec grekord;
		
		.newtext("txtrec", stxtrecord+iCurRecord, sfont, 255,64,64);
		txtrec.setpos( anpointsdim.getcx - txtrec.getw/2, y );
		txtrec.setz( z );
		txtrec.hide;
		grekord.add("txtrec");
		
		.newtext("txtpoints", sTxtPoints+iCurPoints, sfont, .yellow);
		txtpoints.setpos( anpointsdim.getcx - txtpoints.getw/2, y + dy - txtpoints.geth);
		txtpoints.setz( z );
		txtpoints.hide;
		grekord.add("txtpoints");
		
		.newimg("imgbonus", "bonus.png", anpointsbg.getz + 2 );
		.newfont("fntseren2", sfilefont, 50->igetsc);
		.newtext("txtbonus", iBonus, "fntseren2", .red);
		imgbonus.ancenterscreen;
		imgbonus.move(0,-50->igetsc);
		txtbonus.setpos( imgbonus.getcx - txtbonus.getw/2, imgbonus.getcy - txtbonus.geth/2 );
		imgbonus.blit("txtbonus");
		delete txtbonus;
		delete fntseren2;
		imgbonus.hide;
		
		for( int i=0; i<grspec.size; i++ )	{
			@s = grspec.get(i);
			iLevelPoints += vship.get(s) * s.gete(0,1)->to_i;
			@san = "anel" + s;
			new img <san>;
			anels.setframe(s,0);
			<san>.imgclonezoom("anels", 0.3);
			<san>.setz( z );
			@stxt = "txt" + san;
			.newtext(stxt, 0, sfont, .yellow);
			<stxt>.setz( z );
			if( i<5 )	{
				ika++;
				<san>.setpos( xka, y + ika*dy - <san>.geth );
				<stxt>.setpos( xtka, y + ika*dy - <stxt>.geth );
			} else {
				ien++;
				<san>.setpos( xen, y + ien*dy - <san>.geth );
				<stxt>.setpos( xten, y + ien*dy - <stxt>.geth );
			}
			<san>.hide;
			<stxt>.hide;
			grspec.set(i, san);
			grekord.add(san);
			grekord.add(stxt);
		}
		iLevelPoints += iBonus;
		iNelaShipPoints += iLevelPoints;
		new bool bisrekord = false;
		if( iLevelPoints > iCurRecord )	{
			iCurRecord = iLevelPoints;
			bisrekord = true;
			csave.set("record"+iNelaShipLevel, iLevelPoints);
			.newimg("imgrekord", "rekord.png", anpointsbg.getz + 2 );
			.newfont("fntseren2", sfilefont, 50->igetsc);
			.newtext("txtnewrec", iCurRecord, "fntseren2", .red);
			imgrekord.ancenterscreen;
			imgrekord.move(0,-50->igetsc);
			txtnewrec.setpos( imgrekord.getcx - txtnewrec.getw/2, imgrekord.getpy + 0.55*imgrekord.geth );
			imgrekord.blit("txtnewrec");
			delete txtnewrec;
			delete fntseren2;
			imgrekord.hide;
		}
		._showasker("anpoints");
		anpointsyes.setz( anpointsbg.getz + 4 );
		anpointsno.setz( anpointsbg.getz + 4 );
		
		new int icykpoints = 0;
		.timer = ("timpoints", 70, func {
			if( icykpoints < grspec.size )	{
				@san = grspec.get(icykpoints);
				@s = san.strsubbs("anel");
				int ile = vship.get( s );
				if( ile>0 )	{
					vship.set(s,ile-1);
					@stxt = "txt"+san;
					int ile2 = s.gete(0,1);
					<stxt>.txtset( <stxt>.get->to_i + ile2 );
					iCurPoints += ile2;
					txtpoints.txtset(sTxtPoints + iCurPoints);
					.fxsetplay("butmoveon2");
				} else icykpoints++;
				if( icykpoints >= grspec.size )	{
					iCurPoints += iBonus;
					
					/*txtpoints.txtset(stxtbonus + iBonus);
					.timplay("timpoints2", 1500, func {
						txtpoints.txtset(sTxtPoints + iCurPoints);
						timpoints.play;
						} );*/
					fxrekord.play;
					imgbonus.anzoomin(idymekdelay, func {
						txtpoints.txtset(sTxtPoints + iCurPoints);
						.timplay("timpoints2", 1500, func {
							imgbonus.anzoomout(idymekdelay, func {
								timpoints.play;
								} );
							} );
						} );
					
				} else
					.play;
			} else {
				if( bisrekord )	{
					sgmstate = "state_showrekord";
					imgrekord.anzoomin(idymekdelay,func { sgmstate = "state_shownrekord"; } );
					anpointsbg.anzoomout(idymekdelay,null);
					grekord.hide;
					fxrekord.play;
				}
			}
			} );
	}
	asker_anpoints_shown	{
		grspec.eval( func { .show; <"txt"+this>.show; } );
		timpoints.play;
		txtpoints.show;
		txtrec.show;
	}
	preclick_anpointsyes	{
		if( sgmstate=="state_shownrekord" )
			.butclick_anpointsyes;
	}
	butclick_anpointsyes	{
		if( iNelaShipLevel < iIleNelaShipLevels )	{
			iNelaShipLevel++; 
			.stdexit("NelaShipRaid");
		} else {
			.mstdexittop;
		}
	}
	mstdexittop	{
		.playmainmusic;
		.stdexit("MenuTopNelaShip");
	}
	mstdexit	{
		.playmainmusic;
		iNelaShipPoints = 0;
		.stdexit("MenuPlayerNelaShip");
	}
	preclick_anpointsno	{
		if( sgmstate=="state_askexit" )	{
			grekord.hide;
		} else if ( sgmstate=="state_shownrekord" )	{
			.mstdexittop;
		}
	}
	butclick_anpointsno	{
		.mstdexittop;
	}
	moutel(string s)	{
		grels.remove(s);
		grels2.remove(s);
		<slastplan>.remove(s);
		<s>.anhide;
	}
	addnextp	{
		.addplanet(rstartx, rstarty);
		real dt = id_planet.to_r/(25.0->rgetsc);
		rstartx+=0.15->rgetsc + dt;
		rstarty+=0.15->rgetsc + dt;
	}
	addplanet(real rx, real ry)	{
		@s = "planplan"+id_planet;
		new classbgplan <s>;
		camera.addbgr(s, rx, ry);
		<s>.add(grbg_planets.get(id_planet));
		id_planet++;
	}
	mouse_lclick	{
		if( .advstdstate )	{
			@x = mouse.getpx;
			@y = mouse.getpy;
			if( y>icameraposy /*&& anship.isin( x, y, 1, 1 ) */)	{
				/*xship = x - anship.getpx;
				yship = y - anship.getpy;*/
				xship = anship.getw;
				yship = anship.geth/2;
				.advsetstate("state_shipgo");
				bmouselrel = false;
				
			}
		} else if( sgmstate=="state_shipgo" && anbutexit.isin(mouse.getpos,1,1) )
			.butclick_anbutexit;
	}
	mouse_lrel	{
		bmouselrel = true;
		/*if( sgmstate == "state_shipgo" )	{
			.advsetstdstate;
		}*/
	}
	key_down	{
		if( igmdebug )	{
			if( keyboard.iskey("m") )
				gameapi.play("ShipMaps");
			else if( keyboard.iskey("r") )
				gameapi.play(GAME);
		}
	}
	butclick_anbutexit	{
		grpause.pause;
		.showasker;
	}
	butclick_nostdstate_anbutexit	{
		if( sgmstate=="state_shownrekord" || sgmstate=="state_askexit" )	{
			.mstdexit;
		}
	}
	butclick_anaskeryes	{
		.mstdexit;
	}
	butclick_anaskerno	{
		grpause.resume;
		.advsetstdstate;
	}
	butclick_anrestartyes	{
		.stdexit(GAME);
	}
	butclick_anrestartno	{
		iNelaShipPoints = iPoints;
		.mstdexittop;
	}
}

game ShipMaps : NelaShipCommon	{
	init	{
		NelaShipCommon::init("mg_raid");
		
		new real rzoomer = 0.2;
		
		new img imgbg;
		imgbg.create( igmappw, igmapph, .white, 255 );
		
		//.imgs = (A, "bg1.jpg");
		
		new int iedgex = 50;
		new int iedgey = 50;
		new int iedgeex = igmappw-iedgex;
		new int iedgeey;
		@x = iedgex;
		@y = iedgey;
		new gmimgvec grels;
		new gmimgvec grtors;
		new img imgbg1;
		new img imgtor;
		new int iidbg = 1;
		new int iileshowtor = iiletor;
		.mloadbg;
		
		new int ielsx = <grels.first>.getpx;
		new int ielsex = <grels.last>.getex;
		new real rtorlenx = iiletor*imgtor.getw;
		
		.newtxtbut("imgleft", "left");
		.newtxtbut("imgright", "right");
		imgleft.setpos( 0, y+imgtor.geth );
		imgright.setpos( igmappw-imgright.getw, y+imgtor.geth );
		.newtxtbut("butnextbg", "next bg");
		butnextbg.setpos( imgleft.getpx, imgleft.getey + 20 );
		
		.newtxtbut("butsave", "save");
		@dx = 30;
		butsave.setpos( dx, igmapph - butsave.geth-dx );
		.newtxtbut("butload", "load");
		butload.setpos( butsave.getex+dx, butsave.getpy );
		.newtxtbut("butplay", "play");
		butplay.setpos( butload.getex+dx, butload.getpy );
		
		new string sprefile = "";
		@y = butload.getpy - butload.geth * 3;
		for( int i=1; i<=iIleNelaShipLevels; i++ )	{
			@s = "butload"+i;
			.newtxtbut(s, "load "+i);
			<s>.var2("myid",i);
			<s>.addmethod("butclick_"+s, func { .mload(myid); } );
			<s>.setpos( x, y );
			@s2 = "butsave"+i;
			.newtxtbut(s2, "save "+i);
			<s2>.var2("myid",i);
			<s2>.addmethod("butclick_"+s2, func { .msave(myid); } );
			<s2>.setpos( x, y+butload.geth+1 );
			@w = <s>.getw;
			if( <s2>.getw > w ) w = <s2>.getw;
			x+= w+5;
		}
		
		new int ielsmove;
		.cycle=("timove", func {
			if( sgmstate=="state_movels" )	{
				int mv = ielsmove;
				if( keyboard.iskeydown("space") )
					mv = 10*ielsmove;
				.movels(mv);
			}
			.play;
			} );
		
		new anima anship;
		anship.loadzoom( .getpath("ship1.pyz"), rzoomer, rzoomer );
		anship.setpos( 100, 100 );
		anship.setz(10);
		
		@sf = .stdfont(14);
		.newtext("txtf", "F", sf, .red );
		txtf.hide;
		
		new anima anels;
		anels.loadzoom( .getpath("els.pyz"), rzoomer, rzoomer );
		x = iedgex;
		y = imgleft.getey;
		int tmpy = y;
		new int inextel = 0;
		new gmimgvec grs;
		for( int i=0; i<anels.nofactions; i++ )	{
			anels.setframe(i,0);
			// met star sat glaz p1 p2 hole p3 en1 en2 kam1 kam2 kam3
			if( .isspecship(anels.actionname) )	{
				|x,y,tmpy| = .mputel( .maddel(i,0), x, y, tmpy );
			} else {
				for( int j=0; j<anels.nofframes(i); j++ )	{
					|x,y,tmpy| = .mputel( .maddel(i,j), x, y, tmpy );
				}
			}
			
			
		}
		anels.hide;
		new db dbsav;
		
		
		.newtext("txtcur", "", sf, .black );
		txtcur.setpos( 5, 2 );
		.msetcurlev;
		
		new DelayMover cmov;
		cmov.setclickrel(false);
		cmov.unlock;
		new gmimgvec grpat;
		
		timove.play;
		.advsetstdstate;
	}
	msetcurlev	{	txtcur.txtset("Current level: "+sprefile+", current bg: "+iidbg);	}
	mloadbg	{
		bool breload = grtors.size;
		if( breload )	{
			for( int i=1; i<=iileshowtor; i++ )	{
				@s = "imgtor"+i;
				delete <s>;
			}
		}
		imgbg1.load( .getpath("tlo_gry"+iidbg+".jpg") );
		imgbg1.anzoom(rzoomer);
		imgtor.imgclone("imgbg1");
		imgbg1.hide;
		@x = iedgex;
		@y = iedgey;
		iedgeey = iedgey + imgtor.geth;
		for( int i=1; i<=iileshowtor; i++ )	{
			@s = "imgtor"+i;
			new img <s>;
			<s>.copy("imgtor");
			<s>.setpos(x,y);
			x+=<s>.getw;
			<s>.mclip;
			if( !breload )	{
				grels.add(s);
				grtors.add(s);
			}
		}
		imgtor.hide;
	}
	mclip	{	.clip(iedgex,iedgey-5,iedgeex,iedgeey+5);	}
	munclip	{	.clip(0,0,igmappw,igmapph);	}
	mputel(string s, int x, int y, int tmpy)	{
		if( x+<s>.getw > iedgeex )	{
			x = iedgex;
			y = tmpy;
		}
		<s>.ansetbpos(x,y);
		x+=<s>.getw;
		if( <s>.getey > tmpy )
			tmpy = <s>.getey;
		grs.add(s);
		/*if( <s>.actionname->getb(0,4)=="fire" )	{
			txtf.txtcenter(s);
			<s>.blit("txtf");
		}*/
		return x,y,tmpy;
	}
	maddel(int iac, int ifr)	{
		@s = "anels" + inextel;
		.copyanima("anels", s);
		<s>.setframe(iac,ifr);
		inextel++;
		s;
	}
	movels1(int mv)	{
		//grels.move( mv, 0 );
		grels.eval1(func { (@w)
			.move(w,0);
			if( .gettype=="anima" )
				<GAME>.putoverlay(this);
			} , mv);
		ielsx += mv;
		ielsex += mv;
	}
	movels(int mv)	{
		.movels1(mv);
		if( ielsx > iedgex )	{
			.movels1( iedgex-ielsx );
		} else if ( ielsex < iedgeex )	{
			.movels1( iedgeex-ielsex );
		}
	}
	mmove(int ile)	{
		ielsmove = ile*10;
		sgmstate = "state_movels";
		timove.stop(true);
	}
	butclick_imgleft	{	.mmove(1);	}
	butclick_imgright	{	.mmove(-1);	}
	butclick_butnextbg	{
		if( .advstdstate )	{
			.mloadbgid(iidbg+1);
			.msetcurlev;
		}
	}
	mloadbgid(int id)	{
		iidbg = id;
		if( !engine.fileexist(.getpath("tlo_gry"+iidbg+".jpg")) )	{
			iidbg = 1;
		}
		<GAME>.mloadbg;
	}
	mouse_lrel	{
		if( sgmstate=="state_movels" )	{
			.advsetstdstate;
		}
	}
	cmov_GET	{
		if( .advstdstate )	{
			if( grs.isin(mouse.getpos,1,1) )	{
				@s = <GAME>.maddel(0,0);
				<s>.ancopy( grs.getsfound );
				.mgetel(s);
			} else if ( grpat.isin(mouse.getpos,1,1) )	{
				@s = grpat.getsfound;
				.mgetel(s);
				grpat.removeat(grpat.getfound);
				grels.remove(s);
			} else if ( anship.isin( mouse.getpos,1,1) )	{
				.mssetobj("anship");
			}
		}
	}
	mgetel(string s)	{
		.mssetobj(s);
		<s>.setz( 10 );
		.advsetstate("state_getel");
		<s>.munclip;
	}
	cmov_PUT	{
		.advsetstdstate;
		@s = .getfree;
		if( clsurf.commonimgsurf(s, iedgex, iedgey, iedgeex, iedgeey) )	{
			.mputpat(s);
		} else {
			<GAME>.moutpat(s);
		}
	}
	moutpat(string s)	{
		.vardel(s);
		if( .hasvar(s+"fire") )	{
			delete <s+"fire">;
		}
	}
	mputpat(string s)	{
		grpat.add(s);
		grels.add(s);
		<s>.mclip;
		<s>.setz( 5 );
		<s>.show;
		<GAME>.putoverlay(s);
	}
	putoverlay(string san)	{
		if( <san>.actionname->getb(0,4)=="fire" )	{
			@s = san + "fire";
			if( !.hasvar(s) )	{
				new img <s>;
				<s>.imgclone(san);
				<s>.paint(.red,128,0);
			}
			<s>.setz(<san>.getz+1);
			<s>.setpos(<san>.getpx, <san>.getpy);
		}
	}
	mdelall	{
		grels.removegr("grpat");
		//grpat.deleteallgm;
		grpat.eval( func {
			<GAME>.moutpat(this);
			} );
		grpat.free;
	}
	butclick_butsave	{	.msave(sprefile);	}
	msave(string spref)	{
		sprefile = spref;
		if( .advstdstate )	{
			grpat.sortpx;
			dbsav.free;
			dbsav.dbaddstringrow("bkg: "+iidbg, " ");
			for( int i=0; i<grpat.size; i++ )	{
				@s = grpat.get(i);
				real ry = (<s>.getpy - iedgey)->to_r/imgtor.geth->to_r;
				real rx = (<s>.getpx - ielsx)->to_r/rtorlenx;
				@sac = <s>.actionname;
				int irow = dbsav.addrow-1;
				dbsav.add(irow, sac);
				if( !.isspecship(sac) )	{
					dbsav.add(irow,<s>.framenr);
				}
				dbsav.add(irow,rx);
				dbsav.add(irow,ry);
			}
			dbsav.save( .mgetfile );
		}
	}
	mgetfile	{	.getpath("level" + sprefile + ".db");	}
	butclick_butload	{	.mload(sprefile);	}
	mload(string spref)	{
		if( .advstdstate && engine.fileexist( .mgetfile ) )	{
			sprefile = spref;
			.mdelall;
			dbsav.load( .mgetfile );
			int col;
			for( int i=0; i<dbsav.getrowsno; i++ )	{
				@sac = dbsav.get(i,0);
				if( sac=="bkg:" )	{
					.mloadbgid(dbsav.get(i,1));
				} else {
					@iac = anels.actionnr(sac);
					if( .isspecship(sac) )	{
						@san = <GAME>.maddel(iac,0);
						col=1;
					} else {
						@san = <GAME>.maddel(iac, dbsav.get(i,1) );
						col=2;
					}
					<san>.ansetbpos( dbsav.get(i,col)->to_r*rtorlenx + ielsx, dbsav.get(i,col+1)->to_r*imgtor.geth->to_r + iedgey );
					.mputpat(san);
				}
			}
			.msetcurlev;
		}
	}
	butclick_butplay	{
		if( .advstdstate )	{
			/*.butclick_butsave;
			dbsav.load( .mgetfile );
			dbsav.save( .getpath("level1.db") );*/
			iNelaShipLevel = sprefile;
			gameapi.play("NelaShipRaid");
		}
	}
}



new int iBajRewSpeed = 4->igetsc1;
new int iBajkaRecord = .readcfg("bajka_record:",0);

game IntroBaj3Swinki : MermaidStd	{
	init	{
		MermaidStd::init("menu");
		
		.imgsgr = (A, "bgmenu.jpg", "tytul.pyzH 10",
			"grels");
		
		.playmainmusic;
		
		.cycle = ("timbok", func {
			grels.move(-iBajRewSpeed, 0 );
			if( imgbgmenu.getex < igmappw )	{
				grels.move( igmappw-imgbgmenu.getex, 0 );
				<GAME>.mstart;
			} else .play;
			} );
		
		new bool bcanwatch = false;
		new bool bwaitclick = false;
		.snd = ("sndtyt", "tytul", "mgo");
		
		ccs.enter( func { .advsetstdstate; timbok.play; } );
		//gameapi.play("Bajka3Swinki");
	}
	mouse_lclick	{
		if( .advstdstate )	{
			if( bwaitclick )	{
				bwaitclick = false;
				.mtytul;
			} else
				.mgo;
		}
	}
	mstart	{
		int dx;
		if( imgbgmenu.getex < igmappw ) dx = imgbgmenu.getex-igmappw;
		else dx = igmappw - imgbgmenu.getex;
		grels.move( dx, 0 );
		timbok.stop(false);
		if( iBajkaRecord )	{
			bwaitclick = true;
		} else .mtytul;
	}
	mtytul	{
		.cbplay("sndtyt");
		antytul.anzoomin(300, func { bcanwatch=true; });
	}
	mgo	{
		if( iBajkaRecord )	{
			if( !bwaitclick )
				.stdexit("Bajka3Swinki");
		} else
			.stdexit("MenuBaj3Swinki");
	}
}

game MenuBaj3Swinki : MermaidStd	{
	init	{
		MermaidStd::init("menu");
		
		.imgsgr = (A, "bgmenu.jpg", "tytul.pyz 10",
			"grels");
			
		.cbutexit;
		.cbutmusic;
		.loadasker;
		
		antytul.Button_addstdalpha;
		antytul.addmethod("isbutin", func { (@x, @y)
			!anbutexit.isin(x,y,0,0) && !anbutexit.isin(x,y,0,0);
			} );
		
		grels.move( igmappw - imgbgmenu.getex, 0 );
		
		.stdenter;
	}
	mgo	{	.stdexit("Bajka3Swinki");	}
	butclick_antytul	{
		.mgo;
	}
	butclick_anbutexit	{
		.askfor("OutroBaj3Swinki");
	}
}

game OutroBaj3Swinki : MermaidStd	{
	init	{
		MermaidStd::init("outro");
		.img = ("bgoutro.jpg");
		ccs.enter(func {
			.timplay("timend", 5000, "mend");
			} );
		.stdenter;
	}
	mend	{	.stdexit("exit");	}
	mouse_lclick	{	.mend;	}
}

game Bajka3Swinki : MermaidStd	{
	init	{
		MermaidStd::init("bajka");
		
		ccs.benableloading=(false);
		
		.imgs = (A, "butnext.pyz 110", "butprev.pyz 110", "butplay.pyz 110", "butpuzle.pyz 110",
			"$"+.getgamepath+"outro/bgoutro.jpgH 20" );
		.with(A, "anbutnext", "anbutplay", "anbutprev", "anbutpuzle", "mrownaj");
		anbutnext.Button_addstdalpha;
		anbutprev.Button_addstdalpha;
		anbutpuzle.Button_addstdalpha;
		anbutplay.Button_isinalpha;
		butgame.add("anbutplay");
		new gmobjvec grpause;
		anbutplay.addmethod("butclick", func {
			if( .advstdstate )	{
				if( .framenr==0 )	{
					.setframe(-1,1);
					grpause.free;
					if( .cisplaying )	{
						grpause.add(.cgetactsnd);
					}
					grpause.add("timbok");
					grpause.pause;
				} else {
					.setframe(-1,0);
					grpause.resume;
					grpause.free;
				}
			}
			});
		
		.cbutexit;
		.cbutmusic;
		.loadasker;
		
		new img imgbaj;
		new int idbaj;
		new img imgbaj2;
		imgbaj2.hide;
		
		new gmobjvec grels;
		new int iidel = 0;
		new db dbels;
		new int idrow;
		
		new gmimgvec grimg;
		new int ibajspeed;
		grimg.add("imgbaj");
		.cycle = ("timbok", func {
			grimg.move(ibajspeed, 0 );
			if( (ibajspeed<0 && imgbaj.getex < igmappw) || (ibajspeed>0 && imgbaj.getpx > 0) )	{
				int dx;
				if( ibajspeed<0 )	{
					if( imgbaj.getex < igmappw ) dx = imgbaj.getex-igmappw;
					else dx = igmappw - imgbaj.getex;
				} else {
					if( imgbaj.getpx > 0 ) dx = -imgbaj.getpx;
				}
				grimg.move( dx, 0 );
				.mfinpage;
			} else .play;
			} );
		.cycle = ("timnextpage", "mnextpage");
		
		int ibaj = 1;
		if( clsave.has("bajka_idbajka") )
			ibaj = clsave.get("bajka_idbajka");
		.msetpage(ibaj);
		//.stdenter;
		.mhidebuts;
		ccs.enter( func {
			.advsetstdstate;
			.mnextrow;
			} );
	}
	mhidebuts	{
		if( iBajkaRecord )	{
			anbutnext.hide;
			anbutplay.hide;
			anbutprev.hide;
			anbutpuzle.hide;
			anbutexit.hide;
			anbutmuz.hide;
		}
	}
	mrownaj	{	.move(0, igmapph-.getey);	}
	butclick_anbutexit	{
		ccs.buildblack;
		.stdexit("MenuBaj3Swinki");
	}
	butclick_anbutnext	{	.mnextpage;	}
	butclick_anbutprev	{	.mprevpage;	}
	butclick_anbutpuzle	{	.mpuzle;	}
	mclear	{
		.creset;
		for( int i=0; i<grels.size; i++ )	{
			@s = grels.get(i);
			<s>.stop(false);
			delete <s>;
		}
		grels.free;
		for( i=0; i<grimg.size; i++ )	{
			s = grimg.get(i);
			if( s!="imgbaj" )	{
				delete <s>;
			}
		}
		grimg.free;
		grimg.add("imgbaj");
	}
	mgetsnd(string sfile)	{
		string ssnd = "snd" + sfile + iidel;
		iidel++;
		if( .issfx(sfile) )	{
			.newsfx(ssnd,sfile);
		} else .newsnd(ssnd, sfile);
		grels.add(ssnd);
		ssnd;
	}
	miscol(int idcol)	{	dbels.getcolsno(idrow) > idcol;	}
	mcol(int idcol)		{	dbels.get(idrow,idcol);	}
	mfinpage	{
		if( !timbok.isplaying && idrow>=dbels.getrowsno )	{
			if( idbaj >= iIleImgs )	{
				.mtheend;
			} else
				timnextpage.play;
		}
	}
	mnextrow	{ <GAME> {
		idrow++;
		if( idrow >= dbels.getrowsno )	{
			.mfinpage;
		} else {
			@s = dbels.get(idrow,0);
			if( s=="move:" )	{
				ibajspeed = .mcol(1)->to_i->igetsc1;
				if( ibajspeed>0 )	{
					grimg.move( igmappw - imgbaj.getex, 0 );
				}
				timbok.play;
				.mnextrow;
			} else if( s=="bkg:" )	{
				.mloadbaj;
				.mnextrow;
			} else if( s=="bg:" )	{
				.mloadbaj2;
				.mnextrow;
			} else if( s=="show:" )	{
				ccs.buildfromscreen;
				.mloadbaj2;
				.mshowpage("state_showpage");
			} else if( s=="hide:" )	{
				ccs.buildfromscreen;
				imgbaj2.hide;
				.mshowpage("state_hidepage");
			} else if( s=="left:" )	{
				grimg.move( -imgbaj.getpx, 0 );
				.mnextrow;
			} else if( s=="right:" )	{
				grimg.move( igmappw-imgbaj.getex, 0 );
				.mnextrow;
			} else if( s=="fxbg:" )	{
				s = .mgetsnd(dbels.get(idrow,1));
				if( .miscol(2) )
					<s>.setvol( .mcol(2) );
				<s>.play;
				.mnextrow;
			} else {
				s = .mgetsnd(s);
				if( .miscol(1) )
					<s>.setvol( .mcol(1) );
				<s>.addmethod("onfinish", func { .creset; .mnextrow; } );
				.cbplay(s);
			}
		}
	}; }
	mtheend	{
		.advsetstate("state_showtheend");
		ccs.buildfromscreen;
		imgbgoutro.show;
		ccs.enter( func {
			.advsetstdstate;
			} );
	}
	mloadbaj2	{
		imgbaj2.load( .mgetpath + dbels.get(idrow,1) + ".jpg" );
		imgbaj2.show;
		imgbaj2.setz( imgbaj.getz + 1 );
	}
	mloadbaj	{
		imgbaj.load( .mgetpath + dbels.get(idrow,1) + ".jpg" );
		imgbaj.show;
		imgbaj.setz( 10 );
	}
	mnextpage	{	.msetnextpage(1);	}
	mprevpage	{	.msetnextpage(-1);	}
	msetnextpage(int id)	{
		if( grpause.size )	{
			grpause.resume;
			grpause.free;
			anbutplay.setframe(-1,0);
		}
		ccs.buildfromscreen;
		ccs.show;
		.msetpage(idbaj+id);
		if( .advstdstate )
			.mshowpage("state_changepage");
	}
	mshowpage(string sstate)	{
		.advsetstate(sstate);
		ccs.enter( func {
			.advsetstdstate;
			.mnextrow;
			} );
	}
	msetpage(int id)	{
		if( id > iIleImgs ) {
			idbaj = iIleImgs+1;
			.mtheend;
		} else {
			imgbgoutro.hide;
			idbaj = id<1? 1 : id;
			if( idbaj==1 )	{
				anbutprev.hide;
			} else anbutprev.show;
			if( idbaj==iIleImgs ) anbutnext.hide;
			else anbutnext.show;
			.mloadnewpage;
		}
	}
	mgetpath	{	.getgamepath + "/imgs/";	}
	mloadnewpage	{ <GAME> {
		.mhidebuts;
		.mclear;
		timbok.stop(false);
		dbels.loadbeh( .getlangpath("str"+idbaj+".beh") ); 
		if( dbels.get(0,0) == "bkg:" )	{
			idrow = 0;
			.mloadbaj;
			dbels.removerow(0);
		} else {
			imgbaj.load( .mgetpath + "str"+idbaj+".jpg" );
			imgbaj.setz( 10 );
		}
		idrow = -1;
		imgbaj2.hide;
		match( dbels.get(idrow+1,0) )	{
			"right:" => grimg.move( igmappw-imgbaj.getex, 0 );
			"bg:" => {
				idrow++;
				.mloadbaj2;
				idrow--;
			}
			? => ;
		}
		//.mnextrow;
	}; }
	mpuzle	{
		clsave.set("bajka_idbajka", idbaj);
		//sMenuPuzzleExit = "MenuBaj3Swinki";
		sMenuPuzzleExit = "Bajka3Swinki";
		iPuzzleType = 1;
		//sPuzzleExit = "MenuBaj3Swinki";
		sPuzzleExit = "Bajka3Swinki";
		
		.newanima("anmat", "$" + .getgamepath + "/mg_puzzle/matryca_3_4.pyz",0);
		anmat.hide;
		int x = anmat.getpx;
		int y = anmat.getpy;
		anmat.setframe( 0, anmat.nofframes(0)-1 );
		imgPuzel.create( anmat.getex - x, anmat.getey - y, .transparent );
		imgPuzel.setpos(x,y);
		if( imgbgoutro.isvisible )
			imgPuzel.blit("imgbgoutro");
		else if( imgbaj2.isvisible )
			imgPuzel.blit("imgbaj2");
		else
			imgPuzel.blit("imgbaj");
		imgPuzel.hide;
		
		ccs.buildblack;
		.stdexit("MenuTrybPuzzle");
	}
	key_down	{
		if( igmdebug && keyboard.iskey("space") )	{
			.mpuzle;
		}
	}
	/*mouse_lclick	{
		if( .advstdstate )	{
			.cactsndstop(true);
			.creset;
		}
	}*/
	mouse_rclick	{
		if( igmdebug )	{
			//.mnextpage;
			.cactsndstop(true);
		}
	}
}


game IntroNelaZoo : MermaidStd	{
	init	{
		MermaidStd::init("intro");
		.img = ("bgintro.jpg");
		ccs.enter(func {
			.timplay("timend", 3000, "mend");
			} );
		.playmainmusic;
	}
	mend	{	.stdexit("MainMenuNelaZoo");	}
	mouse_lclick	{	.mend;	}
}

game MainMenuNelaZoo : MermaidStd	{
	init	{
		MermaidStd::init("mainmenu");
		
		sPuzleAnimalsExit = "MenuNelaZooAnimals";
		sKoloAnimalsExit = "MenuNelaZooAnimals";
		
		.cbutexit;
		.loadasker;
		
		.imgs = (A, "bgmenu.jpg", "buts.pyzG 10");
		
		grbuts.eval( func {
			.Button_stdstate;
			.addmethod("butclick", func {
				if( .advstdstate ) {
					match( .actionnr(-1) )	{
						0 => {
							.stdexit("NelaZooMenuZoo");
						}
						1 =>	{
							.stdexit("NelaZooFeed");
						}
						2 => {
							sMenuNelaZooAnimalsGame = "PuzleAnimals";
							.stdexit("MenuNelaZooAnimals");
						}
						3 => {
							sMenuNelaZooAnimalsGame = "KoloAnimals";
							.stdexit("MenuNelaZooAnimals"); 
						}
						? => ;
					}
				}
				} );
			butgame.add(this);
			} );
		.stdenter;
	}
	butclick_anbutexit	{	.askfor("OutroStd");	}
}

new string sMenuNelaZooAnimalsGame = "PuzleAnimals";
game MenuNelaZooAnimals : MermaidStd	{
	init	{
		imglobg.hide;
		MermaidStd::init("menu");
		
		.imgs = (A, "bgmenu.jpg", "buts.pyzG 10", "butkolo.pyzH 30", "butpuz.pyzH 30");
		.sfxs = (A, "lasergunshot1 40");
		
		grbuts.eval( func {
			if( .actionname->in(A, "slon", "malpa", "wielblad", "wol", "panda", "tygrys", "tukan", "rys",
				"orangutan", "waran", "szop", "ges") )	{
				.Button_stdalpha;
				.addmethod("butclick", func {
					if( .advstdstate )	{
						sChosenAnimal = .actionname;
						<GAME> {
							imgbgmenu.hide;
							grbuts.hide;
							imglobg.show;
							.newanima("anzwierz", "$"+.getgamepath + "puzle/puz_"+sChosenAnimal+".pyz", 20);
							.advsetstate("state_showbuts");
							anzwierz.anzoomin(idymekdelay, func {
								.advsetstate("state_checkgametype");
								.timplay("timgo", 500, func {
									.stdexit(sMenuNelaZooAnimalsGame);
									} );
								} );
						};
					}
					} );
				butgame.add(this);
				}
			} );
		
		.cbutexit;
		.loadasker;
		.stdenter;
	}
	butclick_anbutexit	{	.stdexit("MainMenuNelaZoo");	}
}

new int iNelaZooZooLevel = 1;
game NelaZooMenuZoo : MermaidStd	{
	init	{
		MermaidStd::init("menuzoo");
		.imgs = (A, "bgmenu.jpg", "butsmode.pyzG 10");
		
		.cbutexit;
		
		grbutsmode.eval( func {
			.Button_stdalpha;
			.addmethod("butclick", func {
				if( .advstdstate )	{
					match(.actionname)	{
						"pacman" => {
							clsave.set("nelazoo_mode","pacman");
							.mgo;
						}
						"feed" => {
							clsave.set("nelazoo_mode","feeder");
							.mgo;
						}
						? => ;
					}
				}
				} );
			butgame.add(this);
			.hide;
			} );
		ccs.enter( func {
			grbutsmode.eval( func { .show; .anzoomin(idymekdelay, "advsetstdstate"); } );
			} );
	}
	mgo {
		.stdexit("NelaZooMenuPac");
	}
	butclick_anbutexit	{	.stdexit("MainMenuNelaZoo");	}
}

game NelaZooMenuPac : MermaidStd	{
	init	{
		MermaidStd::init("menuzoo");
		.imgs = (A, "bgmenu.jpg", "butslevel.pyzG 10", "butstrud.pyz 10", "butshero.pyz 10");
		
		if( clsave.get("nelazoo_mode")=="pacman" )	{
		
		} else {
			anbutstrud.hide;
			.newanima("anstars", "$"+.getgamepath + "zoo/stars.pyz", 20);
			anstars.setframe(1,0);
			new classfullsave csave("arcade_zoo_records.db");
			csave.stdload;
			for( int i=1; i<=10; i++ )	{
				if( csave.has("last_recstars_"+i) )	{
					@s = grbutslevel.get(i-1);
					int ile = csave.get("last_recstars_"+i);
					for( int j=0; j<ile; j++ )	{
						@sim = "imstar"+i+"_"+j;
						new img <sim>;
						<sim>.imgclonezoom("anstars",0.7);
						<sim>.setpos( <s>.getpx + j*(0.7*<sim>.getw)+10->igetsc, <s>.getey-<sim>.geth-20->igetsc );
					}
				}
			}
			anstars.hide;
		}
		
		if( clsave.has("nelazoo_trud") )
			anbutstrud.setframe( clsave.get("nelazoo_trud"), 0 );
		else clsave.set("nelazoo_trud", anbutstrud.actionname );
		anbutstrud.ansetbpos( igmappw - anbutstrud.getw, igmapph-anbutstrud.geth );
		anbutstrud.Button_addstdstate;
		
		if( clsave.has("nelazoo_hero") )	{
			anbutshero.setframe( clsave.get("nelazoo_hero")->to_i, 0 );
		} else {
			anbutshero.setframe(3->rand,0);
			clsave.set("nelazoo_hero", anbutshero.actionnr(-1) );
		}
		anbutshero.ansetbpos( 0, igmapph-anbutshero.geth );
		anbutshero.Button_addstdstate;
		
		.cbutexit;
		
		grbutslevel.eval( func {
			.Button_stdalpha;
			butgame.add(this);
			.addmethod("butclick", func {
				if( .advstdstate )	{
					iNelaZooZooLevel = .actionnr(-1)+1;
					.advsetstate("state_waitgo");
					.timplay("timwait",idymekdelay, func {
						.stdexit("NelaZooZoo");
						} );
				}
				} );
			} );
		.stdenter;
	}
	butclick_anbutexit	{	.stdexit("NelaZooMenuZoo");	}
	butclick_anbutstrud	{	.stdexit("NelaZooMenuTrud");	}
	butclick_anbutshero	{	.stdexit("NelaZooMenuHero");	}
}

game NelaZooMenuTrud : MermaidStd	{
	init	{
		MermaidStd::init("menuzoo");
		.imgs = (A, "bgwybortrud.jpg", "butstrud.pyzG 10");
		grbutstrud.eval( func {
			.Button_stdalpha;
			.addmethod("butclick", func {
				if( .advstdstate )	{
					clsave.set("nelazoo_trud", .actionname );
					.stdexit("NelaZooMenuPac");
				}
				} );
			butgame.add(this);
			} );
		.cbutexit;
		.stdenter;
	}
	butclick_anbutexit	{	.stdexit("NelaZooMenuPac");	}
}

game NelaZooMenuHero : MermaidStd	{
	init	{
		MermaidStd::init("menuzoo");
		.imgs = (A, "bgwyborhero.jpg", "butshero.pyzG 10");
		grbutshero.eval( func {
			.Button_stdalpha;
			.addmethod("butclick", func {
				if( .advstdstate )	{
					clsave.set("nelazoo_hero", .actionnr(-1) );
					.stdexit("NelaZooMenuPac");
				}
				} );
			butgame.add(this);
			} );
		.cbutexit;
		.stdenter;
	}
	butclick_anbutexit	{	.stdexit("NelaZooMenuPac");	}
}

game NelaZooZoo : MermaidStd	{
	init	{
		MermaidStd::init("zoo");
		
		.imgs = (A, "bkg.jpg", "els.pyz 5");
		
		new bool bpacmode = clsave.get("nelazoo_mode")=="pacman";
		
		if( bpacmode )	{
			.imgs = (A, "zpac.pyz 3", "zdrap.pyz 3");
		} else {
			.imgs = (A, "zzwierze.pyz 3", "zzarcie.pyz 2", "tabliczkaH.pyz 200", "stars.pyzH 210");
			.copyanima("antabliczka", "antexit"); 		antexit.setframe("exit",0);
			.copyanima("antabliczka", "antrestart"); 	antrestart.setframe("restart",0);
			.copyanima("antabliczka", "antnext");		antnext.setframe("next",0);
			
			antexit.Button_stdalpha;
			antexit.addmethod("butclick", func { if( .advisstate("state_enpoints") ) .butclick_anbutexit; } );
			butgame.add("antexit");
			
			antrestart.Button_stdalpha;
			antrestart.addmethod("butclick", func { if( .advisstate("state_enpoints")) .stdexit(GAME); } );
			butgame.add("antrestart");
			
			antnext.Button_stdalpha;
			antnext.addmethod("butclick", func { if( .advisstate("state_enpoints")) .mnextlevel; } );
			butgame.add("antnext");
			
			new gmimgvec grstarbg;
			grstarbg.ancopiesname("anstars", "anstarbg", 4);
			new gmimgvec grstar;
			grstar.ancopies("anstars", 4);
		}
		// karmienie, zbieranie do klatek, ucieczka przed dzikimi- pac man, 
		
		.sfxs = (A, "askerups 40", "rekord 50", "pedzel 75" );
		.mkfxset("butmoveon2", 8, 40);
		.mkfxset("mikrofalaend", 4, 50);
		
		.cbutexit;
		
		new gmimgvec grels;
		grels.add("imgbkg");
		
		new bool bzoodebug = false;
		new int iPoints = 0;
		new string sfooder = null;
		
		new int iwsq = 55->igetsc;
		new int ihsq = 63->igetsc;
		new int ispeedx = 10->igetsc;
		
		new string sedgeobj = "imgbkg";
		new int iedgex = 0;
		
		new int iilesq = 0;
		new img imsq;
		imsq.create( iwsq, ihsq, .transparent );
		imsq.imgborders(2,.black,192);
		
		// level 1: 55x62
		
		if( bzoodebug )	{
			.newtext("txpom", "", .stdfont(14), .black);
		} else
			imsq.hide;
		
		new gmimgvec grsq;
		new gmimgvec grnd;
		new gmimgvec grpac;	// do pacmana
		new gmimgvec grzwierz;	// animy chodzace do zastopowania
		new gmimgvec grdrap;	// drapiezniki do pacmana
		
		.mloadid(iNelaZooZooLevel);
		.newfont("fntimer", .cfontpath, 40->igetsc);
		
		.newanima("anplayer", "zplayer.pyz", 10);
		anplayer.setframe(clsave.get("nelazoo_hero")->to_i,0);
		anplayer.msetaswalker;
		anplayer.icomptype = (0);	// oznaczenie, ze nie jest komputerem
		
		if( bpacmode )	{
			.newtext("txlevel", "Level "+iNelaZooZooLevel, "fntimer", .red);
			txlevel.setpos( anbutexit.getex + 20->igetsc, anbutexit.getpy );
			txlevel.setz(50);
			
			new img implayer0;
			implayer0.imgclonezoom("anplayer",0.5);
			implayer0.setpos( 20->igetsc, igmapph - implayer0.geth - 5->igetsc );
			implayer0.setz(5);
			new gmimgvec grlives;
			grlives.add("implayer0");
			match( iNelaZooZooLevel )	{
				1 => {
					anplayer.mputplayer(0,1);
					.madddrap("lew", 6, 16);
					.madddrap("hiena", 3, 10);
					.madddrap("hiena", 1, 12);
					.mlives(8);
				}
				2 => {
					anplayer.mputplayer(3,14);
					.madddrap("tygrys", 1, 5);
					.madddrap("krokodyl", 5, 2);
					.madddrap("hiena", 6, 26);
					.madddrap("lew", 1, 26);
					.mlives(8);
				}
				3 => {
					anplayer.mputplayer(6,4);
					.madddrap("lampart", 0, 0);
					.madddrap("krokodyl", 6, 18);
					.madddrap("krokodyl", 5, 25);
					.madddrap("krokodyl", 2, 18);
					.madddrap("krokodyl", 1, 29);
					.mlives(8);
				}
				4 => {
					anplayer.mputplayer(2,5);
					.madddrap("lampart", 2, 32);
					.madddrap("tygrys", 2, 33);
					.madddrap("lew", 2, 34);
					.madddrap("krokodyl", 2, 36);
					.madddrap("hiena", 2, 37);
					.mlives(8);
				}
				5 => {
					anplayer.mputplayer(2,5);
					.madddrap("lampart", 2, 32);
					.madddrap("lampart", 2, 40);
					.madddrap("tygrys", 2, 33);
					.madddrap("lew", 2, 34);
					.madddrap("krokodyl", 2, 36);
					.mlives(8);
				}
				6 => {
					anplayer.mputplayer(2,5);
					.madddrap("lampart", 2, 32);
					.madddrap("tygrys", 2, 40);
					.madddrap("tygrys", 2, 33);
					.madddrap("lew", 2, 34);
					.madddrap("krokodyl", 2, 36);
					.madddrap("hiena", 2, 37);
					.mlives(8);
				}
				7 => {
					anplayer.mputplayer(2,5);
					.madddrap("lampart", 2, 32);
					.madddrap("lampart", 2, 40);
					.madddrap("tygrys", 2, 33);
					.madddrap("lew", 2, 34);
					.madddrap("krokodyl", 2, 36);
					.madddrap("hiena", 2, 37);
					.mlives(8);
				}
				8 => {
					anplayer.mputplayer(6,2);
					.madddrap("lampart", 4, 32);
					.madddrap("lampart", 4, 38);
					.madddrap("tygrys", 4, 33);
					.madddrap("lew", 4, 34);
					.madddrap("krokodyl", 4, 36);
					.madddrap("hiena", 4, 37);
					.madddrap("hiena", 4, 35);
					.mlives(8);
				}
				9 => {
					anplayer.mputplayer(4,41);
					.madddrap("lampart", 0, 0);
					.madddrap("lampart", 2, 5);
					.madddrap("tygrys", 6, 17);
					.madddrap("tygrys", 0, 17);
					.madddrap("lew", 4, 20);
					.madddrap("krokodyl", 6, 29);
					.madddrap("krokodyl", 0, 39);
					.madddrap("hiena", 2, 26);
					.mlives(9);
				}
				10 => {
					anplayer.mputplayer(0,0);
					.madddrap("lampart", 0, 24);
					.madddrap("lampart", 0, 25);
					.madddrap("tygrys", 0, 26);
					.madddrap("tygrys", 0, 27);
					.madddrap("lew", 0, 28);
					.madddrap("lew", 0, 29);
					.madddrap("krokodyl", 0, 30);
					.madddrap("krokodyl", 0, 31);
					.madddrap("hiena", 0, 32);
					.madddrap("hiena", 0, 33);
					.mlives(10);
				}
				? => anplayer.mputplayersq(grsq.first);
			}
		} else {
			new classfullsave csave("arcade_zoo_records.db");
			csave.saveonset=(true);
			csave.stdload;
			new bool bisrekord;
			if( csave.has("last_rec_"+iNelaZooZooLevel) )	{
				bisrekord = csave.get("last_rec_"+iNelaZooZooLevel);
				new string srecord = clstrdigit::gettime(bisrekord, "ms");
			} else bisrekord = false;
			
			new int icurtime = 0;
			.newtext("txtime", "", "fntimer", .red);
			.mprinttime;
			txtime.setpos( anbutexit.getex + 20->igetsc, 8->igetsc );
			.timer = ("timczas", 1000, func {
				icurtime++;
				.mprinttime;
				.play;
				} );
		
			new db dbfood;
			dbfood.dbbuild(A,
				"lampart","udziec", "hiena","udziec", "krokodyl","udziec", "lew","udziec", 
				"orangutan","banan", "pingwin","ryba", "wielblad","kapusta", "lemur","banan",
				"ara","ziarno", "goryl","banan", "makak","banan", "tamaryna","banan", "papuga",
				"ziarno", "kangur","kapusta", "nosorozec","kapusta", "tukan","ziarno",
				"szympans","banan", "slon","kapusta", "zyrafa","kapusta", "bizon","kapusta",
				"zebra","kapusta", "wiewiorka","orzech", "kameleon","owad", "strus","kapusta",
				"wilk","udziec", "zajac","kapusta", "waz","udziec", "tygrys","udziec",
				2);
			new vector vzwierz; vzwierz.type("string");
			for( int i=0; i<dbfood.getrowsno; i++ )
				vzwierz.add(dbfood.get(i,0));
			vzwierz.remove("pingwin");
			new gmimgvec grsq2;
			grsq2.copy("grnd");
			new gmimgvec grfood;
			match( iNelaZooZooLevel )	{
				1 => {	.mzwierze(A, "bizon", "waz", "zyrafa"); }
				2 => {	.mzwierze(A, "strus", "zajac", "tygrys", "wielblad", "szympans"); }
				3 => {	.mzwierze(A, "goryl", "nosorozec", "slon", "wiewiorka", "ara", "zebra", "kameleon"); }
				4 => {	.mzwierze(A, "lampart", "kangur", "wilk", "zyrafa", "tukan", "makak", "hiena", "tamaryna"); }
				5 => {	.mzwierze(A, "krokodyl", "lew", "orangutan", "lemur", "papuga", "bizon", "zajac", "waz", "nosorozec"); }
				6 => {	.mzwierze(A, "tygrys", "szympans", "goryl", "slon", "ara", "zebra", "zajac", "kangur", "wiewiorka"); }
				7,8,9,10 => .mloszwierz(iNelaZooZooLevel+3);
				? => ;
			}
			new int iilezwierz = grfood.size;
			anplayer.mputplayersq(grsq2.first);
			anzzarcie.hide;
			anzzwierze.hide;
			
			.newtext("txpoints", "", "fntimer", .red);
			txpoints.hide;
			.timer = ("timpoints",70, func {
				ipetla--;
				iPoints+=raddpoints;
				//.mprinttime;
				.mprintpoints;
				.fxsetplay("butmoveon2");
				if( ipetla > 0 )	{
					.play;
				} else {
					timstars.play;
				}
				} );
			.timer = ("timstars", 500, func {
				.setdelay(200);
				iilestars--;
				<grstar.first>.show;
				grstar.removeat(0);
				.fxsetplay("mikrofalaend");
				if( iilestars > 0 )	{
					.play;
				} else {
					if( brekord )	{
						.timplay("timrekord", 1500, func {
							fxrekord.play;
							<GAME>.img = ("rekord.png "+(antabliczka.getz+20));
							imgrekord.setpos( (igmappw-imgrekord.getw)/2, antabliczka.getpy - imgrekord.geth/2 );
							imgrekord.anzoomin(idymekdelay, func {
								txpoints.txtset(iPoints);
								txpoints.txtcenter(this);
								txpoints.setz(.getz+5);
								txpoints.move(0,25->igetsc);
								.advsetstate("state_enpoints");
								} );
							} );
					} else .advsetstate("state_enpoints");
				}
				} );
		}
		if( bzoodebug )	{
			txpom.hide;
			imsq.hide;
		}
		
		.cycle=("timpos", func {
			.msetbgpos;
			.play;
			} );
		timpos.play;
		
		.timer = ("timblink", 200, func {
			if( iidtick > 0 )	{
				if( iidtick%2 )
					anplayer.ansetopacity(64);
				else anplayer.ansetopacity(255);
				iidtick--;
				.play;
			} else {
				anplayer.unlink_internal_filter;
			}
			} );
		timblink.vars2(A, "iiletick", 15, "iidtick", 0);
		
		anels.hide;
		if( bpacmode )	{
			anzdrap.hide;
			anzpac.hide;
		}
		ccs.enter( func {
			.advsetstdstate;
			grdrap.eval("mdrapstart");
			if( bpacmode )	{
			} else timczas.play;
			} );
	}
	mprintpoints	{
		txpoints.txtset("Points: "+iPoints);
		txpoints.txtcenter("antabliczka");
		txpoints.move(0, -60->igetsc);
	}
	mprinttime	{
		if( bisrekord )
			txtime.txtset("Level "+iNelaZooZooLevel+"  Record: "+srecord+" , "+clstrdigit::gettime(icurtime, "ms"));
		else
			txtime.txtset("Level "+iNelaZooZooLevel+"  "+clstrdigit::gettime(icurtime, "ms"));
	}
	mloszwierz(int ile)	{
		vzwierz.hash;
		for( int i=0; i<ile; i++ )	{
			.maddzwierz(vzwierz.get(i));
		}
	}
	mlives(int ile)	{
		match(clsave.get("nelazoo_trud"))	{
			"medium" => ile-=2;
			"hard" => ile-=4;
			? => ;
		}
		for( int i=1; i<ile; i++ )	{
			@s = "implayer"+i;
			new img <s>;
			<s>.copy("implayer0");
			<s>.setpos( <"implayer"+(i-1)>.getex + 3->igetsc1, implayer0.getpy );
			grlives.add(s);
		}
	}
	mdrapstart	{
		sstate = "dotarl";
		snextgnd = sactgnd;
		.mnextgnd;
	}
	madddrap(string sname, int row, int col)	{
		@s = "andrap"+grdrap.size;
		.copyanima("anzdrap", s);
		<s>.setframe(sname,0);
		<s>.msetaswalker;
		<s>.icomptype=(1);
		grdrap.add(s);
		<s>.mputplayer(row,col);
	}
	mzwierze	{	.withlist("maddzwierz");	}
	maddzwierz(string sname)	{
		@s = "anzwierz"+grdrap.size;
		.copyanima("anzzwierze", s);
		<s>.setframe(sname,0);
		<s>.msetaswalker;
		<s>.icomptype=(2);
		string sac = dbfood.dbgets(<s>.actionname, 1);
		<s>.vars2(A, "myfood", sac, "carryfood",null);
		grdrap.add(s);
		@sq = grsq2.rand;
		grsq2.remove(sq);
		<s>.mputplayersq(sq);
		
		
		s = "anfeed"+grfood.size;
		.copyanima("anzzarcie", s);
		<s>.setframe(sac,0);
		sq = grsq2.rand;
		grsq2.remove(sq);
		<s>.mputplayersq(sq);
		
		< <sq>.sfield>.spac = (s);	// zapamietaj zarcie
		
		grfood.add(s);
		<s>.setz(5);
		grels.add(s);
	}
	mnextgnd	{
		while( sstate=="dotarl" )	{
			sdestgnd = grnd.randdiff(sactgnd);
			.mcalcstep;
		}
	}
	msetaswalker	{
		.vars2(A, "sstate", "std", "sdestgnd", null, "sactgnd",null, "snextgnd",null, "icomptype", 0);
		new real rgndlen = 0.0;
		.setasanmover;
		new real rspeedx;
		new real rspeedy;
		.addmethod("onendframe", "mstdframe");
		.addmethod("onfinish", func {
			if( sstate=="moving" )	{
				.mputplayersq(snextgnd);
				if( .advstdstate )	{
					if( snextgnd != sdestgnd )	{
						.mcalcstep;
					} else {
						match( icomptype )	{
							1 => .mnextgnd;
							2 => { .mnextgnd; .mputcarryfood(carryfood);	}
							0 => sstate = "std";	// player
							? => ;
						}
					}
				}
			}
			} );
		grzwierz.add(this);
		grels.add(this);
	}
	mstdframe	{
		if( sstate=="moving" )	{
			.movereal( rspeedx, rspeedy );
			if( icomptype==0 )	{		// player
				if( sfooder!=null )	{
					anplayer.mputfood;
				}
			} else if( icomptype==1 )	{	// tryb pacman, zwierz zyrny
				if( !timblink.isplaying && 0->length(.getposx-anplayer.getposx, .getposy-anplayer.getposy) <= .getw && sactgnd==anplayer.sactgnd )	{
					@s = grlives.last;
					grlives.remove(s);
					<s>.anfadeout(idymekdelay, null);
					if( grlives.empty )	{
						.mstoppac;
						.advsetstate("state_pacfault");
						fxaskerups.play;
						.timplay("timendfault", 1500, "butclick_anbutexit" );
					} else {
						timblink.iidtick = (timblink.iiletick);
						timblink.play;
					}
				}
			} else if( icomptype==2 )	{	// tryb feed, zwierzak
				if( carryfood!=null )	{
					.mputcarryfood(carryfood);
				} else if( sfooder!=null && <sfooder>.actionname==myfood && 0->length(.getposx-anplayer.getposx, .getposy-anplayer.getposy) <= .getw && sactgnd==anplayer.sactgnd )	{
					carryfood = sfooder;
					sfooder = null;
					.mputcarryfood(carryfood);
					.fxsetplay("mikrofalaend");
					if( grfood.empty )	{
						timczas.stop(false);
						<GAME>.mfinfeed;
					}
				}
			}
		}
	}
	mfinfeed	{
		.advsetstate("state_showtabliczka");
		
		new bool brekord;
		if( bisrekord==false || icurtime < bisrekord )	{
			brekord = true;
			csave.set("last_rec_"+iNelaZooZooLevel, icurtime);
		} else brekord = false;
		
		new real raddpoints = icurtime.to_r / iilezwierz.to_r;
		new int iilestars;
		if( raddpoints < 4.0 )	{
			iilestars = 4;
		} else if( raddpoints < 5.5 )	{
			iilestars = 3;
		} else if( raddpoints < 8.0 )	{
			iilestars = 2;
		} else {
			if( raddpoints > 9.0 )
				raddpoints = 9.0;
			iilestars = 1;
		}
		if( csave.get("last_recstars_"+iNelaZooZooLevel)->to_i < iilestars )
			csave.set("last_recstars_"+iNelaZooZooLevel, iilestars);
		
		raddpoints = 100.0 * (10.0-raddpoints);
		new int ipetla = 20;
		
		antabliczka.anzoomin(idymekdelay, func {
			.advsetstate("state_showstars");
			.mprintpoints;
			txpoints.show;
			txpoints.setz( antabliczka.getz+5 );
			grstarbg.each( func { (int id)
				.show;
				int w = id * (.getw + 10->igetsc1);
				int h = 10->igetsc;
				.move( w, h );
				@s = grstar.get(id);
				<s>.setframe(1,0);
				<s>.move( w, h );
				} );
			timpoints.play;
			} );
		antexit.anzoomin(idymekdelay,null);
		antrestart.anzoomin(idymekdelay,null);
		antnext.anzoomin(idymekdelay,null);
	}
	mputsqs	{
		.withlist2("mputsq");
	}
	mputsq(int row, int col)	{
		@s = "imsq"+row+"_"+col;
		iilesq++;
		
		new img <s>;
		<s>.copy("imsq");
		<s>.setpos( col * iwsq - iwsq/2, igmapph - row * ihsq );
		if( bzoodebug )	{
			txpom.txtcenter(s);
			txpom.txtset(""+row+","+col);
			imgbkg.blit("txpom");
		}
		grels.add(s);
	}
	msetbgpos	{	._msetbgpos(anplayer.getcx, anplayer.getcy);	}
	_msetbgpos(int x, int y)	{
		x -= (igmappw/2);
		if( x.abs > 4*ispeedx )	{
			if( x < 0 && imgbkg.getpx <= -ispeedx )	{
				grels.move(ispeedx,0);
			} else if( x > 0 && <sedgeobj>.getex >= igmappw /*+ispeedx*/ )	{
				grels.move(-ispeedx,0);
			}
		}
	}
	mloadid(int id)	{	.mload("level"+id+".db");	}
	mload(string sfile)	{
		new db dbsav;
		if( engine.fileexist( .getpath(sfile) ) )	{
			dbsav.load( .getpath(sfile) );
			
			int starty = 293->igetsc + imgbkg.getpy;
			int startx = iwsq/2 + imgbkg.getpx;
			int rows = 7;
			
			for( int i=0; i<dbsav.getrowsno; i++ )	{
				int row = dbsav.get(i,0);
				int col = dbsav.get(i,1);
				
				string srec = "imsq"+row+"_"+col;
				new ImgRect <srec>;
				<srec>.create(iwsq, ihsq);
				<srec>.setpos( col*iwsq + startx, row*ihsq + starty );
				<srec>.vars2(A, "saction", null, "row", row, "col", col, "bisroad", false, "spac", null);
				grsq.add(srec);
				
				@s = "imat"+row+"_"+col;
				new img <s>;
				<s>.vars2(A, "sfield", srec, "saction", null, "row", row, "col", col);
				<s>.msetelac(dbsav.get(i,2));
				if( <s>.saction == "ziemia" )	{
					imgbkg.blit(s);
					<s>.hide;
					<srec>.bisroad = (true);
					grnd.add(s);
					if( bpacmode )	{
						string spac = "impac"+ grpac.size;
						new img <spac>;
						<spac>.imgclone("anzpac");
						<spac>.ancenterimg(srec);
						<spac>.vars2(A, "smysq", srec);
						grpac.add(spac);
						<srec>.spac = (spac);
						grels.add(spac);
					}
				} else {
					<s>.setz( 10*row );
				}
				if( <s>.getex > iedgex )	{
					iedgex = <s>.getex;
					sedgeobj = s;
				}
				grels.add(s);
				grels.add(srec);
			}
		}
		delete dbsav;
	}
	msetelac(string sac)	{
		anels.setframe(sac,0);
		.msetel;
	}
	msetel	{
		.imgclone("anels");
		.setpos( <sfield>.getpx + anels.lodx, <sfield>.getpy + anels.lody );
		.setz( 5 );
		saction = ( anels.actionname );
	}
	mnextlevel	{
		if( iNelaZooZooLevel<10 )	{
			iNelaZooZooLevel++;
			.stdexit(GAME);
		} else {
			.butclick_anbutexit;
		}
	}
	mouse_rclick	{
		.mnextlevel;
	}
	mputplayersq(string sq)	{	.mputplayer(<sq>.row, <sq>.col);	}
	mputplayer(int row, int col)	{
		@s = "imsq"+row+"_"+col;
		if( <GAME>.hasvar(s) )	{
			//.ancenterimg(s);
			.setpos(<s>.getcx, <s>.getcy );
			.setz( 10*row+5 );
			if( .hasvar("sactgnd") )	{
				sactgnd = (s);
				if( icomptype==0 )	{	// player
					.setz( .getz-2 );
					if( bpacmode )	{
						if( <s>.spac != null )	{	// pacman mode
							iPoints++;
							@spac = <s>.spac;
							<s>.spac = (null);
							grpac.remove(spac);
							grels.remove(spac);
							<spac>.hide;
							if( grpac.empty )	{
								.mfinpac;
							}
						}
					} else {
						if( sfooder==null && <s>.spac != null )	{	// spac = food
							@sfood = <s>.spac;
							<s>.spac = (null);
							grfood.remove(sfood);
							sfooder = sfood;
							anplayer.mputfood;
							fxpedzel.play;
						} else anplayer.mputfood;
					}
				} else if( icomptype==2 )	{
					.mputcarryfood(carryfood);
				}
			}
		}
	}
	mputfood	{	.mputcarryfood(sfooder);	}
	mputcarryfood(string sf)	{
		if( sf!=null )	{
			<sf>.setpos(.getex-<sf>.getw/2,.getpy+<sf>.geth/2);
			<sf>.setz(.getz+1);
		}
	}
	mstoppac	{
		grzwierz.stop(false);
	}
	mfinpac	{
		.mstoppac;
		.advsetstate("state_finishpac");
		
		// test
		.mnextlevel;
	}
	mgetclickedsq	{
		int id = grsq.find_closest( null, func {(string s) 0->length(.getcx-mouse.getpx,.getcy-mouse.getpy); } );
		anplayer.sdestgnd = (grsq.get(id));
	}
	mlen(string sq1, int row, int col)	{	.mlen2(sq1,"imsq"+row+"_"+col);	}
	mlen2(string sq1, string sq2)	{
		if( <GAME>.hasvar(sq2) && <sq2>.bisroad )	{
			0.0->length(<sq1>.getcx-<sq2>.getcx, <sq1>.getcy-<sq2>.getcy);
		} else -1.0;
	}
	mlen3(int row, int col)	{	.mlen(sdestgnd,row,col);	}
	mcalcstep	{
		if( sactgnd != sdestgnd )	{
			rgndlen = .mlen2(sdestgnd, sactgnd);
			snextgnd = sactgnd;
			int row = <sactgnd>.row;
			int col = <sactgnd>.col;
			
			.mcalclen(row-1,col);
			.mcalclen(row,col+1);
			.mcalclen(row+1,col);
			.mcalclen(row,col-1);
			
			if( snextgnd != sactgnd )	{
				real r = .nofframes(-1);
				rspeedx = (<snextgnd>.getcx - .getposx)/r;
				rspeedy = (<snextgnd>.getcy - .getposy)/r;
				sactgnd = snextgnd;
				sstate = "moving";
				.play(-1);
			} else {
				sstate = "dotarl";
				if( icomptype>0 )	{
					.mnextgnd;
				}
			}
		} else {
			if( icomptype>0 )	{
				sstate = "dotarl";
				.mnextgnd;
			} else if ( !bpacmode )	{
				.mputfood;
			}
		}
	}
	mcalclen(int row, int col)	{
		@s = "imsq"+row+"_"+col;
		real r2 = .mlen2(sdestgnd,s);
		if( r2 >= 0.0 )	{
			if( rgndlen > r2 )	{
				snextgnd = s;
				rgndlen = r2;
			}
		}
	}
	mouse_lclick	{
		if( .advstdstate )	{
			.mgetclickedsq;
			anplayer.mcalcstep;
		}
	}
	key_down	{
		if( igmdebug )	{
			if( keyboard.iskey("e") && keyboard.iskeydown("lctrl") )	{
				gameapi.play("NelaZooEdytor");
			} else if (keyboard.iskey("space") )	{
				gameapi.play(GAME);
			}
		}
	}
	butclick_anbutexit	{	.stdexit("NelaZooMenuPac");	}
	butclick_nostdstate_anbutexit	{
		.butclick_anbutexit;
	}
}

game NelaZooEdytor : MermaidStd	{
	init	{
		MermaidStd::init("zoo");
		
		new img imbg;
		imbg.create(igmappw, igmapph, .white, 255);
		
		new real rzoomer = 0.48;
		
		new int iwsq = rzoomer*55+0.5;
		new int ihsq = rzoomer*63+0.5;
		
		new img imgbkg;
		imgbkg.imgloadzoom("bkg.jpg", rzoomer);
		imgbkg.ancenterscreen;
		
		new anima anels;
		anels.loadzoom( .getpath("els.pyz"), rzoomer, rzoomer );
		new gmimgvec grels;
		for( int i=0; i<anels.nofactions; i++ )	{
			anels.setframe(i,0);
			@s = "imgel"+anels.actionname;
			new img <s>;
			<s>.imgclone("anels");
			
			<s>.setpos( 50+(iwsq+10)*i + anels.lodx, 50 + anels.lody );
			<s>.vars2(A, "ilodx", anels.lodx, "ilody", anels.lody, "startx", <s>.getpx, "starty", <s>.getpy, "saction", anels.actionname );
			grels.add(s);
		}
		anels.hide;
		
		.newtext("txpom", "", .stdfont(9), .black);
		
		new gmimgvec grsq;
		new gmimgvec grmat;
		int cols = (2*1280 / 55);
		int starty = rzoomer * 293 + imgbkg.getpy;
		int startx = iwsq/2 + imgbkg.getpx;
		for( int row = 0; row<7; row++ )	{
			for( int col = 0; col < cols; col++ )	{
				@s = "imsq"+row+"_"+col;
				new img <s>;
				<s>.create(iwsq, ihsq, .transparent);
				<s>.imgborders(1,.black,192);
				txpom.txtset(""+row+","+col);
				<s>.setpos( col*iwsq + startx, row*ihsq + starty );
				txpom.txtcenter(s);
				<s>.blit("txpom");
				grsq.add(s);
				
				@s2 = "imat"+row+"_"+col;
				<s>.var2("schild",s2);
				new img <s2>;
				<s2>.imgclone(s);
				<s2>.vars2(A, "sbuild",s, "saction", null, "row", row, "col", col);
				grmat.add(s2);
				<s>.setz( 20 );
			}
		}
		new int isqx = <grsq.first>.getpx;
		new int isqy = <grsq.first>.getpy;
		new int isqex = <grsq.last>.getex;
		new int isqey = <grsq.last>.getey;
		txpom.hide;
		/*for( int y = rzoomer*290; y
		for( int x = iwsq/2*/
		new DelayMover cmov;
		cmov.b2clicks = (true);
		cmov.unlock;
		
		new int iilemaps = 10;
		int x = 20;
		int y = igmapph - 100;
		for( int i=1; i<=iilemaps; i++ )	{
			@s = "butload"+i;
			.newtxtbut(s, "load "+i);
			<s>.vars2(A, "myid",i);
			<s>.addmethod("butclick_"+s, func {
				if( .advstdstate ) 	{
					.mloadid(myid);
				}
				} );
			<s>.setpos(x, y);
			
			s = "butsave"+i;
			.newtxtbut(s, "save "+i);
			<s>.vars2(A, "myid",i);
			<s>.addmethod("butclick_"+s, func {
				if( .advstdstate ) 	{
					.msaveid(myid);
				}
				} );
			<s>.setpos(x, y+<s>.geth + 5);
			x += <s>.getw + 10; 
		}
		
		.advsetstdstate;
	}
	cmov_GET	{
		if( .advstdstate && grels.isin(mouse.getpos,0,0))	{
			string s = grels.getsfound;
			<s>.setz(150);
			.mssetobj( s );
		}
	}
	msetelac(string sac)	{	.msetel("imgel"+sac);	}
	msetel(string simel)	{
		.imgclone(simel);
		.setpos( <sbuild>.getpx + <simel>.ilodx, <sbuild>.getpy + <simel>.ilody );
		.setz( 5 );
		.saction = ( <simel>.saction );
	}
	mfind(string smover)	{
		grsq.find_closest( smover, func {(string smover) 0->length(.getpx-<smover>.getpx,.getey-<smover>.getey); } );
	}
	cmov_PUT	{
		_b_skip_mouselclick = true;
		if( .advstdstate )	{
			@s = .getmover;
			if( clsurf::commonimgsurf(s, isqx, isqy, isqex, isqey) )	{
				string s2 = grsq.get( .mfind(s) );
				@s3 = <s2>.schild;
				<s3>.msetel(s);
			} else {
				.free;
				<s>.setpos( <s>.startx, <s>.starty );
			}
		}
	}
	mloadid(int id)	{	.mload("level"+id+".db");	}
	msaveid(int id)	{	.msave("level"+id+".db");	}
	msave(string sfile)	{
		new db dbsav;
		for( int i=0; i<grmat.size; i++ )	{
			@s = grmat.get(i);
			if( <s>.saction!=null )	{
				dbsav.dbaddrow(A, <s>.row, <s>.col, <s>.saction );
			}
		}
		dbsav.save( .getpath(sfile) );
		delete dbsav;
	}
	mload(string sfile)	{
		new db dbsav;
		for( int i=0; i<grmat.size; i++ )	{
			<grmat.get(i)>.mresetmat;
		}
		if( engine.fileexist( .getpath(sfile) ) )	{
			dbsav.load( .getpath(sfile) );
			for( i=0; i<dbsav.getrowsno; i++ )	{
				<"imat"+dbsav.get(i,0)+"_"+dbsav.get(i,1)>.msetelac(dbsav.get(i,2));
			}
		}
		delete dbsav;
	}
	mresetmat	{
		if( saction!=null )	{
			.imgclone( sbuild );
			saction = null;
		}
	}
	mouse_lclick	{
		if( .advstdstate )	{
			if( grsq.isin(mouse.getpos,0,0) )	{
				@id = grsq.getfound;
				<grmat.get(id)>.mresetmat;
			}
		}
	}
}

game NelaZooFeed : MermaidStd	{
	init	{
		MermaidStd::init("feed");
		
		new string skontynent = "afro";
		
		.sfxs = (A, "rekord 50", "pedzel 75", "blink 80", "mikrofalaend 50" );
		
		.cbutexit;
		.cbuthelp;
		.loadasker;
		.cloadrecord("arcade_zoo_records.db", "feed_record");
		txtime.setpos( anbuthelp.getex + 20->igetsc, 8->igetsc );
		
		.imgs = (A, "bg"+skontynent+".jpg", "help"+skontynent+".jpgH 100", "butlevok.pyz 20", "butkarma.pyzG 30", "butstart.pyz 50");
		.newgrimg("grels", "els"+skontynent, 10);
		int i=0;
		while(i<grels.size)	{
			@s = grels.get(i);
			if( <s>.nofframes(-1) > 1 )	{
				<s>.setframe(-1,1);
				<s>.setasanmover;
				i++;
			} else grels.removeat(i);
		}
		
		new int iilequest = 20;
		new int iidquest = 1;
		new gmimgvec grquest;
		int x = 15->igetsc;
		int y = 627->igetsc;
		for( i=1; i<=iilequest; i++ )	{
			@s = "anlevokbg"+i;
			.copyanima("anbutlevok",s);
			<s>.setpos(x,y);
			
			@s2 = "anlevok"+i;
			.copyanima("anbutlevok",s2);
			<s2>.setframe("ok",0);
			<s2>.setpos(x,y);
			<s2>.hide;
			
			x += anbutlevok.getw;
		}
		anbutlevok.hide;
		
		new DelayMover cmov;
		cmov.setclickrel(false);
		cmov.unlock;
		
		new classfadeinout clfio;
		
		new string sanimal = null;
		new real ranimalx;
		new real ranimaly;
		new int iilesteps = 10;
		new int iidstep;
		.cycle = ("timgoanimal", func {
			if( iidstep >= iilesteps )	{
				if( .advisstate("state_hideanimal") )	{
					<sanimal>.setframe(-1,1);
					<sanimal>.setpos(0,0);
					if( iidquest < iilequest )	{
						iidquest++;
						.mshowanimal;
					} else {
						<GAME>.mfinish;
					}
				} else if( .advisstate("state_showanimal") )	{
					<sanimal>.setframe(-1,0);
					<sanimal>.setpos(0,0);
					.advsetstdstate;
				}
			} else {
				<sanimal>.movereal(ranimalx, ranimaly);
				iidstep++;
				.play;
			}
			} );
		
		new db dbfood;
		dbfood.dbbuild(A,
			"strus", "kapusta",
			"lew", "udziec",
			"wielblad", "kapusta",
			"slon", "kapusta",
			"lampart", "udziec",
			"zebra", "kapusta",
			"krokodyl", "udziec",
			"szympans", "banan",
			"hiena", "udziec",
			"hipopotam", "udziec",
			"zyrafa", "kapusta",
			"gibon", "banan",
			"goryl", "banan",
			"nosorozec", "kapusta",
			"kameleon", "owad",
			2);
		
		.copyanima("anbutstart", "anstart");
		anstart.setframe(1,0);
		anstart.Button_isinalpha;
		butgame.add("anstart");
		anstart.addmethod("butclick", func {
			if( .advisstate("state_waitstart") )	{
				.advsetstate("state_endwaitstart");
				.anzoomout(idymekdelay, null);
				anbutstart.anzoomout(330, func {
					.hide;
					anstart.hide;
					.advsetstdstate;
					.mshowanimal;
					timsecrecord.play;
					} );
			}
			} );
		
		ccs.enter( func {
			.advsetstate("state_waitstart");
			} );
	}
	mshowanimal	{
		.advsetstate("state_showanimal");
		if( sanimal==null )	{
			sanimal = grels.rand;
		} else sanimal = grels.randdiff(sanimal);
		.mgotimer(0,1);
	}
	mhideanimal	{
		.advsetstate("state_hideanimal");
		.mgotimer(1,0);
	}
	mgotimer(int ifr1, int ifr2)	{
		<sanimal>.setframe(-1,ifr1);
		real x = <sanimal>.getpx;
		real y = <sanimal>.getpy;
		<sanimal>.setframe(-1,ifr2);
		ranimalx = (x - <sanimal>.getpx)/iilesteps;
		ranimaly = (y - <sanimal>.getpy)/iilesteps;
		iidstep = 1;
		timgoanimal.play;
	}
	cmov_GET	{
		if( .advstdstate && grbutkarma.isin(mouse.getpos,1,1))	{
			.advsetstate("state_foodtaken");
			@s = grbutkarma.getsfound;
			.mssetobj( s );
			<s>.setz( 50 );
			fxpedzel.play;
		}
	}
	cmov_PUT	{
		if( .advisstate("state_foodtaken") )	{
			@s = .getfree;
			if( sanimal!=null && clsurf::commonimgs(sanimal,s) )	{
				int id = dbfood.findbyrow(<sanimal>.actionname);
				@slevok = "anlevok"+iidquest;
				if( dbfood.get(id,1)==<s>.actionname )	{
					<slevok>.setframe("ok",0);
					fxmikrofalaend.play;
				} else {
					<slevok>.setframe("no",0);
					fxblink.play;
					.csettime(10);
				}
				<slevok>.show;
				.mhideanimal;
			} else {
				.advsetstdstate;
				fxblink.play;
			}
			<s>.setz( 30 );
			<s>.setpos(0,0);
		}
	}
	butclick_anbutexit	{	.askfor("MainMenuNelaZoo");	}
	butclick_nostdstate_anbutexit	{
		//if( .advisstate("state_finito") || .advisstate("state_waitstart") )
			.stdexit("MainMenuNelaZoo");
	}
	butclick_anbuthelp	{
		if( .advstdstate )	{
			.advsetstate("state_helpshow");
			<"imghelp"+skontynent>.show;
			clfio.imgtransparency(1, 20, "imghelp"+skontynent, func { .advsetstate("state_helpshown"); } );
		}
	}
	mouse_lclick	{
		if( .advisstate("state_helpshown") )	{
			.advsetstate("state_hidehelp");
			clfio.imgtransparency(1, -20, "imghelp"+skontynent, func { <"imghelp"+skontynent>.hide; .advsetstdstate; });
		}
	}
	//mouse_rclick	{	if( igmdebug) .mfinish;	}
	mfinish	{
		.advsetstate("state_finito");
		timsecrecord.stop(false);
		
		.img = ("$"+.getgamepath+"zoo/tabliczkaH.pyz 200");
		.copyanima("antabliczka", "antexit"); 		antexit.setframe("exit",0);
		.copyanima("antabliczka", "antrestart"); 	antrestart.setframe("restart",0);
		antexit.Button_stdalpha;
		antexit.addmethod("butclick", func { if( .advisstate("state_enpoints") ) .stdexit("MainMenuNelaZoo"); } );
		butgame.add("antexit");
		
		antrestart.Button_stdalpha;
		antrestart.addmethod("butclick", func { if( .advisstate("state_enpoints")) .stdexit(GAME); } );
		butgame.add("antrestart");
		
		@w = antexit.getw/2;
		antexit.move(w,0);
		antrestart.move(w,0);
		
		.newtext("txcurtime", "Your time: "+clstrdigit::gettime(icurtime, "ms"), "fntsecrecord", .red);
		txcurtime.txtcenter("antabliczka");
		txcurtime.setz( antabliczka.getz + 5 );
		txcurtime.hide;
		new bool brekord = false;
		if( csave.has("feed_record") )	{
			txcurtime.move(0, -ifontrecordsize/2 );
			new int icurec = csave.get("feed_record");
			.newtext("txcurec", "Record: "+clstrdigit::gettime(icurec, "ms"), "fntsecrecord", .red);
			txcurec.hide;
			txcurec.setz( antabliczka.getz + 5 );
			txcurec.txtcenter("antabliczka");
			txcurec.move( 0, ifontrecordsize/2 );
			if( icurtime < icurec )	{
				brekord = true;
				csave.set("feed_record", icurtime);
			}
		} else {
			csave.set("feed_record", icurtime);
			brekord = true;
		}
		
		.advsetstate("state_showtabliczka");
		antabliczka.anzoomin(idymekdelay, func { <GAME> {
			txcurtime.show;
			if( .hasvar("txcurec") )
				txcurec.show;
			if( brekord )	{
				.img = ("$"+.getgamepath+"zoo/rekord.pngH "+(antabliczka.getz+20));
				imgrekord.setpos( (igmappw-imgrekord.getw)/2, antabliczka.getpy - imgrekord.geth/2 );
				.timplay("timend", 1000, func {
					fxrekord.play;
					imgrekord.show;
					imgrekord.anzoomin(idymekdelay, func {
						txtime.txtset(clstrdigit::gettime(icurtime, "ms"));
						txtime.txtcenter("imgrekord");
						txtime.move(0,20->igetsc);
						txtime.setz( imgrekord.getz + 5 );
						.advsetstate("state_enpoints");
						} );
					} );
			} else .advsetstate("state_enpoints");
			}; } );
		antexit.anzoomin(idymekdelay,null);
		antrestart.anzoomin(idymekdelay,null);
	}
}


class CarInsStd : MermaidStd	{
	init	{
		//advmouse.load( "scripts/app_carins/menu/cursors.pyz" );
		MermaidStd::init("menu");
		
		.newanima("anbutexit", "butexit.pyz", 300);
		int x = igmoffsetx + iResX;
		if( x > igmappw ) x = igmappw;
		else if( x < 20 ) x = 20;
		anbutexit.ansetbpos( x - 20->igetsc - anbutexit.getw, igmoffsety );
		anbutexit.Button_addstdstate;
		
		new bool bfullscreen = false;
		
		.loadasker;
			
		.img = ("bkg.png");
		
		.newdb("dbtx", "txts.db");
		new int ifontsize = .ireadscfg("carins_stdbutton_fontsize:",30);
		new string sfntstd = .stdfont(ifontsize);
		new int ibutwidth = .ireadscfg("carins_stdbutton_width:",200);
		new int ibutheight = .ireadscfg("carins_stdbutton_height:",50);
		
		new GUI gui("butgui", ifontsize);
		gui.unlock;
		
		.newtext("txt1", "", sfntstd, .black);
		.newtext("txt2", "", sfntstd, 128,0,0);
		.newtext("txt3", "", sfntstd, .black);
		txt1.setpos( 100->igetsc, 50->igetsc );
		int dy = 10->igetsc;
		txt2.setpos( txt1.getpx, txt1.getpy + ifontsize + dy );
		txt3.setpos( txt1.getpx, txt2.getpy + ifontsize + dy );
		new int iidputxt = 1;
	}
	mputxt(string s)	{
		<"txt"+iidputxt>.txtset( dbtx.dbget(s) );
		iidputxt++;
	}
	key_down	{
		if( !.checktouchpad && keyboard.iskey("f") && (keyboard.iskeydown("lctrl") || keyboard.iskeydown("rctrl")) )	{
			bfullscreen = !bfullscreen;
			engine.setfullscreen(bfullscreen);
		}
	}
}

game CarInsMenu1 : CarInsStd	{
	init	{
		CarInsStd::init;
		butgui.setfontsize(1.2*ifontsize);
		
		new gmimgvec grbuts;
		
		int w = 1.5*ibutwidth;
		int h = 1.5*ibutheight;
		int dx = 50->igetsc;
		
		gui.newbutton("butzrob", dbtx.dbget("zrob"), w, h);
		grbuts.add("butzrob");
		
		gui.newbutton("butwyslij", dbtx.dbget("wyslij"), w, h);
		butwyslij.setpos( butzrob.getex + dx, 0 );
		grbuts.add("butwyslij");
		
		gui.newbutton("butprzejrzyj", dbtx.dbget("przejrzyj"), w, h);
		butprzejrzyj.setpos( butwyslij.getex + dx, 0 );
		grbuts.add("butprzejrzyj");
		
		grbuts.move( (igmappw - grbuts.getw)/2, (igmapph-grbuts.geth)/2 );
		
		.stdenter;
	}
	butclick_anbutexit	{	.askfor("exit");	}
	butzrob_lclick	{
		butzrob.unclick;
		if( .advstdstate )	{
			//.stdexit("CarInsMenuFirmy");
			.stdexit("CarInsMenuFoto");
		}
	}
	butwyslij_lclick	{
		butwyslij.unclick;
		if( .advstdstate )	{
			.stdexit("CarInsMenuWyslane");
		}
	}
	butprzejrzyj_lclick	{
		butprzejrzyj.unclick;
		if( .advstdstate )
			.stdexit("CarInsMenuZrobione");
	}
}

game CarInsMenuZrobione : CarInsStd	{
	init	{
		CarInsStd::init;
		.stdenter;
	}
	butclick_anbutexit	{	.stdexit("CarInsMenu1");	}
}

game CarInsMenuFirmy : CarInsStd	{
	init	{
		CarInsStd::init;
		butgui.setfontsize(25->igetsc);
		
		new gmimgvec grbuts;
		
		int w = 200->igetsc;
		int h = 200->igetsc;
		int dx = 50->igetsc;
		
		gui.newbutton("butpzu", "PZU", w, h);
		grbuts.add("butpzu");
		
		gui.newbutton("buthestia", "Hestia", w, h);
		buthestia.setpos( butpzu.getex + dx, 0 );
		grbuts.add("buthestia");
		
		gui.newbutton("butwarta", "Warta", w, h);
		butwarta.setpos( 0, butpzu.getey + dx );
		grbuts.add("butwarta");
		
		gui.newbutton("butaxa", "AXA", w, h);
		butaxa.setpos( butwarta.getex + dx, butpzu.getey + dx );
		grbuts.add("butaxa");
		
		grbuts.move( (igmappw - grbuts.getw)/2, (igmapph-grbuts.geth)/2 );
		
		butgui.setfontsize(15->igetsc);
		gui.newbutton("butpowrot", dbtx.dbget("powrot"), 100->igetsc, 30->igetsc);
		butpowrot.setpos( dx, igmapph - butpowrot.geth - dx );
		
		clsave.set("carins_mode","mk_foto");
		
		.stdenter;
	}
	butclick_anbutexit	{	.askfor("exit");	}
	butpowrot_lclick	{	.stdexit("CarInsMenu1");	}
	buthestia_lclick	{
		buthestia.unclick;
		if( .advstdstate )
			.stdexit("CarInsMenuFoto");
	}
	butwarta_lclick	{	butwarta.unclick;	}
	butpzu_lclick	{	butpzu.unclick;		}
	butaxa_lclick	{	butaxa.unclick;		}
}

game CarInsMenuFoto : CarInsStd	{
	init	{
		CarInsStd::init;
		
		.sfxs = (A, "pstryk "+.readcfg("carins_pstryk_vol:",40) );
		
		.imgs = (A, "fotos.pyz 10");
		
		new vector vfoto;
		vfoto.resize( anfotos.nofactions, 0 );
		
		anfotos.Button_isin;
		anfotos.addmethod("butmoveon", func {
			if( .advstdstate && .framenr==0 )
				advmouse.setact;
			} );
		anfotos.addmethod("butmoveoff", func {
			if( .advstdstate )
				advmouse.setstd;
			} );
		anfotos.addmethod("butclick", func {
			if( .advstdstate && .framenr==0 )	{
				.mkfoto;
			}
			} );
		butgame.add("anfotos");
		
		new bool brepeat = clsave.get("carins_mode")=="repeat_foto";
		
		new int iidfoto;
		if ( brepeat )	{
			iidfoto = 1+clsave.get("carins_idfoto");
			int ile = clsave.get("carins_ilefoto");
			for( int i=0; i<ile; i++ )
				vfoto.set( i, clsave.get("carins_foto_"+i) );
		} else iidfoto = 0;
		
		int w = ibutwidth;
		int h = ibutheight;
		int dx = 20->igetsc;
		gui.newbutton("butdalej", dbtx.dbget("dalej"), w, h);
		butdalej.setpos( igmappw - butdalej.getw - dx, igmapph - butdalej.geth - 100->igetsc );
		gui.newbutton("butpowtorz", dbtx.dbget("powtorz"), w, h);
		butpowtorz.setpos( butdalej.getpx, butdalej.getpy - butdalej.geth - 3*dx );
		gui.newbutton("butpowrot", dbtx.dbget("powrot"), w, h);
		butpowrot.setpos( dx, butdalej.getpy );
		
		gui.newwndtitle("winall", null, dbtx.dbget("error"), 3.5*w, 3*h);
		gui.printcenter("winall", dbtx.dbget("abyprzejsc"));
		gui.newbutton("butokwinall", "OK", w, h);
		winall.winsetpos( (igmappw - winall.getw)/2, (igmapph - winall.geth)/2 );
		winall.winsetz(100);
		butokwinall.setpos( winall.getcx-butokwinall.getw/2, winall.getey - 10->igetsc - butokwinall.geth );
		winall.blit("butokwinall");
		butokwinall.setz(110);
		butokwinall.hide;
		winall.winhide;
		
		gui.newwndtitle("winuszk", null, "?", 3.5*w, 3*h);
		gui.printcenter("winuszk", dbtx.dbget("czy_uszkodzenia1"));
		gui.newbutton("butuszky", dbtx.dbget("tak"), w, h);
		gui.newbutton("butuszkn", dbtx.dbget("nie"), w, h);
		winuszk.winsetpos( (igmappw - winuszk.getw)/2, (igmapph - winuszk.geth)/2 );
		winuszk.winsetz(100);
		butuszky.setpos( winuszk.getpx+dx, winuszk.getey - 10->igetsc - butuszky.geth );
		winuszk.blit("butuszky");
		butuszky.setz(110);
		butuszky.hide;
		butuszkn.setpos( winuszk.getex-dx-butuszkn.getw, winuszk.getey - 10->igetsc - butuszkn.geth );
		winuszk.blit("butuszkn");
		butuszkn.setz(110);
		butuszkn.hide;
		winuszk.winhide;
		
		if( brepeat )	{
			.mlev(0);
			butdalej.hide;
		} else {
			.mlev(1);
		}
		
		.stdenter;
	}
	butclick_anbutexit	{	.askfor("CarInsMenu1");	}
	resettxts	{
		txt1.txtset("");
		txt2.txtset("");
		txt3.txtset("");
		iidputxt = 1;
	}
	mlev(int id)	{
		.resettxts;
		iidfoto += id;
		if( iidfoto < 1 ) {
			iidfoto = 1;
		} else if (iidfoto > anfotos.nofactions ) {
			iidfoto = anfotos.nofactions;
		}
		butpowrot.show;
		anfotos.setframe(iidfoto-1, vfoto.get(iidfoto-1));
		anfotos.framenr ? butpowtorz.show : butpowtorz.hide;
		match( iidfoto )	{
			1 => {
				.mputxt("prosba");
				.mputxt("przod");
				.mputxt("kadr");
				if( !brepeat )
					butpowrot.hide;
			}
			2 => {
				.mputxt("prosba");
				.mputxt("tyl");
				.mputxt("kadr");
			}
			3 => {
				.mputxt("prosba");
				.mputxt("wnetrze");
			}
			4 => {
				.mputxt("prosba");
				.mputxt("licznik");
			}
			5 => {
				.mputxt("prosba");
				.mputxt("vin");
			}
			6 => {
				.mputxt("prosba");
				.mputxt("klucze");
			}
			7 => {
				.mputxt("prosba");
				.mputxt("uszkodzenia1");
			}
			8 => {
				.mputxt("prosba");
				.mputxt("uszkodzenia2");
			}
			? => ;
		}
	}
	butdalej_lclick {
		butdalej.unclick;
		if( .advstdstate )       {
			if( iidfoto<7 )	{
				if( anfotos.framenr==0 )	{
					.advsetstate("state_morefotostart");
					winall.anzoomin(300, func { 
						.advsetstate("state_morefoto");
						winall.winshow;
						butokwinall.show;
						butokwinall.unlock;
						winall.unlock;
						} );
				} else if( iidfoto==6 ) {
					.advsetstate("state_uszkstart");
					winuszk.anzoomin(300, func { 
						.advsetstate("state_uszk");
						winuszk.winshow;
						butuszkn.show;
						butuszkn.unlock;
						butuszky.show;
						butuszky.unlock;
						winuszk.unlock;
						} );
				} else
					.mlev(1);
			} else if( iidfoto==7 )	{
				.advsetstate("state_uszkstart");
				winuszk.anzoomin(300, func { 
					.advsetstate("state_uszk");
					winuszk.winshow;
					butuszkn.show;
					butuszkn.unlock;
					butuszky.show;
					butuszky.unlock;
					winuszk.unlock;
					} );
			}
		}
	}
	butpowrot_lclick	{
		butpowrot.unclick;
		if( brepeat )	{
			.stdexit("CarInsMenuWyslij");
		} else {
			if( .advstdstate )       {
				.mlev(-1);
			}
		}
	}
	butpowtorz_lclick	{
		butpowtorz.unclick;
		if( .advstdstate )	{
			.mkfoto;
		}
	}
	mkfoto	{
		.advsetstate("state_mkfoto");
		ccs.close( func {
			fxpstryk.play;
			advmouse.setstd;
			vfoto.set( iidfoto-1, 1 );
			clsave.set("carins_foto_"+(iidfoto-1),1);
			ccs.enter( "advsetstdstate" );
			.mlev(0);
			} );
	}
	mhidewinall	{
		sgmstate = "state_morefotoend";
		winall.winhide;
		winall.lock;
		butokwinall.lock;
		butokwinall.hide;
		winall.anzoomout(300, func {
			.advsetstdstate;
			} );
	}
	butokwinall_lclick	{
		butokwinall.unclick;
		.winall_lclick;
	}
	winall_lclick	{
		if( sgmstate=="state_morefoto" )	{
			.mhidewinall;
		}
	}
	mhidewinuszk	{
		winuszk.winhide;
		winuszk.lock;
		butuszkn.lock;
		butuszkn.hide;
		butuszky.lock;
		butuszky.hide;
	}
	butuszkn_lclick	{
		butuszkn.unclick;
		clsave.set("carins_ilefoto", iidfoto);
		for( int i=0; i<vfoto.size; i++ )
			clsave.set("carins_foto_"+i, vfoto.get(i));
		.stdexit("CarInsMenuWyslij");
	}
	butuszky_lclick	{
		butuszky.unclick;
		if( sgmstate=="state_uszk" )	{
			.winuszk_lclick;
			if( iidfoto<7 )
				.mlev(1);
		}
	}
	winuszk_lclick	{
		if( sgmstate=="state_uszk" )	{
			.mhidewinuszk;
			sgmstate = "state_uszkend";
			winuszk.anzoomout(300, func {
				.advsetstdstate;
			} );
		}
	}
	mouse_rclick	{
		//.butuszkn_lclick;
	}
}


game CarInsMenuWyslij : CarInsStd	{
	init	{
		CarInsStd::init;
		
		.imgs = (A, "fotos.pyz 10");
		
		new int iilefoto = clsave.get("carins_ilefoto");
		//iilefoto = 6;
		new vector vfoto;
		for( int i=0; i<iilefoto; i++ )	{
			vfoto.add( clsave.get("carins_foto_"+i) );
			//vfoto.set(i,1);
		}
		clsave.set("carins_mode","repeat_foto");
		
		.mputxt("dziekuje");
		.mputxt("rejestracja");
		new gmimgvec grtx;
		
		new string stxtrej = "txt3";
		int pol = (BYTEZ+BYTEA)/2;
		@startx = txt3.getpx;
		@x = startx;
		@size = 2*ifontsize;
		@y = txt3.getpy + txt3.geth + size/2;
		@dx = 4->igetsc;
		int i = BYTEA;
		int b = 1;
		//for( int i=BYTEA; i<=BYTEZ; i++ )	{
		bool bcontinue = true;
		while( b )	{
			if( b==1 ) {
				if( i>BYTEZ )	{
					b = 2;
					i = BYTE0;
					bcontinue = false;
					x = startx;
					y += 1.2*size;
				} else bcontinue = true;
			} else if( b==2 )	{
				if( i > BYTE9 )	{
					b = 3;
					bcontinue = false;
					x = startx;
					y += 1.2*size;
				} else bcontinue = true;
			} else if( b==3 )	{
				bcontinue = true;
				@st = "SPACE";
				b = 4;
			} else if( b==4 )	{
				@st = "DEL";
				b = 5;
			} else {
				b = 0;
				bcontinue = false;
			}
			if( bcontinue )	{
				@s = "imgtxta"+i;
				if( b<3 )	{
					@st = "a";
					st.setbyte(0,i);
				}
				txt3.txtsetcol( st, .white );
				new img <s>;
				<s>.var2("value",st);
				if( st=="SPACE" || st=="DEL" )
					<s>.create( txt3.getw + ifontsize, 2*ifontsize, .black, 192 );
				else
					<s>.create( 2*ifontsize, 2*ifontsize, .black, 192 );
				
				<s>.setpos( txt3.getpx + txt3.getw/2 - <s>.getw/2, txt3.getpy + txt3.geth/2 - <s>.geth/2 );
				<s>.setz( 26 );
				<s>.blit("txt3");
				<s>.setpos(x,y);
				
				if( i>pol )	{
					pol = BYTEZ;
					x = startx;
					y += 1.2*size;
				} else 
					x+=<s>.getw+dx;
				grtx.add(s);
				<s>.Button_stdms;
				<s>.addmethod("butclick", func {
					if( .advstdstate )	{
						@s = <stxtrej>.get;
						if( value=="DEL" )	{
							if( s.length > 0 )	{
								<stxtrej>.txtset( s.strsube(1) );
							}
						} else if( value=="SPACE" )	{
							if( s.length < 12 )	{
								<stxtrej>.txtset( s+" " );
							} else <stxtrej>.txtset( s.strsube(1) + " " );
						} else {
							if( s.length < 12 )	{
								<stxtrej>.txtset( s+value );
							} else <stxtrej>.txtset( s.strsube(1) + value );
						}
						.mtxt4pos;
					}
					} );
				butgame.add(s);
				i++;
			}
		}
		txt3.txtsetcol("", .red);
		txt3.show;
		.newtext("txt4", "_", sfntstd, .red);
		.mtxt4pos;
		.timer=("timtx",300, func {
			.mtxt4pos;
			if( txt4.isvisible )	{
				txt4.hide;
			} else txt4.show;
			.play;
			} );
		timtx.play;
		
		x = startx;
		y += 1.2*size;
		int ilebuts = 0;
		anfotos.anzoom(0.25);
		for( int i=0; i<iilefoto; i++ )	{
			if( vfoto.get(i) )	{
				@s = "imgfoto"+ilebuts;
				new img <s>;
				anfotos.setframe(i,1);
				<s>.imgclone("anfotos");
				//<s>.anzoom(0.25);
				<s>.setpos( x, y );
				if( (i+1)%5==0 )	{
					x = startx;
					y += ifontsize/2 + <s>.geth;
				} else {
					x += ifontsize/2 + <s>.getw;
				}
				<s>.msetbut(ilebuts);
				grtx.add(s);
				ilebuts++;
			}
		}
		anfotos.hide;
		
		@s = "imgfoto"+ilebuts;
		@s2 = grtx.last;
		new img <s>;
		<s>.imgclonesizecol( s2, .red, 192);
		.newtext("txtfoto", dbtx.dbget("dodajszkode1"), sfntstd, .black);
		//<s>.imgfittxt( dbtx.dbget("dodajszkode"), s, "txtfoto", 5->igetsc, false );
		txtfoto.txtcenter(s);
		txtfoto.move(0, -0.75*txtfoto.geth);
		<s>.blit("txtfoto");
		txtfoto.txtset( dbtx.dbget("dodajszkode2") );
		txtfoto.txtcenter(s);
		<s>.blit("txtfoto");
		txtfoto.hide;
		<s>.setpos(x, y);
		x+= ifontsize + <s>.getw;
		<s>.msetbut(ilebuts);
		ilebuts++;
		grtx.add(s);
		
		int w = ibutwidth;
		int h = ibutheight;
		gui.newbutton("butwyslij", dbtx.dbget("wyslij"), w, h);
		butwyslij.setpos( igmappw - butwyslij.getw - 20->igetsc, igmapph - butwyslij.geth - 100->igetsc );
		
		gui.newbutton("butok", "OK", w, h);
		butok.setpos( butwyslij.getpx, butwyslij.getpy - 3*butok.geth );
		
		gui.newwndtitle("winrej", null, dbtx.dbget("error"), 3.5*w, 3*h);
		gui.printcenter("winrej", dbtx.dbget("brakrej"));
		gui.newbutton("butokwinrej", "OK", w, h);
		winrej.winsetpos( (igmappw - winrej.getw)/2, (igmapph - winrej.geth)/2 );
		winrej.winsetz(100);
		butokwinrej.setpos( winrej.getcx-butokwinrej.getw/2, winrej.getey - 10->igetsc - butokwinrej.geth );
		winrej.blit("butokwinrej");
		butokwinrej.setz(110);
		butokwinrej.hide;
		winrej.winhide;
		
		sgmstate = "state_rejestracja";
		.stdenter;
	}
	msetbut(int id)	{
		.Button_isin;
		.addmethod("butclick", func {
			if( .advstdstate )	{
				clsave.set("carins_idfoto", idfoto);
				if( clsave.get("carins_ilefoto")->to_i < idfoto+1 )
					clsave.set("carins_ilefoto",idfoto+1);
				.stdexit("CarInsMenuFoto");
			}
			} );
		butgame.add(this);
		if( id > 6 )
			id=6;
		new int idfoto = id;
	}
	mtxt4pos	{	txt4.setpos( txt3.getpx + txt3.getw, txt3.getpy );	}
	butwyslij_lclick	{
		butwyslij.unclick;
		if( .advstdstate )	{
			if( .misrej )
				.stdexit("CarInsMenuWyslane");
			else	{
				.mrej;
			}
		}
	}
	butok_lclick	{
		butok.unclick;
		if( .advstdstate )	{
			if( .misrej )
				.stdexit("CarInsMenu1");
			else	{
				.mrej;
			}
		}
	}
	misrej	{
		@s = <stxtrej>.get;
		s.clear;
		s.change(" ","_");
		if( s.length )	{
			true;
		} else false;
	}
	mrej	{
		.advsetstate("state_norejstart");
		winrej.anzoomin(300, func { 
			.advsetstate("state_norej");
			winrej.winshow;
			butokwinrej.show;
			butokwinrej.unlock;
			winrej.unlock;
			} );
	}
	mhidewinrej	{
		sgmstate = "state_norejend";
		winrej.winhide;
		winrej.lock;
		butokwinrej.lock;
		butokwinrej.hide;
		winrej.anzoomout(300, func {
			.advsetstdstate;
			} );
	}
	butokwinrej_lclick	{
		butokwinrej.unclick;
		.winrej_lclick;
	}
	winrej_lclick	{
		if( sgmstate=="state_norej" )	{
			.mhidewinrej;
		}
	}
}

game CarInsMenuWyslane : CarInsStd	{
	init	{
		CarInsStd::init;
		
		.mputxt("wyslano");
		gui.newbutton("butkoniec", dbtx.dbget("zamknij"), 2*ibutwidth, ibutheight);
		butkoniec.ancenterscreen;
		
		.stdenter;
	}
	butkoniec_lclick	{
		butkoniec.unclick;
		.stdexit("CarInsMenu1");
	}
	butclick_anbutexit	{	.stdexit("CarInsMenu1");	}
}


game MainMenuNelaSnow : MermaidStd	{
	init	{
		MermaidStd::init("menusnow");
		
		.imgs = (A, "bgmenu.jpg", "butstrud.pyzG 10", "butstart.pyz 20");
		
		new string strudnosc = clsave.get("nelasnow_trudnosc");
		if( strudnosc==null )	{
			strudnosc = "easy";
			clsave.set("nelasnow_trudnosc", strudnosc);
		}
		
		anbutstart.move(-100->igetsc, -50->igetsc);
		grbutstrud.eval( func {
			.move(120->igetsc,120->igetsc);
			.imgsetoverlay(.red,128);
			.Button_isinalpha;
			.addmethod("butclick", func {
				if( .advstdstate )	{
					sndfxbutclick1.play;
					strudnosc = .actionname;
					.msettrud;
				}
				} );
			butgame.add(this);
			if( strudnosc == .actionname )	{
				<.imgetoverlay>.hide;
			}
			} );
		
		anbutstart.Button_addstdalpha;
		
		.cbutexit;
		.cbutmusic;
		.loadasker;
		
		.stdenter;
	}
	msettrud	{
		grbutstrud.eval( func { <.imgetoverlay>.show; } );
		<.imgetoverlay>.hide;
		clsave.set("nelasnow_trudnosc",strudnosc);
	}
	butclick_anbutexit	{	.askfor("OutroStd");	}
	butclick_anbutstart	{	.stdexit("NelaSnowFight");	}
}

game NelaSnowFight : MermaidStd	{
	init	{
		MermaidStd::init("snow");
		.imgs = (A, "bgsnow.png", "els.pyz", "kule.pyzH 60", "live.pyz 100", "bum.pyzH 110");
		
		.sfxs = (A, "rekord 50");
		.mkfxset("zamach2", 8, 50);
		.mkfxset("zamach3", 8, 50);
		.mkfxset("cios1", 8, 30);
		.mkfxset("child0", 4, 40);
		.mkfxset("child1", 4, 40);
		//.mkfxset("blink", 8, 50);
		
		new string strudnosc = clsave.get("nelasnow_trudnosc");
		
		new gmimgvec grels;
		int imaski = 1;
		string s, string stim;
		new gmobjvec grtim;
		new gmimgvec grzucacz;
		new real rilesteps = 30.0;
		ankule.ansetlastframe(0);
		new real rkulaend = 0.66*ankule.geth;
		for( int i=0; i<anels.nofactions; i++ )	{
			anels.setframe(i,0);
			@sac = anels.actionname->getb(0,1);
			if( sac=="r" )	{
				s = "anel" + i;
				.copyanima("anels",s);
				<s>.setz( imaski*10 );
				grels.add(s);
				<s>.move(0, <s>.geth );
				real x = (<s>.getpx - <s>.lodx)->to_r/rilesteps;
				real y = (<s>.getpy - <s>.lody)->to_r/rilesteps;
				<s>.setasanmover;
				
				<s>.hide;
				stim = "tim"+s;
				.cycle = (stim, func {
					if( iidstep > 0 )	{
						<sanima>.movereal( 0, rdir*rdy );
						iidstep--;
						.play;
					} else {
						if( rdir == -1.0 )	{
							rdir = 2.0;
							.timsetmstick(1500);
							.play;
						} else if( rdir==1.0 ) {
							<sanima>.setpos(0,<sanima>.geth);
							<sanima>.hide;
							grzucacz.remove(sanima);
						} else if( rdir==2.0 )	{
							.timsetmstick(500);
							@skula = sanima + "kula";
							<skula>.setpos( <sanima>.getcx, <sanima>.getpy + <sanima>.geth/3 );
							<skula>.bmove = (false);
							<skula>.rdx = ( <skula>.mgetdestx/<skula>.nofframes(idmaska) );
							<skula>.play(idmaska);
							.fxsetplay("zamach3");
							rdir = 3.0;
							.play;
						} else if( rdir==3.0 )	{
							.mspadaj;
						}
					}
					} );
				<stim>.vars2(A, "sanima", s, "rdx",x, "rdy",y, "rdir",-1.0, "iidstep",rilesteps.to_i, "idmaska",(imaski-1));
				grtim.add(stim);
				
				@skula = s + "kula";
				.copyanima("ankule",skula);
				<skula>.setframe(imaski-1,0);
				<skula>.addmethod("onendframe", func {
					if( bmove ) {
						.movereal(rdx, rdy);
					} else {
						.movereal(rdx, 0);
						if( .framename=="go" )	{
							bmove = true;
							real ile = .nofframes(-1) - .framenr;
							//rdx = .mgetdestx/ile;
							rdy = (igmapph - rkulaend)/ile;
						}
					}
					} );
				<skula>.addmethod("onfinish", func {
					.hide;
					@s = "anbum"+cntbum.next;
					<s>.play("p"+2->rand);
					int y = .getpy-20->igetsc;
					if( y>igmapph ) y=igmapph;
					<s>.setpos(.getcx + (100-200->rand)->igetsc,y);
					if( iilelive > 0 )	{
						//.fxsetplay("blink");
						.fxsetplay("child"+2->rand);
						.fxsetplay("cios1");
						s = "anlive"+(iilelive-1);
						<s>.hide;
						iilelive--;
						if( iilelive==0 )	{
							<GAME>.mfinish;
						}
					}
					} );
				<skula>.setasanmover;
				<skula>.vars2(A, "rdx", 0.0, "rdy",0.0, "bmove",false);
			} else if( sac=="m" ) {
				imaski++;
				s = "anmask" + i;
				.copyanima("anels",s);
				<s>.setz( imaski*10 );
			} else {
				s = "anbalwany" + i;
				.copyanima("anels",s);
				<s>.setz( imaski*10 );
			}
		}
		anels.hide;
		
		new int iilelive;
		match(strudnosc)	{
			"easy" => iilelive = 20;
			"medium" => iilelive = 15;
			"hard" => iilelive = 10;
			? => ;
		}
		@dx = 5->igetsc1;
		new gmimgvec grlive;
		for( int i=0; i<iilelive; i++ )	{
			s = "anlive" + i;
			.copyanima("anlive", s);
			<s>.move(i*(anlive.getw+dx), 0);
			grlive.add(s);
		}
		anlive.hide;
		
		new img imgrzut;
		imgrzut.create( <grlive.last>.getex - <grlive.first>.getpx, 15->igetsc, .green, 222 );
		imgrzut.setpos( anlive.getpx, anlive.getey + 3->igetsc1 );
		imgrzut.setz(100);
		new int ilivex = imgrzut.getpx-1;
		new int iliveex = imgrzut.getex;
		new int iilerzut = 10;
		new int iidrzut = iilerzut;
		new int irzutstep = 1 + imgrzut.getw/iidrzut;
		.mcliprzut;
		.cycletimer=("timrzut",40,func {
			iidrzut++;
			.mcliprzut;
			if( iidrzut<iilerzut )
				.play;
			} );
		int ilecnt = 40;
		new SimpleCounter cntrzut(ilecnt);
		new SimpleCounter cntpl(ilecnt);
		new SimpleCounter cntbum(ilecnt);
		for( i=0; i<ilecnt; i++ )	{
			s = "anprzut"+i;
			.copyanima("ankule",s);
			<s>.setasanmover;
			<s>.hide;
			<s>.vars2(A,"santrafiony",null, "idestx",0, "idesty",0, "rdx",0.0, "rdy",0.0);
			<s>.addmethod("onendframe", func {
				.movereal(rdx, rdy);
				} );
			<s>.addmethod("onfinish", func {
				if( santrafiony!=null )	{
					if( <santrafiony>.isin(idestx,idesty,1,1) )	{
						.fxsetplay("cios1");
						@stim = "tim"+santrafiony;
						@s = "anbum"+cntbum.next;
						<s>.play( <stim>.idmaska );
						<s>.setpos(idestx,idesty);
						if( <stim>.rdir!=1.0 )	{
							<stim>.stop(false);
							<stim>.mspadaj;
						}
					}
					santrafiony = null;
				}
				.hide;
				} );
			
			s = "anbum"+i;
			.copyanima("anbum", s);
		}
		
		new int itimakcja;
		match(strudnosc)	{
			"easy" => itimakcja = 1000;
			"medium" => itimakcja = 900;
			"hard" => itimakcja = 800;
			? => ;
		}
		new int icyklakcja = 0;
		.cycletimer = ("timakcja", itimakcja, func {
			icyklakcja++;
			if( icyklakcja % 100 == 0 && itimakcja>500 )	{
				itimakcja-=100;
				.timsetmstick(itimakcja);
			}
			@s = grtim.rand;
			if( !<s>.isplaying )	{
				<s>.mwypusc;
			}
			.play;
			} );
		timakcja.play;
		
		.cbutexit;
		.cbutmusic;
		.loadasker;
		.cloadrecord("arcade_snofight.db", .mgetrecord);
		.newtext("txtmode", "Mode: "+strudnosc, "fntsecrecord", .red);
		txtmode.setpos( anbutmuz.getex + 20->igetsc, 3->igetsc );
		txtime.setpos( txtmode.getpx, txtmode.getpy + txtmode.geth+3->igetsc );
		timsecrecord.play;
		
		.stdenter;
	}
	mgetrecord	{	"snow_record_"+strudnosc;	}
	mspadaj	{
		.settick(1);
		iidstep = rilesteps;
		rdir = 1.0;
		.play;
	}
	mcliprzut	{
		imgrzut.clip( ilivex,0, ilivex+iidrzut*irzutstep,igmapph );
	}
	mgetdestx	{	(igmappw/2 - .getcx)->to_r;	}
	mwypusc	{
		<sanima>.show;
		<sanima>.setpos(0,0);
		<sanima>.move(0,<sanima>.geth);
		grzucacz.add(sanima);
		grzucacz.sortimgs;
		iidstep = rilesteps;
		rdir = (-1.0);
		.play;
	}
	butclick_anbutexit	{	.askfor("MainMenuNelaSnow");	}
	mouse_lclick	{
		if( .advstdstate )	{
			if( iidrzut==iilerzut )	{
				.fxsetplay("zamach2");
				iidrzut = 0;
				.mcliprzut;
				timrzut.play;
				@s = "anprzut"+cntrzut.next;
				<s>.setframe("kulebule",0);
				real x = mouse.getpx;
				real y = mouse.getpy;
				real ile = <s>.nofframes(-1);
				if( grzucacz.isin(x,y,1,1) )	{
					<s>.santrafiony = (grzucacz.getsfound);
				}
				real rx = 2*igmappw/3;
				real ry = igmapph;
				<s>.setpos(rx, ry);
				<s>.rdx = ((x-rx)/ile);
				<s>.rdy = ((y-ry)/ile);
				<s>.idestx = (x);
				<s>.idesty = (y);
				<s>.play(-1);
			}
		}
	}
	mfinish	{
		.advsetstate("state_finito");
		timsecrecord.stop(false);
		timakcja.stop(false);
		
		.img = ("tabliczkaH.pyz 200");
		.copyanima("antabliczka", "antexit"); 		antexit.setframe("exit",0);
		.copyanima("antabliczka", "antrestart"); 	antrestart.setframe("restart",0);
		antexit.Button_stdalpha;
		antexit.addmethod("butclick", func { if( .advisstate("state_enpoints") ) .stdexit("MainMenuNelaSnow"); } );
		butgame.add("antexit");
		
		antrestart.Button_stdalpha;
		antrestart.addmethod("butclick", func { if( .advisstate("state_enpoints")) .stdexit(GAME); } );
		butgame.add("antrestart");
		
		@w = antexit.getw/2;
		antexit.move(w,0);
		antrestart.move(w,0);
		
		.newtext("txcurtime", "Your time: "+clstrdigit::gettime(icurtime, "ms"), "fntsecrecord", .red);
		txcurtime.txtcenter("antabliczka");
		txcurtime.setz( antabliczka.getz + 5 );
		txcurtime.hide;
		new bool brekord = false;
		if( csave.has(.mgetrecord) )	{
			txcurtime.move(0, -ifontrecordsize/2 );
			new int icurec = csave.get(.mgetrecord);
			.newtext("txcurec", "Record: "+clstrdigit::gettime(icurec, "ms"), "fntsecrecord", .red);
			txcurec.hide;
			txcurec.setz( antabliczka.getz + 5 );
			txcurec.txtcenter("antabliczka");
			txcurec.move( 0, ifontrecordsize/2 );
			if( icurtime > icurec )	{
				brekord = true;
				csave.set(.mgetrecord, icurtime);
			}
		} else {
			csave.set(.mgetrecord, icurtime);
			brekord = true;
		}
		
		.advsetstate("state_showtabliczka");
		antabliczka.anzoomin(idymekdelay, func { <GAME> {
			txcurtime.show;
			if( .hasvar("txcurec") )
				txcurec.show;
			if( brekord )	{
				.img = ("rekord.pngH "+(antabliczka.getz+20));
				imgrekord.setpos( (igmappw-imgrekord.getw)/2, antabliczka.getpy - imgrekord.geth/2 );
				.timplay("timend", 1000, func {
					fxrekord.play;
					imgrekord.show;
					imgrekord.anzoomin(idymekdelay, func {
						txtime.txtset(clstrdigit::gettime(icurtime, "ms"));
						txtime.txtcenter("imgrekord");
						txtime.move(0,20->igetsc);
						txtime.setz( imgrekord.getz + 5 );
						.advsetstate("state_enpoints");
						} );
					} );
			} else .advsetstate("state_enpoints");
			}; } );
		antexit.anzoomin(idymekdelay,null);
		antrestart.anzoomin(idymekdelay,null);
	}
}


game MainMenuModa : MermaidStd	{
	init	{
		MermaidStd::init("menumoda");
		gameapi.play("GameModa");
	}
}


game GameModa : MermaidStd	{
	init	{
		MermaidStd::init("mg_moda");
		
		.imgs = (A, "bkg.jpg", "pola.pyzGH 100", "buts.pyzG 10", "postac.pyzG 5", "gumka.pyz 120", "butright.pyz 100", "butleft.pyz 100");
		
		.sfxs = (A, "lasergunshot1 50", "mikrofalaend 60", "pageflip1 70", "pedzel 70");
		
		new gmimgvec grels;
		new anima anel;
		new int iidel;
		
		anbutleft.Button_addstdstate;
		anbutright.Button_addstdstate;
		new img imgbgkol;
		new int iIleBgKol = 0;
		for( ; engine.fileexist(.getgraphpath + "imgsbg/bg"+(iIleBgKol+1)+".jpg"); iIleBgKol++ )	{}
		if( iIleBgKol==0 )	{
			anbutleft.hide;
			anbutright.hide;
			imgbgkol.create( igmappw - imgbkg.getw, igmapph, .white, 255 );
			imgbgkol.setpos( imgbkg.getex, 0 );
		}
		
		new vector vecz;	// z parametr dla czesci stroju
		new db dbid;		// id - stroje odnoszace sie do tego samego imgs
		new db dbreq;		// require - wymaga danego stroju wczesniej
		match( sgmproject )	{
			"Moda_NelaBal" => {
				vecz.beginadd("begin", 11,10,6,8,9,1,2,5,4,3,7);
				
				dbid.dbbuild(A,
					3,3,
					4,3,
					5,3,
					2);
				dbreq.dbbuild(A,
					2,1,
					3,1,
					4,1,
					5,1,
					2);
			}
			"Moda_NelaPiknik" => {
				vecz.beginadd("begin", 8,5,7,6,4,3,2,1);
				dbid.dbbuild(A,
					6,6,
					7,6,
					2);
					// 1_naszyjnik, 2_pasek ,3_top_a ,4_spodnica ,5_skrzydla ,6_kapelusz_a ,7_kapelusz_b ,8_buty
			}
			//"Moda_NelaPlac"	=> ;
			"Moda_NelaTurystka" => {
				vecz.beginadd("begin", 1,2,3,5,4,6);
				dbreq.dbbuild(A,
					4,5,
					2);
			}
			? => ;
		}
		
		angumka.Button_isin;
		butgame.add("angumka");
		angumka.addmethod("butclick", func {
			if( .advstdstate )	{
				if( .framenr==0 )	{
					.setframe(-1,1);
					.skipmouselclick;
					fxlasergunshot1.play;
				}
			}
			} );
		
		grbuts.each( func { (int id)
			id++;
			@s = "imgs"+id;
			<GAME>.varnew("img", s);
			<s>.vars2(A, "myz", 10+id, "iidstroj",-1, "myid", id);
			if( vecz.size )	{
				<s>.myz = ( 10+vecz.find(id) );
			}
			<s>.Button_isinalpha;
			<s>.hide;
			<s>.addmethod("butclick", func {
				if( .advstdstate && angumka.framenr==1 )	{
					for( int i=1; i<=grbuts.size; i++ )	{
						@s = "imgs"+i;
						if( s != this )	{
							int idreq = dbreq.findbyrow(<s>.myid);
							if( idreq >= 0 && dbreq.get(idreq,1)->to_i == myid )	{
								<s>.free;
								<s>.hide;
								<s>.iidstroj = (-1);
							}
						}
					}
					
					.free;
					.hide;
					iidstroj = -1;
					fxmikrofalaend.play;
				}
				} );
			butgame.add(s);
			
			.Button_std;
			.addmethod("butclick", func {
				if( .advstdstate )	{
					.mloadel(.actionnr(-1)+1);
					fxpageflip1.play;
				}
				} );
			butgame.add(this);
			} );
		
		grpola.eval( func {
			.Button_isin;
			.addmethod("butclick", func {
				if( .advstdstate )	{
					@id = .actionnr(-1);
					if( id < grels.size )	{
						int idreq = dbreq.findbyrow(iidel);
						if( idreq < 0 || <"imgs"+dbreq.get(idreq,1)>.iidstroj != -1 )	{
							anel.load( .getgraphpath + "s"+iidel+".pyz" );
							anel.setframe(id,0);
							anel.hide;
							int idel = dbid.findbyrow(iidel);
							if( idel < 0 )
								idel = iidel;
							else idel = dbid.get(idel,1);
							@s = "imgs" + idel;
							<s>.imgclone("anel");
							<s>.iidstroj = (id);
							<s>.show;
							<s>.setz(<s>.myz);
							fxpedzel.play;
						}
					}
				}
				} );
			butgame.add(this);
			} );
		
		.cbutexit;
		.loadasker;
		//anbutexit.setpos( angumka.getex+3->igetsc1, anbutexit.getpy );
		.mputbg(0);
		
		.stdenter;
	}
	mputbg(int id)	{
		if( iIleBgKol > 0 )	{
			idBgKol.inextrol(id, iIleBgKol);
			imgbgkol.load( .getgraphpath + "imgsbg/bg"+idBgKol+".jpg" );
			imgbgkol.setpos( imgbkg.getex, 0 );
			@x = imgbgkol.getpx + imgbgkol.getw/3;
			anbutleft.ansetbpos( x, imgbgkol.getey-anbutleft.geth );
			anbutright.ansetbpos( x, imgbgkol.getpy );
		}
	}
	butclick_anbutleft	{	.mputbg(-1);	}
	butclick_anbutright	{	.mputbg(1);	}
	butclick_anbutexit	{
		.askfor("OutroStd");
	}
	mhidel	{
		if( grels.size )	{
			grels.deleteloaded;
			grels.free;
		}
		grpola.hide;
	}
	mloadel(int idel)	{	<GAME> (idel) { (int idel)
		iidel = idel;
		.mhidel;
		"grels" .* ("els"+idel+".pyz");
		grels.setz( <grpola.first>.getz + 5 );
		grpola.show;
		.skipmouselclick;
	}; }
	mouse_lclick	{
		if( .advstdstate )	{
			.mhidel;
			angumka.setframe(0,0);
		}
	}
}


|iMemoW, iMemoH| = 4, 2;	// cols , rows
iMemoTryb = 1;	// 0 - player, 1 - p vs c, 2 - p vs p
iMemoAI = 2;

game MainMenuMemo : MermaidStd	{
	init	{
		MermaidStd::init("menu_memo");
		.cbutexit;
		.loadasker;
		
		.imgs = (A, "bgmenu.jpg", "players.pyzG 10", "timer.pyzGH 10", "mode.pyzGH 10");
		
		grplayers.eval( func {
			.Button_isin;
			.addmethod("butclick", func {
				if( .advstdstate )	{
					match(.actionname)	{
						"1p" => {
							iMemoTryb = 0;
							ccs.buildfromscreen;
							grplayers.hide;
							grtimer.show;
							sgmstate = "state_showtimer";
							.stdenter;
						}
						"pvc" => {
							iMemoTryb = 1;
							ccs.buildfromscreen;
							grplayers.hide;
							grmode.show;
							sgmstate = "state_showmode";
							.stdenter;
						}
						"pvp" => {
							iMemoTryb = 2;
							.mgotosize;
						}
						? => ;
					}
				}
				} );
			butgame.add(this);
			} );
		grtimer.eval( func {
			.Button_isin;
			.addmethod("butclick", func {
				if( .advstdstate )	{
					if( .actionname=="timeroff" )	{
						clsave.set("Memo_timer","off");
					} else clsave.set("Memo_timer","on");
					.mgotosize;
				}
				} );
			butgame.add(this);
			} );
		grmode.eval( func {
			.Button_isin;
			.addmethod("butclick", func {
				if( .advstdstate )	{
					match(.actionname)	{
						"easy" => iMemoAI = 0;
						"medium" => iMemoAI = 2;
						"hard" => iMemoAI = 4;
						? => ;
					}
					.mgotosize;
				}
				} );
			butgame.add(this);
			} );
		
		.stdenter;
	}
	mgotosize	{
		ccs.buildblack;
		.stdexit("MenuMemoSize");
	}
	butclick_anbutexit	{
		if( <grtimer.first>.isvisible || <grmode.first>.isvisible )	{
			ccs.buildfromscreen;
			grtimer.hide;
			grmode.hide;
			grplayers.show;
			sgmstate = "state_showplayers";
			.stdenter;
		} else {
			ccs.buildblack;
			if( sMainMenuMemo=="OutroStd" )
				.askfor(sMainMenuMemo);
			else .stdexit(sMainMenuMemo);
		}
	}
}

game MenuMemoSize : MermaidStd	{
	init	{
		MermaidStd::init("menu_memo");
		.cbutexit;
		.loadasker;
		
		.imgs = (A, "bgmenu.jpg", "rozmiar.pyzG 10");
		
		new db dbs;
		dbs.dbbuild(A,
			4,2,"l",
			4,3,"l",
			4,4,"m",
			5,4,"m",
			6,4,"m",
			6,5,"m",
			7,6,"m",
			8,6,"s",
			8,7,"s",
			8,8,"s",
			9,8,"s",
			10,8,"s",
			3);
		
		grrozmiar.eval( func {
			.Button_isin;
			butgame.add(this);
			.addmethod("butclick", func {
				if( .advstdstate )	{
					int id = .actionnr(-1);
					iMemoW = dbs.get(id,0);
					iMemoH = dbs.get(id,1);
					clsave.set("Memo_elsize", dbs.get(id,2));
					.stdexit("GameMemo");
				}
				} );
			} );
		
		.stdenter;
	}
	butclick_anbutexit	{
		.stdexit("MainMenuMemo");
	}
}

game GameMemo : MermaidStd, TMemo	{
	init	{
		MermaidStd::init("mg_memo");
		
		new string selsize = clsave.getdef("Memo_elsize", "m");
		
		.sfxs = (A, "rekord 60", "brawa1 80", "askerups 70", "pageflip1 70", "podnies1 50", "mikrofalaend 70");
		
		int ilebgs = .calcgmfiles("bkg",".jpg");
		.tinit("bkg"+(1+ilebgs.rand)+".jpg", "els"+selsize+".pyz", "tyl"+selsize+".pyz", 2);
		
		int w = iMemoW*(1.2*annak.getw);
		int h = iMemoH*(1.2*annak.geth);
		int w2 = 0.85*igmappw;
		int h2 = 0.75*igmapph;
		if( w > w2 ) w = w2;
		if( h > h2 ) h = h2;
		.tfitinsurf( w, h, 0, 50->igetsc );
		
		.cbutexit;
		.loadasker;
		
		int ifont = 40->igetsc;
		if( iMemoTryb==0 )	{
			new bool btimeron = clsave.is("Memo_timer","on");
			
			if( btimeron )	{
				.newfont("fntim", .cfontpath, ifont);
				.newtext("txtime","","fntim",.red);
				txtime.setpos( anbutexit.getex + 10->igetsc, 10->igetsc );
				new int icurtime = 0;
				.timer = ("timczas",1000,func {
					icurtime++;
					.mprinttime;
					.play;
					} );
				new classfullsave csave("Memo_records.db");
				csave.saveonset=(true);
				csave.stdload;
				new bool bisrekord;
				if( csave.has("rec_"+iMemoW+"x"+iMemoH) )	{
					bisrekord = csave.get("rec_"+iMemoW+"x"+iMemoH);
					new string srecord = clstrdigit::gettime(bisrekord, "ms");
				} else bisrekord = false;
				.mprinttime;
			}
		} else {
			.newanima("anplayer1", "ludki.pyz", 20);
			.copyanima("anplayer1", "anplayer2");
			if( iMemoTryb==2 )
				anplayer2.setframe("player2",0);
			else anplayer2.setframe("computer",0);
			.copyanima("anplayer1", "anarrow");
			anarrow.setframe("arrow",0);
			int dx = 20->igetsc;
			int dy = ifont+dx;
			anplayer1.ansetbpos(dx, igmapph-anplayer1.geth-dy);
			anplayer2.ansetbpos(igmappw-dx-anplayer2.getw, igmapph-anplayer2.geth-dy);
			.msetplayer(1);
			
			.newfont("fntpt", .cfontpath, ifont);
			.newtext("timp1","","fntpt",.red);
			.newtext("timp2","","fntpt",.red);
			new int ipointsp1 = 0;
			new int ipointsp2 = 0;
			timp1.setpos(anplayer1.getpx, anplayer1.getey+dx/2);
			timp2.setpos(anplayer2.getpx, anplayer2.getey+dx/2);
			.mprintpoins;
		}
		
		ccs.enter( func {
			.advsetstdstate;
			.tm_start;
			if( iMemoTryb==0 && btimeron )
				timczas.play;
			} );
	}
	msetplayer(int id)	{
		@s = "anplayer"+id;
		anarrow.setpos(<s>.getcx, <s>.getpy);
	}
	mprinttime	{
		if( bisrekord )
			txtime.txtset("Record: "+srecord+" , "+clstrdigit::gettime(icurtime, "ms"));
		else
			txtime.txtset(clstrdigit::gettime(icurtime, "ms"));
	}
	mouse_lclick	{
		if( .advstdstate )
			.tm_mouselclick;
	}
	butclick_anbutexit	{
		.askfor("MenuMemoSize");
	}
	tnextplayer	{
		TMemo::tnextplayer;
		.msetplayer(iplayer);
	}
	tpoint	{
		fxmikrofalaend.play;
		if( iMemoTryb>0 )	{
			if( iplayer==1 ) ipointsp1++;
			else ipointsp2++;
			.mprintpoins;
		}
		
	}
	mprintpoins	{
		timp1.txtset(ipointsp1);
		timp1.txtshadow(1,"fntpt");
		timp2.txtset(ipointsp2);
		timp2.txtshadow(1,"fntpt");
	}
	tchoose	{	fxpageflip1.play;	}
	terror	{	fxpodnies1.play;	}
	tfinish()	{
		if( iMemoTryb==0 )	{
			fxbrawa1.play;
			if( btimeron )	{
				timczas.stop(false);
				if( bisrekord==0 || icurtime<bisrekord )	{
					csave.set("rec_"+iMemoW+"x"+iMemoH, icurtime);
					<GAME>.img = ("rekord.png 100");
					imgrekord.ancenterscreen;
					txtime.txtset(clstrdigit::gettime(icurtime, "ms"));
					txtime.setpos( imgrekord.getcx-txtime.getw/2, imgrekord.getpy + 0.55*imgrekord.geth );
					imgrekord.blit("txtime");
					txtime.hide;
					sgmstate = "state_showrekord";
					imgrekord.anzoomin(idymekdelay, "mfin");
					fxrekord.play;
				}
			} else .mfin;
		} else {
			.tpoint;
			if( ipointsp1==ipointsp2 )	{ fxbrawa1.play;}
			else if (ipointsp1>ipointsp2)	{ fxbrawa1.play;	}
			else	if( iMemoTryb==2)	{ fxbrawa1.play;	}
			else { fxaskerups.play;	}
			.mfin;
		}
	}
	mfin	{	sgmstate = "state_finished";	}
	butclick_nostdstate_anbutexit	{
		if( sgmstate=="state_finished" ) .stdexit("MenuMemoSize");
		else
			.butclick_anbutexit;
	}
}




new string sMainMenuPuzBaj = "OutroStd";

game MainMenuPuzBaj : MermaidStd	{
	init	{
		sMenuButExit = "MainMenuPuzBaj";
		sMenuButOk = "MenuTrybPuzzle";
		
		MermaidStd::init("menu_puzbaj");
		
		if( engine.fileexist(.getpath("bgmenupuzbaj.jpg") ) )
			.newimg("imgbkg",.getpath("bgmenupuzbaj.jpg"),0);
		else .newimg("imgbg", "$" + .getgamepath + "menu_tryb/tryby.jpg",0);
		.imgs = (A, "bgmenupuzbaj.jpg", "butpuz.pyz 10", "butbaj.pyz 10");
		
		.cbutexit;
		.loadasker;
		
		anbutpuz.Button_addstdstate;
		anbutbaj.Button_addstdstate;
		
		.stdenter;
	}
	butclick_anbutexit	{
		.askfor(sMainMenuPuzBaj);
	}
	butclick_anbutpuz	{	.stdexit(sMenuImgStd);		}
	butclick_anbutbaj	{	.stdexit("BajkaCzytana");	}
}

game BajkaCzytana : MermaidStd	{
	init	{
		MermaidStd::init("bajkaczyt");
		
		.cbutexit;
		
		new classfullsave csave("bajkaczytana.db");
		csave.saveonset=(true);
		csave.stdload;
		new int ilastpage = csave.get(sgmproject);
		if( ilastpage<1 ) ilastpage=1;
		new img imgbg;
		
		.newfont("fnpage", "configs/fonts/seren1.ttf", 50->igetsc);
		.newtext("txtpage", "", "fnpage", .yellow);
		txtpage.setz(10);
		.newtext("txtfirstpage", "<< START", "fnpage", .yellow);
		txtfirstpage.setz(10);
		txtfirstpage.setpos( 3->igetsc1, txtfirstpage.mypagepos );
		txtfirstpage.txtshadow(1,"fnpage");
		
		.mload(0);
		
		.stdenter;
	}
	mypagepos	{	igmapph - .geth - 3->igetsc1;	}
	mload(int id)	{
		if( engine.fileexist( .mpath(ilastpage+id) ) )	{
			ilastpage+=id;
			csave.set(sgmproject, ilastpage);
			ccs.buildfromscreen;
			imgbg.load(.mpath(ilastpage));
			imgbg.setpos(0,0);
			txtpage.txtset(ilastpage);
			txtpage.setpos( igmappw - txtpage.getw - 3->igetsc1, txtpage.mypagepos );
			txtpage.txtshadow(1,"fnpage");
			sgmstate = "state_nextpage";
			ccs.enter("advsetstdstate");
			if( ilastpage==1 )
				txtfirstpage.txthides;
			else txtfirstpage.txtshows;
		}
	}
	mpath(int id)	{	.getpath(sPuzBajImgPref + id + ".jpg");	}
	mouse_lclick	{
		if( .advstdstate )	{
			if( mouse.getpx > igmappw/2 )	{
				.mload(1);
			} else if( txtfirstpage.isin(mouse.getpos,0,0) )	{
				.mload(1-ilastpage);
			} else .mload(-1);
		}
	}
	butclick_anbutexit	{
		ccs.buildblack;
		.stdexit("MainMenuPuzBaj");
	}
}

