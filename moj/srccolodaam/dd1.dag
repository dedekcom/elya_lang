
new db dbconf;
dbconf.loadscript("configs/config.beh");
public def readcfg(string svar, def val)	{
	int id = dbconf.findbyrow(svar);
	if( id<0 ) val;
	else dbconf.get(id,1);
}

engine.setdebugstate( .readcfg("enginedebug:", 0) );

new int igmdebug = .readcfg("igmdebug:", 0);
new int igmpcdebug = .readcfg("igmpcdebug:", 0);
if( igmpcdebug )	{
	mouse.showsys;
}
new int igmexportan = .readcfg("igmexportan:", 0);
new int igmimportan = .readcfg("igmimportan:", 0);
new int igmenablesave = .readcfg("igmenablesave:", 0);

new int igmdelay = .readcfg("igmdelay:", engine.getloopdelay);

/**************************************************************/
new int igmwinlocal = .readcfg("igmwinlocal:", 0);		// special folder windows
new int igmmac = .readcfg("igmmac:", 0);
new int igmipad = .readcfg("igmipad:", 0);
new int igmiphone = .readcfg("igmiphone:", 0);
new int igmandroid = .readcfg("igmandroid:", 0);

new string sgmdeveloper = .readcfg("sgmdeveloper:", "Dagiel");
new string sgmproject = dbconf.dbget("sgmproject:");

public bool isapple		{	igmipad || igmmac || igmiphone;		}
public bool checktouchpad	{	igmipad || igmiphone || igmandroid;	}

//---------------------- ekran ------------------------------

|new int igmappw, new int igmapph| = engine.getappsize;	// rozmiar
|new int igmoffsetx, new int igmoffsety| = engine.getscreenoffset;	// przesuniecie na wezszych od apki monitorach
//|new int iResX, new int iResY| = engine.getscreensize;	// rozmiar gry po przeskalowaniu
|new int iResX, new int iResY| = engine.getscreenres;	// rozmiar gry po przeskalowaniu
|new real rgmscalex, new real rgmscaley| = engine.getscreenscale;
new int i1024offsetx = 171->igetsc;
public int getxoffset	{
	igmandroid ? (engine.getxandro < igmoffsetx ? igmoffsetx : engine.getxandro) : igmoffsetx;
}

// ("appw/h: "+igmappw+","+igmapph+" offset: "+igmoffsetx+","+igmoffsety+" resx/y: "+iResX+","+iResY)->print;

public def getappcenter	{
	return igmappw/2, igmapph/2;
}
public int edgeex	{	iResX+igmoffsetx;	}
public int edgeey	{	iResY+igmoffsety;	}
//------------------ sciezki --------------------

public string getwinpath(string spath)	{
	string s = engine.getspecialpath("appdata");
	if( s!=null )	{
		s + "/" + sgmdeveloper + "/" + sgmproject + "/" + spath;
	} else spath;
}

public getsavepath	{
	if( .isapple )	{
		engine.getsavepath;
	} else {
		(igmwinlocal ?  .getwinpath("saves/") :  "saves/");	
	}
}

public buildsavedir	{
	if( igmwinlocal && !.isapple )	{
		string s = engine.getspecialpath("appdata");
		if( s!=null )	{
			s += "/" + sgmdeveloper;
			int odp = engine.mkdir(s);
			odp = 0;
			if( odp==0 || odp==1 )	{
				s +=  "/" + sgmproject;
				odp = engine.mkdir(s);
				odp = 0;
				if( odp==0 || odp==1 )	{
					s+= "/saves";
					_ = engine.mkdir(s);
				}
			}
		}
	}
}
.buildsavedir;

/******** konstrukcje  ********************/
new string	A = "!!!";
new real		PI = 3.14159265358979323846;
new int		BYTE0 = "0"->getbyte(0);
new int		BYTE9 = "9"->getbyte(0);
new int		BYTEa = "a"->getbyte(0);
new int		BYTEz = "z"->getbyte(0);
new int		BYTEA = "A"->getbyte(0);
new int		BYTEZ = "Z"->getbyte(0);
new int		BYTE_ = "_"->getbyte(0);
new int		BYTESPACE = " "->getbyte(0);

public empty_func	{}

public varget(string svar)				{	[svar];				}
public varset(string svar, def val)			{	<svar> = val;			}
public varnew(string styp, string svar)			{	new <styp> <svar>;	}
public varnewif(string styp, string svar)		{	if( !.hasvar(svar) )	.varnew(styp,svar);}
public vardelif(string svar)				{	if( .hasvar(svar) )	.vardel(svar);		}
public vardel(string svar)				{	delete <svar>;		}
public reader(string sname)	{
	.varnewif("def", sname);
	.addmethod( sname, func { [.methodname]; } );
}
public writer(string sname)	{
	.varnewif("def", sname);
	.addmethod( sname+"=", func { (def val) <.methodname->strsube(1)> = val; } );
}
public var(string sname)	{
	.reader(sname);
	.writer(sname);
}
public var2(string sname, def val)	{
	.var(sname);
	<sname> = val;
}
public withlist(string sfun)	{
	@s = _;
	while( A != s )	{
		.<sfun>(s);
		@s = _;
	}
}
public withlist2(string sfun)	{
	@s = _;
	while( A != s )	{
		@s1 = _;
		.<sfun>(s1,s);
		@s = _;
	}
}
public vars	{	.withlist("var");}
public vars2	{	.withlist2("var2");}

/*****************************************************/
public builder_func(string sfun)	{
	<.getbuildername>.<.getbuildername+sfun>;
}
public callfun(string sob, string sfun)	{
	if( sfun!=null ) sob==null ? .<sfun> : <sob>.<sfun>;
}
public string add_callfun(string spref, string sob, string sfun)	{ <gameapi.getgamename> (spref, sob, sfun) { (@spref, @sob, @sfun)
	@s = spref + "_callfun_";
	.vars2(A, s+"sob",sob, s+"sfun",sfun);
	.addmethod(s, func {
		@s = .methodname;
		.callfun( [s + "sob"], [s + "sfun"] );
		} );
	s;
}; }
public string fullname_callfun(string sob, string sfun)	{
	.add_callfun(.getfullname, sob, sfun);
}
public dprint(string smsg)	{
	int d = engine.getstack;
	("stack=" + d + " : " +smsg)->print;
}
public printargs(int ile)	{
	string sargs = "";
	while( ile>0 )	{
		def s = _;
		sargs = "(" + s.gettype + ") " + s + "  " + sargs;
		ile--;
	}
	engine.print("args: " + sargs);
}
/*****************************************************/
public bool in	{
	bool b = false;
	@x = .get;
	@y = _;
	while( A != y )	{
		if( !b )	b = x==y;
		@y=_;
	}
	b;
}
public with(string sfun)	{
	string sob = _;
	while( sob!=A )	{
		<sob>.<sfun>();
		sob=_;
	}
}
public copycall(string sfun, string sob)	{
	string s = "__call" + sfun;
	new string <s>;
	<s> = sob;
	.addmethod( sfun, func {
		string sf = .methodname;
		< [ "__call" + sf ] >.<sf>();
		});
}
public copycalls(string sobj)	{
	string s = _;
	while( s!=A )	{
		.copycall( s, sobj ); 
		s=_;
	}
}
/***********************************/
public mresize()	{	< .gettype + "_pack">::resizemethods( this );	}
/******** petle ********************/
public times(string sfun)		{	this.for_plus(0, this.get()-1, sfun );		}
public upto(int ito, string sfun)	{	this.for_plus( this.get(), ito, sfun );	}
public downto(int ito, string sfun)	{	this.for_minus( this.get(), ito, sfun );	}
public for_plus(int ifrom, int ito, string sfun)	{
	if( ito-ifrom<=0 )	return;
	for( ; ifrom<=ito; ifrom++)	this.<sfun>(ifrom);
}
public for_minus(int ifrom, int ito, string sfun)	{
	if( ifrom-ito<=0 )	return;
	for( ; ifrom>=ito; ifrom--)	this.<sfun>(ifrom);
}
public double_for(int w, int h, string sfun)	{
	int j;
	for( int i=0; i<w; i++)	{
		for( j=0; j<h; j++)	{
			this.<sfun>(i,j);
		}
	}
}
/****************************************/

// klasa do np. dynamicznego tworzenia obiektow z prefixem+id
class classobjcounter	{
	init(string sprefix)	{
		new string _sprefix=sprefix;
		new int _iile=0;
		.var2("limit",0);
	}
	string get()	{
		if( limit>0 ) _iile=_iile%limit+1;
		else _iile++;
		return _sprefix + (_iile-1);
	}
	int size()	{_iile;}
	int getid(int id)	{	_sprefix + (_iile-1-id);	}
}

/*class classvsigobj	{
	init()	{
		new bool bplaying=false;
	}
	virtual play()	{	bplaying=true;	}
	virtual stop(bool bstop)	{ 
		bplaying=false;
		if( bstop )	{	this.onfinish();	}
	}
	virtual bool isplaying()	{	bplaying;	}
}*/

/***************************************************************************/

class classsignals	{
	init()	{}
	/********** std obj **********************/
	stdfinish(string sob) { <sob>.addmethod("onfinish",func { this.<this.getname()+"_FINISH">();}); }
	stdstart(string sob) { <sob>.addmethod("onstart",func { this.<this.getname()+"_START">(); }); }
	stdsigs(string sob)	{
		this.stdstart(sob);
		this.stdfinish(sob);
	}
	/********** anima **********************/
	buildanima(string san)	{
		this.stdsigs(san);
		<san>.addmethod("onendframe", func { this.<this.getname()+"_ENDFRAME">(); } );
	}
	/********** snd **********************/
	buildsnd(string ssnd)	{	this.stdsigs(ssnd);		}
	/********** timer **********************/
	buildtimer(string stimer)	{
		this.stdsigs(stimer);
		<stimer>.addmethod("ontick", func { this.<this.getname()+"_TICK">(); });
	}
	/********** button *******************/
	buildbut(string sbut)	{
		<sbut>.addmethod("onclick", func { this.<this.getname()+"_CLICK">(); });
		<sbut>.addmethod("onrel", func { this.<this.getname()+"_REL">(); });
		<sbut>.addmethod("onmoveon", func { this.<this.getname()+"_MOVEON">(); });
		<sbut>.addmethod("onmoveoff", func { this.<this.getname()+"_MOVEOFF">(); });
	}
}

/******************************************************************/

class classlocker	{
	init()	{
		new bool _block = true;
	}
	public lock()	{	_block=true;	}
	public unlock()	{	_block=false;	}
	public setlock(bool b)	{	_block=b;	}
	public bool getlock()	{	return _block;	}
	public bool unlocked	{	_block==false;	}
	public setaslocker(string sob)	{
		<sob>.addmethod("buildlocker", func { new bool _block=true; });
		<sob>.buildlocker;
		<sob>.addmethod("lock", "lock");
		<sob>.addmethod("unlock", "unlock");
		<sob>.addmethod("setlock", "setlock");
		<sob>.addmethod("getlock", "getlock");
		<sob>.addmethod("unlocked", "unlocked");
	}
}

/***************************************************************************/

module classdbreader	{
	init()	{
		new db dbl;
	}
	readdb( string sfunc )	{
		int id = 0;
		int ile = dbl.getrowsno();
		while( id < ile )	{
			this.<sfunc>( id );
			id++;
		}
	}
	readrow( string srow, string sfunc )	{
		int ipos = dbl.findbyrow( srow );
		if( ipos >= 0 )	{
			this.<sfunc>( ipos );
		}
	}
}

/***************************************************************************/


/***************************************************************************/
class collection	{
	init(string styp)	{	new string stype=styp;	}
	public string type()	{	return stype;		}
}

class array : collection {
	init(string styp, int idimens, int isiz)	{
		collection::init(styp);
		new int idim = idimens;
		new int isize = isiz;
		new vector vec;
		vec.type(styp);
		if( idimens<=0 || isiz<=0 )	return;
		//vec.resize( isiz.pow(isiz,idimens), 0 );
		vec.resize( isiz.pow(idimens), 0 );
	}
	int getid()	{
		int pos=0;
		int dim=idim-1;
		while(dim>0)	{
			pos+=_;
			pos*=isize;
			dim--;
		}
		return pos+_;
	}
	public def get()	{	return vec.get( this.getid() );	}
	public set(def svar)	{	vec.set( this.getid(), svar);	}
	public int getsize()	{	return isize;			}
	public int getdim()	{	return idim;			}
}

class stack : collection	{
	init(string styp)	{
		collection::init(styp);
		new vector vec;
		vec.type(styp);
		new <styp> var;
	}
	public push(string svar){	vec.add(svar);		}
	public def top()	{	return vec.last();	}
	public def pop()	{
		var = this.top();
		vec.removeat( vec.size()-1 );
		return var;
	}
	public free	{	vec.free;	}
}

class map : collection	{
	init(string styp)	{
		collection::init(styp);
		new int isize=0;
	}
	set(string svar, def val)	{
		if( !this.hasvar("v"+svar) )	this.add(svar);
		<"v"+svar>.set(val);
	}
	add(string svar)	{	new <stype> <"v"+svar>;		}
	def get(string svar)	{	return ["v"+svar];		}
	remove(string svar)	{	delete <"v"+svar>;		}
	bool contains(string svar){	return this.hasvar("v"+svar);	}
}
class map2 : collection	{
	init(string styp)	{
		collection::init(styp);
		new vector vn;
		vn.type("string");
		new vector vec;
		vec.type(styp);
	}
	add(string svar, def val)	{	vn.add(svar);	vec.add(val);	}
	set(string svar, def val)	{	vec.set( vn.find(svar), val );	}
	bool contains(string svar)	{	return vn.contains(svar);	}
	def get(string svar)		{	return vec.get( vn.find(svar) );}
	remove(string svar)	{
		int id = vn.find(svar);
		if( id>=0 )	{
			vec.removeat( id );
			vn.removeat(id);
		}
	}
	free()	{	vn.free();	vec.free();	}
	print	{	vec.print;	vn.print;	}
}


/***************************************************************************/

class Music	{
	init	{
		new vector vmus;
		vmus.type("string");
		new int ilastid;
		.vars2(A, "musicvolume", 100, "globalvolume", 100);
		new string smixer = "gameapi";
		//onmusicfin      {       mus.play;       }
	}
	smixer	{	 smixer;	}
	smixer=(string s)	{
		smixer = s;
		.updatevolume;
	}
	playdb(string s, int row, int icol)	{
		vmus.free;
		while (icol < <s>.getcolsno(row) )	{
			vmus.add( <s>.get(row, icol) );
			icol++;
		}
		ilastid = 0;
		.play;
	}
	playvec(string s, int id)	{
		vmus.free;
		while( id< <s>.size )	{
			vmus.add( <s>.get(id) );
			id++;
		}
		ilastid = 0;
		.play;
	}
	playstr(string s)	{
		vmus.vecbuildfromstring(s, " ");
		ilastid = 0;
		.play;
	}
	play	{
		if( ilastid >= vmus.size ) return;
		
		string s = MUSICPATH + vmus.get(ilastid);
		if( s.gete(0,3)!="ogg" && s.gete(0,3)!="wav" ) s+=".ogg";
		if( !engine.fileexist(s) )	{
			s = SFXPATH + vmus.get(ilastid);
		}
		
		ilastid++;
		
		bool bloop=false;
		int fin=0;
		int fout = 0;
		musicvolume = globalvolume;
		
		for( int i=ilastid; i<vmus.size; i++)	{
			@s1 = vmus.get(i);
			match(s1)	{
				"-l" => bloop = true;
				"-v", "-vol" => { i++;
					musicvolume = vmus.get(i);
					}
				"-fin" => { i++; fin = vmus.get(i); }
				"-fout" => { i++; fout = vmus.get(i); }
				"-p" => ;
				? => { ilastid=i; i = vmus.size; }
			}
		}
		.updatevolume;
		if( bloop ) {
			ilastid = vmus.size;
			if( smixer=="engine" && engine.ismusicplaying && engine.getactmusic==s ) {
			} else {
				<smixer>.playmusic(s);
			}
		} else {
			<smixer>.loadmusic(s);
			if (fin) <smixer>.fadeinmusic(fin);
			else {
				<smixer>.startmusic;
			}
			if (fout) <smixer>.fadeoutmusic(fout);
		}
	}
	getvol	{	(globalvolume * musicvolume) / 100;	}
	fadeout(int ms)	{
		if( <smixer>.ismusicplaying ) {
			<smixer>.fadeoutmusic(ms);
			ilastid=vmus.size;
		}
	}
	updatevolume	{
		<smixer>.setmusicvol(.getvol);
	}
	isplaying	{	<smixer>.ismusicplaying;	}
	getactmusic	{	engine.getactmusic;	}
	stop	{
		<smixer>.endmusic(false);
	}
}

/**************************************************************/
	// zmienne globalna - stany gry

new int igmstate;
new string sgmstate;
public printstate	{	("sgmstate = "+sgmstate + " ,  igmstate = "+igmstate)->print;}

new bool igmdemo = .readcfg("igmdemo:",false);
new bool igmbegin = true;
new bool igmsoundson = .readcfg("igmsoundson:",true);

new string sgmfontfile = .readcfg("sgmfontfile:", "configs/fonts/normal.ttf");
new string sgmfontmono = .readcfg("sgmfontmono:", "configs/fonts/normal.ttf");
new string sgmfontmonobold = .readcfg("sgmfontmonobold:", "configs/fonts/normal.ttf");
new string sgmfontbold = .readcfg("sgmfontbold:", "configs/fonts/normal.ttf");
new string sgmfontitalic = .readcfg("sgmfontitalic:", "configs/fonts/normal.ttf");

new string SFXPATH = .readcfg("sfxpath:", "sounds/sfx/");
new string BGRPATH = .readcfg("sndbgrpath:", "sounds/sfx/");
new string MUSICPATH = .readcfg("musicpath:", "sounds/music/");

new string LANG;
new string LANGDIR;
new string SNDPATH;

public LANG=(@s)	{
	LANG = s;
	SNDPATH = "sounds/" + LANG + "/";
	LANGDIR = "lang/" + LANG + "/";
}

.LANG = (.readcfg("lang:", "eng"));

/**************************************************************/
	// standardowa klasa do tworzenia zmiennych
class newvars		{
	init()	{
		new string _sclpath = "";
		new string _sclwavpath = "";
	}
	string _checkfont(string sfont, int isize, string sfnt)	{
		if( sfont==null )	sfont=sgmfontfile;
		if( sfont.contains(".ttf") )	{
			new font <sfnt>;
			<sfnt>.load( sfont, isize );
			sfont = sfnt;
		}
		sfont;
	}
	string checkfont(string sfont, int isize)	{
		._checkfont(sfont, isize, "_fnt");
	}
	bool begingame()	{
		igmbegin = !igmbegin;
		!igmbegin;
	}
	newarray(string styp, string sbase, int size)	{
		if( size<= 0 )	return;
		size--;
		while(size>=0)	{
			new <styp> <sbase+size>;
			size--;
		}
	}
	setgraphpath(string spath)	{
		_sclpath = spath;
		engine.setpath(spath);
	}
	setwavpath(string spath)	{	_sclwavpath = spath; }
	string getgraphpath()	{	_sclpath; }
	string getsndpath()	{	_sclwavpath; }
	getpath(string sfile)	{
		if( sfile.getb(0,1)=="$" ) sfile.strsubb(1);
		else .getgraphpath + sfile;
	}
	pathload(string sfile)	{	.load(.getgraphpath + sfile);	}
	newanima(string sname, string sfile, int z)	{
		new anima <sname>;
		if( sfile.gete(0,4)!=".pyz" )
			sfile += ".pyz";
		@s = .getpath(sfile);
		<sname>.load( s );
		if( igmdebug )	{
			if( igmexportan )	{
				<sname>.saveimages("debug/" + s.getb(0, s.length-s.strgeteto("/")->length) + 
					s.strgeteto("/")->strsubes(".pyz") + "/" );
			} else if( igmimportan )	{
				s = "debug/" + s.strsubes(".pyz") + "/";
				if( engine.fileexist( s + "0.png") )	{
					<sname>.loadimages( s );
				}
			}
		}
		<sname>.setz(z);
	}
	newstdanima(string sname, string sfile, int z)	{
		this.newanima(sname, sfile, z);
		this.stdanaction(sname);
	}
	copyanimaactz(string ssrc, string sdest, string saction, int z)	{
		this.copyanimaact(ssrc, sdest, saction);
		<sdest>.setz(z);
	}
	copyanimaact(string ssrc, string sdest, string saction)	{
		this.copyanima(ssrc, sdest);
		<sdest>.setframe( saction, 0 );
	}
	copyanima(string ssrc, string sdest)	{
		new anima <sdest>;
		<sdest>.copy( ssrc );
	}
	copyanimas(string san, string sname, int istart, int ilosc)	{
		if (ilosc>0)	{
			for(int i=0; i<ilosc; i++)
				this.copyanima( san, sname + (istart + i)  );
		}
	}
	newanimas(string sname, string sfile, int z, int ilosc)	{
		if(ilosc>0) {
			this.newanima(sname+"0", sfile, z);		// pierwsza load z zerem
			this.copyanimas(sname+"0", sname, 1, ilosc-1);		// pozostale kopiowane z niej
		}
	}
	int newanframesgr(string san, string sname, int iaction, string sgr)	{	// tworzy animacje z klatek
		int ile = <san>.nofframes( iaction );
		this.copyanimas( san, sname, 0, ile );
		for(int i=0; i<ile; i++)	{
			<sname+i>.setframe(iaction, i);
			if( sgr!=null )	{	<sgr>.add( sname+i );	}
		}
		ile;		// zwraca ilosc stworzonych animacji
	}
	int newanframes(string san, string sname, int iaction)	{	// tworzy animacje z klatek
		this.newanframesgr(san,sname,iaction,null);
	}
	newcanvas(string sname, int w, int h, int r, int g, int b, int a, int z)	{
		new img <sname>;
		<sname>.create(w,h,r,g,b,a);
		<sname>.setz(z);
	}
	newimg(string sname, string sfile, int z)	{
		new img <sname>;
		<sname>.load( .getpath( sfile ) );
		<sname>.setz(z);
	}
	copyimg(string ssrc, string sdest)	{
		new img <sdest>;
		<sdest>.copy(ssrc);
	}
	playmusic(string sfile)	{gameapi.playmusic( MUSICPATH + sfile );	}
	snewsnd(string sname, string sfile)	{
		this.newsnd(sname,sfile);
		<sname>.addmethod("onfinish","__std_finish");
	}
	_newsnd(string sname, string sfile, bool bfree)	{
		new snd <sname>;
		if( !sfile.contains(".") ) {
			sfile += ".wav";
		}
		if( !engine.fileexist(sfile) )	{
			sfile = sfile.strsubes("wav") + "ogg";
		}
		if( bfree )
			<sname>.setstartstopflag(false, true);
		<sname>.load( sfile );
		if( igmsubtitle )	{
			subtitle.register(sname, sfile);
		}
	}
	newsfx(string sname, string sfile)	{	._newsnd(sname, SFXPATH + sfile, false);	}
	newbgr(string sname, string sfile)	{	._newsnd(sname, BGRPATH + sfile, false);	}
	newbgrloop(string s, string s2)		{	.newbgr(s,s2); .sndplayloop(s);	}
	newsnd(string sname, string sfile)	{	._newsnd(sname, .getsndpath+sfile, false);	}
	newsndfree(string sname, string sfile)	{	._newsnd(sname, .getsndpath+sfile, true);	}
	newsndloop(string sname, string sfile)	{
		this.newsnd(sname,sfile);
		this.looponfinish1( sname );
	}
	looponfinish1( string sob )	{<sob>.addmethod("onfinish","_stdsndloop");	}
	sndplayloop(string sob)	{
		this.looponfinish1( sob );
		<sob>.play();
	}
	newsnds(string sbase, int inamestart, string sfilebase, int ifilefrom, int ifileto)	{
		string s;
		int ile = ifileto-ifilefrom+1;
		for(int i=0; i<ile; i++)	{
			s = sbase + (inamestart + i);
			new snd <s>;
			<s>.load( this.getsndpath() + sfilebase + (ifilefrom+i) + ".wav" );
		}
	}
	newtimer(string sname, int idelay, int iticks)	{
		new timer <sname>;
		<sname>.settick(iticks);
		<sname>.delay(idelay);
	}
	newtimercycle(string sname, int icycle, int iticks)	{
		new timer <sname>;
		<sname>.settick(iticks);
		<sname>.setcycle(icycle);
	}
	stdanaction(string san)	{
		string s = <san>.actionname();
		if( s.contains("L")  )	this.looponfinish(san);
		else if( s.contains("H")  )	this.hideonfinish(san);
		if( s.contains("P")  )	<san>.play(-1);
	}
	int newanactionsgr(string san, string sname, string sgr)	{
		int ile = <san>.nofactions();
		this.copyanimas( san, sname, 0, ile );
		string s;
		for(int i=0; i<ile; i++)	{
			s = sname+i;
			<s>.setframe(i,0);
			this.stdanaction(s);
			if( sgr!=null )	{<sgr>.add( s );}
		}
		ile;
	}
	int newanactions(string san, string sname)	{ this.newanactionsgr(san,sname,null);	}
	int newanfrbyactgr(string san, string sname, string sgr)	{
		int ile = <san>.nofactions();
		for( int i=0; i<ile; i++)	_ = this.newanframesgr(san, sname+i+"_", i, sgr);
		ile;
	}
	int newanfrbyact(string san, string sname)	{ this.newanfrbyactgr(san,sname,null);	}
	int loadanfrbyact(string san, string sfile, int z)	{
		string s = "_"+san;
		this.newanima(s,sfile,z);
		int ile = this.newanfrbyact(s, san);
		<s>.hide();
		ile;
	}
	int loadanactions(string san, string sfile, int z)	{
		string s = "_"+san;
		this.newanima(s, sfile, z);
		int ile = this.newanactions(s, san);
		<s>.hide();
		ile;
	}
	int loadanframes(string san, string sfile, int iaction, int z)	{
		string s = "_"+san;
		this.newanima(s, sfile, z);
		int ile = this.newanframes(s, san, iaction);
		<s>.hide();
		ile;
	}
	newbutimg(string sbut, string sstd, string smov, string sclick, string smouse)	{
		new button <sbut>;
		<sbut>.set(sstd, smov, sclick);
		<sbut>.setmouse(smouse);
	}
	newbutan(string sbut, string sanstd, string sanmov, string sanclick, string smouse)	{
		new button <sbut>;
		<sbut>.setan(sanstd, sanmov, sanclick);
		<sbut>.setmouse(smouse);
	}
	/*****************************************************/
	newdb(string sdb, string sfile)	{
		new db <sdb>;
		<sdb>.load( .getpath(sfile) );
	}
	newdbscript(string sdb, string sfile)	{
		new db <sdb>;
		//<sdb>.loadscript( this.getgraphpath() + sfile );
		<sdb>.loadscritp( .getpath(sfile) );
	}
	vargmset(string svar, def val)	{
		string sg = gameapi.getgamename();
		if( !<sg>.hasvar(svar) )	<sg>.varnew( val.gettype(), svar );
		<svar> = val;
	}
}


new anima anmsc;

class classadvmouse	{
	init()	{
		//new anima anmsc;
		new string sactac;
	}
	public load(string sname)	{
		anmsc.load(sname);
		anmsc.addmethod("onendframe", "setnextframe");
		anmsc.addmethod("onsetframe", func { .hide; } );
		anmsc.hide();
	}
	public stdload	{
		if( !igmdebug && .checktouchpad )	.load("scripts/common/kursorypad.pyz");
		else .load("scripts/common/cursors.pyz");
	}
	setnextframe	{
		anmsc.ansetnextfr;
		mouse.setcursor("anmsc");
	}
	setif(string sac)	{
		if( .get!=sac )
			.set(sac);
	}
	set(string saction)	{
		sactac = saction;
		//anmsc.setframe( saction, 0 );
		if( !anmsc.isplaying( saction ) )	{
			anmsc.play( saction );
		}
		mouse.setcursor("anmsc");
	}
	setstd()	{	this.set("normal");	}
	setactive()	{	this.set("active");	}
	setact()	{	this.set("active");	}
	setbut		{	this.set("active");	}
	setexit()	{	this.set("exit");	}
	setwait()	{	this.set("wait");	}
	get()		{	anmsc.actionname();	}
	lodx	{	anmsc.lodx;	}
	lody	{	anmsc.lody;	}
	refresh	{ if( sactac!=null ) .set(sactac);	}
}

new classadvmouse advmouse;
advmouse.stdload;

if( !.checktouchpad )	{
	advmouse.setstd;
	engine.stdbutcursor("anmsc");
}

/***************************************************************************/

module clsurf	{
	init()	{}
	bool isin(int x, int y, int x1, int y1, int x2, int y2)	{	x >= x1 && x<=x2 && y>=y1 && y<=y2;	}
	bool isin2(int x, int y, int x1, int y1, int w, int h)	{	x >= x1 && x < x1+w && y>=y1 && y<y1+h;	}
	bool inscreen(int x, int y, int dx, int dy)	{	this.isin( x, y, 0-dx, 0-dy, 800+dx, 600+dy );	}
	bool insurf(int x, int y, string simg) { .isin(x,y,<simg>.getpx, <simg>.getpy, <simg>.getex-1, <simg>.getey-1);}
	bool issurfin(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)	{
		this.isin(x1,y1, x3,y3,x4,y4) || this.isin(x2,y1, x3,y3,x4,y4) ||
		this.isin(x1,y2, x3,y3,x4,y4) || this.isin(x2,y2, x3,y3,x4,y4) ||
		( x1<x3 && x2>x4 && y1<y3 && y2>y4 );
	}
	bool commonsurface(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)	{
		this.issurfin(x1,y1,x2,y2, x3,y3,x4,y4) || 
				this.issurfin(x3,y3,x4,y4, x1,y1,x2,y2);
	}
	bool commonimgs(string simg1, string simg2)	{
		this.commonsurface(<simg1>.getpx(), <simg1>.getpy(), <simg1>.getex()-1, <simg1>.getey()-1,
				<simg2>.getpx(), <simg2>.getpy(), <simg2>.getex()-1, <simg2>.getey()-1 );
	}
	bool surfwithinsurf(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)	{
		this.isin(x1,y1, x3,y3,x4,y4) && this.isin(x2,y1, x3,y3,x4,y4) &&
				this.isin(x1,y2, x3,y3,x4,y4) && this.isin(x2,y2, x3,y3,x4,y4);
	}
	bool imgwithinimg(string simg1, string simg2)	{
		this.surfwithinsurf(<simg1>.getpx(), <simg1>.getpy(), <simg1>.getex()-1, <simg1>.getey()-1,
				<simg2>.getpx(), <simg2>.getpy(), <simg2>.getex()-1, <simg2>.getey()-1 );
	}
}

/* modul do obliczen odleglosci */

module cllen	{
	init()	{
		new int il1;
		new int ilx;
		new int ily;
	}
	int ilenx()	{ return ilx; }
	int ileny()	{ return ily; }
	int ilen4(int x1, int x2)	{	return (x1-x2)->abs();	}
	int ilen3(string simg1, string simg2)	{
		return this.ilen( <simg1>.getcx(), <simg1>.getcy(), <simg2>.getcx(), <simg2>.getcy() );
	}
	int ilen5(string simg1, string simg2)	{
		return this.ilen( <simg1>.getpx(), <simg1>.getpy(), <simg2>.getpx(), <simg2>.getpy() );
	}
	int ilen2(string simg1, int x, int y)	{return this.ilen( <simg1>.getcx(), <simg1>.getcy(), x,  y );	}
	int ilen(int x1, int y1, int x2, int y2)	{
		ilx = x1-x2;
		ily = y1-y2;
		return il1.length( ilx, ily );
	}
	int iclenx(string simg1, int x)	{	return <simg1>.getcx() - x;	}
	int iclenx2(string simg1, string simg2)	{	return <simg1>.getcx() - <simg2>.getcx();	}
	int icleny(string simg1, int y)	{	return <simg1>.getcy() - y;	}
	int icleny2(string simg1, string simg2)	{	return <simg1>.getcy() - <simg2>.getcy();	}
	int isbetween2(string simg1, string simg2, int x1, int y1, int x2, int y2)	{
		return this.isbetween(simg1, <simg2>.getcx(), <simg2>.getcy(), x1, y1, x2, y2);
	}
	int isbetween(string simg1, int xx, int yy, int x1, int y1, int x2, int y2)	{
		il1 = this.ilen( simg1, xx, yy );
		return ilx>=x1 && ilx<=x2 && ily>=y1 && ily<=y2;
	}
	int ilodlen(string s1, string s2)	{	.ilen(<s1>.lodx,<s1>.lody, <s2>.lodx, <s2>.lody);	}
	int iposlen(string simg1, string simg2)	{
		.ilen( <simg1>.getpos, <simg2>.getpos );
	}
}

/****************************************************/
class classansearcher	{
	init()	{}
	def _findnotr(string san, int x, int y, int dx, int dy)	{
		int ex = <san>.getex() , int ey = <san>.getey();
		while( x!=ex && y!=ey )	{
			if( <san>.isin(x,y,false,true) ) return x,y;
			x+=dx;	y+=dy;
		}
		return -1,-1;
	}
	def firstnotrx1y(string san)	{	return ._findnotr(san,<san>.getpx(), <san>.getpy(), 1, 0);	}
	def firstnotrexy1(string san)	{	return ._findnotr(san,<san>.getex()-1, <san>.getpy(), 0, 1);	}
	def firstnotrxy1(string san)	{	return ._findnotr(san,<san>.getpx(), <san>.getpy(), 0, 1);	}
	def firstnotrx1ey(string san)	{	return ._findnotr(san,<san>.getpx(), <san>.getey()-1, 1, 0);	}
}

public def anfindnotr(int x, int y, int dx, int dy)	{
		int ex = .getex() , int ey = .getey();
		while( x!=ex && y!=ey )	{
			if( .isin(x,y,false,true) ) return x,y;
			x+=dx;	y+=dy;
		}
		return -1,-1;
	}
public def anfindalfa(int x, int y, int dx, int dy, int alfa)	{
		int ex = .getex() , int ey = .getey();
		while( x!=ex && y!=ey )	{
			if( .isin(x,y,false,true) ) {
				|_,_,_,int a| = .getrgba(x,y);
				if( a == alfa )
					return x,y;
			}
			x+=dx;	y+=dy;
		}
		return -1,-1;
	}
public def anfirstnotrx1y	{	return .anfindnotr(.getpx(), .getpy(), 1, 0);	}
public def anfirstnotrexy1	{	return .anfindnotr(.getex()-1, .getpy(), 0, 1);	}
public def anfirstnotrxy1	{	return .anfindnotr(.getpx(), .getpy(), 0, 1);	}
public def anfirstnotrx1ey	{	return .anfindnotr(.getpx(), .getey()-1, 1, 0);	}

class signal_pack	{
	init()	{}
	addsignals(string san)	{
		<san>.addmethod("operator<", func { (string sfun) this.addmethod("onfinish", sfun ); } );
	}
}
/***************************************************************************/
class ImagePos	{
	init	{}
	getex	{	.getpx + .getw;	}
	getey	{	.getpy + .geth;	}
	getcx	{	.getpx + .getw/2;	}
	getcy	{	.getpy + .geth/2;	}
	setpos(int x, int y)	{	.move(x-.getpx, y-.getpy);	}
}
class ImageVisible	{
	init	{
		new bool _isvisible=1;
	}
	isvisible	{	_isvisible;	}
	show		{	_isvisible=1;	}
	hide		{	_isvisible=0;	}
}
class Image	{
	init	{}
	public resizemethods(string sob)	{
		<sob>.vars2(A, "getz",0, "getpx",0, "getpy",0, "getw",0, "geth",0, "isvisible", 0);
		<sob>.addmethod("show", func { isvisible=1; }	);
		<sob>.addmethod("hide", func { isvisible=0; }	);
		<sob>.addmethod("setz", func { (int z) getz=z; } );
		<sob>.addmethod("setpos", func { (int x, int y) getpx=x; getpy=y; } );
		<sob>.addmethod("move", func { (int x, int y) getpx+=x; getpy+=y; } );
		<sob>.addmethod("getex", func { getpx+getw; } );
		<sob>.addmethod("getey", func { getpy+geth; } );
		<sob>.addmethod("getcx", func { getpx+getw/2; } );
		<sob>.addmethod("getcy", func { getpy+geth/2; } );
		<sob>.addmethod("isin", func { (int x, int y, int bv, int ba)
			if( !ba ) {
				if( !bv || (bv&&isvisible) )	{
					x>=getpx && x<.getex && y>=getpy && y<.getey;
				} else 0;
			} else 0;
			} );
	}
}
	// rozszerzenia dla animcaji
class anima_pack : signal_pack	{
	init()	{}
	public resizemethods(string san)	{
		<san>.addmethod("_clanbuildpomvars", func { new int _ixp; new int _iyp; } );
		<san>._clanbuildpomvars();
		<san>.addmethod("setbpos", func {(int x, int y) .setpos( x-.lodx, y-.lody ); });
		<san>.addmethod("saverelpos", func {(int x,int y)_ixp=x-.getpx;_iyp=y-.getpy;} );
		<san>.addmethod("setrelpos", func{(int x, int y) .setbpos( x - _ixp, y - _iyp );});
		<san>.addmethod("mssaverelpos", func {.saverelpos( mouse.getpos );} );
		<san>.addmethod("mssetrelpos", func {.setrelpos( mouse.getpos );});
		<san>.addmethod("rplay", func {(string sact)if( !.isplaying(sact) ) .play(sact);});
		<san>.addmethod("setcpos", func {(int x, int y).setbpos( x-.getw/2, y-.geth/2 );});
		<san>.addmethod("operator=", func { (string s) .copy(s); } );
		<san>.addmethod("operator==", func { (string s)
			.actionnr==<s>.actionnr && .framenr==<s>.framenr; } );
		this.addsignals(san);
	}
}

class timer_pack : signal_pack	{
	init()	{}
	resizemethods(string sob)	{
		this.addsignals(sob);
	}
}
/***************************************************************************/
class vector_pack	{
	init()	{}
	each(string sfun)	{	for( int i=0; i<.size; i++) this.<sfun>(.get(i));	}
	resizemethods(string svec)	{
		<svec>.addmethod("each", "each");
		<svec>.addmethod("operator-", func { (def x) this.remove(x); this; } );
		<svec>.addmethod("operator+", func { (def x) this.add(x); this; } );
	}
}

/***************************************************************************/

public new_object(string styp, string sob)	{
	new <styp> <sob>;
	<styp+"_pack">::resizemethods(sob);
}
public new_anima(string s)	{	.new_object("anima",s);	}
public new_vector(string s)	{	.new_object("vector",s);	}

/***************************************************************************/

class classanfilter	{
	init()	{}
	buildanfilter()	{
		new filter ft;
		ft.link( this.getname() );
		ft.setpivottype(1);
	}
	public build(string san)	{
		<san>.addmethod("buildanfilter","buildanfilter");
		<san>.buildanfilter();
		<san>.addmethod("setopacity",	func {	(int iop) ft.setopacity(iop); }		);
		<san>.addmethod("setzoom",		func {	(real r) ft.setzoom(r); }			);
		<san>.addmethod("setangle",		func {	(real r) ft.setangle(r); }			);
		<san>.addmethod("getangle",		func {	return ft.getangle; }			);
		<san>.addmethod("rotate",		func {	(real r)	ft.rotate(r); }			);
		<san>.addmethod("setpivottype",	func {	(int ityp) ft.setpivottype(ityp); }	);
		<san>.addmethod("unlink",		func {	ft.unlink(); }					);
		<san>.addmethod("link",			func {	ft.link(this); }					);
		<san>.addmethod("blend",		func {	(string s) ft.blend(s); }			);
		<san>.addmethod("mask",		func {	(string s) ft.mask(s); }			);
	}
}

/***************************************************************************/

class classancounter	{
	init()	{
		new int iile;
		new int id;
		new string _san;
		new vector _vs;
		new int _pos;
	}
	set(string sname, int ile)	{
		_san = sname;
		iile = ile;
		id = 0;
		_pos = sname.length();
		_vs.resize( ile, false );
	}
	string get()	{
		string s = _san+id;
		id = (id+1)%iile;
		return s;
	}
	string getf()	{
		for(int i=0; i<iile; i++)	{
			if( !_vs.get(i) )	{
				_vs.set(i, true);
				return _san+i;
			}
		}
		return null;	// brak wolnych
	}
	retf(string s)	{	_vs.set( s.strsubbs( _san ), false );	}
	isfree(int pos)	{	return _vs.get(pos);	}
	int getile()	{	return iile;	}
	bool allfree	{	_vs.vecsum==0; }
}

/**************************************************************/
	// operacje na obrazach, dzwiekach, timerach i animacjach
class gmobjvec {
	init()	{
		new vector lsim;
		lsim.type("string");
	}
	operator=(string sgr)	{
		if( engine.varexist(sgr) )	{
			match(<sgr>.gettype())	{
				"vector" => this.copy(sgr);
				"gmobjvec" => this.copy(sgr);
				"gmimgvec" => this.copy(sgr);
				? => {	this.free(); this.add(sgr); }
			}
		} else {
			this.free();
			this.add(sgr);
		}
	}
	save(string s)	{	if( igmenablesave ) lsim.save(s);	}
	load(string s)	{	lsim.load(s);	}
	operator+(string sob)	{	this.add(sob);		this;	}
	operator-(string sob)	{	this.remove(sob);	this;	}
	removegr(string sgr)	{	for( int i=0; i < <sgr>.size; i++)	.remove( <sgr>.get(i) );	}
	addtogr(string sgr)	{	for( int i=0; i<this.size(); i++)	<sgr>.add(this.get(i));	}
	addgr(string sgr)	{	for( int i=0; i< <sgr>.size(); i++)	this.add( <sgr>.get(i) );	}
	addgroups	{	.withlist("addgr");	}
	copy(string sgr)	{
		this.free();
		this.addgr(sgr);
	}
	free()	{ lsim.free();	}
	int size()	{ 	lsim.size;	 }
	bool empty()	{	.size==0;	}
	hash()	{ lsim.hash(); }
	string first()	{ lsim.get(0); }
	string last()	{ lsim.get( lsim.size-1 ); }
	print()	{
		engine.print("");
		engine.print("------ type("+.gettype+") " + this + " ------");
		lsim.print();
		engine.print("------ end ------");
		engine.print("");
	}
	string get(int i)	{	lsim.get(i);	}
	set(int pos, string sval)	{	lsim.set(pos,sval);	}
	add(string simg)	{	lsim.add(simg);	}
	additer(string s, int ifrom, int iile)	{
		while( iile>0 )	{
			.add(s+ifrom);
			ifrom++;
			iile--;
		}
	}
	buildarray(string styp, string sname, int ilosc)	{
		<gameapi.getgamename>.newarray(styp,sname,ilosc);
		.additer(sname,0,ilosc);
	}
	deleteall	{	for( int i=0; i<.size; i++)	delete <.get(i)>;	}
	deleteallgm	{
		@s = gameapi.getgamename;
		for( int i=0; i<.size; i++)	<s>.vardel(.get(i));
	}
	deleteallgmobj	{
		@s = gameapi.getgamename;
		for( int i=0; i<.size; i++)	<s>.deletegmobj(.get(i));
	}
	lockall	{	.eval("lock");	}
	unlockall	{	.eval("unlock");	}
	addbegin(string simg)	{	lsim.addbegin(simg);	}
	swap(int i, int j)	{	lsim.swap(i,j);	}
	addonce(string simg)	{	if( !lsim.contains(simg) )	lsim.add(simg);	}
	sepadd(string separator)	{
		string s = _;
		while( s!=separator )	{
			this.addbegin(s);
			s = _;
		}
	}
	addlist	{	.sepadd(A);	}
	removelist	{ .withlist("remove");	}
	insertat(string sob, int pos)	{
		@ile = .size;
		if( pos<=0 )	.addbegin(sob);
		else if (pos>=ile)	.add(sob);
		else {
			.add(null);
			for( @i=ile; i>pos; i--)	.set( i, .get(i-1) );
			.set(pos, sob );
		}
	}
	remove(string simg)	{	lsim.remove(simg);	}
	removeat(int pos)		{	lsim.removeat(pos);	}
	removefirst			{	lsim.removeat(0);	}
	removelast			{	lsim.removeat(.size-1);	}
	removealloccurs(string simg)	{	while(this.contains(simg))	this.remove(simg);	}
	removeif(string sfun)	{
		for( int i=0; i<.size; i++)
			if( <.get(i)>.<sfun>() )  .removeat(i);
	}
	int find(string simg)		{	lsim.find(simg);	}
	int contains(string simg)	{	lsim.contains(simg);	}
	addgroup(string sob, int ile)	{	.addgroup2( sob, 0, ile-1 );	}
	addgroup2(string sob, int ifrom, int ito)	{
		while( ifrom <= ito )	{
			this.add( sob+ifrom );
			ifrom++;
		}
	}
	string rand()	{
		int ile = .size;
		ile>0 ? .get(ile.rand) : null;
	}
	string randdiff(string s)	{
		int ile = .size;
		if( ile>0 )	{
			int id = ile.rand;
			int i = id;
			while( .get(id)==s )	{
				id = (id+1)%ile;
				if( id==i )	return null;
			}
			.get(id);
		} else
			null;
	}
	buildfullvars	{	.each( func { (@id) .buildfullname; } );	}
	buildvars		{	.each( func { (@id) .addtogamevars(this); } );	}
	/******************* metody na obiektach grupy *****************************/
	movefrom(string simg, int x, int y)	{
		int i = this.find(simg);
		if( i>=0 )	{
			while( i<lsim.size() )	{
				<lsim.get(i)>.move(x,y);
				i++;
			}
		}
	}
	move(int x, int y)	{	this.eval2("move",x,y);	}
	setpos(int x, int y)	{	this.eval2("setpos",x,y);	}
	show()	{	this.eval("show");	}
	hide()	{	this.eval("hide");	}
	stop(int fin)	{	this.eval1("stop",fin);	}
	play()	{	this.eval("play");	}
	setdelay(int d)	{	this.eval1("setdelay",d);	}
	isplaying	{
		for( int i=0; i<.size; i++)	if( <.get(i)>.isplaying(-1) ) return true;
		false;
	}
	graddmethod(string sdest, string ssrc)	{	this.eval2("addmethod",sdest,ssrc);	}
	string getimg(int x, int y, int bignorehidden, int bignorealpha)	{
		for( int i=lsim.size()-1; i>=0; i--)	{
			if( <lsim.get(i)>.isin( x,y,bignorehidden,bignorealpha ) )	return lsim.get(i);
		}
		return null;
	}
	int isin(int x, int y, bool bignorehidden, bool bignorealpha)	{
		for( int i=lsim.size()-1; i>=0; i--)	{
			if( <lsim.get(i)>.isin( x,y,bignorehidden,bignorealpha ) )	return i+1;
		}
		return false;
	}
	setframe(def ac, int ifr)	{	this.eval2("setframe",ac,ifr);	}
	setz(int z)	{	this.eval1("setz",z);	}
	/**************/
	eval(string sfunc)	{
		for(int i=0; i<lsim.size(); i++)	{<lsim.get(i)>.<sfunc>();	}
	}
	eval1(string sfunc, def darg)	{
		for(int i=0; i<lsim.size(); i++)	{<lsim.get(i)>.<sfunc>(darg);}
	}
	eval2(string sfunc, def darg1, def darg2)	{
		for(int i=0; i<lsim.size(); i++)	{<lsim.get(i)>.<sfunc>(darg1, darg2);}
	}
	eval3(string sfunc, def darg1, def darg2, def darg3)	{
		for(int i=0; i<lsim.size(); i++)	{<lsim.get(i)>.<sfunc>(darg1, darg2, darg3);}
	}
	int _find(string sfun, def id)	{
		for( int i=0; i<this.size; i++) if ( <this.get(i)>.<sfun>()==id ) return i;
		-1;
	}
	int _find1(string sfun, @id)	{
		for( int i=0; i<.size; i++) if ( <this.get(i)>.<sfun>(id) ) return i;
		-1;
	}
	each(string sfun)	{	for( int i=0; i<.size; i++) <.get(i)>.<sfun>(i);	}
	each1(string sfun, @d1)	{	for( int i=0; i<.size; i++) <.get(i)>.<sfun>(i, d1);	}
	each2(string sfun, @d1, @d2)	{	for( int i=0; i<.size; i++) <.get(i)>.<sfun>(i, d1, d2);	}
	bool ineach(string sfun)	{
		for( int i=0; i<.size; i++) if( !<.get(i)>.<sfun>(i) )	return false;
		true;
	}
	int find_closest(string sob, string sfun)	{
		if( .empty ) return;
		int id = 0, real il;
		real ilen = <.get(0)>.<sfun>(sob);
		for( int i=1; i<.size; i++)	{
			il = <.get(i)>.<sfun>(sob);
			if( il < ilen )	{
				id = i;
				il = ilen;
			}
		}
		id;
	}
	/**************/
	sortimgsfun(string sfun)	{	lsim.vecsort(sfun);	}
	sortimgs()	{	// sortowanie od najmniejszych
		lsim.vecsort("_scmpimg1");
	}
	bool _scmpimg1(string s0, string s1)	{
		( <s0>.getz() < <s1>.getz() || ( <s0>.getz()==<s1>.getz() && <s0>.getidobj() < <s1>.getidobj() ) );
	}
}

class gmimgvec : gmobjvec	{
	init()	{
		gmobjvec::init();
		new int _ix = 0;
		new int _iy = 0;
		new int _iz = 0;
		new int _ifound = -1;
		new string sanload = null;
	}
	_setpos(int x, int y)	{	|_ix, _iy| = x,y;	}
	int lodx()	{0;}
	int lody()	{0;}
	int getposx()	{	_ix;	}
	int getposy()	{	_iy;	}
	int getpos()	{	return _ix, _iy;	}
	int getpx() {	_ix;	}
	int getpy() {	_iy;	}
	int getw()	{	this.getex()-this.getpx();	}
	int geth()	{	this.getey()-this.getpy();	}
	int getcx() {	this.getpx()+this.getw()/2;	}
	int getcy() {	this.getpy()+this.geth()/2;	}
	int getz()	{	_iz;	}
	int getex()	{
		int ile = this.size();
		if( ile<=0 )	{	return _ix;	}
		int x = <this.get(0)>.getex();
		int x2;
		for( int i=1; i<ile; i++)	{
			x2 = <this.get(i)>.getex();
			if( x2>x )	{	x=x2;	}
		}
		x;
	}
	int getey()	{
		int ile = this.size();
		if( ile<=0 )	{	return _iy;	}
		int y = <this.get(0)>.getey();
		int y2;
		for( int i=1; i<ile; i++)	{
			y2 = <this.get(i)>.getey();
			if( y2>y )	{	y=y2;	}
		}
		y;
	}
	int _getpx()	{
		int ile = this.size();
		if( ile<=0 )	{	return _ix;	}
		int x = <this.get(0)>.getpx();
		int x2;
		for( int i=1; i<ile; i++)	{
			x2 = <this.get(i)>.getpx();
			if( x2<x )	{	x=x2;	}
		}
		x;
	}
	int _getpy()	{
		int ile = this.size();
		if( ile<=0 )	{	return _iy;	}
		int y = <this.get(0)>.getpy();
		int y2;
		for( int i=1; i<ile; i++)	{
			y2 = <this.get(i)>.getpy();
			if( y2<y )	{	y=y2;	}
		}
		y;
	}
	int _getw	{	.getex-._getpx;	}
	int _geth	{	.getey-._getpy;	}
	/*minx	{	.find_closest(null, func {(@s) .getpx; } );	}
	miny	{	.find_closest(null, func {(@s) .getpy; } );	}
	countborders	{
		_ix = .minx;
		_iy = .miny;
	}*/
	setz(int z)	{
		_iz = z;
		this.eval1("setz",z);
	}
	move(int x, int y)	{
		_ix +=x;
		_iy +=y;
		this.eval2("move",x,y);
	}
	setpos(int x, int y)	{
		_ix = x;
		_iy = y;
		this.eval2("setpos",x,y);
	}
	setpos2(int x, int y)	{
		_ix = x;
		_iy = y;
		if( !.empty )	{
			x -= <.get(0)>.getpx;
			y -= <.get(0)>.getpy;
			.move(-x,-y);
		}
	}
	changeframe(int ifr) {
		string s;
		for( int i=0; i<.size; i++)	{
			s = .get(i);
			<s>.setframe( <s>.actionnr(-1), ifr );
		}
	}
	nplay(int n)	{	.eval1("play",n);	}
	txtreset	{	for( int i=0; i<.size; i++) <.get(i)>.txtset("");	}
	anputgr()	{	this.eval("anputgr");	}
	anputy(int ypos)	{	this.eval1("anputy", ipos);	}
	int isin(int x, int y, bool bignorehidden, bool bignorealpha)	{
		for( int i=lsim.size()-1; i>=0; i--)	{
			if( <lsim.get(i)>.isin( x,y,bignorehidden,bignorealpha ) )	{
				_ifound=i;
				return i+1;
			}
		}
		_ifound = -1;
		false;
	}
	int isinfunc(int x, int y, string sfunc)	{
		for( int i=lsim.size()-1; i>=0; i--)	{
			if( <lsim.get(i)>.<sfunc>( x,y ) )	{
				_ifound=i;
				return i+1;
			}
		}
		_ifound = -1;
		false;
	}
	int isincut(int x, int y, bool bignorehidden, bool bignorealpha)	{
		for( int i=lsim.size()-1; i>=0; i--)	{
			if( <lsim.get(i)>.withincut(x,y) && <lsim.get(i)>.isin( x,y,bignorehidden,bignorealpha ) )	{
				_ifound=i;
				return i+1;
			}
		}
		_ifound = -1;
		false;
	}
	bool withincut(int x, int y)	{
		y; x;
		.ineach(func { (@id)
			int x = _;
			int y = _;
			.withincut(x,y);
			y; x;
			} );
		x = _;
		y = _;
	}
	int findif(string sfunc)	{	._find( sfunc,true);	}
	int getfound()	{	_ifound;	}
	string getsfound()	{	this.get(_ifound);	}
	int findfr(int id)	{	._find("framenr", id);	}
	int findsfr(string s)	{	._find("framename", s);	}
	int findac(int id)	{	._find("anactnr", id);	}
	int findsac(string sac)	{	._find("actionname", sac);	}
	int nearest_to(string sob)	{
		//.find_closest(sob, func {(string s) 0->length( .getpx-<s>.getpx, .getpy-<s>.getpy ); } );
		.find_closest(sob, func {(string s) cllen.ilen5(this,s); } );
	}
	string getsac(string sac)	{	.get( .findsac(sac) );	}
	string getsacfr(string sac, int fr)	{	for(int i=0; i<.size; i++) if( <.get(i)>.actionname==sac && <.get(i)>.framenr==fr ) return .get(i); null; }
	/*def find_min(string s)	{
		if( .empty ) return;
		int x = <s>.getpx;
		int y = <s>.getpy;
		int id = 0, int il;
		int ilen = id.length( <.get(0)>.getpx-x, <.get(0)>.getpy-y );
		for( int i=1; i<.size; i++)	{
			il = id.length( <.get(i)>.getpx-x, <.get(i)>.getpy-y );
			if( il < ilen )	{
				id = i;
				il = ilen;
			}
		}
	}*/
	blitto(string simg)	{	for( int i=0; i<.size; i++)	<simg>.blit(.get(i));	}
	sortz(int z)	{	for( int i=0; i<.size; i++) <.get(i)>.setz(z+i);	}
	/****************************/
	ancopies(string san, int ile)	{
		for( int i=0; i<ile; i++)	{
			<GAME>.copyanima(san, san+"_"+i);
			.add(san+"_"+i);
		}
	}
	loadallan(string sname, string sfile, int z)	{
		string s = gameapi.getgamename();
		<s>.newanima(sname,sfile,z);
		_ = <s>.newanfrbyactgr(sname, sname, this);
		<sname>.hide();
	}
	addsrcanima(string san) {       .var2("srcanima", san); }
	operator*(string s)	{
		string sg = gameapi.getgamename;
		string san;
		if ( s.contains(".pyz") ) {
			if( s.getb(0,1)=="$" )	{
				new vector _vtmp; _vtmp.type("string");
				_vtmp.vecbuildfromstring(s, "/");
				san = "an" + _vtmp.last->strsubes(".pyz");
				delete _vtmp;
			} else {
				san = "an" + s.strsubes(".pyz");
			}
			<sg>.newanima(san,s,0);
		} else san = s;
		sanload = san;
		_ = <sg>.newanactionsgr(san, san, this);
		<san>.hide();
		.addsrcanima(san);
	}
	operator<(string s)	{
		string sg = gameapi.getgamename;
		string san;
		if ( s.contains(".pyz") ) {
			san = "an" + s.strsubes(".pyz");
			<sg>.newanima(san,s,0);
		} else san = s;
		sanload = san;
		_ = <sg>.newanfrbyactgr(san, san, this);
		<san>.hide();
		.addsrcanima(san);
	}
	deleteloaded	{
		.deleteallgm;
		if( sanload!=null ) <gameapi.getgamename>.vardel(sanload);
	}
	deleteinit	{
		@s = gameapi.getgamename;
		for( int i=0; i<.size; i++)	{
			@s2 = .get(i);
			if( <s2>.gettype=="gmimgvec" )	{
				<s2>.deleteinit;
			}
			<s>.vardel(s2);
		}
		if( sanload!=null ) <gameapi.getgamename>.vardel(sanload);
	}
}

class gmadvvec : gmimgvec	{
	init	{	gmimgvec::init;	}
	int butisin(int x, int y, bool bignorehidden, bool bignorealpha)	{
		for( int i=lsim.size()-1; i>=0; i--)	{
			if( <lsim.get(i)>.butisin( x,y,bignorehidden,bignorealpha ) )	{
				_ifound=i;
				return i+1;
			}
		}
		_ifound = -1;
		false;
	}
}

class gmmaskvec : gmadvvec	{
	init()	{	gmadvvec::init;	}
	int butisin(int x, int y, bool bigvis, bool bigalpha)	{	gmimgvec::butisin(x,y,false,bigalpha);	}
}




new int igmsubtitle = .readcfg("igmsubtitle:", 0);
new int igmlektor = .readcfg("igmlektor:", 1);
new int igmchardelay = .readcfg("igmchardelay:", 100);
new int igmsubmindelay = .between(2000, .readcfg("igmsubmindelay:", 2000), 200000);

class Subtitle	{
	init(string sdbfile, int borx)	{
		real rwidth = 0.5;
		new int col0; new int col1; new int col2;
		.restorecolor;
		string spath = SNDPATH;
		
		new string ssubpos = .readcfg("sgmsubtitlespos:", "down");
		@s = dbconf.dbgets("sgmsubtitlespos:",2);
		new int isubpos = (s!=null ? s : 15);
		new bool bshadow = .readcfg("igmsubshadow:", 0);
		new int bblackbg = .readcfg("igmsubblackbg:", 170);
		
		new int iborx = borx;
		
		new int ifontsize = fntsubtitle.getsize;
		
		new db dbl;
		dbl.load(LANGDIR + sdbfile);
		int i=0;
		string s;
		while( i<dbl.getrowsno )	{
			if( dbl.getcolsno(i) < 2 || dbl.get(i,0)->getb(0,1)=="#" )
				dbl.removerow(i);
			else i++;
		}
		
		
		string s2;
		new vector v1;	v1.type("string");
		int cols = (iResX-2*borx)/(rwidth*ifontsize+1);
		
		int k, int j;
		int linie = 0;
		for( int i=0; i<dbl.getrowsno; i++)	{
			s = spath + dbl.get(i,0)+".wav";
			if( !engine.fileexist(s) )
				s = spath + dbl.get(i,0)+".ogg";
			dbl.set( i, 0, s );
			s = dbl.get(i,1);
			v1.vecbuildfromstring(s, " ");
			s2 = "";
			k = 1;
			for( j=0; j<v1.size; j++)	{
				if( s2.length + v1.get(j)->length + 1 <= cols )	s2 += " " + v1.get(j);
				else {
					if( k==1 )	dbl.set(i, k, s2);
					else dbl.add(i, s2);
					s2 = v1.get(j);
					k++;
				}
			}
			if( k==1 )	dbl.set(i, k, s2);
			else dbl.add(i, s2);
			if( k>linie ) linie = k;
		}
		
		new gmimgvec grtxt;
		new gmimgvec grtxts;
		for( int i=0; i<linie; i++)	{
			s = "txt"+i;
			if( bshadow )	{
				s2 = "txts"+i;
				classgame::newtext(s2,"","fntsubtitle",.black);
				grtxts.add(s2);
			} else if ( bblackbg )	{
				s2 = "imgs"+i;
				new img <s2>;
				grtxts.add(s2);
			}
			classgame::newtext(s,"","fntsubtitle",.getcolor);
			grtxt.add(s);
		}
		
		new db dbsnd;
		new timer timtxt;
		timtxt.settick(1);
		timtxt.setcycle(1);
		timtxt.addmethod("onfinish", func {
			if( !.cisplaying )	.hidesubs;
			else .play;
			} );
		.setz(12000);
	}
	geth	{
		if( grtxts.size )	<grtxts.first>.geth;
		else if ( grtxt.size )	<grtxt.last>.geth;
		else 0;
	}
	reset	{
		.stop;
		dbsnd.free;
	}
	hidesubs	{
		grtxt.hide;
		grtxts.hide;
	}
	setz(int z)	{
		grtxt.setz(z);
		grtxts.setz(z-1);
	}
	stop	{
		.hidesubs;
		timtxt.stop(false);
	}
	register(string ssnd, string sfile)	{
		@id = dbl.findbyrow(sfile);
		if( id>=0 )	{
			@r = dbsnd.findbyrow(ssnd);
			if( r>=0 )	dbsnd.set(r, 1, id);
			else {
				@r = dbsnd.addrow-1;
				dbsnd.add(r, ssnd);
				dbsnd.add(r, id);
			}
		}
	}
	getiddialog(string s)	{	dbsnd.findbyrow(s);	}
	hasdialog(string s)	{	.getiddialog(s) >= 0;	}
	int play(string s)	{
		.stop;
		@id = dbsnd.findbyrow(s);
		if( id>=0 )	{
			int ileznakow = 0;
			id = dbsnd.get(id, 1);
			@ile = dbl.getcolsno(id)-1;
			string s[2], int dx, int dy;
			grtxt.setpos( 0, 0 );
			int dy = 2;
			for( int i=0; i<ile; i++)	{
				s0 = grtxt.get(i);
				<s0>.txtsetcol(dbl.get(id, i+1), col0, col1, col2);
				ileznakow += <s0>.get->length;
				<s0>.setpos( (iResX-<s0>.getw)/2 + igmoffsetx, i*ifontsize + dy + igmoffsety );
				<s0>.show;
				if( bshadow )	{
					s1 = grtxt.get(i);
					<s1>.txtsetcol(<s0>.get,  col0, col1, col2);
					<s1>.setpos(<s0>.getpx+1, <s0>.getpy+1);
					<s1>.show;
				} /*else if ( bblackbg )	{
					s1 = grtxts.get(i);
					dx = 4;
					dy = 2;
					//<s1>.create( <s0>.getw+ dx, <s0>.geth+dy, .black, 255 );
					//<s1>.setpos(<s0>.getpx-dx/2, <s0>.getpy-dy/2);
					<s1>.create( iResX, <s0>.geth, .black, bblackbg );
					<s1>.setpos( 0, <s0>.getpy );
					<s1>.setz( <s0>.getz-1 );
					<s1>.show;
				}*/
			}
			if( bblackbg )	{
				s0 = grtxt.first;
				s1 = grtxts.first;
				if( ssubpos=="up" )	{
					<s1>.create( iResX, <grtxt.get(ile-1)>.getey, .black, bblackbg );
					<s1>.setpos( igmoffsetx, igmoffsety );
				} else {
					<s1>.create( iResX, <grtxt.get(ile-1)>.getey - <s0>.getpy, .black, bblackbg );
					<s1>.setpos( igmoffsetx, <s0>.getpy+igmoffsety );
				}
				<s1>.setz( <s0>.getz-1 );
				<s1>.show;
			}
			if( ssubpos=="up" )	{
				dy = 0;
			} else {
				dy = iResY - ile*(ifontsize+dy)-isubpos;
				grtxt.move( 0, dy );
				if( bshadow || bblackbg ) grtxts.move(0, dy);
			}
			timtxt.play;
			ileznakow *= igmchardelay;
			ileznakow < igmsubmindelay ? igmsubmindelay : ileznakow;
		} else 0;
	}
	setcolor(int r, int g, int b)	{
		col0 = r;
		col1 = g;
		col2 = b;
	}
	getcolor	{	return col0, col1, col2;	}
	restorecolor	{	.setcolor(.white);	}
}

if( igmsubtitle )	{
	new font fntsubtitle;
	fntsubtitle.load( .readcfg("subtitles_font:", sgmfontfile), .readcfg("subtitles_fontsize:", 24->igetsc) );
	new Subtitle subtitle( .readcfg("subtitles_src:", "subtitles.db"), 50);
}

class classsound {
	init()	{
		new string _csplay = null;
		new timer timlektor;
		timlektor {
			//.var2("bsndfin", false);
			new bool bsndfin = true;
		};
		timlektor.addmethod("setsndfin", func { (bool b) bsndfin = b; } );
		timlektor.addmethod("onfinish", func {
			if( bsndfin )	{
				if( _csplay!=null ) <_csplay>.onfinish;
			} else bsndfin = true;
			} );
		if( igmsubtitle )	{
			subtitle.reset;
		}
	}
	creset()		{ _csplay = null; }
	string cgetactsnd()	{ _csplay; }
	bool cisactsnd(string ssnd)	{	ssnd==_csplay;	}
	crselfplay(string ssnd)	{
		if( !this.cisplaying() )	this.cbplay(ssnd);
		else if ( this.cgetactsnd()!=ssnd )	this.cbplay(ssnd);
	}
	cbselfplay(string ssnd)	{
		if( !.cisplaying || .cgetactsnd!=ssnd )	.cbplay(ssnd);
	}
	cbplay(string ssnd)	{
		if(this.cisplaying())
			.csplaystop(true);
		.cbsplay(ssnd);
	}
	cbsplay(string ssnd)	{
		_csplay = ssnd;
		if( ssnd!=null)
			.csubplay(ssnd);
	}
	cbplayfin(string ssnd, string sfun)	{
		<ssnd>.addmethod("onfinish", sfun);
		.cbplay(ssnd);
	}
	cbplay2(string ssnd)	{
		if(this.cisplaying())
			.csplaystop(false);
		.cbsplay(ssnd);
	}
	crplay(string ssnd)	{
		if( !.cisplaying )
			.cbsplay(ssnd);
	}
	/*crplay(string ssnd)	{
		if( _csplay!=null && <_csplay>.isplaying() )	return;
		_csplay = ssnd;
		if( ssnd!=null )
			.csubplay(ssnd);
		//	<ssnd>.play();
	}*/
	cbplayif(string ssnd)	{
		if(.cisplaying)
			.cbplay(ssnd);
	}
	crbgplay(string ssnd)	{
		if( ssnd != null && !<ssnd>.isplaying() )
			.csubplay(ssnd);
			//<ssnd>.play();
	}
	crandplay(string ssnd, int irand, string styp)	{
		if( irand.rand()==0 )	this.<"c"+styp+"play">( ssnd );
	}
	cplayf(string styp, string ssnd, string sfun)	{
		this.<"c"+styp+"play">(ssnd);
		if( <ssnd>.isplaying() && sfun!=null)	<ssnd>.addmethod("onfinish",sfun);
	}
	//cactsndstop(bool bfin)	{	if(_csplay!=null)	<_csplay>.stop(bfin);	}
	cactsndstop(bool bfin)	{
		if(.cisplaying)	.csplaystop(bfin);
	}
	csplaystop(bool bfin)	{
		if( timlektor.isplaying )	{
			timlektor.setsndfin(bfin);
			timlektor.stop(true);
		} else
			<_csplay>.stop(bfin);
	}
	cstopsnds(bool b)	{
		if( _csplay.in && .cisplaying )
			.cactsndstop(b);
	}
	bool cisplaying()	{
		_csplay!=null ? ( timlektor.isplaying || <_csplay>.isplaying ) : false;
	}
	bool cisplayingsnd	{
		_csplay!=null ? <_csplay>.isplaying : false;
	}
	csubplay(string s)	{
		if( igmsubtitle )	{
			int ilektor = igmlektor;
			if( !<s>.loaded )	{
				igmlektor = 0;
			}
			@dt = subtitle.play(s);
			if( igmlektor || dt<=0 ) <s>.play;
			else {
				timlektor.setdelay( dt );
				timlektor.play;
			}
			igmlektor = ilektor;
		} else
			<s>.play;
	}
	cisdialogplaying	{
		.cisplaying && subtitle.hasdialog(.cgetactsnd);
	}
}

/***************************************************************************/
class classsndbank	{
	init()	{
		new int itype;
		new int ilicz = 0;
		new int iile;
		new string splay=null;
		new string ssnd = "snd";
	}
	/********************************/
	loadsingle(string sfile, int ile)	{
		if( ile<=0)	{	iile=0;	return;	}
		iile=ile;
		itype=0;
		for( int i=0; i<ile; i++)	newvars::newsnd( ssnd+i, sfile );
	}
	/********************************/
	load(string sfilebase, int ifilefrom, int ifileto, int ityp, int itypstart)	{
		iile = ifileto-ifilefrom+1;
		if(iile<=0)	{
			iile = 0;
			return;
		}
		newvars::newsnds( ssnd, 0, sfilebase, ifilefrom, ifileto);
		itype = ityp;			// 0 - po kolei, 1 - random
		if(itypstart==1)	{	// 0 - od pierwszego, 1 - randomowy
			ilicz = iile.rand( );
		}
	}
	addmethod(string ssig, string sfunc)	{
		for( int i=0; i<iile; i++)	<ssnd+i>.addmethod( ssig, sfunc );
	}
	stop(int ifin)	{	if(splay!=null)	<splay>.stop(ifin);	}
	int isplaying()	{	splay!=null ? <splay>.isplaying() : false;	}
	randplay( int irand )	{	if( irand.rand()==0 )	this.play();	}
	playid(int id)	{
		ilicz=id%iile;
		this.play();
	}
	play()	{
		this.stop(false);
		this.bgplay();
	}
	reset()	{	ilicz=0;	}
	/************************************************/
	rbgplay()	{	if( !this.isplaying() )	this.bgplay();	}
	rplay()		{	if( !this.isplaying() )	this.play();	}
	bgplay()	{
		splay = ssnd + ilicz;
		<splay>.play();
		if( itype==0)	ilicz = (ilicz+1)%iile;
		else if (itype==1)	ilicz = iile.rand();
	}
	setvol(int vol)	{	for( int i=0; i<iile; i++)	<ssnd+i>.setvol( vol );	}
}

class SoundSource	{
	init	{	}
	setvol(string ssnd, int srcvol, int outvol, real rad, real length)	{
		if( length.abs>=rad ) <ssnd>.setvol(outvol);
		else {
			srcvol = (1.0-length.abs/rad)*srcvol + outvol;
			if( srcvol > 100 ) srcvol=100;
			<ssnd>.setvol(srcvol);
		}
	}
}

/**************************************************************/
	// standardowe czynnosci przy grach, popakowane w metody
class classgame : newvars , classsound {
	init()	{
		newvars::init();
		classsound::init();
		new int _iconstid;
		new gmobjvec _grsfxs;
	}
	/**************************************************************/
	bkg=(@sfile)	{
		if( sfile.contains(".pyz") ) .newanima("anbkg", sfile, 0);
		else .newimg("imgbkg",sfile,0);
	}
	bgr=(@sfile)	{
		//this.csndplayloop("sndbgr",sfile);
		.csndbgr(sfile);
	}
	path=(@s)	{	.setgraphpath("scripts/"+s+"/");	}
	cycle=(@stimer, @sfun)	{	.cnewtimercyclefin(stimer,1,1,sfun);	}
	timer=(@stimer, @itime, @sfun) { .cnewtimerfin(stimer,itime,1,sfun);	}
	timplay(@stimer, @itime, @sfun) {
		.cnewtimerfin(stimer,itime,1,sfun);
		<stimer>.play;
	}
	def _getflags(string s)	{
		@bloop = false;
		if( s.contains("L") )	{
			s.strremove("L");
			bloop=true;
		}
		@bplay = false;
		if( s.contains("P") )	{
			s.strremove("P");
			bplay=true;
		}
		@bhide = false;
		if( s.contains("H") )	{
			s.strremove("H");
			bhide=true;
		}
		return s,bloop,bplay,bhide;
	}
	img=(@sfile)	{
		_ = ._build_img(sfile);
	}
	getlangfile(string s)	{
		@s2 = s.strsube(4) + "_" + LANG + s.gete(0,4);
		engine.fileexist( .getpath(s2) ) ? s2 : s;
	}
	_build_img(@sfile)	{
		|sfile,@bloop,@bplay,@bhide| = ._getflags(sfile);
		bool bgroup = false;
		if(sfile.contains("G"))	{
			sfile.strremove("G");
			bgroup = true;
		}
		@iz = 0;
		if( sfile.contains(" ") )	{
			iz = sfile.strgetfrom(" ");
			sfile = sfile.strgetto(" ");
		}
		string sname;
		if( sfile.contains("/") ) {
			new vector _v_sfile;
			_v_sfile.type("string");
			_v_sfile.vecbuildfromstring(sfile,"/");
			sname = _v_sfile.last->strsube(4);
			delete _v_sfile;
		} else sname = sfile.strsube(4);
		string s;
		if( sfile.contains(".pyz") ) {
			if( bgroup )	{
				s = "gr"+sname;
				.newgrimg(s, .getlangfile(sfile)->strsubes(".pyz"), iz);
			} else {
				s = "an" + sname;
				.newanima(s, .getlangfile(sfile), iz);
			}
		} else {
			s = "img" + sname;
			.newimg(s, .getlangfile(sfile), iz);
		}
		if( bloop ) <s>.anloopfin;
		if( bplay ) <s>.play(-1);
		if( bhide ) <s>.hide;
		s;
	}
	imgsgr=	{
		string sgr = _;
		string simg;
		new gmimgvec <sgr>;
		@s = _;
		while( A != s )	{
			<sgr>.add(._build_img(s));
			@s = _;
		}
	}
	imgs=	{	.withlist("img=");	}
	clone(string sob)	{
		<gameapi.getgamename> (this, .gettype, sob) { (@sthis, @styp, @sob)
			new <styp> <sob>;
			<sob>.copy(sthis);
		};
	}
	clones=	{	.withlist("clone");	}
	list=(@sname)	{
		@s=_;
		new gmobjvec <sname>;
		while(A!=s)	{
			<sname>.addbegin(s);
			s = _;
		}
	}
	list2={
		@s = .newconst("gmobjvec");
		.list=(s);
		s;
	}
	debug=(@b)	{	engine.setdebugstate(b);	}
	sfx=(string s)	{
		bool bloop2 = s.contains("N");
		if( bloop2 )	{
			s.strremove("N");
		}
		|s,@bloop,@bplay,_| = ._getflags(s);
		@ivol = 100;
		if( s.contains(" ") )	{
			ivol = s.strgetfrom(" ");
			s = s.strgetto(" ");
		}
		string sf = "fx"+s;
		//.newsnd(sf, "sfx/"+s+".wav");
		.newsfx( sf, s+".wav");
		<sf>.setvol( ivol );
		if( bloop ) <sf>.addmethod("onfinish","_stdsndloop");
		if( bplay ) <sf>.play;
		else if( bloop2 ) <sf>.playloop;
		_grsfxs.add(sf);
	}
	sfxs=	{	.withlist("sfx=");	}
	snd=(string sname, string sfile, string sfun)	{
		.newsndfree(sname, sfile + ".wav");
		<sname>.addmethod("onfinish", sfun);
	}
	tickstart	{
		if( !.hasvar("__timspeed") )	new TicksCounter __timspeed;
		__timspeed.start;
	}
	tickstop	{	__timspeed.print("ticker: ");	}
	/**************************************************************/
	csndplayloop(string ssnd, string sfile)	{
		this.newsndloop(ssnd,sfile);
		<ssnd>.play();
	}
	csndbgr(string sfile)	{
		//this.csndplayloop("sndbgr",sfile);
		.newbgr("sndbgr", sfile );
		.sndplayloop("sndbgr");
	}
	cloadcursor(string sfile)	{
		if( sfile.contains(".") )	{
			.newimg("imgkursor", sfile,0);
			sfile = "imgkursor";
		}
		<sfile>.hide();
		mouse.setcursor(sfile);
		engine.stdbutcursor(sfile);
// 		bsms.setown();
	}
	/****************************************************************/
	newimgarray(string sname, string styp, string sn, int ile)	{
		new gmimgvec <sname>;
		<sname>.buildarray(styp,sn,ile);
	}
	newfont(string sfnt, string sfile, int isize)	{
		new font <sfnt>;
		<sfnt>.load( sfile, isize );
	}
	monofont(string sfnt, int isize)	{	.newfont(sfnt, sgmfontmono, isize);	}
	newfontbold(string sfnt, int isize)	{	.newfont(sfnt, sgmfontbold, isize);	}
	string snewfont(string sfontfile, int isize)	{
		string s = .newconst("font");
		<s>.load( sfontfile, isize );
		return s;
	}
	string stdfont(int isize)	{	.snewfont( sgmfontfile, isize	);	}
	string stdmono(int isize)	{	.snewfont( sgmfontmono, isize);	}
	string stdbold(int isize)	{	.snewfont( sgmfontbold, isize);	}
	int getconstid	{	_iconstid++;	_iconstid-1;	}
	string newconst(string styp)	{
		string s = "const"+styp+.getconstid;
		new <styp> <s>;
		return s;
	}
	string consttext(string stext, int x, int y, int isize, int r, int g, int b)	{
		string s = this.newconst("text");
		string sf = .stdfont(isize);
		<s>.setfont(sf);
		<s>.set(stext);
		<s>.createtxt(r,g,b);
		<s>.setpos(x,y);
		return s;
	}
	newtext(string stxt, string stext, string sfont, int r, int g, int b)	{
		new text <stxt>;
		<stxt>.set(stext);
		<stxt>.setfont(sfont);
		<stxt>.createtxt(r,g,b);
	}
	newtextposz(string stxt, string stext, string sfont, int r, int g, int b, int x, int y, int z)	{
		.newtext(stxt,stext,sfont,r,g,b);
		<stxt>.anposz(x,y,z);
	}
	newgrimg(string sgr, string sfile, int z)	{
		new gmimgvec <sgr>;
		sgr .* (sfile+".pyz");
		<sgr>.setz(z);
	}
	/****************************************************************/
	cfinmethod(string sobj, string sfuncfin)	{	<sobj>.addmethod("onfinish", sfuncfin);	}
	cnewsndfin(string sname, string sfile, string sfunc)	{
		this.newsnd(sname,sfile);
		this.cfinmethod(sname,sfunc);
	}
	cnewsndsfin(string sbase, int inamestart, string sfilebase, int ifilefrom, int ifileto, string sfunc)	{
		this.newsnds(sbase, inamestart, sfilebase, ifilefrom, ifileto);
		this.caddobjsfunfin(sbase, inamestart, inamestart+( ifileto-ifilefrom), sfunc);
	}
	cnewsndfinbplay(string sname, string sfile, string sfunc)	{
		this.cnewsndfin(sname,sfile,sfunc);
		this.cbplay(sname);
	}
	cnewtimerfin(string sname, int idelay, int iticks, string sfunc)	{
		this.newtimer(sname,idelay,iticks);
		this.cfinmethod(sname,sfunc);
	}
	cnewtimercyclefin(string sname, int icycle, int iticks, string sfunc)	{
		this.newtimercycle(sname,icycle,iticks);
		this.cfinmethod(sname,sfunc);
	}
	/****************************************************************/
	caddobjsfun(string ssnd, int ifrom, int ito, string ssig, string sfunc)	{
		while( ifrom <= ito )	{
			<ssnd+ifrom>.addmethod( ssig, sfunc+ifrom );
			ifrom++;
		}
	}
	caddobjsfunfin(string ssnd, int ifrom, int ito, string sfunc)	{
		this.caddobjsfun( ssnd, ifrom, ito, "onfinish", sfunc );
	}
	/****************************************************************/
	newancounter(string scounter, string sname, string sfile, int z, int ile)	{
		this.newanimas( sname, sfile, z, ile);
		new classancounter <scounter>;
		<scounter>.set( sname, ile );
	}
	newancounterh(string scounter, string sname, string sfile, int z, int ile)	{
		this.newancounter( scounter, sname, sfile, z , ile );
		for( int i=0; i<ile; i++)	<sname+i>.hide();
	}
	newancounterf(string scounter, string sname, string sfile, int z, int ile, string sfun)	{
		this.newancounter( scounter, sname, sfile, z , ile );
		for( int i=0; i<ile; i++)	<sname+i>.addmethod("onfinish", sfun);
	}
	newancounterhf(string scounter, string sname, string sfile, int z, int ile, string sfun)	{
		this.newancounter( scounter, sname, sfile, z , ile );
		for( int i=0; i<ile; i++)	{
			<sname+i>.addmethod("onfinish", sfun);
			<sname+i>.hide();
		}
	}
	cnewanimafin(string sname, string sfile, int z, string sfunc)	{
		this.newanima(sname, sfile, z);
		<sname>.addmethod("onfinish", sfunc );
	}
	ccopyanimafin(string sname, string snew, string sfunc)	{
		this.copyanima(sname, snew);
		<snew>.addmethod("onfinish", sfunc );
	}
	/****************************************************************/
	cloadwavs(string sdb, string sfile)	{
		this.newdb( sdb, sfile );
		int id = 0;
		int ile = <sdb>.getrowsno();
		int i[6], string s[5];
		while( id < ile )	{
			i1 = <sdb>.getcolsno(id);
			i2 = 0;
			s1 = <sdb>.get( id, i2 );	i2++;
			if( s1.getb(0,1)!="#" )	{
				s3 = <sdb>.get( id, i2 );	i2++;
				if( s1=="wav" || s1=="sfx" )	{
					s2 = <sdb>.get( id, i2 );	i2++;
					if( s1=="sfx")	{
						this.newsfx( s3, s2 );
					} else { this.newsnd( s3, s2 ); }
					if( i2 < i1 )	{
						s1 = <sdb>.get( id, i2 );	i2++;
						s2 = <sdb>.get( id, i2 );	i2++;
						if( s1=="method" )	{
							<s3>.addmethod("onfinish", s2 );
						} else if (s1.gete(0,4)=="play")	{
							this.<"c"+s1.gete(4,10)+"playonfin">(s3, s2);
						} else if ( s1=="vol" )	{
							<s3>.setvol( s2 );
						}
					}
				} else if (s1=="group")	{
					s2 = <sdb>.get( id, i2 );	i2++;
					i3 = <sdb>.get( id, i2 );	i2++;
					i4 = <sdb>.get( id, i2 );	i2++;
					if( i2 < i1 )	{		// jest method
						s1 = <sdb>.get( id, i2 );	i2++;
						if( s1=="method" )	{
							s4 = <sdb>.get( id, i2 );	i2++;
							this.cnewsndsfin( s3, i3, s2, i3, i4, s4 );
						}
					} else {
						this.newsnds( s3, i3, s2, i3, i4 );
					}
				} else if (s1=="bank")	{
					s2 = <sdb>.get( id, i2 );	i2++;
					i0 = <sdb>.get( id, i2 );	i2++;
					i3 = <sdb>.get( id, i2 );	i2++;
					i4 = <sdb>.get( id, i2 );	i2++;
					i5 = <sdb>.get( id, i2 );	i2++;
					new classsndbank <s3>;
					<s3>.load( s2, i0, i3, i4, i5);
					if( i2<i1)	{
						s1 = <sdb>.get( id, i2 );	i2++;
						if( s1=="method")	{
							s4 = <sdb>.get( id, i2 );	i2++;
							<s3>.addmethod( "onfinish", s4 );
						} else if (s1=="vol")	{
							<s3>.setvol( <sdb>.get( id, i2 ) );
						}
					}
				} else if ( s1=="method" )	{
					s2 = <sdb>.get( id, i2 );	i2++;
					i3 = <sdb>.get( id, i2 );	i2++;
					i4 = <sdb>.get( id, i2 );	i2++;
					while( i3<=i4)	{
						<s2+i3>.addmethod("onfinish", s3);
						i3++;
					}
				} else if ( s1=="singlebank")	{
					s2 = <sdb>.get( id, i2 );	i2++;
					i3 = <sdb>.get( id, i2 );	i2++;
					new classsndbank <s3>;
					<s3>.loadsingle( s2, i3 );
				} else if ( s1=="bgr" )	{
					this.csndbgr( s3 );
					if( i2 < i1 )	{
						if( <sdb>.get( id, i2 )=="vol" )	{
							i2++;
							sndbgr.setvol( <sdb>.get( id, i2 ) );
							i2++;
						}
					}
				} else if ( s1=="music" )	{
					this.playmusic( s3 );
					if( i2 < i1 )	{
						if( <sdb>.get( id, i2 )=="vol" )	{
							i2++;
							sndbgr.setvol( <sdb>.get( id, i2 ) );
							i2++;
						}
					}
				}
			}
			id++;
		}
	}
	/****************************************************************/
	crestart()	{	gameapi.play( gameapi.getgamename() );	}
	/****************************************************************/
	cgetscreenshoot(string sfile, real rzoom)	{
		if( igmenablesave )	{
			new img _imgsavebkg;
			_imgsavebkg.create(iResX,iResY,.white,255);
			_imgsavebkg.setz(2000);
			_imgsavebkg.blitscreen;
			
			if( rzoom!=1.0 )	{
				new filter _ftbg;
				_ftbg.link("_imgsavebkg");
				_ftbg.setsmooth(1);
				_ftbg.setzoom(rzoom);
			}
			_imgsavebkg.setpos(0,0);
			
			new img _im_1;
			_im_1.create(rzoom*iResX, rzoom*iResY, .white,255);
			_im_1.setpos(_imgsavebkg.getpx, _imgsavebkg.getpy);
			_im_1.blit("_imgsavebkg");
			
			_im_1.save(sfile);
			
			delete _im_1;
			if( rzoom!=1.0 )	{
				_ftbg.unlink;
				delete _ftbg;
			}
			delete _imgsavebkg;
		}
	}
}


/***************************************************************************/

class clfindfunc	{
	init()	{}
	int _stdfindfunc(string sobj, int ifirst, int ilast, string sname, string sfunc)	{	
		while(ifirst<=ilast)	{
			if( <sobj + ifirst>.<sfunc>() ==sname )	return ifirst;
			ifirst++;
		}
		-1;
	}
	int _stdfindfunc2(string sobj, int iile, string sname, string sfunc)	{	
		._stdfindfunc(sobj, 0, iile-1, sname, sfunc);
	}
	/****************************************************************/
	cfindandeval2(string sobj, int iile, string sname, string sfunc, string seval)	{	
		.cfindandeval(sobj, 0, iile-1, sname, sfunc, seval);
	}
	cfindandeval(string sobj, int ifirst, int ilast, string sname, string sfunc, string seval)	{	
		int pos = ._stdfindfunc(sobj, ifirst, ilast, sname, sfunc);
		if(pos>=0)	<sobj+pos>.<seval>();
	}
}



/*****************************************************************/
class classbutton 	{
	init()	{
		new string san = "anbut";
		new string sbut = "but";
		new int iilebut = 0;
		new string sfxmon = null;
	}
	_cbuildbutname(string sname)	{	new string _sbutname=sname; }
	string cgetbutname()	{ return _sbutname; }
	build(string sfile, int z, string smouse)	{this.build2(sfile,z,smouse,null);	}
	build2(string sfile, int z, string smouse, string sgrp)	{	// wczytuje animacje i buduje z niej przyciski
		string smain = "_" + san;
		new anima <smain>;
		<smain>.load( sfile );
		<smain>.setz(z);
		int ile = <smain>.nofactions();
		int j;	int k;
		int iliczans = 0;
		string sn1, string sn2, string sn3;
		string spom;
		for(int i=0; i<ile; i++)	{
			sn1 = null;	sn2 = null;	sn3 = null;
			j = <smain>.nofframes(i);
			for(k=1; k<=j; k++)	{
				spom = san + iliczans;
				if(k==1)	{	sn1=spom; } 
				else if (k==2)	{ sn2 = spom; }
				else if (k==3)	{ sn3 = spom; }
				newvars::copyanima( smain, spom );
				<spom>.setframe( i, k-1 );
				iliczans++;
			}
			if( sgrp!=null && <sgrp>.contains( <smain>.nameofaction(i)) ) {
				<sn1>.setz(z-1);
			} else this.addbut(sn1, sn2, sn3, smouse);
		}
		<smain>.hide();
	}
	/***************************** \/ \/ \/ \/ \/ wewnetrzne \/ \/ \/ \/ \/ *************************************************/
	_buildfuncclick( string sname )	{	new string _sfunclick = sname; }
	_stdbutclick()	{	this.<_sfunclick>( this.getbutname() );		}
	_buildfuncrel( string sname )	{	new string _sfuncrel = sname; }
	_stdbutrel()	{	this.<_sfuncrel>( this.getbutname() );	}
	_buildfuncmovon( string sname )	{	new string _sfunmovon = sname; }
	_stdbutmovon()	{
		if( sfxmon!=null )	<sfxmon>.play();
		this.<_sfunmovon>( this.getbutname() );
	}
	_buildfuncmovoff( string sname )	{	new string _sfunmovoff = sname; }
	_stdbutmovoff()	{	this.<_sfunmovoff>( this.getbutname() );	}
	butsigfun(string sb, string sfunc, string ssig, string sfun1, string sfun2)	{
		if( sfunc==null )	return;
		<sb>.addmethod(sfun1, sfun1);
		<sb>.<sfun1>( sfunc );
		<sb>.addmethod(ssig, sfun2);
	}
	sigfunc(string sfunc, string ssig, string sfun1, string sfun2)	{
		for(int i=0; i<iilebut; i++)	this.butsigfun(sbut + i, sfunc, ssig, sfun1, sfun2);
	}
	print()	{for(int i=0; i<iilebut; i++)	engine.print( <sbut+i>.getbutname() );}
	setrect()	{
		string s;
		for( int i=0; i<iilebut; i++)	{
			s = <sbut+i>.getimg;
			<sbut+i>.setrect( <s>.getpx, <s>.getpy, <s>.getex, <s>.getey );
		}
	}
	setflags(bool bvis, bool balph)	{	for(int i=0; i<iilebut; i++)	<sbut+i>.setflags(bvis,balph);	}
	/***************************** /\ /\ /\ /\ /\ wewnetrzne /\ /\ /\ /\ /\ ************************************************/
	sfxonmovon(string ssnd)	{	sfxmon=ssnd;	}
	clickfunc(string sfunc)	{this.sigfunc(sfunc,"onclick", "_buildfuncclick", "_stdbutclick");	}
	relfunc(string sfunc)	{this.sigfunc(sfunc,"onrel", "_buildfuncrel", "_stdbutrel");	}
	movonfunc(string sfunc)	{this.sigfunc(sfunc,"onmoveon", "_buildfuncmovon", "_stdbutmovon");	}
	movofffunc( string sfunc)	{this.sigfunc( sfunc,"onmoveoff", "_buildfuncmovoff", "_stdbutmovoff");}
	/*****************************************************************/
	int ilebuts()	{	return iilebut;	}
	/*****************************************************************/
	int ifind(string sname)	{return clfindfunc::_stdfindfunc2(sbut, iilebut, sname, "getbutname");	}
	string sfind(string sname)	{
		int pos = clfindfunc::_stdfindfunc2(sbut, iilebut, sname, "getbutname");
		return pos>=0 ? sbut+pos : null;
	}
	/*****************************************************************/
	_cbutfun(string sname, string sfunc)	{
		clfindfunc::cfindandeval2(sbut, this.ilebuts(), sname, "getbutname", sfunc );
	}
	_callbutfunc(string sfunc)	{	for(int i=0; i<iilebut; i++)	<sbut+i>.<sfunc>();	}
	_cibutfunc(string sfunc, int ile)	{
		if( ile > iilebut )	ile = iilebut;
		for(int i=0; i<ile; i++)	<sbut+i>.<sfunc>();
	}
	ienable( int ile )	{	this._cibutfunc("enable", ile);	}
	benableall()	{	this.resumeall();	this.enableall();	}
	pauseall()	{	this._callbutfunc("pause");	}
	resumeall()	{	this._callbutfunc("resume");	}
	enableall()	{	this._callbutfunc("enable");	}
	disableall()	{	this._callbutfunc("disable");	}
	disabled	{	<sbut+0>.disabled;	}
	
	benable(string sname)	{	this.resume(sname);	this.enable(sname);	}
	disable(string sname)	{	this._cbutfun( sname, "disable");	}
	enable(string sname)	{	this._cbutfun( sname, "enable");	}
	pause(string sname)	{	this._cbutfun( sname, "pause");	}
	resume(string sname)	{	this._cbutfun( sname, "resume");	}
	
	resetall()	{	for(int i=0; i<iilebut; i++)	<sbut+i>.setcursorpos(0, 0);	}
	setcursorpos(int x, int y)	{	for(int i=0; i<iilebut; i++)	<sbut+i>.setcursorpos(x, y);	}
	/*****************************************************************/
	string getimg(string sname)	{
		string s= this.sfind(sname);
		return s!=null ? <s>.getimg() : null;	
	}
	callimgfun(string sname, string sfun)	{	<.getimg(sname)>.<sfun>;	}
	/*****************************************************************/
	newmouse(string sname, string snewmouse)	{
		string s = this.sfind(sname);
		if(s!=null)	<s>.setmouse( snewmouse );
	}
	addbut(string san1, string san2, string san3, string smouse)	{
		string spom = sbut + iilebut;
		newvars::newbutan( spom, san1, san2, san3, smouse);
		<spom>.addmethod("getbutname","cgetbutname");
		<spom>._cbuildbutname( <san1>.actionname() );	// nazwa buttonu to nazwa akcji
		iilebut++;
	}
	/*****************************************************************/
	_addfunc(string s, string sfclick, string sfrel, string sfmvon, string sfmvoff)	{
		if( s== null)	return;
		this.butsigfun( s, sfclick, "onclick", "_buildfuncclick", "_stdbutclick");
		this.butsigfun( s, sfrel, "onrel", "_buildfuncrel", "_stdbutrel");
		this.butsigfun( s, sfmvon, "onmoveon", "_buildfuncmovon", "_stdbutmovon");
		this.butsigfun( s, sfmvoff, "onmoveoff", "_buildfuncmovoff", "_stdbutmovoff");
	}
	addfuncto(string sname, string sfclick, string sfrel, string sfmvon, string sfmvoff)	{
		this._addfunc( this.sfind(sname), sfclick, sfrel, sfmvon, sfmvoff);
	}
	addfunctolast(string sfclick, string sfrel, string sfmvon, string sfmvoff)	{
		this._addfunc( sbut + (iilebut-1) , sfclick, sfrel, sfmvon, sfmvoff);
	}
	/*****************************************************************/
	_transmet(string sob, string sfunc, string smet, string s)	{
		new string <"_sob" + s> = sob;
		new string <"_sf" + s> = sfunc;
		this.<smet>( "_trf"+s );
	}
	transclickfunc(string sob, string sfunc)	{this._transmet( sob, sfunc, "clickfunc", "cl" );	}
	transrelfunc(string sob, string sfunc)	{this._transmet( sob, sfunc, "relfunc", "rl" );	}
	transmovonfunc(string sob, string sfunc){this._transmet( sob, sfunc, "movonfunc", "mn" );	}
	transmovofffunc(string sob, string sfunc){this._transmet( sob, sfunc, "movofffunc", "mf" );	}
	_trfcl(string s)	{	<_sobcl>.<_sfcl>(s);		}
	_trfrl(string s)	{	<_sobrl>.<_sfrl>(s);		}
	_trfmn(string s)	{
		if( sfxmon!=null )	<sfxmon>.play();
		<_sobmn>.<_sfmn>(s);
	}
	_trfmf(string s)	{	<_sobmf>.<_sfmf>(s);		}
}


/*****************************************************************/

class classmask : classbutton	{
	init()	{
		classbutton::init();
	}
	buildmask(string sfile, string smouse)	{
		this.build(sfile, 0, smouse);
		int ile = this.ilebuts();
		for(int i=0; i<ile; i++)	{
			<sbut+i>.setflags(false, false);
			<sbut+i>.hide();
		}
	}
	buildmaskfunc(string sfile, string smouse, string sfunc)	{
		this.buildmask(sfile, smouse);
		this.clickfunc(sfunc);
	}
	addmask(string sanim, string sname, string smouse, int bhide)	{		// dodanie np. ludka jako maski
		string spom = sbut + iilebut;
		newvars::newbutan( spom, sanim, null, null, smouse);
		<spom>.addmethod("getbutname","cgetbutname");
		sname==null ? <spom>._cbuildbutname(<sanim>.actionname()) : <spom>._cbuildbutname(sname);
		if(bhide)	{
			<spom>.setflags(false, false);
			<spom>.hide();
		}
		iilebut++;
	}
	addadvmask(string sanim, string sname, string smouse, string sfuncclick)	{
		this.addmask( sanim, sname, smouse, false );
		this.addfunctolast( sfuncclick, null, null, null);	
	}
}

/*****************************************************/
public _stdanloop()	{	this.play(-1); }
public _stdanhide()	{	this.hide();	}
public _stdsndloop()	{	this.play(); }
public __std_finish()	{	this.<this+"_FINISH">();	}
public looponfinish(string san)	{	<san>.addmethod("onfinish", "_stdanloop");	}
public hideonfinish(string san)	{	<san>.addmethod("onfinish", "_stdanhide");	}
/*****************************************************/
public string strsube(int ile)	{	this.getb( 0, this.length()-ile );	}
public string strsubb(int ile)	{	this.getb( ile, this.length() - ile );	}
public string strsubbs(string s)	{	this.strsubb( s.length() );	}
public string strsubes(string s)	{	this.strsube( s.length() );	 }
public string strgetto(string schar)	{
	@id = .find(schar);
	id<0 ? .get : .getb(0, id);
}
public string strgeteto(string schar)	{
	@id = .rfind(schar);
	id<0 ? .get : .getb(id+1, .length);
}
public bool streq(string s)	{	.get == s.getb(0, .length);	}
public string strgetfromto(int ipos, string schar)	{	this.getb(ipos, this.find(schar));	}
public string strgetfrom(string schar)	{	.getb(.find(schar)+schar.length, .length );	}
public strremove(string s)	{	.set( .strgetto(s) + .strgetfrom(s) ); }
public bool strisbetween(int b1, int b2)	{
	int ib;
	for(int i=0; i<.length; i++)	{
		ib = .getbyte(i);
		if( ib<b1 || ib>b2 )	return false;
	}
	true;
}
public bool strisint		{	.strisbetween(BYTE0, BYTE9);	}
public bool strisbin	{	.strisbetween(BYTE0, BYTE0+1);	}
public bool strisalpha	{	.strisbetween(BYTEa, BYTEz);	}
public streach(string sfun)	{
	string s;
	for( int i=0; i<.length; i++) {
		s = .getb(i,1);
		<s>.<sfun>(i);
	}
}
public string strdotpos(int pos)	{	.strgetto(".") + "." + .strgetfrom(".")->getb(0,pos);}
/*****************************************************/
public swap(string s1, string s2)	{
	[s1];
	<s1> = [s2];
	<s2> = _;
}
public bool stats(int ile)	{	(ile <= 0) ? false : ( 100->rand <= ile );}
public def between(def i1, def i, def i2)	{	( i < i1 ) ? i1 : (i>i2) ? i2 : i;}
public def max(def val1, def val2)	{	val1>val2 ? val1 : val2;	}
public def min(def val1, def val2)		{	val1<val2 ? val1 : val2;	}
public inextrol(int id, int ile)	{
	int i = id + .get;
	if( i < 1 ) .set(ile);
	else if ( i > ile ) .set(1);
	else .set(i);
}
/*************** do wykorzystania na obiektach!! ***********************************/
public movoffsetr	{	.move(igmoffsetx,0);	}
public movoffsetl	{	.move(-igmoffsetx,0);	}
public imgprint	{
	(this+": pos="+.getposx+","+.getposy+" xy="+.getpx+","+.getpy+" wh="+.getw + ","+.geth + 
		" exy="+.getex +","+.getey+" lod="+.lodx+","+.lody+" z="+.getz)->print;
}
public imgborders(int w, int r, int g, int b, int a)	{	.imgborderss(w,r,g,b,a,"1111"); }
public imgborderss(int w, int r, int g, int b, int a, string sbor)	{
	new img _img_bor;
	_img_bor.create(.getw, w, r,g,b,a);
	_img_bor.setpos(.getpx, .getpy );
	if(sbor.getb(3,1)=="1")
		.blit("_img_bor");
	_img_bor.move(0, .geth-w);
	if(sbor.getb(1,1)=="1")
		.blit("_img_bor");
	_img_bor.create(w,.geth,r,g,b,a);
	_img_bor.setpos(.getpx, .getpy);
	if(sbor.getb(0,1)=="1")
		.blit("_img_bor");
	_img_bor.move(.getw-w, 0);
	if(sbor.getb(2,1)=="1")
		.blit("_img_bor");
	delete _img_bor;
}
public imgroundborder(int w, int r, int g, int b, int a)	{
	.imgborders(w,r,g,b,a);
	.imgerasecorners;
}
public imgerasecorners	{
	@x = .getpx;
	@y = .getpy;
	.putrgba(x,y,.transparent);
	.putrgba(.getex-1,y,.transparent);
	.putrgba(.getex-1,.getey-1,.transparent);
	.putrgba(x,.getey-1,.transparent);
}
public real imgdrawline(string sbrush, int xstart, int ystart, int xstop, int ystop, real istep, real rdy)	{
	.imgfuncline("blit",sbrush,xstart,ystart,xstop,ystop,istep,rdy);
}
public real imgeraseline(string sbrush, int xstart, int ystart, int xstop, int ystop, real istep, real rdy)	{
	.imgfuncline("erase",sbrush,xstart,ystart,xstop,ystop,istep,rdy);
}
public imgputoncenter(string simg)	{	.setpos( <simg>.getcx-.getw/2, <simg>.getcy-.geth/2);	}
public real imgfuncline(string sfun, string sbrush, int xstart, int ystart, int xstop, int ystop, real istep, real rdy)	{
	@dx = xstop-xstart;
	@dy = ystop-ystart;
	real r;
	if( dx==0 )	{
		if( dy<0 )	{
			r = rdy+ystart;
			while( r>=ystop )	{
				<sbrush>.setpos(xstart, r);
				.<sfun>(sbrush);
				r-=istep;
			}
			ystop-r;
		} else if (dy>0)	{
			r = rdy+ystart;
			while( r<=ystop )	{
				<sbrush>.setpos(xstart, r);
				.<sfun>(sbrush);
				r+=istep;
			}
			r-ystop;
		} else rdy;
	} else {
		r = rdy.length(dx, dy);
		real rd;
		while( rdy<=r )	{
			rd = 1.0 - (r-rdy)/r;
			<sbrush>.setpos( (rd*dx)+xstart, (rd*dy)+ystart );
			.<sfun>(sbrush);
			rdy+=istep;
		}
		rdy-r;
	}
}
public anresizemets()	{	anima_pack::resizemethods(this.getname());	}
//public def anfirstnontr	{	classansearcher::firstnotrx1y(this);	}
public def anfirstnontr	{	classansearcher::_findnotr(this,.getpx, .getpy, 1, 0);	}
public anloopfin()	{	this.addmethod("onfinish", "_stdanloop");	}
public anloopplay(int iact)	{	this.anloopfin();	this.play(iact);	}
public anloopsplay(string sact)	{	this.anloopfin();	this.play(sact);	}
public anhidefin()	{	this.addmethod("onfinish","_stdanhide");	}
public anputgr()	{	this.setz( this.getey() );	}
public anputy(int ypos)	{	this.move(0, ypos - this.geth() - this.getpy());	}
public anputx(int xpos)	{	this.move(0, xpos - this.geth() - this.getpy());	}
public ansetposgr(int x, int y)	{	this.setpos(x,y);	this.anputgr();	}
public anplayz(int id, int z)	{	this.setz(z);	this.play(id);	}
public anplaygr(int id)	{	this.play(id);	this.anputgr();	}
public anplayzpos(int id, int z, int x, int y)	{	this.setpos(x,y);	this.anplayz(id,z);	}
public anplaypos(int x, int y)	{	this.setpos(x,y);	this.play(-1);	}
public anplayposgr(int x, int y)	{	this.ansetposgr(x,y);	this.play(-1);	}
public anplaypos2(int x, int y, string sact)	{	this.setpos(x,y);	this.play(sact);	}
public anplaypos3(int x, int y, int iact)	{	this.setpos(x,y);	this.play(iact);	}
public anhide()	{	this.stop(false);	this.hide();	}
public andownpos(int x, int y)	{	this.setpos( x, y-this.geth() );	}
public ansetbpos(int x, int y)	{	this.setpos( x-this.lodx(), y-this.lody() );	}
public ansetcpos(int x, int y)	{	.ansetbpos( x - .getw/2, y - .geth/2 );	}
public ancenterscreen {       .ansetcpos( igmappw/2, igmapph/2 ); }
public ancenterimg(string simg)	{	.ansetcpos( <simg>.getpx+<simg>.getw/2, <simg>.getpy+<simg>.geth/2 );	}
public imgfit(int x, int y, int ex, int ey)	{
	if( .getpx < x ) .move( x-.getpx, 0 );
	if( .getpy < y ) .move( 0, y-.getpy );
	if( .getex > ex ) .move( ex-.getex, 0 );
	if( .getey > ey ) .move( 0, ey-.getey );
}
public imgfitscreen	{	.imgfit( igmoffsetx, igmoffsety, iResX+igmoffsetx, iResY+igmoffsety );	}
public ansetframe(int id)	{	this.setframe( this.actionnr(-1), id );	}
public ansetsframe(def d, string s)	{
	.setframe(d,0);
	int id = 0;
	while( id < .nofframes(-1) && .framename!=s )	{
		id++;
		.setframe(-1,id);
	}
}
public ansetlastframe(def act)	{	.setframe( act, .nofframes(act)-1 );	}
public int anonscreen()	{	clsurf.inscreen(this.getcx(), this.getcy(), this.getw()/2, this.geth()/2);	}
public objplayfin(string sfun)	{	this.addmethod("onfinish", sfun);	this.play();	}
public objloop()	{	this.addmethod("onfinish","_stdsndloop");	}
public objplayloop()	{	this.objloop;	this.play();	}
public anplayfin(def act, string sfun)	{	this.addmethod("onfinish", sfun);	this.play(act);	}
public anplaysmoothfin(def act, string sfun)	{	.addmethod("onfinish", sfun);	.playsmooth(act);	}
public anplayif(def act)	{ if( .isplaying(act)==false ) .play(act);	}
public anytoz()	{	this.setz(this.getposy());	}
public anposz(int x, int y, int z)	{	.setpos(x,y);	.setz(z);	}
public string annextaction(string sact)	{ this.nameofaction( (this.actionnr(sact)+1)%this.nofactions() );}
public int annextact	{ (.actionnr(-1)+1)%.nofactions; }
public ansetnextact	{	.setframe( (.actionnr(-1)+1)%.nofactions, 0 ); }
public ansetnextfr		{	.setframe( -1, (.framenr+1)%.nofframes(-1)); }
public ansetrandfr	{	.setframe(-1, .nofframes(-1)->rand);	}
public anhasaction(string sac)	{	.actionnr(sac) != .nofactions;}
public anaddfilter()	{	classanfilter::build(this.getname());	}
public anaddfx	{	AnimaFx::build( this );	}
public anputc(int x1, int y1, int x2, int y2)	{
	.ansetbpos(x1,y1);
	.move( (x2-x1-.getw)/2, (y2-y1-.geth)/2 );
}
public aninlod(int itoler)	{	itoler.length( .getpx - .lodx, .getpy - .lody ) <= itoler; }
public angetcpos	{	return .getcx, .getcy;	}
public anactnr	{	.actionnr(-1);	}
public angetcrgba	{	.getrgba(.getcx, .getcy);	}
public anisin(int x, int y, bool bv, bool ba)	{
	for( int i=0; i<.nofactions; i++)	{
		.setframe(i, 0);
		if( .isin(x,y,bv,ba) ) return i;
	}
	-1;
}
public anreload(string sfile)	{
	int id = .actionnr(-1);
	int fr = .framenr;
	bool bplay = .isplaying(-1)!=false;
	|int x, int y| = .getpos;
	int z = .getz;
	.load( .getpath(sfile) );
	.setpos(x, y);
	.setz(z);
	if( id < .nofactions ) {
		if( bplay ) .play(id);
		.setframe(id ,fr );
	} else .setframe(0 ,0);
}
public anclipob(string sob)	{	.clip(<sob>.getpx, <sob>.getpy, <sob>.getex, <sob>.getey);	}
public anclipscreen		{	.clip(0,0,igmappw,igmapph);	}
public ancopyan(string san)	{
	.setframe( <san>.actionnr(-1), <san>.framenr );
	<san>.isvisible ? .show : .hide;
	.setpos( <san>.getpos );
}
public anconstmove(int delay, int x, int y)	{
	.vars2(A, "mvx", x, "mvy", y);
	.setdelay(delay);
	.anplayfin(-1, func { .play(-1); .move(mvx, mvy); });
}
//---------------- sounds --------------------
public fxplayifgr(string ssnd,int istart, int iend)	{
	while( <ssnd+istart>.isplaying && istart < iend )	{
		istart++;
	}
	<ssnd+istart>.playif;
}
//--------------- scale ----------------
public scmove(int x, int y)	{	.move( rgmscalex*x, rgmscaley*y );	}
public scpos(int x, int y)	{	.setpos( rgmscalex*x, rgmscaley*y );	}
public int igetsc		{	(rgmscalex*.get + 0.5)->to_i;	}
/***************** text ****************/
public txtset(string s)	{	.set(s);	.create;	}
public txtsetcol(string s, int r, int g, int b)	{	.set(s);	.createtxt(r,g,b);	}
public txtshadow(int w, string sfont)	{
	if( !.hasvar("txts") )	{
		new text txts;
		txts.setfont(sfont);
	}
	txts.set(.get);
	txts.setpos(.getpx+w, .getpy+w);
	txts.setz(.getz-1);
	txts.show;
	txts.createtxt(0,0,0);
}
public txthides	{	.hide; if(.hasvar("txts")) txts.hide; }
public txtisin(int x, int y)	{
	x>=.getpx && x<.getpx+.getw && y>=.getpy && y<=.getpy+.geth;
}
public txtcenter(string sob)	{	.setpos( <sob>.getcx - .getw/2, <sob>.getcy - .geth/2 );}
public txtright(string sob)	{	.setpos( <sob>.getex - .getw, <sob>.getcy - .geth/2 );}
public txtcenterscreen		{	.setpos( (igmappw-.getw)/2, (igmapph-.geth)/2 );	}
public imgfittxt( string stxt, string simg, string simgtxt, int stepy, bool bcreate )	{
	if( bcreate )	{
		.create( <simg>.getw, <simg>.geth + 2*stepy, .transparent );
		.setpos( <simg>.getpx, <simg>.getpy );
	}
	
	new vector _vtmplin;
	_vtmplin.type("string");
	_vtmplin.vecbuildfromstring(stxt, " ");
	string s = "", string s2, string s3;
	int x, int y, int ex, int ey;
	bool bnewline, bool bnextline;
	string snewline = "\\n";
	
	int yp = <simg>.getpy;
	|x, y| = classansearcher::_findnotr(simg, <simg>.getpx, yp, 1, 0);
	|ex, ey| = classansearcher::_findnotr(simg, <simg>.getex-1, yp, -1, 0);
	for( int i=0; i< _vtmplin.size; i++)	{
		s2 = s;
		s3 = _vtmplin.get(i);
		
		if( s3.contains(snewline) )	{
			string st1 = s3.strgetto(snewline);
			string st2 = s3.strgetfrom(snewline);
			if( st1.length > 0 ) {
				s3 = st1;
			} else s3 = "";
			if( st2.length > 0 )	{
				_vtmplin.vecaddat(i+1, st2);
			}
			bnewline=true;
		} else bnewline = false;
		s += s3 + " ";
		<simgtxt>.txtset(s);
		<simgtxt>.setpos( x, yp );
		if( <simgtxt>.getpx + <simgtxt>.getw > ex || bnewline )	{
			if( <simgtxt>.getpx + <simgtxt>.getw <= ex )	{
				s2 = "";
			} else if ( bnewline && i+1<_vtmplin.size)	{
				_vtmplin.set(i+1, snewline + _vtmplin.get(i+1));
			}
			if( s2!="" ) {
				<simgtxt>.txtset(s2);
				s = s3 + " ";
				s2 = s;
			} else {
				s = "";
				s2 = "";
			}
			.blit( simgtxt );
			yp += stepy;
			if( yp < <simg>.getey )	{
				|x, y| = classansearcher::_findnotr(simg, <simg>.getpx, yp, 1, 0);
				|ex, ey| = classansearcher::_findnotr(simg, <simg>.getex-1, yp, -1, 0);
			}
		}
	}
	if( s!="" ) {
		<simgtxt>.txtset(s);
		<simgtxt>.setpos( x, yp );
		.blit(simgtxt);
	}
	delete _vtmplin;
}
/***************** vector ****************/
public vecinc(int pos)	{	this.set( pos, this.get(pos)+1 );	}
public vecdec(int pos)	{	this.set( pos, this.get(pos)-1 );		}
public vecnewint(int ile)	{
	this.free();
	if( ile>0 )	for( int i=0; i<ile; i++)	{	this.add(i);	}
}
public veccopy(string svec)	{
	this.free();
	for( int i=0; i< <svec>.size(); i++ )	this.add( <svec>.get(i) );
}
public int vecnextid(def val)	{
	int id = .find(val);
	if( id>=0 )	id = (id+1)%.size;
	id;
}
public int vecprevid(def val)	{
	int id = .find(val);
	if( id>0 )	id--;
	else if (id==0)	id = .size-1;
	id;
}
public def vecget(int id)	{
	( id>=0 && id<.size) ? .get(id) : null;
}
public def vecnext(def val)	{	.vecget( .vecnextid(val) );	}
public def vecprev(def val)	{	.vecget( .vecprevid(val) );	}
public def veclast()	{
	int ile = this.size();
	ile>0 ? this.get(ile-1) : null;
}
public def vecpop()	{
	@x = .last;
	.removeat( .size - 1 );
	x;
}
public veclimes(int ile)	{	while( .size > ile )	_ = .vecpop;	}
public def vecpopfront()	{
	def x = this.get(0);
	this.removeat( 0 );
	x;
}
public vecreplace(def d1, def d2)	{
	@id = .find(d1);
	if( id>=0 )	.set(id,d2);
}
public insertsort(int ile, string sgetfun, string scomparefun, string sswapfun)	{
	if( ile<=1 )	{	return;	}
	def s[2], int id, int i, int j;
	for( i=0; i<ile; i++)	{
		s0 = this.<sgetfun>(i);
		id = i;
		for( j=i+1; j<ile; j++)	{
			s1 = this.<sgetfun>(j);
			if( this.<scomparefun>(s1,s0) )	{
				s0 = s1;
				id = j;
			}
		}
		this.<sswapfun>(i,id);
	}
}
public obbuildfromstring(string s, string separator, string sfunadd)	{
	int pos = s.find(separator);
	while( pos>-1 )	{
		this.<sfunadd>( s.getb(0,pos) );
		s = s.strsubb(pos+1);
		pos = s.find(separator);
	}
	if( s.length()>0 )	{	this.<sfunadd>(s);	}
}
public obbuildfromstring2(string s, string separator, string sfunadd)	{
	int pos = s.find(separator);
	while( pos>-1 )	{
		if( pos>0 )	this.<sfunadd>( s.getb(0,pos) );
		s = s.strsubb(pos+1);
		pos = s.find(separator);
	}
	if( s.length()>0 )	{	this.<sfunadd>(s);	}
}
public vecsort(string scomparefun)	{ .insertsort( .size, "get", scomparefun,"swap" ); }
public string vecbuildfromstring(string s, string separator)	{
	this.free();
	this.obbuildfromstring(s,separator,"add");
}
public string vecbuildfromstring2(string s, string separator)	{
	this.free();
	this.obbuildfromstring2(s,separator,"add");
}
public vecremoveto(int ito)		{	for( int i=0; i<ito; i++ ) this.removeat(0);		}
public vecremovefrom(int ifrom)	{	while( ifrom<this.size() ) this.removeat(ifrom);	}
public vecfindfrom(int ifrom, def d)	{
	while (ifrom<.size)	{
		if( .get(ifrom)==d ) return ifrom;
		else ifrom++;
	}
	-1;
}
public vecposfromto(int i1, int i2)	{
	if( i1==i2 || .size==0 )	return;
	def x = .get(i1);
	if( i1>i2 )	for( int i=i1; i>i2; i--)	{	.set(i, .get(i-1));		}
	else if (i1<i2)	for( int i=i1; i<i2; i++)	{	.set(i, .get(i+1));	}
	.set(i2,x);
}
public vecposfirst( def x )	{
	int id = .find(x);
	if( id>=0 )	.vecposfromto(id, 0);
	else	.addbegin(x);
}
public vecposlast( def x )	{
	int id = .find(x);
	if( id>=0 )	.vecposfromto(id, .size-1);
	else	.addbegin(x);
}
public vecset(def x, def d2)	{
	int id = .find(x);
	if( id>=0 )	.set(id,d2);
}
public bool veceq(string svec)	{
	int id = .size;
	if( id != <svec>.size  )	return false;
	for( int i=0; i< id; i++)	if( .get(i)!=<svec>.get(i) ) return false;
	true;
}
public vecbuild	{	.withlist("addbegin");}
public bool veceq2	{
	new vector ___v;
	___v.type(.getvectype);
	___v.vecbuild;
	bool b = .veceq("___v");
	delete ___v;
	b;
}
public veccopydbrow(string sdb, int irow)	{	.free;	 .vecadddbrow(sdb,irow);	}
public vecadddbrow(string sdb, int irow)	{	for( int i=0; i< <sdb>.getcolsno(irow); i++)	.add( <sdb>.get(irow,i) );	}
public def vecchecknext(int id)	{
	id++;
	id < .size ? .get(id) : null;
}
public vecaddat(int pos, def val)	{
	if( pos>=0 && pos <= .size )	{
		.add(val);
		for( int i=.size-1; i>pos; i-- )	{
			.set(i, .get(i-1));
		}
		.set(pos,val);
	}
}
public def vecsum	{
	if( .size )	{
		def sum = .get(0);
		for( int i=1; i<.size; i++)	{
			sum+=.get(i);
		}
		sum;
	} else 0;
}
public int vecclosest(def val)	{
	int ile = .size;
	if( ile <= 0 ) return -1;
	int id = 0;
	def ipom = (val - .get(0))->abs;
	for( int i=1; i<ile; i++)	{
		def ipom2 = (val - .get(i))->abs;
		if( ipom2<ipom )	{
			id = i;
			ipom = ipom2;
		}
	}
	id;
}
public vecloadargs	{
	@s = _;
	while(s!=A)	{
		.addbegin(s);
		@s = _;
	}
}
public vecbuildlines(string stxt, int charlimit)	{
	.free;
	.type("string");
	if( charlimit <= 0 ) return;
	new vector _vtmplin;
	_vtmplin.type("string");
	_vtmplin.vecbuildfromstring(stxt, " ");
	string s = "";
	for( int i=0; i< _vtmplin.size; i++)	{
		s+=_vtmplin.get(i) + " ";
		if( s.length >= charlimit )	{
			.add(s);
			s = "";
		}
	}
	if( s!="" ) .add(s);
	delete _vtmplin;
}
/************** db ************************/
public dbbuild(int icol)	{
	if( icol<=0 )	return;
	icol--;
	.free;
	string s = _, int id;
	for( int i = 0; s!=A; )	{
		if( i==0 )	id = this.addbeginrow() - 1;
		this.addbegin(0,s);
		s = _;
		i = (i<icol)? i+1 : 0;
	}
}
public dbbuild2	{
	.free;
	string s = _;
	while( s!=A )	{
		if( s==null )	_ = .addbeginrow;
		else .addbegin(0,s);
		s = _;
	}
}
public dbaddvec(string svec)	{
	@id = .addrow-1;
	for( int i=0; i< <svec>.size; i++)	.add(id, <svec>.get(i));
}
public dbcopy(string sdb)	{	.dbcopyfromto(sdb, 0, <sdb>.getrowsno);}
public dbcopyrow(string sdb, int irow)	{	.dbcopyfromto(sdb,irow,irow+1);	}
public dbcopyfromto(string sdb, int i1, int i2)	{
	.free;
	.dbaddrowfromto(sdb,i1,i2);
}
public dbaddrowfromto(string sdb, int i1, int i2)	{
	int i, int j, int row;
	for( i =i1; i< i2; i++)	{
		row = .addrow-1;
		for( j=0; j< <sdb>.getcolsno(i); j++)	{
			.add( row, <sdb>.get(i,j) );
		}
	}
}
public dbadddbrowtorow(int myrow, string sdb, int row)	{
	for( int i=0; i< <sdb>.getcolsno(row); i++)	{
		.add( myrow, <sdb>.get(row,i) );
	}
}
public dbremovecol(int col)	{	for(int i=0; i<.getrowsno; i++) if( .getcolsno(i)>col ) .removeat(i,col);	}
public dbcopyfromtos(string sdb, string sfrom, string sto)	{
	.dbcopyfromto(sdb, <sdb>.findbyrow(sfrom)+1, <sdb>.findbyrow(sto));
}
public dbremovelast()	{
	.removerow( .getrowsno-1 );
}
public dbcuttosize(int isize)	{
	if( isize>0 ) while( .getrowsno > isize )	.dbremovelast;
	else	.free;
}
public dbaddlast(string svar)	{	this.add( this.getrowsno()-1, svar );	}
public dbaddstringrow(string s, string separator)	{
	_ = this.addrow();
	this.obbuildfromstring(s,separator,"dbaddlast");
}
public dbrowtostring(int row, int colstart, int colend, string separator)	{
	string s="";
	int ile = .getcolsno(row)-1;
	if( colend<0 || colend > ile )
		colend = ile;
	for( ; colstart<=colend; colstart++) s+= .get(row,colstart) + separator;
	s;
}
public dbgetstringrow(int row)	{	.dbrowtostring(row, 0, -1, "");	}
public dbaddrow	{
	@id = .addrow - 1;
	@s = _;
	while(A!=s)	{
		.addbegin(id, s);
		@s = _;
	}
}
public dbaddrowfrom(string sdb, int irow, int icol)	{
	if( <sdb>.rowinrange(irow) && icol>=0)	{
		int id = this.addrow()-1;
		int ile = <sdb>.getcolsno(irow);
		while( icol < ile )	{
			this.add( id, <sdb>.get( irow, icol ) );
			icol++;
		}
	}
}
public string dbchecknext(int irow, int icol)	{
	icol++;
	icol < this.getcolsno(irow) ? this.get(irow,icol) : null;
}
public string dbgets(string s, int icol)	{
	@id = .findbyrow(s);
	if( id>=0 && .getcolsno(id)>icol ) .get(id,icol);
	else null;
}
public string dbget(string s)	{ @id=.findbyrow(s); id>=0 ? .get( id, 1 ) : null; }
public int dbgetint(string s)	{ @id=.findbyrow(s); id>=0 ? .get( id, 1 )->to_i : 0; }
public real dbgetscr(string s)	{ @id=.findbyrow(s); id>=0 ? .get( id, 1 )->to_r*rgmscalex : 0.0; }
public int dbinsertless(int i1)	{
	int id = this.addrow()-1;
	this.add(id,i1);
	this.dbsort("cmpless");
	while( id>=0 )	{
		if( i1==this.get(id,0) )	return id;
		id--;
	}
	-1;
}
public bool dbdelvar(int irow, string svar)	{ this.dbdelvarn(irow,svar,1);}
public bool dbdelvarn(int irow, string svar, int n)	{
	int id = this.dbfindinrow(irow,svar);
	if( id>=0 )	{
		this.removen(irow,id,n);
		return true;
	}
	false;
}
public int dbfindinrow(int irow, string svar)	{
	if( this.rowinrange(irow) )	{
		for( int i=0; i<this.getcolsno(irow); i++)	if( this.get(irow,i)==svar )	return i;
	}
	-1;
}
public int dbfindbycol(int icol, string svar)	{
	for( int i=0; i<this.getrowsno(); i++)	{if( this.get(i,icol)==svar ) return i;}
	-1;
}
public bool dbrowcontains(int irow, string svar)	{	this.dbfindinrow(irow,svar)!=-1;	}
public string dbfirst(int id)		{	this.get(id,0);	}	
public bool cmpless(int i1, int i2)	{	i1<i2;	}
public bool cmpabove(int i1, int i2)	{	i1>i2;	}
public bool dbfirstless(int i1, int i2)	{	.get(i1,0) < .get(i2,0);	}
public dbsort(string scomparefun)	{	.insertsort( .getrowsno, "dbfirst",scomparefun, "swap" ); }
public dbsetall(string svar)	{	for( @i=0; i<.getrowsno; i++)	for(@j=0; j<.getcolsno(i); j++)	.set(i,j,svar);	}
public dbeach_row(string sfun)	{	for( @i=0; i<.getrowsno; i++) .<sfun>(i);	}
public dbeq(string sdb)	{
	if( .getrowsno != <sdb>.getrowsno ) return false;
	int ile, int j;
	for( int i=0; i<.getrowsno; i++)	{
		ile = .getcolsno(i);
		if( ile!=<sdb>.getcolsno(i) ) return false;
		for( j=0; j<ile; j++)	{
			if( .get(i,j)!=<sdb>.get(i,j) ) return false;
		}
	}
	true;
}
/************** int ************************/
public int randdiff(int zakres, int odjakiej)	{
	if( zakres<=1 )		return -1;
	for( int i1 = zakres.rand; i1==odjakiej; i1= zakres.rand )	{}
	i1;
}
public int bin_to_i	{
	string s = .get;
	int idwa = 1;
	int iout = 0;
	for( int i=s.length-1; i>=0; i--)	{
		if( s.getb(i,1)=="1") iout+=idwa;
		idwa*=2;
	}
	iout;
}


//---------------- sygnaly --------------

public std_anfadeout_finish	{
	.unlink_internal_filter;
	.hide;
}

//------------- funkcje ------------

public string internal_filter	{
	@s = "__ft" + this;
	if( !.hasvar(s) ) {
		new filter <s>;
		<s>.buildfullname;
	}
	<s>.link(this);
	<s>.getfullname;
}

public string internal_timer	{
	@s = "__tim" + this;
	if( !.hasvar(s) ) {
		new timer <s>;
		<s>.setcycle(1);
		<s>.vars2(A, "sfunc", null, "sfilter", null, "rstep", 0.0, "ropacity", 0.0, "rstepzoom", 0.0, "rzoom", 0.0,
			"rzoomsmall", 0.0, "rzoombig", 1.0, "ralfamin", 0.0, "ralfamax", 255.0);
	}
	s;
}
public unlink_internal_filter	{
	@s = .internal_timer;
	if( .hasvar(s) ) <s>.stop(false);
	<.internal_filter>.unlink;
}
public anhideonsetframe	{
	.var("bhideonsf");
	if( !.hasvar("bopacityfr") )	{
		.addmethod("onsetframe", "_stdanhide" );
	}
}

public anopacityframe	{
	.var("bopacityfr");
	.addmethod("onsetframe", func {
		@s = .framename;
		if( s.getb(0,2)=="op" )	{
			<.internal_filter>.setopacity( s.strsubb(2)->to_r/100.0 * 255 );
		} else <.internal_filter>.setopacity(255);
		if( .hasvar("bhideonsf") )
			.hide;
		} );
}

public anrandfrplay	{
	.var("brandfrplay");
	.addmethod("onendframe", "ansetrandfr");
}

public ansetopacity(int iop)	{
	<.internal_filter>.setopacity(iop);
}
public anzoom(real fzoom)	{
	@s = .internal_filter;
	<s>.setpivottype(1);
	<s>.setsmooth(1);
	<s>.setzoom(fzoom);
}
public anzoomin(int ms, string sfun)	{
	.ansetopacity(255);
	.anzoomfadeinout(ms,1,0,sfun);
}
public anzoomout(int ms, string sfun)	{
	.ansetopacity(255);
	.anzoomfadeinout(ms,-1,0,sfun);
}
public anfadein(int ms, string sfun)	{
	.anzoomfadeinout(ms,0,1,sfun);
}
public anzoomfadein(int ms, string sfun)	{
	.anzoomfadeinout(ms,1,1,sfun);
}
public anzoomfadeout(int ms, string sfun)	{
	.anzoomfadeinout(ms,-1,-1,sfun);
}
public anfadeout(int ms, string sfun)	{
	.anzoomfadeinout(ms,0,-1,sfun);
}
public anzoomfadeinout(int ms, int zoomdir, int dir, string sfun)	{
	._anzoomfadeinout(ms, zoomdir, dir, sfun, 0,255, 0.0,1.0 );
}
public _anzoomfadeinout(int ms, int zoomdir, int dir, string sfun, real alfamin, real alfamax, real rzoomsmall, real rzoombig)	{
	if( dir>0 ) dir=1;
	else if (dir<0) dir=-1;
	
	if(zoomdir>0 ) zoomdir=1;
	else if(zoomdir<0) zoomdir=-1;
	
	.show;
	@sf = .internal_filter;
	@st = .internal_timer;
	<sf>.link(this);
	<st>.sfunc = (sfun);
	
	ms = ms / engine.getloopdelay;
	if( ms<=0 )	{
		if( dir>0 )	.ansetopacity(alfamax);
		else	.ansetopacity(alfamin);
		if( sfun!=null ) .<sfun>;
		return;
	}
	
	real step = (alfamax-alfamin)/ms;
	if( step<1.0 ) step = 1.0;
	real stepzoom = (rzoombig - rzoomsmall)/ms;
	//<st>.vars2(A, "sfilter", sf, "rstep", step * dir, "ropacity", 0.0, "rstepzoom", stepzoom*zoomdir, "rzoom", 0.0);
	<st>.sfilter = (sf);
	<st>.rstep = ( step * dir );
	<st>.ropacity = ( alfamin );
	<st>.rstepzoom = ( stepzoom * zoomdir );
	<st>.rzoom = ( 0.0 );
	<st>.rzoomsmall = (rzoomsmall);
	<st>.rzoombig = (rzoombig);
	<st>.ralfamin = (alfamin);
	<st>.ralfamax = (alfamax);
	if( dir )	{
		<sf>.setopacity( dir==1 ? alfamin : alfamax );
		<st>.ropacity = ( <sf>.getopacity );
	}
	if( zoomdir )	{
		<sf>.setzoom( zoomdir==1 ? rzoomsmall+stepzoom : rzoombig );
		<st>.rzoom = ( <sf>.getzoomx );
	}
	<st>.addmethod("onfinish", func {
		ropacity += rstep;
		rzoom += rstepzoom;
		if( (ropacity>=ralfamax && rstep>0.0) || (rzoom>=rzoombig && rstepzoom>0.0) )	{
			if( rstepzoom>0.0 ) {
				<sfilter>.setzoom( rzoombig );
			}
			if( rstep>0.0 )	<sfilter>.setopacity(ralfamax);
			if( sfunc!=null ) <.getbuildername>.<sfunc>;
		} else if ( (ropacity<=ralfamin && rstep<0.0) || (rstepzoom<0.0 && rzoom < rzoomsmall-rstepzoom) )	{
			/*if( rstepzoom<0.0 ) <.getbuildername>.hide;
			if( rstep<0.0 )	<sfilter>.setopacity(0);*/
			if( (rstepzoom<0.0 && rzoomsmall==0.0) || (rstep<0.0 && ropacity<=ralfamin) )	{
				<sfilter>.unlink;
				<.getbuildername>.hide;
			}	// gdy rzoomsmall != 0, zostaw widoczny
			if( sfunc!=null ) <.getbuildername>.<sfunc>;
		} else {
			if( rstep !=0.0 )
				<sfilter>.setopacity(ropacity);
			if( rstepzoom!=0.0 )
				<sfilter>.setzoom(rzoom);
			.play;
		}
		} );
	<st>.play;
}

public imgbuildfromlist	{
	new vector __vtmp;
	__vtmp.type("string");
	__vtmp.vecloadargs;
	.imgbuildfromvec("__vtmp");
	delete __vtmp;
}
public imgbuildfromvec(string svec)	{
	if( <svec>.empty ) return;
	string s = <svec>.first;
	int x = <s>.getpx;
	int y = <s>.getpy;
	int ex = <s>.getex;
	int ey = <s>.getey;
	for( int i=1; i < <svec>.size; i++ )	{
		s = <svec>.get(i);
		if( x > <s>.getpx ) x = <s>.getpx;
		if( y > <s>.getpy ) y = <s>.getpy;
		if( ex < <s>.getex ) ex = <s>.getex;
		if( ey < <s>.getey ) ey = <s>.getey;
	}
	.create( ex-x, ey-y, .transparent );
	.setpos(x, y);
	for( i=0; i< <svec>.size; i++)	{
		.blit(<svec>.get(i));
	}
}

public anfadeoutloop	{	.anfadeout(ifadedelay,"anfadeinloop");	}
public anfadeinloop	{	.anfadein(ifadedelay,"anfadeoutloop");	}
public imgstopoverlay	{
	@s = .imgetoverlay;
	<s>.unlink_internal_filter;
	<s>.hide;
}
public imgetoverlay	{	"imgoverlay_"+this;	}
public imgstartoverlay	{	<.imgetoverlay>.anfadeinloop;	}
public _imgbuildoverlay(string sover, int r, int g, int b, int a, int delay)	{
	if( !<GAME>.hasvar(sover) )
		<GAME>.varnew("img", sover);
	//<sover>.clone(this);
	/*<sover>.create( .getw, .geth, .transparent );
	<sover>.setpos( .getpx, .getpy );
	<sover>.blit(this);
	<sover>.setz( .getz );*/
	<sover>.imgclone(this);
	<sover>.paint(r,g,b,a,0);
	if( delay>0 && !<sover>.hasvar("ifadedelay") )	{
		<sover>.var2("ifadedelay", delay);
		<sover>.anfadeinloop;
	}
}
public imgbuildoverlay(int r, int g, int b, int a, int delay)	{	._imgbuildoverlay(.imgetoverlay,r,g,b,a,delay);	}
public imgsetoverlay(int r, int g, int b, int a)	{	.imgbuildoverlay(r,g,b,a,0);	}

public imgclonesize(string simg)	{
	.create( <simg>.getw, <simg>.geth, .transparent );
	.setpos( <simg>.getpx, <simg>.getpy );
}
public imgclonesizecol(string simg, int r, int g, int b, int a)	{
	.create( <simg>.getw, <simg>.geth, r,g,b,a );
	.setpos( <simg>.getpx, <simg>.getpy );
}
public imgclone(string simg)	{
	.imgclonesize(simg);
	.blit(simg);
	.setz( <simg>.getz );
	<simg>.isvisible ? .show : .hide;
}


/***************************************************************************/
class classgamepause	{
	init()	{
		new button butpause;
		butpause.setrect( 0, 0, iResX, iResY );
		butpause.addmethod("onclick", "resume");
		butpause.disable();
	}
	resume()	{
		butpause.disable();
		gameapi.resume();
	}
	pause()	{
		gameapi.pause();
		butpause.enable();
		butpause.resume();
	}
}

class TicksCounter	{
	init()	{
		new int istart;
	}
	start()	{	istart = engine.getticks();	}
	stop()	{	istart = engine.getticks() - istart;	}
	get()		{	return istart;	}
	int stopget()	{	this.stop();	return this.get();	}
	print(string s)	{	engine.print(s+" delay: "+this.stopget()+" ms");	}
	put()	{	.print("");	}
}


class ObjController	{
	init()	{
		<GAME>.addgmobj(this);
	}
	removefromgame	{	<GAME>.removegmobj(this); }
}
class LObjController : ObjController, classlocker	{
	init()	{
		ObjController::init;
		classlocker::init;
	}
}

class gmbankvec : gmobjvec	{
	init	{
		gmobjvec::init;
		.var2("iid", -1);
	}
	startrand	{	if(.size>0) iid=.size->rand;	}
	play()	{
		this.stop(false);
		int ile = this.size();
		if( ile==0 ) return;
		iid = (iid+1)%ile;
		<this.get(iid)>.play();
	}
	onfinish()	{}
	stop(bool bfin)	{
		if( this.isplaying() )	{
			<this.getplay()>.stop(bfin);
			if( bfin ) this.onfinish();
		}
	}
	isplaying	{	( iid>=0 )	? <.getplay>.isplaying : false;	}
	getplay()	{	return this.get(iid);	}
}

class ClassGameController	{
	init	{
		new gmobjvec __grobj;
		new string GAME = this;
	}
	public addgmobj(string s)	{	__grobj.add(s);		}
	public removegmobj(string s)	{	__grobj.remove(s);	}
	public isgmobj(string s)	{	__grobj.contains(s);	}
	public deletegmobj(string s)	{
		if( .hasvar(s) )	{
			.removegmobj(s);
			delete <s>;
		}
	}
	setpriority(string sob1, string sob2)	{
		int id1 = __grobj.find(id1);
		int id2 = __grobj.find(id2);
		if( id1>=0 && id2>=0 && id1>id2 )	{
			__grobj.swap(id1,id2);
		}
	}
	mousemove	{
		__grobj.eval("onmousemove");
		.mouse_move;
	}
	mouselclick	{
		__grobj.eval("onmouselclick");
		.mouse_lclick;
	}
	mouserclick	{
		__grobj.eval("onmouserclick");
		.mouse_rclick;
	}
	mouselrel	{
		__grobj.eval("onmouselrel");
		.mouse_lrel;
	}
}

class GameController : ClassGameController, classlocker {
	init(string ssndbase)	{
		ClassGameController::init;
		classlocker::init();
		//new gmobjvec __grobj;
		
		new db _dbsnd;
		_dbsnd.setseparator("|");
		new string _sndbase = ssndbase;
		
		new timer __dblclick;
		__dblclick.delay(250);
		__dblclick.settick(1);
		
		new int _itimersnddelay = 50;
		new bool _b_ismoddbg = engine.varexist("moddbg");
	}
	public game_exit()	{
		//.stdexportsnd;
	}
	/*************************************************/
	public setsndbase(string sb)	{	_sndbase=sb;	}
	public say(string styp, string stxt)	{	this.sayf(styp,stxt,null);	}
	public sayf(string styp, string stxt, string sfun)	{
		string s = this.getsndtxt(stxt);
		<s>.setstartstopflag(false,true);
		this.cplayf(styp, s, sfun);
	}
	public string getsndtxt(string stxt)	{
		string ssnd = "snd" + _sndbase + _dbsnd.getrowsno();
		this.addsnd( ssnd, stxt );
		ssnd;
	}
	_sndtimerstart()	{
		int id = _dbsnd.dbfindbycol(1,this.getname());
		if( id>=0 )	engine.print( _dbsnd.get( id,2) );
		else 		engine.print( this.getname() + " not in _dbsnd");
		engine.print("");
	}
	public addsndf(string ssnd, string stxt, string sfun)	{
		this.addsnd(ssnd,stxt);
		if( sfun!=null )	{
			if( ssnd.getb(0,1)==":" ) ssnd = ssnd.strsubb(1);
			<ssnd>.addmethod("onfinish", sfun );
		}
	}
	public asf(string ssnd, string stxt)	{	this.addsndff( "snd" + ssnd, stxt, "end" + ssnd);	}
	public addsndff(string ssnd, string stxt, string sfun)	{
		this.addsndf(ssnd,stxt,sfun);
		//<ssnd>.setstartstopflag(false,true);
	}
	gmconsnd(string ssnd, string swav)	{
		new snd <ssnd>;
		<ssnd>.setstartstopflag(false,true);
		<ssnd>.load( .getsndpath+swav );
		if( igmsubtitle )	{
			subtitle.register(ssnd, .getsndpath+swav);
		}
	}
	public addsnd(string ssnd, string stxt)	{
		int id = _dbsnd.addrow()-1;
		string swav;
		if( ssnd.getb(0,1)==":" )	{
			ssnd = ssnd.strsubb(1);
			swav = _sndbase + "_" + ssnd + id;
		} else swav = _sndbase + id;
		if( engine.fileexist( .getsndpath + swav + ".ogg" ) )
			swav += ".ogg";
		else swav += ".wav";
		string sg = gameapi.getgamename();
		if( igmsoundson && engine.fileexist( this.getsndpath() + swav ) )	{
			<sg>.gmconsnd( ssnd, swav );
		} else {
			<sg>.newtimer( ssnd, stxt.length()*_itimersnddelay, 1);
			<ssnd>.addmethod("onstart", "_sndtimerstart");
			<ssnd>.addmethod("setstartstopflag", func { (bool b1, bool b2) ; });
		}
		_dbsnd.add(id, swav);
		_dbsnd.add(id, ssnd);
		_dbsnd.add(id, stxt);
	}
	public addbank(string sbank, string sfunc)	{
		new gmbankvec <sbank>;
		string s = _;
		string s2;
		while( s!=A )	{
			s2 = this.getsndtxt(s);
			<sbank>.addbegin( s2 );
			if( sfunc!=null ) <s2>.addmethod("onfinish", sfunc );
			s = _;
		}
	}
	public exportbank(string sbase)	{
		if( igmenablesave ) {
			new db <"__db"+sbase> (sbase)	{ (@sbase)
				.dbbuild(1);
				.setseparator("|");
				.dbeach_row( func { (@id)
					@s = this->strsubbs("__db");
					.addbegin(id, "snd"+s+id);
					.addbegin(id, s+id+".wav");
					} );
				if( igmdebug )
					.save("exports/"+sbase+".dlg");
			};
			delete <"__db"+sbase>;
		}
	}
	public importbank(string sbank, string sbase, string sfun)	{
		new gmbankvec <sbank>;
		.importgroupto(sbase, sfun, null, sbank);
	}
	public exportsnd(string sfile)	{	if( igmdebug ) _dbsnd.save(sfile);	}
	public stdexportsnd()	{	this.exportsnd( "exports/" + _sndbase + ".dlg" );	}
	public sounds=()	{	.buildsnds;	}
	public sounds_from(string sbase)	{
		new db __tmpdb;
		@stmpbase = _sndbase;
		.setsndbase(sbase);
		__tmpdb.load("exports/"+sbase+".dlg");
		_dbsnd.free;
		@s = _;
		int id, string sf;
		while( A!=s )	{
			@s1 = _;
			id = __tmpdb.dbfindbycol(1, s1);
			if( id>=0 )	{
				sf = .getsndpath + __tmpdb.get(id,0);
				if( engine.fileexist( sf ) )	{
					<GAME>.gmconsnd( s1, __tmpdb.get(id,0) );
					<s1>.addmethod("onfinish", s );
				} else	.addsndf( s1, __tmpdb.get(id,1), s );
			}
			@s = _;
		}
		_dbsnd.free;
		delete __tmpdb;
		.setsndbase(stmpbase);
	}
	public buildsnds()	{
		_dbsnd.free;
		new db __dbsnd;
		__dbsnd.dbbuild(3);
		.buildfromdb("__dbsnd");
		delete __dbsnd; 
	}
	public buildfromdb(string sdb)	{
		for( int i=0; i< <sdb>.getrowsno; i++)	{
			.addsndf( <sdb>.get(i,0), <sdb>.get(i,1), <sdb>.get(i,2) );
		}
		.stdexportsnd;
	}
	public importsnd(string sbase, string sfun)	{	this.importgroup(sbase, sfun, null );	}
	public importgroup(string sbase, string sfun, string sgr)	{	.importgroupto(sbase,sfun,sgr,null);	}
	public importgroupto(string sbase, string sfun, string sgr, string sgrto)	{
		new db __tmpdb;
		@stmpbase = _sndbase;
		.setsndbase(sbase);
		__tmpdb.load("exports/"+sbase+".dlg");
		_dbsnd.free();
		string s;
		for( int i=0; i<__tmpdb.getrowsno(); i++)	{
			s = __tmpdb.get(i,1);
			if( sgr==null || <sgr>.contains(s) )	{
				.addsndf( s, __tmpdb.get(i,2), sfun );
				if( sgrto!=null ) <sgrto>.add(s);
			}
		}
		_dbsnd.free();
		__tmpdb.free();
		delete __tmpdb;
		.setsndbase(stmpbase);
	}
	public freesnd()	{	_dbsnd.free();	}
	/*************************************************/
	/*public addgmobj(string s)		{	__grobj.add(s);		}
	public removegmobj(string s)	{	__grobj.remove(s);	}
	public isgmobj(string s)	{	__grobj.contains(s);	}
	public deletegmobj(string s)	{
		if( .hasvar(s) )	{
			.removegmobj(s);
			delete <s>;
		}
	}*/
	public lockall()		{
		__grobj.eval("lock");
		this.lock();	
	}
	public unlockall()		{
		__grobj.eval("unlock");
		this.unlock();
	}
	public gmunlockall	{	<GAME>.unlockall;	}
	public gmlockall	{	<GAME>.lockall;	}
	public lock=(bool b)	{	b ? .gmlockall : .gmunlockall; }
	gmcontrol_mousemove	{
		__grobj.eval("onmousemove");
		this.mouse_move();
		if( _b_ismoddbg ) moddbg.msmove();
	}
	gmcontrol_mouselclick	{
		__grobj.eval("onmouselclick");
		this.mouse_lclick();
		if( __dblclick.isplaying )	.mouse_dblclick;
		else __dblclick.play;
		if( _b_ismoddbg ) moddbg.mslclick();
	}
	is_dblclick	{	__dblclick.isplaying;	}
	reset_dblclick	{	__dblclick.play;	}
	gmcontrol_mouserclick()	{
		__grobj.eval("onmouserclick");
		this.mouse_rclick();
	}
	gmcontrol_mouselrel()	{
		__grobj.eval("onmouselrel");
		this.mouse_lrel();
		if( _b_ismoddbg ) moddbg.mslrel();
	}
	gmcontrol_mouserrel()	{
		__grobj.eval("onmouserrel");
		this.mouse_rrel();
	}
	gmcontrol_keydown()	{
		__grobj.eval("onkeydown");
		this.key_down();
		if( _b_ismoddbg ) moddbg.dbkeydown;
	}
	mousemove	{	.gmcontrol_mousemove;	}
	mouselclick	{	.gmcontrol_mouselclick;	}
	mouselrel	{	.gmcontrol_mouselrel;	}
	mouserclick	{	.gmcontrol_mouserclick;	}
	mouserrel	{	.gmcontrol_mouserrel;	}
	keydown		{	.gmcontrol_keydown;	}
}

/* classadv : klasa do przygodowek	*/

new int PrzygodaNumer = 1;
new int PrzygodaMode = .readcfg("PrzygodaMode:", 0);
new bool AdventureGame;

new classfullsave clsave("save.txt");
new string sgmlastscene = null;
new string sgmglobpath = null;	// dla gier, ktore sa w innym katalogu niz ich nazwa
new string sgmgame = null;		// jezeli .adv inaczej sie nazywa niz game

new CutScene ccs(0, 0, igmappw, igmapph);
ccs.setz(2000);

class classadv : classgame, GameController {
	init(string s)	{
		engine.setloopdelay(igmdelay);
		classgame::init();
		.setwavpath(SNDPATH);
		GameController::init(s);
		
		new string _s_game_path;
		new bool bmslock = false;
		
		new bool _b_ismodadvglob = engine.varexist("modadvglob");
		
		new Music music;
		new Button butgame;
		
		igmstate = 0;
		sgmstate = "state_init";
	}
	butenable	{	butgame.addbut(this);		}
	butdisable	{	butgame.removebut(this);	}
	butrefresh	{	butgame.onmousemove;	}
	//--------------- zgodnosc advcontroller z bangui
	advmslock			{	bmslock=true;	}
	advmsunlock			{	bmslock=false;	}
	advgetlock			{	bmslock;	}
	advmssetlock(bool block)	{	block ? .advmslock : .advmsunlock;	}
	//-------------------
	switch_path(string spath)	{
		_s_game_path = <gameapi.getgamename>.getgraphpath;
		<gameapi.getgamename>.setgraphpath(spath);
	}
	restore_path	{	<gameapi.getgamename>.setgraphpath(_s_game_path);	}
	/**************************************************************************/
	newclpathf(string spt, string san, string sfile, int x, int y, real rstep, int ityp)	{
		new classpathf <spt>;
		<spt>.build(san, this.getgraphpath() + sfile, x, y, rstep, ityp);
	}
	newclpathfcopy(string spt, string san, string sptf, real rstep)	{
		new classpathf <spt>;
		<spt>.buildfrom( san, sptf, rstep );
	}
	newpathf(string spathf, string sfile, int x, int y)	{
		new path <spathf>;
		<spathf>.build( this.getgraphpath() +sfile, x, y, 2.0, 1 );
	}
	/**************************************************************************/
	newclbut(string sbut, string sfile, int z, string smouse)	{
		new classbutton <sbut>;
		<sbut>.build( this.getgraphpath() + sfile, z, smouse );
	}
	newclmask(string sm, string sfile, string smouse)	{
		new classmask <sm>;
		<sm>.buildmask( this.getgraphpath() + sfile, smouse );
	}
	newclmaskfunc(string sm, string sfile, string smouse, string sfunc)	{
		new classmask <sm>;
		<sm>.buildmaskfunc( this.getgraphpath() + sfile, smouse, sfunc );
	}
	//---------------------- SAVE ----------------------
	advsaveonstart	{
		clsave.set("GAME_game", gameapi.getgamename);
		clsave.set("GAME_sgmgame", sgmgame);
		clsave.set("GAME_sgmglobpath", sgmglobpath);
		clsave.set("GAME_sgmlastscene", sgmlastscene);
		clsave.set("GAME_ccs", ccs.isvisible);
		.advautosave;
	}
	advautosave	{
		clsave.save("autosave.txt");
		if( _b_ismodadvglob )
			modadvglob.savepck("autosave");
	}
	advautoload	{	._advload("autosave");	}
	advcacheload	{	._advload("cache");	}
	advcachesave	{	._advsave("cache");	}
	_advload(string s)	{
		modadvglob.delheros;
		modadvglob.loadpck(s);
		
		clsave.load(s+".txt");
		sgmgame = clsave.get("GAME_sgmgame");
		sgmglobpath = clsave.get("GAME_sgmglobpath");
		sgmlastscene = clsave.get("GAME_sgmlastscene");
		if( clsave.bis("GAME_ccs") ) ccs.show; else ccs.hide;
		gameapi.play( clsave.get("GAME_game") );
	}
	_advsave(string s)	{
		if( igmenablesave )	{
			new classfullsave _saver(s + ".txt");
			_saver.load("autosave.txt");
			_saver.stdsave;
			delete _saver;
			new vector _vcsave;	_vcsave.type("string");
			new vector _vcsv2;	_vcsv2.type("string");
			if( .saveexist("grpck_autosave.txt") )
				_vcsave.vecload("grpck_autosave.txt");
			_vcsave.vecsave("grpck_"+s+".txt");
			@s2;
			for( int i=0; i<_vcsave.size; i++)	{
				s2 = _vcsave.get(i);
				_vcsv2.vecload(s2 + "autosave_name.txt" );
				_vcsv2.vecsave(s2 + s + "_name.txt" );
				_vcsv2.vecload(s2 + "autosave_file.txt" );
				_vcsv2.vecsave(s2 + s + "_file.txt" );
			}
			delete _vcsave;
			delete _vcsv2;
	// 		arPocket.save( "saves/" + this+sfilepref + "_name.txt" );
	// 		arPocketFile.save( "saves/" + this+sfilepref + "_file.txt" );
		}
	}
	getsavename	{	"save"+PrzygodaNumer;	}
	advload_game	{	._advload(.getsavename);	}
	advsave_game	{	._advsave(.getsavename);	}
	//-------------- STAN GRY --------------
	advstdstate		{	sgmstate=="state_std";	}
	advsetstdstate		{	.advsetstate("state_std");	}
	advsetstate(string s)	{	sgmstate = s;	}
	advisstate(string s)	{	sgmstate==s;	}
	//-------------- przejscia -----------
	stdexitdefadv(string spath, string sgame)	{
		clsave.set("GAME_snextgame", sgame);
		clsave.set("GAME_snextgamepath", spath);
		clsave.set("GAME_snextgametype", "-def");
		.stdexitgame;
	}
	stdexitadvadv(string spath, string sgame)	{
		clsave.set("GAME_snextgame", sgame);
		clsave.set("GAME_snextgamepath", spath);
		clsave.set("GAME_snextgametype", "-adv");
		.stdexitgame;
	}
	stdexit(string sgame)	{
		clsave.set("GAME_snextgame", sgame);
		clsave.set("GAME_snextgamepath", null);
		clsave.set("GAME_snextgametype", "-mg");
		.stdexitgame;
	}
	stdexitgame	{
		if( sgmstate!="state_end" ) 	{
			if( clsave.bis("GAME_fadeout_music") )	{
				clsave.set("GAME_fadeout_music",false);
				music.fadeout(1000);
			}
			//ccs.buildfromscreen;
			sgmstate = "state_end";
			ccs.close( func {
				string sNextGame = clsave.get("GAME_snextgame");
				match(clsave.get("GAME_snextgametype"))	{
					"-def" => .gotoadv(clsave.get("GAME_snextgamepath"), sNextGame);
					"-adv" => .gotoadv2(clsave.get("GAME_snextgamepath"), sNextGame);
					? => gameapi.play(sNextGame);
				}
				} );
		}
	}
	gotoadv(string spath, string sgame)	{
		sgmlastscene = gameapi.getgamename;
		sgmglobpath = spath;
		sgmgame = sgame;
		gameapi.play("gameadvdef");
	}
	gotoadv2(string spath, string sgame)	{
		sgmlastscene = gameapi.getgamename;
		sgmglobpath = spath;
		sgmgame = null;
		gameapi.play(sgame);
	}
	//-------------------
	onmusicfin      {	music.play;	}
	//virtual game_exit	{}
	exit	{
		.game_exit;
		if( igmsubtitle )	{
			subtitle.reset;
		}
		if( _b_ismodadvglob )
			modadvglob.onexit;
	}
	appdeactivate   {	gameapi.pause;	}
	appactivate	{	gameapi.resume;	}
}


/***************************************************************************/

public winsave(string sval)	{
	if( igmenablesave )	{
		new db _db_win;
		_db_win.load("output.db");
		@id = _db_win.addrow-1;
		_db_win.add(id, sval);
		_db_win.save("output.db");
		delete _db_win;
	}
}

/***************************************************************************/

public saveexist(string sfile)	{	engine.fileexist( .getsavepath + sfile );	}

public vecsave(string sfile)	{	if( igmenablesave ) .save(.getsavepath + sfile);	}

public vecload(string sfile)	{	.load( .getsavepath + sfile );	}

class classfullsave	{
	init(string sfile)	{
		new db dbsav;
		dbsav.setseparator("|");
		new string sstdfile;
		.setfile(sfile);
		//.var2("saveonset",0);
		new bool saveonset = 0;
	}
	public save(string sfile)	{
		if( igmenablesave )
			dbsav.save( .getsavepath + sfile );
	}
	
	_load(string sfile)	{
		if( engine.fileexist(sfile) )	{
			dbsav.free;
			dbsav.load(sfile);
		}
	}
	public load(string sfile)	{	._load( .getsavepath + sfile );	}
	public print()	{	dbsav.print();	}
	public printvar(string svar)	{	engine.print(this + ".var: "+svar+" = " +.get(svar));	}
	public setfile(string sf)	{	sstdfile = sf;	}
	public stdload()	{	this.load(sstdfile);	}
	public stdsave()	{	this.save(sstdfile); }
	public free()	{	dbsav.free();	}
	public set(string sname, string svar)	{
		int id = dbsav.findbyrow(sname);
		if( id>=0 )	{
			dbsav.set(id,1,svar);
		} else {
			id = dbsav.addrow()-1;
			dbsav.add( id, sname );
			dbsav.add( id, svar );
		}
		if( saveonset )
			this.stdsave();
	}
	public bset(string sname)	{	this.set(sname,true);	}
	public string get(string sname)	{
		int id = dbsav.findbyrow(sname);
		id>=0?dbsav.get(id,1):null;
	}
	public bool is(string sname, string svar)	{
		int i = dbsav.findbyrow(sname);
  		i>=0?dbsav.get(i,1)==svar:false;
	}
	//public bool bis(string sname)	{	return this.is(sname,true);	}
	public bool bis(string sname)	{
		int i = dbsav.findbyrow(sname);
		i>=0?dbsav.get(i,1)!=false:false;
	}
	public bool sbis(string sname)	{
		if( sname.getb(0,1)=="!" ) !.bis(sname.strsubb(1));
		else .bis(sname);
	}
	public bool bislist(string s)	{
		new vector vtmp;
		vtmp.type("string");
		vtmp.vecbuildfromstring(s," ");
		bool b = false;
		if( vtmp.size )	{
			b = clsave.sbis(vtmp.first);
			int i = 1;
			while( i<vtmp.size )	{
				match(vtmp.get(i))	{
					"&" => {
						b = b && clsave.sbis(vtmp.get(i+1));
						i+=2;
					}
					"|" => {
						b = b || clsave.sbis(vtmp.get(i+1));
						i+=2;
					}
					? => i++;
				}
			}
		}
		delete vtmp;
		b;
	}
	public bool bisand2(string spref, int iend)	{	.bisand(spref,1,iend,"");	}
	public bool bisand(string spref, int istart, int iend, string ssuf)	{
		bool b = true;
		while( istart <= iend )	{
			b = b && clsave.bis( spref + istart + ssuf );
			istart++;
		}
		b;
	}
	public bool has(string sname)	{ dbsav.findbyrow(sname) >= 0; }
	public bool bgo(string sname)	{
		if( !.bis(sname) )	{
			.bset(sname);
			true;
		} else false;
	}
	public saveonset=(bool b)	{	saveonset=b;	}
	public remove(string sname)	{
		int i = dbsav.findbyrow(sname);
		if( i>=0 ) {
			dbsav.removerow(i);
			if( saveonset )
				this.stdsave();
		}
	}
}



class StringChecker	{
	init()	{}
	/*bool isdigit(string s)	{	s.to_i == s;	}
	int getint(string s)	{	return s.to_i();	}
	real getreal(string s)	{	return s.to_r();	}	
	bool isreal(string s)	{	return this.isdigit(s)&&s.contains(".");	}
	bool isstring(string s) {	return s.getb(0,1)=="\"";	}
	string getstring(string s)	{	return s.strsubb(1);	}*/
	bool isdigit(string s)		{	s.to_i()!=0 || s.getb(0,1)=="0";	}
	int getint(string s)		{	s.to_i();	}
	real getreal(string s)		{	s.to_r();	}	
	bool isreal(string s)		{	this.isdigit(s) && s.contains(".");	}
	bool isstring(string s) 	{	s.getb(0,1)=="\"";	}
	string getstring(string s)	{	s.strsubb(1);	}
}

class Script	{
	init(string sfile)	{
		new db __dbcode;
		new string __sdb;
		new int __irow;
		new int __icol;
		new string __sreads;
		
		new vector __vec;
		__vec.type("string");
		
		new string __sarg;
		new int __iarg;
		new real __rarg;
		
		new StringChecker __csc;
		new map2 __mp("int");		// odnosniki do funkcji
		for( int i=0; i<10; i++)	new string <"ARG"+i>;
		
		this.load(sfile);
	}
	public ARG=(int id, string s)	{ <"ARG"+id> = s; }
	public ARG(int id)	{ ["ARG"+id]; }
	public load(string sfile)	{
		if( sfile==null )	return;
		if( sfile.contains(".") )	{		// znaczy sie plik jest
			__sdb = "__dbcode";
			__dbcode.loadbeh(sfile);
		} else {
			__sdb = sfile;		// odwolanie przez inna baze
		}
		__mp.free();
		for( int i=0; i < <__sdb>.getrowsno(); i++)	{
			if( <__sdb>.get(i,0)=="func" )
				__mp.add( <__sdb>.get(i,1), i );
		}
		this.call("init");
	}
	public def get(string svar)	{	[svar];	}
	bool isvar(string s)		{	s.getb(0,1)=="$";	}
	string getvar(string s)	{
		s = s.strsubb(1);
		if( !engine.varexist(s) )
			new def <s>;
		s;
	}
	bool isfunc(string s)	{	(s.contains(".") && !__csc.isreal(s)) || (s.contains("::"));	}
	getfunc(string sfun)	{
		__vec.free();
		if( sfun.contains(".") )	{
			__vec.add( sfun.strgetto(".") );
			__vec.add( sfun.strgetfrom(".") );
		} else {
			__vec.add( sfun.strgetto("::") );
			__vec.add( sfun.strgetfrom("::") );
		}
	}
	string _get()	{
		__icol++;
		<__sdb>.get(__irow,__icol-1);
	}
	bool isnext()	{
		if( __icol < <__sdb>.getcolsno(__irow) )	{
			__sreads=<__sdb>.get(__irow,__icol);
			true;
		} else
			false;
	}
	perror(bool expr, string sout)	{
		if( expr )
			engine.print("error: " + sout);
	}
	interpcall(string scal)	{
		this.getfunc(scal);
		string sob = __vec.get(0);
		if( sob.getb(0,1)=="*" ) sob=[sob.strsubb(1)];
		string sfun = __vec.get(1);
		if( sfun.getb(0,1)=="*" ) sob=[sfun.strsubb(1)];
		__vec.free();
		__icol++;	// omin '('
		string s = this._get();
		while( s!=")" )	{
			this.getexpr(s);	// odloz na stos argumenty
			s = this._get();
		}
		if( scal.contains("::") )	{
			<sob>::<sfun>;
		} else {
			if( sob=="this" ) sob=null;
			this.callfun(sob,sfun);
		}
	}
	string getvname(string s)	{
		if( this.isvar(s) )	{
			s=this.getvar(s);
		} else if(__csc.isreal(s))	{
			__rarg = s.to_r();
			s = "__rarg";
		} else if( __csc.isdigit(s) ) {
			__iarg = s;
			s = "__iarg";
		} else if( __csc.isstring(s) ) {
			__sarg = __csc.getstring(s);
			s = "__sarg";
		}
		s;
	}
	bool isscriptfun(string s)	{	s.contains("->");	}
	string getscriptfun(string s)	{	s.strsubb(2);	}
	getexpr(string sexpr)	{
		if( __csc.isstring(sexpr) )	{
			<this.getvname(sexpr)>.get();
		} else if( this.isfunc(sexpr) )	{
			this.interpcall(sexpr);
		} else if(this.isscriptfun(sexpr))	{
			int r = __irow;
			int c = __icol;
			this.call( this.getscriptfun(sexpr) );
			__irow = r;
			__icol = c;
		} else {
			<this.getvname(sexpr)>.get();
		}
	}
	bool cmp()	{
		bool bodp=false;
		def d0 = this.getexpr(this._get());
		string s2 = this._get();		// typ porownania
		def d1 = this.getexpr( this._get() );
		match(s2)	{
			"==" =>	{	bodp = d0 == d1;	}
			"!=" =>	{	bodp = d0 != d1;	}
			"<" =>	{	bodp = d0 < d1;		}
			">" =>	{	bodp = d0 > d1;		}
			"<=" =>	{	bodp = d0 <= d1;	}
			">=" =>	{	bodp = d0 >= d1;	}
			? => ;
		}
		s2 = this._get();
		if( s2=="||" )	
			bodp || this.cmp();
		else if (s2=="&&")
			bodp && this.cmp();
		else	bodp;
	}
	public containsfun(string sfun)	{	__mp.contains(sfun);	}
	public addscript(string sob, string smethod, string sfunscript)	{
		<sob>.vars2(A, "_script_eval", this, "_smetscript_"+smethod, sfunscript);
		<sob>.addmethod( smethod, func {
			<_script_eval>.call( ["_smetscript_"+.methodname] );
			} );
	}
	public call(string sfun)	{
		if( !__mp.contains(sfun) )	return;
		
		__irow = __mp.get( sfun );
		__irow++;
		__icol=0;
		
		bool bgo = true;
		bool bif = false, bool bifexp, bool bwhile=false;
		bool belif=false;
		int iwhilerow;
		string s[3], int i[3];
		while( bgo )	{
			__icol=0;
			s0 = this._get();
			match(s0)	{
				"new"=>{
					s0 = this._get();
					s1 = this._get();
					s1 = s1.strsubb(1);	// pozbadz sie $
					if( this.isnext() )	{
						if( __sreads=="[" )	{
							__icol++;
							i0 = this._get();
							for(i1=0; i1<i0; i1++)	{
								new <s0> <s1+i1>;
							}
						} else {		// powinien byc "(" dla konstruktora
							__icol++;
							while( this.isnext() && __sreads!=")" )	this.getexpr( this._get() );
							new <s0> <s1>;
						}
					} else {
						new <s0> <s1>;
					}
					__irow++;
				}
				"delete" =>	{	delete <this.getvar(this._get())>;	__irow++;	}
				(s0=="if" || belif || bwhile)?s0:"" => {
	// 				belif ? this.perror(!bif,"else without if") : this.perror(bif,"if within if");
					__icol++;		// '('
					bifexp = this.cmp();
					if(s0=="if") bif=true;
					belif=false;
					bwhile = false;
					__irow++;
					if( !bifexp )	{
						i1=1;
						while(i1)	{
							s0 = <__sdb>.get(__irow,0);
							if( s0=="else"||s0=="elif"||s0=="fi"||s0=="done") i1=0;
							else	__irow++;
						}
					}
				}"else" => { 	this.perror(!bif,"else without if");
					__irow++;
					if( bifexp )	{
						while(<__sdb>.get(__irow,0)!="fi")
							__irow++;
					}
				} "fi" =>	{	this.perror(!bif,"fi without if");
					bif=false;
					bifexp = false;
					belif=false;
					__irow++;
				} "elif"=>	{
					if( bifexp )	{
						__irow++;
						while(<__sdb>.get(__irow,0)!="fi")
							__irow++;
					} else {
						belif = true;
					}
				} "end" =>	bgo=false;
				"while" =>	{
					iwhilerow = __irow;
					bwhile = true;
				}"done" =>	{
					if( bifexp )	{
						__irow = iwhilerow;
					} else {
						__irow++;
					}
				}"print" =>	{
					s0 = "";
					while( this.isnext() )
						s0 += this.getexpr( this._get() ); 
					engine.print( s0 );
					__irow++;
				}"return" => 	{
					if( this.isnext() )	{
						this.getexpr( __sreads );
					}
					return;
				} ? => { 
					if (s0.getb(0,1)=="$")	{
						s0 = this.getvar( s0 );
						__icol++;		// olej <<
						<s0> = this.getexpr(this._get());
						while( this.isnext() )	{
							__icol++;		// omin znak dzialania
							def d2 = this.getexpr( this._get() );
							match(__sreads)	{
								"+"	=>	<s0> += d2;
								"-"	=> 	<s0> -= d2;
								"*"	=>	<s0> *= d2;
								"/"	=>	<s0> /= d2;
								"%"	=>	<s0> %= d2;
								?	=>	;
							}
						}
					} else
						this.getexpr( s0 );
					__irow++; 
				}
			}
			if( __irow >= <__sdb>.getrowsno() )	{
				this.perror(1,"function "+sfun+" not finished!");
				bgo=false;
			}
		}
	}
}


public animaloader_load(string sdbfile)	{
	new db _dbanl;
	_dbanl.loadbeh( .getpath(sdbfile) );
	string s[3], string san, string sord;
	int col;
	int i[2];
	real r[2];
	for( int i=0; i< _dbanl.getrowsno; i++) 	{
		if( _dbanl.getcolsno(i) > 0 )	{
			col = 0;
			match(_dbanl.get(i,col))	{
				"an:" => {
					col++;
					s0 = _dbanl.get(i,col); col++;
					if( s0.contains(".pyz") )	{
						san = "an" + s0.strsubes(".pyz");
						.newanima(san, s0, 0);
					} else {
						.copyanima( _dbanl.get(i,col) , s0 );
						col++;
					}
					for( int j=col; j<_dbanl.getcolsno(i); j++)	{
						sord = _dbanl.get(i,j);
						match( sord )	{
							"-z" => {
								j++;
								<san>.setz( _dbanl.get(i,j) );
							}
							"-hide" => <san>.hide;
							"-opacityframe" => <san>.anopacityframe;
							"-nplay" => {
								j++;
								<san>.play( _dbanl.get(i,j)->to_i );
							}
							"-play" => {
								j++;
								<san>.play( _dbanl.get(i,j) );
							}
							"-delay" => {
								j++;
								<san>.setdelay( _dbanl.get(i,j) );
							}
							"-drawmode" => {
								s0 = _dbanl.get(i,j);	j++;
								if( s0=="lineardodge" )	{
									<san>.setdrawmode(1);
								}
							}
							"-hideonstart" => {
								<san>.anhideonsetframe;
							}
							"-buildroto", "-buildrotorle" => {
								j++;
								real rkatl = _dbanl.get(i,j);	j++;	// kat dodatni
								real rkatr = _dbanl.get(i,j);	j++;	// kat ujemny
								real speed = _dbanl.get(i,j);	j++;	// speed - minus startuj w lewo, plus w prawo
								int delay = _dbanl.get(i,j);
								.gmbuildroto(san, rkatl, rkatr, speed, delay, ( sord == "-buildrotorle" ? true : false ));
							}
							? => j = .animaloader_an(san, "_dbanl", i, j);
						}
					}
				}
				? => ;
			}
		}
	}
}

public animaloader_an(string san, string sdb, int row, int col)	{
	col;
}

public gmbuildroto(string san, real rkatl, real rkatr, real speed, int delay, bool brle)	{
	int i0 = <san>.getpx;
	int i1 = <san>.getpy;
	<san>.setframe(1,0);
	<san>.ansetbpos(i0, i1);
	string s[2];
	
	real r3 = 0.0;
	speed = speed.abs;
	i0 = 0;
	string sprev = null;
	for( real r2 = rkatr; r2<=rkatl; r2+=r3 )	{
		real r4 = ((r2-rkatr)/(rkatl-rkatr))->abs;
		
		if( r4._rin1(0.1) ) r3 = 0.4*speed;
		else if ( r4._rin1(0.2) ) r3 = 0.8*speed;
		else r3 = speed;
		
		s1 = "_imgroto"+i0+san;
		new img <s1>;
		<s1>.buildrotozoom(san, r2, 1.0, 1.0);
		while( sprev!=null && <s1>.getw==<sprev>.getw && <s1>.geth==<sprev>.geth &&
			<s1>.getpx==<sprev>.getpx && <s1>.getpy==<sprev>.getpy )	{
			r4 = 0.2;
			r2 += r4*r3;
			r3 *= (r4 + 1.0);
			<s1>.buildrotozoom(san, r2, 1.0, 1.0);
		}
		<s1>.setz( <san>.getz );
		<s1>.hide;
		if( brle ) <s1>.rle;
		
		sprev = s1;
		i0++;
	}
	s0 = "_timroto"+san;
	.cycle = (s0, func {
		<slastimg>.hide;
		slastimg = "_imgroto"+idimg+san;
		<slastimg>.show;
		idimg = idimg+dir;
		if( idimg < 0 )	{
			idimg=0;
			dir = 1;
		} else if( idimg >= ileimgs ) {
			idimg = ileimgs-1;
			dir = -1;
		}
		.play;
		} );
	<s0>.setcycle(delay);
	<s0>.vars2(A, "san", san, "ileimgs", i0, "slastimg", s1, "idimg", 0, "dir", 1);
	<san>.hide;
	<"_imgroto0"+san>.show;
	<s0>.play;
}

public transparent	{	return 0,0,0,0;	}
public red			{	return 255,0,0;	}
public green		{	return 0,255,0;	}
public blue			{	return 0,0,255;	}
public white		{	return 255,255,255; }
public black		{	return 0,0,0;		}
public grey(int c)	{	return c,c,c;		}
public yellow		{	return 255,255,0;	}

class Color	{
	init	{
		.vars(A,"r","g","b","a");
	}
	operator=(string scol)	{	this.set( <scol>.get() );	}
	img=(@simg)	{
		|r,g,b,a| = <simg>.getrgba( classansearcher::firstnotrx1y(simg) );
	}
	get			{	return r,g,b,a;	}
	set(int r2, int g2, int b2, int a2)	{	|r,g,b,a| = r2,g2,b2,a2;	}
	rgb=(int r2, int g2, int b2)	{	|r,g,b|=r2,g2,b2;	}
	rgb	{	return r,g,b;	}
	print	{	engine.print("Color::" + this + " (r,g,b,a) = ("+r+","+g+","+b+","+a+")");	}
}

/***************************************************************************/

class classasker : newvars	{
	init()	{
		newvars::init();
		new string sfuncyes = null;
		new string sfuncno = null;
		new string ssndask;
		new string ssndyes;
		new string ssndno;
		new classsound clsnd;
	}
	reset()	{
		sfuncyes=null;	sfuncno=null;
		buts.resetall();
	}
	setfuncs(string syes, string sno)	{
		sfuncyes = syes;
		sfuncno = sno;
	}
	fxonmovon(string ssnd)	{	buts.sfxonmovon(ssnd);	}
	setmouse(string smouse)	{
		buts.newmouse("yes", smouse);
		buts.newmouse("no", smouse);
	}
	load(string sfile, int z)	{
		new classbutton buts;
		buts.build(sfile, z, null);
		buts.transclickfunc( engine.actclassname(), "butclick");
		buts.transmovonfunc( engine.actclassname() , "butmovon");
		buts.disableall();
	}
	ask( string sask, string syes, string sno, string sf1, string sf2 )	{
		this.setfuncs(sf1,sf2);
		this.ask2( sask, syes, sno );
	}
	ask2( string sask, string syes, string sno )	{
		ssndask=sask;
		ssndyes = syes;
		ssndno = sno;
		gameapi.pause();
		buts.benableall();
		buts.pause("bkg");
		clsnd.creset();
		clsnd.cbplay( sask );
		.<this+"_ask">;
	}
	/**********************************************/
	butmovon(string sc)	{
		/*if( ssndask!=null )	{
			if( <ssndask>.isplaying()==true )	{
				return;
			}
		}*/
		if( sc=="yes" )	{
			<ssndask>.stop(false);
			clsnd.cbplay( ssndyes );
		} else if (sc=="no")	{
			<ssndask>.stop(false);
			clsnd.cbplay( ssndno );
		}
	}
	butclick(string sc)	{
		if( sc=="bkg" )	return;
		gameapi.resume();
		buts.disableall();
		clsnd.cactsndstop(false);
		if( sc=="yes" && sfuncyes!=null)	{
			this.<sfuncyes>();
			.<this+"_yes">;
		} else if( sc=="no" && sfuncno!=null)	{
			this.<sfuncno>();
			.<this+"_no">;
		}
	}
	disabled	{	buts.disabled;	}
	setcursorpos(int x, int y)	{	buts.setcursorpos(x,y);	}
}

/***************************************************************************/
class classplacepointer	{
	init()	{
		new anima anpointer;
		anpointer.addmethod("onfinish", func { this.play(-1); } );
		new int _iz = 1000;
	}
	public load(string sfile)	{
		anpointer.load(sfile);
		this.setz(_iz);
		anpointer.hide();
	}
	public setz(int iz)	{
		_iz = iz;
		anpointer.setz(iz);
	}
	public stop()	{	anpointer.stop(false);	}
	public stoph()	{	anpointer.stop(false);	anpointer.hide();	}
	public show(int x, int y, string sdir)	{
		anpointer.setpos(x,y);
		anpointer.play(sdir);
	}
	move(@x, @y)	{	anpointer.move(x,y);	}
	public showob(string sob, string sdir)	{	this.show(<sob>.getcx(), <sob>.getcy(), sdir);	}
	public showpob(string sob, string sdir)	{	this.show(<sob>.getpx(), <sob>.getpy(), sdir);	}
}

class SimpleCounter	{
	init(int ilength)	{
		.var2("length", ilength );
		new int iid = 0;
	}
	int next()	{	iid = (iid+1)%length;		iid;	}
	set(int i)	{	iid=i;	}
	reset()	{	iid=0;	}
	get()	{	iid;	}
}

/******************************************/

module clstrdigit	{
	init()	{}
	public string getdigit(int idigit, int ilepozycji)	{
		string s = idigit;
		while( s.length() < ilepozycji )	s = "0" + s;
		return s;
	}
	public string gettime(int itime, string smod)	{
		return this.getstime( this.geth(itime), this.getm(itime), this.gets(itime), 
			smod.contains("h"), smod.contains("m"), smod.contains("s") );
	}
	public string getstime(int ih, int im, int is, bool bh, bool bm, bool bs)	{
		string s = "";
		if( bh ) s+= ih;
		if( bm ) s+= (bh?":":"") + this.getdigit(im,2);
		if( bs ) s+= ((bh||bm)?":":"") + this.getdigit(is,2);
		return s;
	}
	public int geth(int itime)	{	return itime/3600;	}
	public int getm(int itime)	{	return (itime/60)%60;	}
	public int gets(int itime)	{	return itime%60;	}
	public string getns(int itime, int n)	{	return this.getdigit( this.gets(itime),n );	}
	public string getnm(int itime, int n)	{	return this.getdigit( this.getm(itime),n );	}
	string getbinary(int ival)	{
		string s = "";
		while(ival>0)	{
			s = "" + (ival%2) + s;
			ival/=2;
		}
		return s;
	}
	string bintohex(string sval)	{
		string s;
		match(sval.length%4)	{
			3=>"0"; 2=> "00"; 1=> "000";
			? => "";
		}
		s = _;
		sval = s + sval;
		s = "";
		for( int i=0; i<sval.length; i+=4)	{
			match(sval.getb(i,4))	{
				"0000" => "0";	"0001" => "1";	"0010" => "2";	"0011" => "3";
				"0100" => "4";	"0101" => "5";	"0110" => "6";	"0111" => "7";
				"1000" => "8";	"1001" => "9";	"1010" => "A";	"1011" => "B";
				"1100" => "C";	"1101" => "D";	"1110" => "E";	"1111" => "F";
				? => ;
			}
			s += _;
		}
		s;
	}
}

public string getbinary			{	clstrdigit::getbinary(.get);		}
public string getdigit(int ile)		{	clstrdigit::getdigit(.get,ile);		}
public string getbindigit(int ile)	{	clstrdigit::getdigit( .getbinary,ile);	}

class Text	{
	init(string sfont, int ifontsize, int ifr, int ifg, int ifb, int x, int y, int z)	{
		if( sfont==null )	sfont = sgmfontfile;
		if( sfont.contains(".ttf") )	{
			new font _fnt;
			_fnt.load( sfont, ifontsize );
			sfont = "_fnt";
		}
		new int iR = ifr;
		new int iG = ifg;
		new int iB = ifb;
		new int iFontSize = ifontsize;
		new text txt;
		txt.setfont(sfont);
		txt.setz(z);
		txt.setpos(x,y);
		txt.show;
		
		new text txtbg;
		txtbg.hide();
	}
	public hide()	{	txt.hide;	}
	public show()	{	txt.show;	}
	public setpos(int x, int y)	{	txt.setpos(x,y);	}
	public set(string s)	{
		txt.set( s );
		txt.createtxt( iR, iG, iB );
	}
	public string get()	{	return txt.get;	}
	public setbg(int ir, int ig, int ib, int ia)	{
		txtbg.setbkg(txt.getpx()-iFontSize/2, txt.getpy()-iFontSize/2,
			txt.getw()+iFontSize, iFontSize*2, ir, ig, ib, ia );
		txtbg.setborders(1,255,255,255,128);
		txtbg.show();
	}
	operator=(string val)	{	this.set(val);	}
	move(int x, int y)	{	txt.move(x,y);	}
}

class Cypher : Text	{
	init(string sfont, int ifontsize, int ifr, int ifg, int ifb, int x, int y, int z)	{
		Text::init(sfont, ifontsize, ifr, ifg, ifb, x, y, z );
		this.set(0);
	}
	add(int dt)	{	this.set( dt + this.get );	}
	iget()		{	this.get->to_i;		}
	operator+(int val)	{	this.add(val);	}
	operator++()	{	this.add(1);	}
	operator--()	{	this.add(-1);	}
	operator-(int val)	{	this.add(-val);	}
	operator=(int val)	{	this.set(val);	}
	operator==(int val)	{	.get==val;	}
	operator!=(int val)	{	.get!=val;	}
	operator>(int val)	{	.get>val;	}
	operator<(int val)	{	.get<val;	}
}

class SecCounter	{
	init(string sdigits, int starttime, int dt)	{
		new string sdigit = sdigits;
		.vars2(A, "istarttime", starttime, "idtime", dt, "itime", 0);
		this.reset();
		this.cnewtimerfin("timcyk",1000,1, func { .play; <.getbuildername>.tick; } );
	}
	public play()	{	timcyk.play();	}
	public stop()	{	timcyk.stop(false);}
	public string sgettime()	{	return clstrdigit.gettime(itime, sdigit);	}
	public int gettime()	{	return itime;	}
	public tick	{	.update(idtime);	}
	public reset()	{
		//this.update(-itime);
		itime = istarttime;
	}
	public update(int isec)	{
		itime+=isec;
	}
}

class TextTimeCounter : Text, SecCounter	{
	init(string sfont, int ifontsize, int ifr, int ifg, int ifb, int x, int y, int z, string sdigits, int starttime, int dt)	{
		Text::init(sfont, ifontsize, ifr, ifg, ifb, x, y, z);
		SecCounter::init(sdigits, starttime, dt);
		.reset;
		.update(0);
	}
	public update(int isec)	{
		SecCounter::update(isec);
		this.set( this.sgettime() );
		if( itime<=0 && idtime<0 )	{
			.<this + "_finish">;
		}
	}
}

class gfxObject	{
	init(string sob)	{	new string sgfxobj = sob; }
	setpos		{	<sgfxobj>.setpos;	}
	move		{	<sgfxobj>.move;	}
	getpos		{	<sgfxobj>.getpos;	}
	getposx		{	<sgfxobj>.getposx;	}
	getposy		{	<sgfxobj>.getposy;	}
	getpx		{	<sgfxobj>.getpx;	}
	getpy		{	<sgfxobj>.getpy;	}
	getw			{	<sgfxobj>.getw;	}
	geth			{	<sgfxobj>.geth;	}
	getcx		{	<sgfxobj>.getcx;	}
	getcy		{	<sgfxobj>.getcy;	}
	getex		{	<sgfxobj>.getex;	}
	getey		{	<sgfxobj>.getey;	}
	lodx			{	<sgfxobj>.lodx;	}
	lody			{	<sgfxobj>.lody;	}
	setz			{	<sgfxobj>.setz;		}
	getz			{	<sgfxobj>.getz;	}
	show		{	<sgfxobj>.show;	}
	hide			{	<sgfxobj>.hide;	}
	isvisible		{	<sgfxobj>.isvisible;	}
	bool isin		{	<sgfxobj>.isin;		}
}

class gfxSquare : Color, gfxObject	{
	init(int x1, int y1, int w1, int h1)	{
		Color::init;
		.vars(A, "w", "h");
		w=w1; h=h1;
		new img imggfx;
		imggfx.setpos(x1,y1);
		gfxObject::init("imggfx");
	}
	build	{	imggfx.create(w,h,r,g,b,a);	}
	shadow(int dx, int dy, int alpha)	{
		|@x,@y| = imggfx.getpos;
		imggfx.setpos(0,0);
		new img _img1;
		new img _img2;
		if( imggfx.getw>0 )	{
			_img1.create(w,h,.transparent);
			_img1.blit("imggfx");
		} else _img1.create(w,h,.get);
		_img2.create(w,h,.black,alpha);
		if( dx<0 )	{
			_img1.move(-dx, 0);
			x+=dx;
		} else	_img2.move( dx, 0 );
		if( dy<0 )	{
			_img1.move(0,-dy);
			y+=dy;
		} else	_img2.move( 0, dy );
		w += dx.abs;
		h += dy.abs;
		imggfx.create(w, h, .transparent);
		imggfx.blit("_img2");
		imggfx.blit("_img1");
		delete _img1;
		delete _img2;
		imggfx.move(x,y);
	}
	blackborder(int width, int a2)	{	.border(width,width, .black,a2);	}
	border(int width, int height, int r2, int g2, int b2, int a2)	{
		|@x,@y| = imggfx.getpos;
		imggfx.setpos(0,0);
		new img _img;
		if( imggfx.getw>0 )	{
			_img.create(w,h,.transparent);
			_img.blit("imggfx");
		} else _img.create(w,h,.get);
		_img.move(width,height);
		w += 2*width;
		h += 2*width;
		imggfx.create(w,h,r2,g2,b2,a2);
		imggfx.blit("_img");
		delete _img;
		imggfx.move(x,y);
	}
}

class Rect	{
	init(int _x, int _y, int _w, int _h)	{
		.vars(A, "x", "y", "w", "h");
		.set(_x, _y, _w, _h);
		new vector vecgr; vecgr.type("string");
		vecgr.add("gmimgvec");
	}
	x2	{	x+w;	}
	y2	{	y+h;	}
	set(int _x, int _y, int _w, int _h)	{ x=_x; y=_y; w=_w; h=_h; }
	setborders(int _x, int _y, int _x2, int _y2)	{
		x=_x; y=_y; w=_x2-_x; h=_y2-y;
	}
	fit(string simg)	{
		if( vecgr.contains( <simg>.gettype) ) {
			@dx = x-<simg>._getpx;
			if( dx>0 ) <simg>.move(dx,0);
			@dy = y-<simg>._getpy;
			if( dy>0 ) <simg>.move(0,dy);
		} else {
			@dx = x-<simg>.getpx;
			if( dx>0 ) <simg>.move(dx,0);
			@dy = y-<simg>.getpy;
			if( dy>0 ) <simg>.move(0,dy);
		}
		dx = .x2-<simg>.getex;
		if( dx<0 ) <simg>.move(dx,0);
		dy = .y2-<simg>.getey;
		if( dy<0 ) <simg>.move(0,dy);
	}
	fitrand(string simg)	{	<simg>.ansetbpos( x+(w-<simg>.getw)->rand, y+(h-<simg>.geth)->rand);	}
	fitgrouprand(string sgr)	{	for( int i=0; i< <sgr>.size; i++) .fitrand( <sgr>.get(i) );	}
	fitgroup(string sgr)	{	for( int i=0; i< <sgr>.size; i++) .fit( <sgr>.get(i) );	}
	bool isin(int _x, int _y)	{	_x>=x && _x<x+w && _y>=y && _y<y+h;	}
}

class ImgRect	{
	init	{
		.vars2(A, "ix",0,"iy",0,"iw",0,"ih",0,"bvis",1, "iz", 0);
	}
	setpos(int x, int y)	{	ix=x; iy=y;	}
	move(int x, int y)	{	ix+=x; iy+=y;	}
	getpos			{	return ix,iy;	}
	getposx			{	ix;		}
	getposy			{	iy;		}
	getpx			{	ix;		}
	getpy			{	iy;		}
	getw			{	iw;		}
	geth			{	ih;		}
	getcx			{	ix+iw/2;	}
	getcy			{	iy+ih/2;	}
	getex			{	ix+iw;		}
	getey			{	iy+ih;		}
	lodx			{	0;		}
	lody			{	0;		}
	setz(int z)		{	iz=z;		}
	getz			{	iz;		}
	show			{	bvis = true;	}
	hide			{	bvis = false;	}
	isvisible		{	bvis;		}
	bool isin(int x, int y, bool bv, bool ba)	{
		if( bv==false || .isvisible )
			x>=ix && x<ix+iw && y>=iy && y<iy+ih;
		else false;
	}
	setrect(int x, int y, int x2, int y2)	{
		ix=x; iy=y; iw=x2-x; ih=y2-y;
	}
	print	{
		("x: "+ix+", y: "+iy+", w: "+iw+", h: "+ih)->print;
	}
	operator=(string srec)	{
		|ix,iy,iw,ih,iz,bvis| = <srec>.getpx, <srec>.getpy, <srec>.getw, <srec>.geth, <srec>.getz, <srec>.isvisible;
	}
}

/***************************************************************************/

class classfadeinout		{
	init()	{
		new timer timf;
		new string _sob;
		new int _istep;
		new int _ival;
		new int _ib1;
		new int _ib2;
		new string _sfun;
		new string _sfunfin;
		new string _sobfin;
		timf.addmethod("onfinish", "_ctimffin");
	}
	/***************\/\/\/\/\/ wewnetrzne \/\/\/\/\/\/************************************/
	_cfinito(int v)	{
		<_sob>.<_sfun>( v );
		if( _sfunfin!=null)	{
			if( _sobfin==null )
				this.<_sfunfin>();
			else <_sobfin>.<_sfunfin>;
		}
	}
	_ctimffin()	{
		_ival+=_istep;
		if( _ival > _ib2 )	{
			this._cfinito( _ib2 );
		} else if( _ival<_ib1 )	{
			this._cfinito( _ib1 );
		} else {
			<_sob>.<_sfun>( _ival );
			this.play();
		}
	}
	_play( int icycle, int istep, string sob, string sfun, int ib1, int ib2, string sob2, string sfun2 )	{
		_sobfin = sob2;
		_sfunfin = sfun2;
		_ib1 = ib1;
		_ib2 = ib2;
		int i = istep.abs();
		if( icycle <= 0 || i==ib1 || i>ib2 )	return;
		_sfun = sfun;
		timf.setcycle( icycle );
		_sob = sob;
		if( istep>0 )	_ival = _ib1;
		else if( istep<0 )	_ival=_ib2;
		else return;
		<sob>.<sfun>( _ival );
		_istep = istep;
		timf.play();
	}
	/******************* /\/\/\/\/\/\/\ wewnetrzne /\/\/\/\ ****************************/
	imgtransparency(int icycle, int istep, string simg, string sfun)	{
		this._play( icycle, istep, simg, "transparency", 0, 255, null, sfun );
	}
	setopacity(int icycle, int istep, string simg, string sfun)	{
		this._play( icycle, istep, simg, "setopacity", 0, 255, null, sfun );
	}
	sndvolume(int icycle, int istep, string ssnd, string sfun)	{
		this._play( icycle, istep, ssnd, "setvol", 0, 100, null, sfun );
	}
	/***************************************************/
	isplaying	{	timf.isplaying;	}
}

class CutScene : gfxObject	{
	init(int x1, int y1, int x2, int y2)	{
		new int X1;	new int Y1;
		new int X2;	new int Y2;
		new img _gsq;
		.build(x1, y1, x2, y2);
		gfxObject::init("_gsq");
		new string _sfunc1;
		new string _sob1;
		new string _sfunc2;
		new string _sob2;
		new int _idelay = 10;
		new classfadeinout _clfio;
	}
	build(int x1, int y1, int x2, int y2)	{
		|X1, Y1, X2, Y2| = x1, y1, x2, y2;
		_gsq.create(X2-X1,Y2-Y1,.black,255);
		_gsq.setpos(X1,Y1);
		_gsq.hide;
		_gsq.transparency(0);
	}
	buildblack	{	.build(X1,Y1,X2,Y2);	}
	buildfromfile(string sfile)	{
		@z = .getz;
		new img _imtmp;
		_imtmp.load(sfile);
		_gsq.transparency(255);
		_gsq.blit("_imtmp");
		delete _imtmp;
		_gsq.hide;
		_gsq.transparency(0);
	}
	buildfromscreen	{
		_gsq.transparency(255);
		_gsq.blitscreen;
		_gsq.hide;
		_gsq.transparency(0);
	}
	cloneto(string simg)	{
		<simg>.clone("_gsq");
	}
	delay(int n)	{	_idelay=n;	}
	transparency(int n)	{	_gsq.transparency(n);	}
	playfin(string sfunc1, string sfunc2)	{	.playobfin(null,sfunc1, null, sfunc2);	}
	playobfin(string sob1, string sfunc1, string sob2, string sfunc2)	{
		_sob1 = (sob1==null) ? gameapi.getgamename : sob1;
		_sfunc1 = sfunc1;
		_sob2 = (sob2==null) ? gameapi.getgamename : sob2;
		_sfunc2 = sfunc2;
		_gsq.show;
		_gsq.transparency(0);
		_clfio._play( 1, _idelay, this, "transparency", 0, 255, this, func {
			.callfun(_sob1, _sfunc1);
			_gsq.show;
			_clfio._play( 1, -_idelay, this, "transparency", 0, 255, this, "_callfun2" );
			} );
	}
	close(string sfunc1)	{	.obclose(gameapi.getgamename, sfunc1);	}
	obclose(string sob, string sfunc1)	{
		_sob1 = sob;
		_sfunc1 = sfunc1;
		_gsq.transparency(0);
		_gsq.show;
		_clfio._play( 1, _idelay, this, "transparency", 0, 255, this, func {
			_gsq.hide;
			.callfun(_sob1, _sfunc1);
			} );
	}
	enter(string sfunc2)	{	.obenter(gameapi.getgamename, sfunc2);	}
	obenter(string sob, string sfunc2)	{
		_sob2 = sob;
		_sfunc2 = sfunc2;
		_gsq.transparency(255);
		_gsq.show;
		_clfio._play( 1, -_idelay, this, "transparency", 0, 255, this, "_callfun2" );
	}
	_callfun2	{
		_gsq.hide;
		.callfun(_sob2, _sfunc2);
	}
	isplaying	{	_clfio.isplaying;	}
	show	{
		_gsq.transparency(255);
		_gsq.show;
	}
	showloading	{
		if( !.hasvar("txtloading") )	{
			@sfont = .stdfont(64->igetsc);
			.newtext("txtloading", "Loading", sfont, .grey(222) );
			txtloading.setz( .getz + 1 );
			txtloading.txtcenterscreen;
			txtloading.txtshadow(1, sfont);
		}
		txtloading.txtshow;
	}
	hideloading	{	txtloading.txthides;	}
}


public string allchars	{	"a0 t_!@#$%^&*()_+-=[]\\|}{;':\",./<>?`~"; }

class TextTyper : classlocker, gfxObject {
	init(string sfont, int isize, int ir, int ig, int ib, string schars, int ilimit)	{
		classlocker::init();
		sfont = .checkfont(sfont, isize);
		new int iR = ir;
		new int iG = ig;
		new int iB = ib;
		new string sChars = schars;
		new int iLimit = ilimit;		// 0 - unlimited
		
		.vars2(A,"Sdir","left", "W", 0, "iFontSize", isize, "X", 0, "Y", 0);
		
		new text txt1;
		txt1.setfont(sfont);
		txt1.set("");
		new text txt2;
		txt2.setfont(sfont);
		txt2.set("_");
		txt2.createtxt(iR,iG,iB);
		txt2.hide();
		
		new text txtpass;
		txtpass.setfont(sfont);
		txtpass.hide;
		new bool bpass = false;
		
		new string _sob=null;
		new string _sfun=null;
		
		this.cnewtimerfin("timcyk",300,1,"fintimcyk");
		
		gfxObject::init("txt1");
	}
	setaspasswd	{
		bpass = true;
		txt1.hide;
		txtpass.setz( txt1.getz );
		txtpass.show;
		.copytopass;
	}
	copytopass	{
		@id = txt1.get->length;
		string s = "";
		for( int i=0; i<id; i++)	s += "*";
		txtpass.txtset(s);
		txtpass.setpos( txt1.getpx, txt1.getpy );
	}
	setastext	{
		bpass = false;
		txt1.show;
		txtpass.hide;
	}
	public isin(int x, int y, bool bv, bool ba)	{	txt1.isin(x,y,bv,ba);	}
	getcol	{	return iR,iG,iB;	}
	fintimcyk()	{
		if( this.getlock() )	return;
		this.updatecyk();
		this.play();
	}
	updatecyk()	{
		if( txt2.isvisible() )	{
			txt2.hide();
		} else {
			txt2.setpos( txt1.getex(), txt1.getpy() );
			txt2.show();
		}
	}
	public enable()	{
		this.unlock();
		this.updatecyk();
		timcyk.play();
	}
	public disable()	{
		txt2.hide();
		timcyk.stop(false);
		this.lock();
	}
	public onenter(string sob, string sfun)	{	_sob=sob;	_sfun=sfun;	}
	public setpos(int x, int y)	{
		X = x;
		Y = y;
		//txt1.setpos(x,y);
		.updatetxt(.get);
	}
	public move(int x, int y)	{	.setpos(X+x, Y+y); }
	public setz(int z)	{	txt1.setz(z);txt2.setz(z);	}
	public get()	{
		string s = txt1.get();
		( s.length()>0 ) ? s : "";
	}
	getpx	{	txt1.getpx;	}
	getpy	{	txt1.getpy;	}
	getcx	{	txt1.getcx;	}
	getcy	{	txt1.getcy;	}
	geth	{	txt1.geth;	}
	getey	{	txt1.getpy + iFontSize;	}
	clip(int x1, int y1, int x2, int y2)	{
		txt1.clip(x1,y1,x2,y2);
		txt2.clip(x1,y1,x2,y2);
	}
	public length	{	txt1.get->length;	}
	public set(string s)	{	txt1.set(s);	}
	public txtset(string s)	{	txt1.txtsetcol(s,.getcol);	}
	public limit=(int il)	{	iLimit=il;	}
	public onkeydown()	{
		if( this.getlock() )	return;
		.<this+"_ontype">;
		if( keyboard.iskeydown("enter") )	{
			this.disable();
			this.callfun(_sob,_sfun);
			.<this+"_onenter">;
			return;
		}
		string s;
		if( sChars.contains("t") && keyboard.iskey("tab") )	s = " ";
		else s = keyboard.getkey();
		string s2 = txt1.get();
		if( ( (keyboard.isalpha && sChars.contains("a") ) || ( keyboard.isdigit && sChars.contains("0") )
			|| sChars.contains(s) ) && (iLimit<=0 || iLimit>s2.length)  )	{
			//txt1.set( s2+s );
			//txt1.createtxt(iR,iG,iB);
			.updatetxt(s2+s);
			this.updatecyk();
		} else if (keyboard.iskey("backspace") && s2.length()>0)	{
			//txt1.set( s2.strsube(1) );
			//txt1.createtxt(iR,iG,iB);
			.updatetxt( s2.strsube(1) );
			this.updatecyk();
		}
		.<this+"_ontyped">;
	}
	updatetxt(string s)	{
		txt1.set(s);
		txt1.createtxt(iR, iG, iB);
		if( Sdir == "center" )	txt1.setpos( X+(W-txt1.getw)/2, Y );
		else if (Sdir=="right")	txt1.setpos( X+W-txt1.getw, Y );
		else txt1.setpos(X, Y);
		if( bpass )	.copytopass;
		.<this+"_onwrite">;
	}
}

class ConTextTyper : TextTyper, ObjController	{
	init()	{
		TextTyper::init();
		ObjController::init();
	}
}

new string sTextBoxTyperSys = null;
class TextBoxTyper : LObjController, ImagePos	{
	init(string sfont, int ish, int isw, int ir, int ig, int ib, string schars, int x, int y, int w, int h, int dy)	{
		LObjController::init;
		ImagePos::init;
		new @Font = .checkfont(sfont, ish);
		.vars2(A,"Cols", w/isw, "Rows", h/(ish+dy), "X", x, "Y", y, "Row", 0, "enablemove", true, "W", w,
			"insystem", false, "H", h, "isvisible", 1, "clipx1", x, "clipy1", y, "clipx2", 0, "clipy2", 0, "clipped", false );
		new @Size = ish;
		new @Dy = dy;
		new @Z = 0;
		string s;
		new gmimgvec grtt;
		new gmimgvec gren;
		for( int i=0; i<Rows; i++)	{
			s = "tt"+i;
			new TextTyper <s>(Font,ish,ir,ig,ib,schars,Cols);
			<s>.W = (w);
			<s>.Sdir = ("left");
			<s>.setpos( x, y+i*(ish+dy) );
			grtt.add(s);
		}
	}
	settyper(int id, string sfont, int ish, int isw, int ir, int ig, int ib, string schars, string sdir)	{
		int x;
		int y;
		string s;
		string stext = "";
		if( id<0 ) {
			x = <grtt.last>.X;
			y  = <grtt.last>.getey+Dy;
			id = grtt.size;
			grtt.add("tt"+id);
		} else {
			s = grtt.get(id);
			x = <s>.X;
			y = <s>.getpy;
			stext = <s>.get;
			grtt.movefrom( s, 0, ish - <s>.iFontSize );
			delete <s>;
		}
		s = "tt" + id;
		new TextTyper <s>(sfont,ish,ir,ig,ib,schars,W/isw);
		<s>.W = (W);
		<s>.Sdir = (sdir);
		<s>.updatetxt(stext);
		<s>.setz(Z);
		<s>.setpos( x, y );
	}
	move(int x, int y)	{	grtt.move(x,y); gren.move(x,y); X+=x; Y+=y;	}
	size	{	grtt.size;	}
	setz(int z)	{	Z = z; grtt.setz(z);	gren.setz(z); }
	getz	{	Z;	}
	show	{	isvisible=1; grtt.show;	}
	hide		{	isvisible=0;	grtt.hide;		}
	clip(int x1, int y1, int x2, int y2)	{
		clipped = true;
		clipx1=x1;	clipy1=y1;	clipx2=x2;	clipy2=y2;
		for( int i=0; i<grtt.size; i++) <grtt.get(i)>.clip(x1,y1,x2,y2);
	}
	getw	{	W;	}
	geth	{	H;	}
	enumerate(int dx)	{
		string s[2];
		for( int i=0; i<grtt.size; i++)	{
			s0 = "txte"+i;
			new text <s0>;
			gren.add(s0);
			<s0>.setz(Z);
			<s0>.setfont(Font);
			<s0>.txtsetcol(""+(i+1)+".", tt0.getcol);
			<s0>.setpos(X-<s0>.getw-dx,Y+i*(Size+Dy));
		}
	}
	cut(int id)	{	Rows=id;	}
	enable	{	.unlock;	.activateact;	}
	disable	{	.lock; grtt.eval("disable");	}
	actual	{	"tt"+Row;	}
	activate(int id)	{
		.unlock;
		if( id>=0 && id<Rows )	{
			if( insystem )	{
				if( <GAME>.isgmobj(sTextBoxTyperSys) && sTextBoxTyperSys!=this )	<sTextBoxTyperSys>.deactivate;
				sTextBoxTyperSys = this;
			}
			.deactivate;
			Row = id;
			<"tt"+ Row>.enable;
			.<this+"_activate">;
		}
	}
	activateact	{	.activate(Row);	}
	deactivate	{	<"tt"+Row>.disable;	}
	onkeydown	{
		if(.getlock)	return;
		.<this+"_boxontype">;
		if( keyboard.iskeydown("enter") )		{
			@s = .getid(Rows-1);
			s.clear;
			if( s.length==0 && enablemove )	{
				for( @i=Rows-1; i>Row+1; i--)	.setid( .getid(i-1), i);
				if( Row+1<Rows) .setid("", Row+1);
			}
			.activate(Row+1);
		} else if (keyboard.iskey("up") && Row>0) .activate(Row-1);
		else if (keyboard.iskey("down") && Row<Rows-1) .activate(Row+1);
		else if (keyboard.iskey("pgdown"))	{
			if(Row<Rows-10) .activate(Row+10);
			else .activate(Rows-1);
		} else if (keyboard.iskey("pgup"))	{
			if(Row>9) .activate(Row-10);
			else .activate(0);
		} else if ((keyboard.iskey("backspace") || keyboard.iskey("delete")) && <.actual>.length==0 ) {
			if( enablemove )	{
				for( @i=Row; i<Rows-1; i++)	.setid( .getid(i+1), i);
				.setid("",Rows-1);
			}
			if( keyboard.iskey("backspace") )
				.activate(Row-1);
		} else grtt.eval("onkeydown");
	}
	onmouselclick	{
		if(.getlock)	return;
		|int x, int y| = mouse.getpos;
		//if(  )	{
		if( (clipped && clsurf.isin(x,y,clipx1,clipy1,clipx2,clipy2)) || (!clipped && clsurf.isin2(x,y,X,Y,W,H)) )	{
			.deactivate;
			//.activate( ((y-Y)*Rows)/H );
			for( int i=0; i<.size; i++)	{
				if( <"tt"+i>.getey > y ) {
					.activate(i);
					return;
				}
			}
		} else {
			.<this+"_OUTSIDE">;
		}
	}
	int isin(int x, int y, bool bv, bool ba)	{
		if( bv && !isvisible ) return 0;
		clsurf.isin2(x,y,X,Y,W,H);
	}
	string getid(int id)	{	<"tt"+id>.get;	}
	string getact		{	<"tt"+Row>.get;	}
	int idpx(int id)	{	<"tt"+id>.getpx;	}
	int idpy(int id)	{	<"tt"+id>.getpy;	}
	//int getpy	{	.idpy(0);	}
	//int getpx	{	.idpx(0);	}
	int getpx	{	X;	}
	int getpy	{	Y;	}
	string get	{	.getfrom(0);	}
	string getfrom(int id)	{	.getlinesfrom(id,"");	}
	string getlinesfrom(int id, string send)	{
		string s = "";
		for( int i=id; i<grtt.size; i++) s += <"tt"+i>.get + send;
		s;
	}
	string getlines	{	.getlinesfrom(0," ");	}
	int nonempty(int id)	{
		string s;
		for( ; id<grtt.size; id++)	{
			s = <"tt"+id>.get;
			s.clear;
			if( s.length > 0 ) return id;
		}
		-1;
	}
	clear	{	grtt.txtreset;	}
	setid(string s, int id)	{	if( grtt.size>=id )	<"tt"+id>.txtset(s);	}
	settext(int ile)	{
		while(ile>0)	{
			ile--;
			.setid(_,ile);
		}
	}
	copytodb(string sdb)	{
		<sdb>.free;
		for( int i=0;i<grtt.size; i++)	{
			<sdb>.add( <sdb>.addrow-1, <grtt.get(i)>.get);
		}
	}
	copyfromdb(string sdb)	{	.copyfromdbii(sdb, 0, <sdb>.getrowsno);	}
	copyfromdbss(string sdb, string s1, string s2)	{	.copyfromdbii(sdb, <sdb>.findbyrow(s1)+1, <sdb>.findbyrow(s2) );	}
	copyfromdbii(string sdb, int row1, int row2)	{
		if( row1==-1 || row2==-1 ) return;
		.clear;
		if( row2-row1 > .size ) row2 = row1+.size;
		for( int i=row1; i<row2; i++)	{
			if( <sdb>.getcolsno(i) )
				.setid( <sdb>.get(i,0), i-row1 );
		}
	}
	copyfromdbrow(string sdb, int row, int startcol)	{
		int size = <sdb>.getcolsno(row);
		if( size>.size ) size = .size;
		for( int i=startcol; i<size; i++)
			.setid( <sdb>.get(row,i), i-startcol );
	}
	save(string sfile)	{
		if( igmenablesave )	{
			new db __tmpdb;
			.copytodb("__tmpdb");
			__tmpdb.setseparator("|");
			__tmpdb.save(sfile);
			delete __tmpdb;
		}
	}
	load(string sfile)	{
		new db __tmpdb;
		__tmpdb.load(sfile);
		.copyfromdb("__tmpdb");
		delete __tmpdb;
	}
	/*H	{
		if( grtt.size )	<grtt.last>.getey-<grtt.first>.getpy;
		else 0;
	}*/
}

class GUITextBoxTyper : TextBoxTyper	{
	init(string sfont, int ish, int isw, int ir, int ig, int ib, string schars, int x, int y, int w, int h, int dy)	{
		TextBoxTyper::init(sfont,ish,isw,ir,ig,ib,schars,x,y,w,h,dy);
		.vars2(A,"rewinder", null, "rewinderbg", null);
	}
	setrewinder(string s)	{
		rewinder = s;
		rewinderbg = s + "bg";
	}
	activate(int id)	{
		TextBoxTyper::activate(id);
		.updaterewactual;
	}
	updaterewactual	{	.updaterewpos(Row);	}
	updaterewpos(int id)	{
		if( rewinder!=null )	{
			@s = "tt"+id;
			if( <s>.getpy < <rewinderbg>.getpy )		<rewinder>.rewind( 0, <rewinderbg>.getpy - <s>.getpy );
			else if (<s>.getey > <rewinderbg>.getey)		<rewinder>.rewind( 0, <rewinderbg>.getey - <s>.getey );
		}
	}
}

/****************************************************************/
class DelayTaker	{
	init()	{
		new bool bonrel = false;
		new bool bstart = false;
		new bool bclickrel = true;
		this.cnewtimerfin("timwez",300,1, func { bonrel=true; } );
	}
	public setclickrel(bool b)	{	bclickrel=b;	}
	public setdelay(int idelay)	{	timwez.delay(idelay);	}
	public take()	{
		if( bclickrel )	{
			timwez.play();
			bonrel=false;
		} else bonrel=true;
		bstart=true;
		
	}
	public ret()	{
		bonrel=false;
		bstart=false;
		timwez.stop(false);
	}
	public bool isonclick()	{
		this.stoptimer();
		( bstart && !bonrel );
	}
	public bool isonrel()	{
		this.stoptimer();
		( bstart && bonrel );
	}
	public bool istaken()	{	bstart;	}
	public stoptimer()	{	timwez.stop(false);	}
}


class ImgMover	{
	init()	{
		new string smoved=null;
		new int ilastx;
		new int ilasty;
		new int irelx;
		new int irely;
	}
	public mssetobj(string s)	{	this.setobj(s,mouse.getpos);	}
	public setobj(string s, int x, int y)	{	this.set(s,x,y,0,0);	}
	public setcobj(string s)	{	.setobj(s, <s>.getcx, <s>.getcy);	}
	public setpobj(string s)	{	.setobj(s, <s>.getpx, <s>.getpy);	}
	public set(string s, int x, int y, int dx, int dy)	{
		ilastx = <s>.getposx()-dx;
		ilasty = <s>.getposy()-dy;
		irelx = x-<s>.getpx();
		irely = y-<s>.getpy();
		smoved = s;
	}
	public msmove()		{	this.move(mouse.getpos);	}
	public msftmove()	{	this.ftmove(mouse.getpos);	}
	public move(int x, int y)	{
		if( smoved!=null )	{
			<smoved>.setpos( x-<smoved>.lodx()-irelx, y-<smoved>.lody()-irely );
		}
	}
	public ftmove( int x, int y)	{	if( smoved!=null )	<smoved>.setpos( x, y );	}
	public retobj()	{	this.ret(0,0);	}
	public ret(int dx, int dy)	{
		<smoved>.setpos(ilastx+dx, ilasty+dy);
		this.free();
	}
	public put(int x, int y)	{
		<smoved>.setpos(x,y);
		this.free();
	}
	public free()			{	smoved=null;	}
	public string getmover()	{	smoved;	}
	public string getfree		{	@s = smoved; .free; s; }
	public bool moving()		{	smoved!=null;	}
	public setmoved(string s)	{	smoved=s;	}
}

class ConImgMover : ImgMover, ObjController	{
	init()	{
		ImgMover::init();
		ObjController::init();
	}
	onmousemove()	{	this.msmove();	}
	onmouselclick	{	.<this+"_GET">;	}
	onmouselrel	{	if( smoved!=null ) .<this+"_PUT">;	}
}

class DelayImgMover : classlocker, ImgMover	{
	init()	{
		classlocker::init;
		ImgMover::init();
		new DelayTaker cldt; 
		.var2("b2clicks",false);
	}
	public setclickrel(bool b)	{	cldt.setclickrel(b);	}
	public reset	{	cldt.ret;	}
	_put	{
		if( !b2clicks )
			cldt.ret;
		.<this+"_PUT">;
	}
	_get	{
		.<this+"_GET">;
	}
	set(string s, int x, int y, int dx, int dy)	{
		ImgMover::set(s,x,y,dx,dy);
		if( !b2clicks )
			cldt.take;
	}
	onmousemove()	{	this.msmove();	}
	onmouselclick()	{
		if( this.getlock() ) return;
		if( b2clicks )	{
			if( !.moving )	._get;
			else ._put;
		} else {
			if( cldt.isonclick() )	this._put();
			else if (!cldt.istaken())
				._get;
		}
	}
	onmouselrel()	{
		if( this.getlock() ) return;
		if( cldt.isonrel() && !b2clicks )
			this._put();
	}
}

class DelayMover : DelayImgMover, ObjController	{
	init()	{
		DelayImgMover::init();
		ObjController::init();
	}
}

class WaitImgMover : ImgMover, ObjController	{
	init()	{
		ImgMover::init;
		ObjController::init;
		new DelayTaker cldt; 
	}
	public setclickrel(bool b)	{	cldt.setclickrel(b);	}
	public reset	{	cldt.ret;	}
	set(string s, int x, int y, int dx, int dy)	{
		ImgMover::set(s,x,y,dx,dy);
		cldt.take;
	}
	onmousemove	{	.msmove;	}
	onmouselclick	{	.<this+"_GET">;	}
	onmouselrel	{
		if( cldt.isonrel )	{
			.reset;
			.<this+"_PUT">;
		} else if( .moving ) {
			.reset;
			.<this+"_SET">;
		}
	}
}

class Rewinder : classlocker	{
	init(int x1, int y1, int x2, int y2)	{
		classlocker::init();
		new string sarrowdir;
		new int ilenx;
		new int ileny;
		new string sgr;
		new string sorientation;
		new bool bvertical;
		new bool bfilteritem = false;
		
		// clip obiektow
		new int ibx1=0;
		new int ibx2=iResX;
		new int iby1=0;
		new int iby2=iResY;
		
		new int iodleg = 2;	// odleglosc pomiedzy przedmiotami
		
		new ImgMover clmv;
		
		this.cnewtimercyclefin("timtick", 1, 1, "timfin");
		
		// granice
		.vars2(A, "borx1", x1, "bory1", y1, "borx2", x2, "bory2", y2);
		
		new snd fxrew;
// 		fxrew.addmethod("onfinish", func { this.play(); } );
	}
	public movefilter()		{	bfilteritem=true;	}
	public movenormal()	{	bfilteritem=false;	}
	public setfxrew(string sfile)	{
		fxrew.load(this.getsndpath()+sfile);
	}
	public getitem(string s, int x, int y)	{
		/*clmv.set(s,x,y,<sgr>.getpx(),<sgr>.getpy());
		<s>.clip(0,0,800,600);
		<sgr>.movefrom(s, 0, -<s>.geth);
		<sgr>.remove(s);*/
		<s>.setz( <s>.getz+1 );
		clmv.set(s,x,y,<sgr>.getpx(),<sgr>.getpy());
		<s>.clip(0,0,iResX,iResY);
		if( sorientation=="up" || sorientation=="down")	{
			<sgr>.movefrom(s, -(<s>.getw+iodleg), 0 );
			<s>.move( <s>.getw,0 );
		} else {
			<sgr>.movefrom(s, 0, -(<s>.geth+iodleg));
			<s>.move(0, <s>.geth );
		}
		<sgr>.remove(s);
	}
	public bool pickup(int x, int y)	{
		if( <sgr>.isin(x,y,true,true) )	{
			this.getitem( <sgr>.getsfound(), x, y );
			return true;
		}
		return false;
	}
	public bool mspickup()	{	return this.pickup(mouse.getpos );	}
	public freeitem()	{	clmv.free();	}
	public moveitem()	{
		if( bfilteritem )		clmv.msftmove();
		else		clmv.msmove();
	}
	public retitem()	{
		string s = clmv.getmover();
		clmv.ret(<sgr>.getpx(),<sgr>.getpy());
		this.putitem(s);
	}
	public putitem(string s)	{
		if( sorientation=="up" || sorientation=="down")	{
			<s>.move( <sgr>.getex-<s>.getpx+iodleg, 0);
		} else {
// 			@dx = anupstd.getex - <s>.getw;
// 			<s>.setpos( dx - <s>.lodx, <sgr>.getey-<s>.lody);
			<s>.move( 0, <sgr>.getey-<s>.getpy+iodleg);
		}
		<sgr>.add(s);
		<s>.setz( <s>.getz-1 );
		<s>.clip(ibx1,iby1,ibx2,iby2);
	}
	public string getmoved()	{	return clmv.getmover();	}
	public int getbutw()	{	return anupstd.getw();	}
	public int getbuth()	{	return anupstd.geth();	}
	public movearrows(int x, int y)	{	grarrows.move(x,y);	}
	public build(string sfile, int z, string scursor, string sorient, int dt, string sgrelem)	{
		sgr = sgrelem;
// 		this.newanima("anupstd",sfile,z);
		new anima anupstd;
		anupstd.load(sfile);
		anupstd.setz(z);
		
		anupstd.setframe("up",0);
		this.copyanima("anupstd","anupact");
		anupact.setframe("up",1);
		this.copyanima("anupstd","andownact");
		andownact.setframe("down",1);
		this.copyanima("anupstd","andownstd");
		andownstd.setframe("down",0);
		this.newbutan("butup","anupstd","anupact",null,scursor);
		this.newbutan("butdown","andownstd","andownact",null,scursor);
		butup.addmethod("onmoveon","_rewbutmoveon");
		butdown.addmethod("onmoveon","_rewbutmoveon");
		butup.addmethod("onmoveoff","_rewstrzalkaoff");
		butdown.addmethod("onmoveoff","_rewstrzalkaoff");
		butup.addmethod("onclick","_rewbutclick");
		butdown.addmethod("onclick","_rewbutclick");
		butup.addmethod("onrel","_rewbutrel");
		butdown.addmethod("onrel","_rewbutrel");
		sorientation=sorient;
		new gmimgvec grarrows;
		_ = "grarrows" .+ "anupstd" .+ "anupact" .+ "andownact" .+ "andownstd";
		
		int dy, int dx, int ix, int iy;
		if( sorientation=="up" || sorientation=="down")	{
			bvertical = false;
			ilenx = dt;
			if( sorientation=="down")	{
				anupstd.setpos(borx1,bory2-anupstd.geth());
				anupact.setpos(borx1,bory2-anupact.geth());
				andownstd.setpos(borx2-andownstd.getw(),bory2-andownstd.geth());
				andownact.setpos(borx2-andownact.getw(),bory2-andownact.geth());
				dy = andownstd.getey();
			} else {
				anupstd.setpos(borx1,bory1);
				anupact.setpos(borx1,bory1);
				andownstd.setpos(borx2-andownstd.getw(),bory1);
				andownact.setpos(borx2-andownact.getw(),bory1);
				dy = bory1;
			}
			ibx1 = anupstd.getex()+iodleg;
			ibx2 = andownstd.getpx()-iodleg;
			dx = ibx1;
		} else {
			bvertical = true;
			ileny = dt;
			if( sorientation=="right")	{
				anupstd.setpos(borx2-anupstd.getw(),bory1);
				anupact.setpos(borx2-anupact.getw(),bory1);
				andownstd.setpos(borx2-andownstd.getw(),bory2-andownstd.geth());
				andownact.setpos(borx2-andownact.getw(),bory2-andownact.geth());
				dx = anupstd.getex();
			} else {
				anupstd.setpos(borx1,bory1);
				anupact.setpos(borx1,bory1);
				andownstd.setpos(borx1,bory2-andownstd.geth());
				andownact.setpos(borx1,bory2-andownact.geth());
				dx = borx1;
			}
			iby1 = anupstd.getey()+iodleg;
			iby2 = andownstd.getpy()-iodleg;
			dy = iby1;
		}
		butup._rewbuildbut(this.getname(),"up");
		butdown._rewbuildbut(this.getname(),"down");
		
		int ile = <sgrelem>.size();
		<sgrelem>._setpos(dx,dy);
		new int ilimx = dx;
		new int ilimy = dy;
		string s;
		for(int i=0; i<ile; i++)	{
			s = <sgr>.get(i);
			if( sorientation=="right")	{
				<s>.setpos( dx - <s>.getw() - <s>.lodx(), dy - <s>.lody() );
				dy += <s>.geth()+iodleg;
			} else if (sorientation=="left")	{
				<s>.setpos( dx - <s>.lodx(), dy - <s>.lody() );
				dy += <s>.geth()+iodleg;
			} else if (sorientation=="up")	{
				<s>.setpos( dx - <s>.lodx(), dy - <s>.lody() );
				dx += <s>.getw()+iodleg;
			} else if (sorientation=="down")	{
				<s>.setpos( dx - <s>.lodx(), dy - <s>.geth() - <s>.lody() );
				dx += <s>.getw()+iodleg;
			}
			<s>.clip(ibx1,iby1,ibx2,iby2);
		}
	}
	/*************************************/
	_rewbuildbut(string s, string s2)	{
		new string _sob = s;
		new string _sdir;
		if( s2=="up" )	{
			if(bvertical==false)	{	_sdir = "left";	}
			else {	_sdir = "up";	}
		} else if (s2=="down")	{
			if(bvertical==false)	{	_sdir = "right";	}
			else {	_sdir = "down";	}
		}
	}
	_rewbutmoveon()	{
		//this.mstrzalkaon(_sdir);
		this.<_sob+"_"+_sdir+"_MOVEON">();
	}
	_rewbutclick()	{
		this.mstrzalkaon(_sdir);
		this.<_sob+"_"+_sdir+"_CLICK">();
	}
	mstrzalkaon(string s)	{
		sarrowdir=s;
		timtick.play();
	}
	_rewbutrel	{
		sarrowdir=null;
		timtick.stop(false);
		fxrew.stop(false);
	}
	_rewstrzalkaoff()	{
		sarrowdir=null;
		timtick.stop(false);
		fxrew.stop(false);
		this.<_sob+"_"+_sdir+"_MOVEOFF">();
	}
	timfin()	{
		if( this.getlock() )	{	return;	}
		bool bok = false;
		if( sarrowdir!=null && !<sgr>.empty())	{
			if( sarrowdir=="up")	{
				if( <sgr>.getey() > andownstd.getpy() - ileny )	{
					<sgr>.move(0,-ileny);
					bok=true;
				}
			} else if (sarrowdir=="down") {
				if( <sgr>.getpy() < ilimy )	{
					<sgr>.move(0,ileny);
					bok=true;
				}
			} else if (sarrowdir=="left")	{
				if( <sgr>.getex() > andownstd.getpx() - ilenx )	{
					<sgr>.move(-ilenx,0);
					bok=true;
				}
			} else if (sarrowdir=="right") {
				if( <sgr>.getpx() < ilimx )	{
					<sgr>.move(ilenx,0);
					bok=true;
				}
			}
		}
		if( bok )	{
			if( !fxrew.isplaying() )	fxrew.play();
		} else {
			fxrew.stop(false);
		}
		this.play();
	}
}

class ConRewinder : Rewinder, ObjController {
	init()	{
		Rewinder::init();
		ObjController::init();
		new DelayTaker cldt; 
	}
	public getitem(string s, int x, int y)	{
		Rewinder::getitem(s,x,y);
		cldt.take();
	}
	_put()	{
		cldt.ret();
		this.<this + "_PUT">();
	}
	onmousemove()	{	this.moveitem();	}
	onmouselrel()	{
		if( this.getlock() )	return;
		if( cldt.isonrel() )	{	this._put();	}
	}
	onmouselclick()	{
		if( this.getlock() ) return;
		if( cldt.isonclick() )	{
			this._put();
		} else if ( !cldt.istaken() )	{
			this.<this+"_GET">();
		}
	}
}

class Button : LObjController	{
	init	{
		LObjController::init;
		.unlock;
		new gmimgvec grbuts;
		.vars2(A,"sobject", null, "sclicked",null,"bcheck2klik", 0);
		
		new int ipadclick = 0;
	}
	print		{	grbuts.print;		}
	sort		{	grbuts.sortimgs;	}
	addgroups	{	grbuts.addgroups;	grbuts.sortimgs;	}
	addgroup(string s)	{	grbuts.addgr(s);	grbuts.sortimgs;	}
	addlist		{	grbuts.addlist;		grbuts.sortimgs;	}
	add(string sob)	{	grbuts.add(sob);	grbuts.sortimgs;	}
	addonce(string sob)	{ grbuts.addonce(sob);	grbuts.sortimgs;	}
	addbut(string sob)	{ grbuts.addonce(sob);	grbuts.sortimgs;	}
	contains(string sob)	{ grbuts.contains(sob);	}
	addlocker(string sob)	{
		.add(sob);
		classlocker::setaslocker(sob);
	}
	removebutlist	{	.withlist("removebut"); }
	removebut(string sbut)	{
		grbuts.remove(sbut);
		bool b = (sobject!=null || sclicked!=null);
		if( sbut==sobject ) sobject=null;
		if( sbut==sclicked ) sclicked = null;
		if( b )	{
			.onmousemove;
		}
	}
	removebutmoveoff(string sbut)	{
		grbuts.remove(sbut);
		.checkmoveoff(sbut);
	}
	checkmoveoff(string sbut)	{
		if( sbut==sobject )	{
			.lastoff;
			.onmousemove;
		}
	}
	load(string sname, string sfile, string sfuninit) {
		<GAME>.varnew("gmimgvec", sname);
		sname .* sfile;
		<sname>.each( sfuninit );
		.addgroup(sname);
	}
	remove(string sname)	{
		if( <GAME>.hasvar(sname) )	{
			//for( int i=0; i < <sname>.size; i++ )	grbuts.remove( <sname>.get(i) );
			grbuts.removegr(sname);
		}
	}
	loadfrom(string sname, string spath, string sfile, string sfuninit) {
		@s = .getgraphpath;
		.setgraphpath(spath);
		.load(sname,sfile,sfuninit);
		.setgraphpath(s);
	}
	onmouselclick	{
		if( .getlock ) return;
		
		if( .checktouchpad && bcheck2klik )	{
			if( ipadclick )	{
				@s = sobject;
				//.onmousemove;
				if( s==sobject )	{
					ipadclick=0;
					._butmouselclick;
				} else if ( sobject==null )	{
					ipadclick=0;
				}
			} else {
				ipadclick=1;
				//.onmousemove;
			}
		} else {
			._butmouselclick;
		}
	}
	_butmouselclick	{
		.<this + "_lclick">;
		if( sobject!=null)	{
			sclicked = sobject;
			if (<sobject>.hasaddedmet("butclick") )
				<sobject>.butclick;
		}
	}
	onmouselrel	{
		if( .getlock ) return;
		if( .checktouchpad )	{
			.lastoff;
		}
		.<this + "_lrel">;
		if( sclicked!=null && <sclicked>.hasaddedmet("butlrel") )	{
			<sclicked>.butlrel;
		} else sclicked=null;
	}
	onmousemove	{
		if( .getlock ) return;
		if( sclicked!=null )	{
			if( <sclicked>.hasaddedmet("butmoving") )	<sclicked>.butmoving;
		}
		|int x, int y| = mouse.getpos;
		if(grbuts.isinfunc(x,y,"isbutin") )	{
			@s = grbuts.getsfound;
			if( s!=sobject )	{
				.lastoff;
				sobject = s;
				.<this + "_moveon">;
 				if( <s>.hasaddedmet("butmoveon") )
					<s>.butmoveon;
			}
		} else {
			.lastoff;
		}
	}
	lastoff	{
		if( sobject!=null )	{
			.<this + "_moveoff">;
			if( <sobject>.hasaddedmet("butmoveoff") )
				<sobject>.butmoveoff;
			sobject = null;
		}
	}
	refresh	{
		.lastoff;
		.onmousemove;
	}
	/*
	virtual bool isbutin(int x, int y)	{ 0; }
	virtual butclick	{}
	virtual butmoveon {}
	virtual butmoveoff {}*/
}

public Button_isin		{	.addmethod("isbutin", func { (@x,@y) .isin(x,y,1,0); } );	}
public Button_isinvis		{	.addmethod("isbutin", func { (@x,@y) .isin(x,y,0,0); } );	}
public Button_isinalpha		{	.addmethod("isbutin", func { (@x,@y) .isin(x,y,1,1); } );	}
public Button_isinvisalpha	{	.addmethod("isbutin", func { (@x,@y) .isin(x,y,0,1); } );	}
public Button_moveon		{
	.addmethod("butmoveon", func {
		sndfxmoveonms.playif;
		advmouse.setbut;
		if( .nofframes(-1)>1 ) .setframe(-1,1);
	} );
}
public Button_moveonstate		{
	.addmethod("butmoveon", func {
		if( .advstdstate )	{
			sndfxmoveonms.playif;
			advmouse.setbut;
			if( .nofframes(-1)>1 ) .setframe(-1,1);
		}
	} );
}
public Button_moveonplay		{
	.addmethod("butmoveon", func {
		sndfxmoveonms.play;
		advmouse.setbut;
		if( .isplaying(-1)==false ) .play(-1);
	} );
}
public Button_moveoff		{	.addmethod("butmoveoff", func { advmouse.setstd; .setframe(-1,0);} );	}
public Button_moveonms		{	.addmethod("butmoveon", func { advmouse.setbut; } );			}
public Button_moveonfxms	{	.addmethod("butmoveon", func { advmouse.setbut; sndfxmoveonms.playif; } ); }
public Button_moveonfxmstate	{
	.addmethod("butmoveon", func {
		if( .advstdstate )	{
			advmouse.setbut; 
			sndfxmoveonms.playif; 
		}
		} );
	}
public Button_moveoffms		{	.addmethod("butmoveoff", func { advmouse.setstd; } );			}
public Button_std		{	.Button_isin; .Button_moveon; .Button_moveoff;				}
public Button_stdstate		{	.Button_isin; .Button_moveonstate; .Button_moveoff;				}
public Button_stdalpha		{	.Button_isinalpha; .Button_moveon; .Button_moveoff;			}
public Button_stdms		{	.Button_isinalpha; .Button_moveonms; .Button_moveoffms;			}
public Button_stdmstate		{	.Button_isinalpha; .Button_moveonmstate; .Button_moveoffms;			}
public Button_stdclick		{	.addmethod("butclick", "Button_butclick" );		}
public Button_addstd	{
	.Button_std;
	.Button_stdclick;
	butgame.add(this);
}
public Button_addstdalpha	{
	.Button_stdalpha;
	.Button_stdclick;
	butgame.add(this);
}
public Button_addstdstate	{
	.Button_stdstate;
	.addmethod("butclick", func {
		if( .advstdstate )	{
			sndfxbutclick1.playif;
			.Button_butclick;
		} else .<"butclick_nostdstate_"+this>;
		} );
	butgame.add(this);
}
public Button_butclick		{	.<"butclick_"+this>;	}
public Button_butmoveon		{	.<"butmoveon_"+this>;	}
public Button_butmoveoff	{	.<"butmoveoff_"+this>;	}

class Buttons : LObjController	{
	init(string sfile)	{
		LObjController::init;
		.unlock;
		new gmimgvec grbuts;
		new int __id = 0;
		new string sanbut = "anbut";
		.newanima(sanbut, sfile, 10);
		_ = .newanactionsgr(sanbut, sanbut, "grbuts");
		anbut.hide;
		grbuts.setz(10);
		grbuts.removeif( func {
			if( .actionname=="bkg" ) { .setz( .getz-1); true; }
			else false; 
			});
		new string slastb = null;
		.vars2(A,"sobject", null, "bvisible", true, "balpha", true);
		
		new int ipadclick = 0;
		.var2("bcheck2klik", false);
	}
	_release()	{
		if( .checktouchpad )	{
			ipadclick = 0;
		}
		<slastb>.setframe(-1,0);
		.copyobj;
		.<this + "_moveoff">();
		slastb = null;
		//bsms.setstd;
		advmouse.setstd;
	}
	getbut	{	grbuts.getsfound;	}
	onmousemove()	{
		if( .getlock ) return;
		grbuts.setframe(-1,0);
		def id =  grbuts.isin(mouse.getpos,bvisible,balpha);
		if( slastb!=null ) <slastb>.setframe(-1, 1);
		if( id ) {
			string s = grbuts.getsfound;
			if( s!=slastb )	{
				if( slastb!=null )	._release;
				slastb = s;
				<s>.setframe(-1,1);
				.copyobj;
				//bsms.setact;
				advmouse.setact;
				.<this + "_moveon">();
			}
		} else if( slastb!=null )	{
			._release;
		}
		//slastb==null ? bsms.setstd : bsms.setact;
	}
	copyobj()	{	sobject = <slastb>.actionname;	}
	onmouselclick()	{
		if( .getlock ) return;
		
		if( .checktouchpad && bcheck2klik )	{
			if( ipadclick )	{
				ipadclick=0;
				._butmouselclick;
			} else {
				ipadclick=1;
				.onmousemove;
			}
		} else {
			._butmouselclick;
		}
	}
	_butmouselclick	{
		if( slastb!=null )	{
			.copyobj;
			.<this + "_lclick">;
		}
	}
	onmouselrel	{
		if( .getlock ) return;
		if( slastb!=null )	{
			.copyobj;
			.<this + "_lrel">;
		}
	}
	disable	{
		.lock;
		grbuts.hide;
		if( slastb!=null )	{
			//bsms.setstd;
			advmouse.setstd;
			slastb=null;
		}
	}
	enable	{
		.unlock;
		grbuts.show;
	}
}

class TextDb : classlocker, ObjController, gfxObject {
	init(string sfont, int isize, string sdbfile, int r, int g, int b, int x, int y, int dy, int z, string sdir)	{
		classlocker::init;
		ObjController::init;
		new string sFont = sfont;
		new string sFontBold = null;
		new string sFontItalic = null;
		new string sFontBoldItalic = null;
		new bool bhtml = false;
		
		string s;
		int id, int i;
		if( sfont.contains("$") )	{
			bhtml = true;
			new vector vfont; vfont.type("string");
			vfont.vecbuildfromstring( sfont, "$" );
			
			for( i=0; i<vfont.size; i++)	{
				s = vfont.get(i);
				if( s.contains("_italic") && s.contains("_bold") )	{
					sFontBoldItalic = s;
				} else if ( s.contains("_italic") )	{
					sFontItalic = s;
				} else if ( s.contains("_bold") )	{
					sFontBold = s;
				} else sFont = s;
			}
			if( sFont.contains("$") )	{
				if( sFontItalic!=null ) sFont = sFontItalic;
				else if( sFontBold!=null ) sFont = sFontBold;
				else sFont = sFontBoldItalic;
			}
			sfont = sFont;
		} else sfont = .checkfont( sfont, isize );
		new int iFontSize = isize;
		
		.var2("Z",z);
		string skey = null;
		if( sdbfile.contains(":") )	{
			skey = sdbfile.strgetto(":") + ":";
		}
		if( sdbfile.contains(".db") )	{
			if( skey =="$path:" )	{
				new db dbtxt;
				dbtxt.load( sdbfile.strsubbs(skey) );
			} else .newdb( "dbtxt", sdbfile );
		} else {
			match(skey)	{
				"$lang:" => .lang_db("dbtxt", sdbfile.strsubbs(skey) );
				"$var:" => {
					new db dbtxt;
					dbtxt.dbcopy( sdbfile.strsubbs(skey) );
				}
				"$row:" => {
					new db dbtxt;
					s = sdbfile.strsubbs(skey)->strgetto(",");
					id = sdbfile.strgetfrom(",");
					for( i=0; i< <s>.getcolsno(id); i++)	{
						_ = dbtxt.addrow;
						dbtxt.add(i, <s>.get(id,i) );
					}
				}
				? => {
					new db dbtxt;
					dbtxt.dbaddlast( sdbfile );
				}
			}
		}
		int w = 0, int ile = dbtxt.getrowsno;
		
		if( sdir.getb(0,5)=="limit" )	{
			int lim = sdir.strsubbs("limit_");
			new vector vtmp; vtmp.type("string");
			new vector vtmp2; vtmp2.type("string");
			for( int i=0; i<dbtxt.getrowsno; i++)	{
				vtmp.vecbuildfromstring( dbtxt.get(i,0), " " );
				for( int j=0; j<vtmp.size; j++)
					vtmp2.add(vtmp.get(j));
			}
			dbtxt.free;
			string s = "";
			string s2;
			for( i=0; i<vtmp2.size; i++)	{
				s2 = vtmp2.get(i);
				if( (s+s2)->length < lim )	{
					s += s2 + " ";
				} else {
					j = dbtxt.addrow-1;
					dbtxt.add(j, s);
					s = s2 + " ";
				}
			}
			j = dbtxt.addrow-1;
			dbtxt.add(j, s);
			ile = dbtxt.getrowsno;
		}
		
		new gmimgvec grtxt;
		grtxt._setpos(x,y);
		for( i=0; i< ile; i++)	{
			s = "txt" + i;
			new text <s>;
			@s1 = dbtxt.get(i,0);
			if( bhtml )	{
				if( s1.contains("<b>") ) { sfont = sFontBold; s1.strremove("<b>"); }
				else if( s1.contains("<bi>") ) { sfont = sFontBoldItalic; s1.strremove("<bi>"); }
				else if( s1.contains("<i>") ) { sfont = sFontItalic; s1.strremove("<i>"); }
				else sfont = sFont;
			}
			<s>.setfont( sfont );
			
			<s>.set( s1 );
			<s>.setpos(x,y);
			y+=isize+dy;
			<s>.setz(z);
			<s>.createtxt(r,g,b);
			if( <s>.getw>w ) w = <s>.getw;
			grtxt.add(s);
		}
		.var2("Rows", ile);
		if( sdir == "right" || sdir =="center" )	{
			for( i=0; i<ile; i++)	{
				s = "txt" + i;
				if( sdir == "center" )	{
					<s>.move( (w-<s>.getw)/2, 0 );
				} else {
					<s>.move( w-<s>.getw, 0 );
				}
			}
		}
		.var2("W", w);
		gfxObject::init("grtxt");
	}
	stdshadow(int dt)	{	.setshadow(0,0,0,dt);	}
	setshadow(int r, int g, int b, int dt)	{
		string s[2];
		string sfont = ._checkfont(sFont, iFontSize, "_fntbrd");
		for( int i=0; i< dbtxt.getrowsno; i++)	{
			s0 = "txt" + i;
			s1 = "txts" + i;
			new text <s1>;
			<s1>.set( <s0>.get );
			<s1>.setfont( sfont );
			<s1>.setz( <s0>.getz-1 );
			<s1>.setpos( <s0>.getpx+dt, <s0>.getpy+dt );
			<s1>.createtxt(r,g,b);
			grtxt.add(s1);
		}
	}
	setz(int z)	{
		/*for( int i=0; i< dbtxt.getrowsno; i++)	{
			<"txt" + i>.setz(z);
			<"txts" + i>.setz(z-1);
		}*/
		Z = z;
		grtxt.setz(z);
	}
	getz	{ Z;	}
	isin(int x, int y, bool bv, bool ba)	{	grtxt.isin(x,y,bv,ba);	}
	view	{
		@s = _;
		string s2;
		while(A!=s)	{
			s2 = grtxt.get(s);
			<s2>.show;
			s2 = "txts" + s2.strsubbs("txt");
			if( engine.varexist(s2) ) <s2>.show;
			@s=_;
		}
	}
	blitto(string simg)	{
		string s;
		for( int i=0; i<grtxt.size; i++)	{
			s = grtxt.get(i);
			<s>.buildfullname;
			<simg>.blit(<s>.getfullname);
			<GAME>.vardel(<s>.getfullname);
		}
	}
	setcol(int r, int g, int b)	{
		for( int i=0; i<grtxt.size; i++) <grtxt.get(i)>.createtxt(r,g,b);
	}
	clip(int x1, int y1, int x2, int y2)	{
		for( int i=0; i<grtxt.size; i++) <grtxt.get(i)>.clip(x1,y1,x2,y2);
	}
	setpos(int x, int y)	{
		@dx = x-grtxt.getposx;
		@dy = y-grtxt.getposy;
		grtxt.move(dx, dy);
		//for( int i=0; i<grtxt.size; i++) <grtxt.get(i)>.setpos(x+,y1,x2,y2);
	}
}

class Lexer	{
	init	{}
	buildlex	{
		.vars(A,"id","found");
		new vector vconsts;
		vconsts.type("string");
		new vector vtmp1;
		vtmp1.type("string");
		new vector vtmp2;
		vtmp2.type("string");
		
		new int dot = "."->getbyte(0);
		new string _literal_char = "\"";
	}
	setliteralchar(string s)	{	_literal_char=s;	}
	getliteralchar	{	_literal_char;	}
	bool _isvar(int b1, int b2)	{
		int i = id;
		found = "";
		int ib;
		while(i<.length)	{
			ib = .getbyte(i);
			if( ib>=b1 && ib<=b2 )	{
				found += .getb(i,1);
				i++;
			} else {
				if( (ib>=BYTEa && ib<=BYTEz) || (ib>=BYTEA && ib<=BYTEZ) || ib==BYTE_ )	found="";
				i = .length;
			}
		}
		found.length;
	}
	bool isreal	{
		int i = id;
		found = "";
		int ib;
		bool kropka=true;
		while(i<.length)	{
			ib = .getbyte(i);
			if( (ib>=BYTE0 && ib<=BYTE9) || (ib==dot&&kropka) )	{
				if( ib==dot ) kropka=false;
				found += .getb(i,1);
				i++;
			} else i = .length;
		}
		if( kropka || found.getb(0,1)=="." || found.gete(0,1)=="." ) found="";
		found.length;
	}
	bool isident	{
		int i = id;
		found = "";
		int ib;
		while(i<.length)	{
			ib = .getbyte(i);
			if( (ib>=BYTEa && ib<=BYTEz) || (ib>=BYTEA && ib<=BYTEZ) || ib==BYTE_ ||
				(i>id && ib>=BYTE0 && ib<=BYTE9) )	{
				found += .getb(i,1);
				i++;
			} else i = .length;
		}
		found.length;
	}
	bool isliteral	{
		if( .check!=.getliteralchar )	return false;
		int i = id+1;
		found = "";
		string s;
		while(i<.length)	{
			s = .getb(i,1);
			if( s==.getliteralchar )	{
				//found += s;
				return true;
			} else {
				found += s;
				i++;
			}
		}
		false;
	}
	bool isconst	{
		string s0;
		bool b = .isident;
		for( int i=0; i< vconsts.size; i++)	{
			s0 = vconsts.get(i);
			if( b )	{
				if( s0 == found )	return true;
			} else {
				found = .getb(id, s0.length);
				if( s0 == found ) return true;
			}
		}
		false;
	}
	gettoken(string svec, bool bideal)	{
		<svec>.free;
		while( .notend )	{
			if (.check==" ")	id++;
			else if (.isconst)	{	<svec>.add("$const"); <svec>.add(.read);	}
			else if (.isreal )		{<svec>.add( "$real" );	.next; if( bideal ) <svec>.add( found );}
			else if (.isint )		{<svec>.add( "$int" );	.next; if( bideal ) <svec>.add( found );}
			else if (.isident )	{<svec>.add( "$alpha" );	.next; if( bideal ) <svec>.add( found );}
			else if (.isliteral )	{<svec>.add( "$literal" );	.next; id+=2; if( bideal ) <svec>.add( found );}
			else	{<svec>.add("$error"); id++; }
		}
	}
	int expectdb(string sdb, bool bideal)	{	// identyczne lub parse
		int j, string s;
		for( int i=0; i< <sdb>.getrowsno; i++)	{
			//vtmp2.veccopydbrow(sdb,i);
			vtmp2.free;
			for( j=0; j< <sdb>.getcolsno(i); j++)	{
				s = <sdb>.get(i,j);
				s.clear;
				if( s!="" ) vtmp2.add(s);
			}
			if( .expectvec("vtmp2", bideal) )	return i;
		}
		-1;
	}
	bool expectvec(string svecsrc, bool bideal)	{
		id = 0;
		.gettoken("vtmp1", bideal);
		/*vtmp1.print;
		<svecsrc>.print;*/
		vtmp1.veceq(svecsrc);
		/*bool b = vtmp1.veceq(svecsrc);
		if( !b ) {
			("wrong expect "+.get)->print;
			vtmp1.print;
			<svecsrc>.print;
		}
		b;*/
	}
	bool expects(string s, string ssep, bool bideal)	{
		vtmp2.vecbuildfromstring(s,ssep);
		.expectvec("vtmp2", bideal);
	}
	consts=	{	vconsts.withlist("addbegin");	}
	setas(string sob)	{
		<sob>.addmethod("buildlex", "buildlex");
		<sob>.buildlex;
		<sob>.addmethod("start",	func { (string s) .set(s);	id=0; } );
		<sob>.addmethod("notend",	func {	id<.length;	} );
		<sob>.addmethod("getnext",	func { if( id==.length ) return null;
					id++;	.getb(id-1,1);	} );
		<sob>.addmethod("next",	func { id+=found.length;	} );
		<sob>.addmethod("check",	func { if( id==.length ) return null; found=.getb(id,1); found; });
		<sob>.addmethod("ischar",	func { (string s) s.contains( .getb(id,1) ); } );
		<sob>.addmethod("isint",	func{	._isvar(BYTE0, BYTE9);	} );
		<sob>.addmethod("isreal", "isreal");
		<sob>.addmethod("isbinary",	func{	._isvar(BYTE0, BYTE0+1);	} );
		<sob>.addmethod("isident",	"isident" );
		<sob>.addmethod("isconst",	"isconst" );
		<sob>.addmethod("_isvar", "_isvar");
		<sob>.addmethod("read",	func { .next;	found;	} );
		<sob>.addmethod("isliteral", "isliteral");
		<sob>.addmethod("gettoken", "gettoken");
		<sob>.addmethod("expects", "expects");
		<sob>.addmethod("expectvec", "expectvec");
		<sob>.addmethod("expectdb", "expectdb");
		<sob>.addmethod("consts=", "consts=");
		<sob>.addmethod("setliteralchar", "setliteralchar");
		<sob>.addmethod("getliteralchar", "getliteralchar");
	}
}


class AnimaFx	{
	init {}
	build(string san)	{
		<san>.addmethod("_buildanfx", func {
			new db dbsnd;
			dbsnd.dbbuild(3);
			for( int i=0; i<dbsnd.getrowsno; i++) dbsnd.set(i,0, dbsnd.get(i,0)+"_"+dbsnd.get(i,1));
			} );
		<san>._buildanfx;
		<san>.addmethod("onsetframe", func {
			@id = dbsnd.findbyrow(.actionname+"_"+.framenr);
			if( id>=0 ) {
				<"fx"+dbsnd.get(id,2)>.play;
			}
			} );
	}
}

class Localize	{
	init	{}
	_lang_db(string sname, string sfile, string sfunload)	{
		new db <sname>;
		<sname>.<"load"+sfunload>( .lang_path(sfile) + ".db");
	}
	lang_db(string sname, string sfile)	{ ._lang_db(sname,sfile,"");	}
	lang_dbscript(string sname, string sfile)	{ ._lang_db(sname,sfile,"script");	}
	lang_dbbeh(string sname, string sfile)	{ ._lang_db(sname,sfile,"beh");	}
	lang_path(string sfile)	{ LANGDIR + gameapi.getgamename + "_" + sfile; }
}

class PyzCounter	{
	init(string sanima, int timestep)	{
		new int istart;
		new int istop;
		new int istep;
		new int idigits = 50;
		new int iactual;
		new string _sanima = sanima;
		.vars2(A, "idx",2, "itimestep", timestep);
		
		new gmimgvec grcnt;
		for( int i=0; i<idigits; i++ )	{
			string s = "pcc" + sanima + i;
			.copyanima(sanima, s);
			<s>.hide;
			grcnt.add(s);
		}
		.timer = ("timcnt", timestep, func {
			iactual += istep;
			.view(iactual);
			if( iactual==istop )	{
				<.getbuildername>.<.getbuildername+"_finish">;
			} else .play;
			} );
	}
	getcypher(int id)	{	"pcc" + _sanima + id;	}
	start(int start, int stop, int step)	{
		istart = start;
		istop = stop;
		istep = step;
		iactual = istart;
		.view(istart);
		timcnt.play;
	}
	showcypher(int i, int cypher)	{
		string s = .getcypher(i);
		<s>.setframe(0, cypher);
		<s>.show;
	}
	stop	{
		timcnt.stop(false);
	}
	view(int cnt)	{
		grcnt.hide;
		grcnt.setpos(0,0);
		if( cnt==0 )	{
			.showcypher(0,0);
		} else {
			for( int i=0; cnt > 0; i++ )	{
				.showcypher(i, cnt%10);
				cnt=cnt/10;
			}
			int w = 0;
			for( int j=i-1; j>=0; j-- )	{
				<.getcypher(j)>.move( w, 0 );
				w = w + <.getcypher(j+1)>.getw;
			}
		}
	}
}
/*************************************************************************/

class AnMover	{
	init(string san, real x, real y)	{
		new timer tmov;
		tmov.settick(1);
		tmov.setcycle(1);
		//new real rdx = x;
		//new real rdy = y;
		.vars2(A, "rdx", x, "rdy", y);
		new real rsx = 0;
		new real rsy = 0;
		new string sanima = san;
		tmov.addmethod("onfinish", func {
			.move;
			.builder_func("_finish");
			.play;
			} );
	}
	move	{
		rsx += rdx;
		rsy +=rdy;
		int x = rsx;
		int y = rsy;
		if( x || y ) {
			<sanima>.move(x,y);
			rsx-=x;
			rsy-=y;
		}
	}
	reset	{
		rsx=0;
		rsy=0;
	}
	play	{
		.reset;
		tmov.play;
	}
	stop	{	tmov.stop(false);	}
	enableroll	{	.addmethod( this + "_finish", func { .roll(0,0); } );	}
	roll(int dx, int dy)	{
		if( rdx < 0 && <sanima>.getex < 0 ) <sanima>.ansetbpos( igmappw + dx, <sanima>.getpy );
		else if ( rdx > 0 && <sanima>.getpx >= igmappw ) <sanima>.ansetbpos( dx - <sanima>.getw, <sanima>.getpy );
		if( rdy < 0 && <sanima>.getey < 0 ) <sanima>.ansetbpos( <sanima>.getpx, igmapph + dy );
		else if ( rdy > 0 && <sanima>.getpy >= igmapph ) <sanima>.ansetbpos( <sanima>.getpx, dy - <sanima>.geth );
	}
}

public SetAnMover_tmov_onfinish	{	<.getbuildername>.sam_move; .play;	}
class SetAnMover	{
	init	{}
	setas(string sanima, real x, real y)	{
		<sanima>.addmethod("setanmover", "setanmover");
		<sanima>.setanmover(x,y);
		<sanima>.addmethod("sam_move", "sam_move");
		<sanima>.addmethod("sam_copy", "sam_copy");
		<sanima>.addmethod("sam_addtimer", func {
			new timer tmov;
			tmov.settick(1);
			tmov.setcycle(1);
			tmov.addmethod("onfinish", "SetAnMover_tmov_onfinish" );
			} );
		<sanima>.addmethod("sam_playtimer", func { tmov.play; }		);
		<sanima>.addmethod("sam_stoptimer", func { tmov.stop(false); }	);
	}
	setanmover(real x, real y)	{
		new real rdx = x;
		new real rdy = y;
		new real rsx = 0;
		new real rsy = 0;
		.var2("sam_speed", 1.0);
	}
	sam_move	{
		rsx += (rdx*sam_speed);
		rsy += (rdy*sam_speed);
		int x = rsx;
		int y = rsy;
		if( x || y ) {
			.move(x,y);
			rsx-=x;
			rsy-=y;
			if( .hasvar("ansamcopy") )	{
				ansamcopy.move(x,y);
				if( rdx>0 )	{
					if( ansamcopy.getpx > rollerx )	{
						@dx = ansamcopy.getpx -.getw;
						ansamcopy.move( dx, 0 );
						.move( dx, 0 );
					}
				}
			}
		}
	}
	sam_copy	{
		.vars2(A, "rollerx", 0, "rollerex", igmappw);
		.copyanima(this, "ansamcopy");
		ansamcopy.show;
		if( rdx>0 )	{
			ansamcopy.ansetbpos( .getpx - .getw, .getpy );
			//("act: "+.actionname + ","+ansamcopy.actionname + " z: "+.getz+","+ansamcopy.getz+" x: "+.getpx+","+ansamcopy.getpx)->print;
		}
	}
}

/*************************************************************************/
class classlives	{
	init()	{}
	set(int ile, int idamage, int x, int y, int h, int r1, int g1, int b1, int a1, int r2, int g2, int b2, int a2, int z, string sside)	{
		new int iside;
		
		if( sside=="left")iside=-1;
		else	iside=1;
		
		new int iilezyc = ile;
		new int ibum	= idamage;
		int idl = iilezyc*ibum;
		new int iposxsila = x;
		new int iendxsila = x+idl;
		new int iposysila = y;
		newvars::newcanvas( "imgsilapodkladka",idl, h, r1, g1, b1, a1, z-1 );
		newvars::newcanvas( "imgsila",idl, h, r2, g2, b2, a2, z );
		imgsila.setpos( iposxsila, iposysila );
		imgsila.clip(iposxsila, 0,  imgsila.getex(), 600);
		imgsilapodkladka.setpos( iposxsila, iposysila );
	}
	reset()	{
		imgsila.setpos( iposxsila, iposysila );
	}
	damage(int idam)	{
		imgsila.move( iside*idam*ibum, 0);
	}
	int destroyed()	{
		if( iside<0)	return imgsila.getex() < iposxsila;
		return imgsila.getpx() > iendxsila;
	}
	heal(int idam)	{
		imgsila.move( -iside*idam*ibum, 0 );
		if( iside > 0 )	{
			if( imgsila.getpx() < iposxsila )	{
				imgsila.setpos( iposxsila, iposysila );
			}
		} else {
			if( imgsila.getpx() > iposxsila )	{
				imgsila.setpos( iposxsila, iposysila );
			}
		}
	}
}


class imganima : gmimgvec	{
	init	{
		gmimgvec::init;
		new int idgran = 0;
		new timer timan;
		timan.settick(1);
		timan.addmethod("onfinish", func {
			idgran++;
			@s = .getbuildername;
			if( idgran == <s>.size )	{
				<s>.<s+"_finish">;
			} else {
				.setframe(idgran);
				<s>.<s+"_endframe">;
				.play;
			}
			} );
	}
	load(string simg, string sfiletype, int istart, int istop, int icycle)	{
		timan.setcycle(icycle);
		for( int i=istart; i<istop; i++)	{
			@s = simg + i;
			.newimg("an" + s, s + "." + sfiletype, 0);
			.add("an" + s);
		}
		.setframe(0);
	}
	play	{
		.setframe(0);
		timan.play;
	}
	setframe(int id)	{
		.hide;
		idgran = id;
		<.get(id)>.show;
	}
}


class GuiItem	{
	init	{}
	/****************** rotujacy obiekt **************************/
	setasrototaker(string sanima, real ilerot, real ileobrotow)	{
		<sanima>.addmethod("_setasrototaker", func { (@ilerot, @ileobrotow)
			.vars2(A, "ilerotos",ilerot, "idrotos", 0.0, "ikatos", (ileobrotow*360.0)/ilerot,
				"rzoomx", 0.0, "rzoomy", 0.0, "rzoomstepx", 0.0, "rzoomstepy", 0.0,
				"rmovx", 0.0, "rmovy", 0.0, "istartalfa", 128,
				"iendx", 0.0, "iendy", 0.0,
				"irotodir", 1, "izoomdir", 0);
			new filter ftroto;
			ftroto.setpivottype(2);
			
			new timer timrotocenter;
			timrotocenter.setcycle(1);
			timrotocenter.addmethod("onfinish", func {
				if( <.getbuildername>.rototaker_setroto )
					.play;
				} );
			//SetAnMover::setas(this, 0.0, 0.0);
			} );
		<sanima>._setasrototaker(ilerot, ileobrotow);
		<sanima>.addmethod("rototaker_start", "rototaker_start");
		<sanima>.addmethod("rototaker_startwh", "rototaker_startwh");
		<sanima>.addmethod("rototaker_startact", "rototaker_startact");
		<sanima>.addmethod("rototaker_setroto", "rototaker_setroto");
		<sanima>.addmethod("rototaker_endroto", func { .<"rototaker_"+ this + "_endroto">; } );	// std funkcja, mozna podmienic
	}
	bool rototaker_setroto	{
		if( izoomdir )	{
			@r = idrotos/ilerotos;
			@rx = rzoomx + rzoomstepx*r;
			@ry = rzoomy + rzoomstepy*r;
			ftroto.rotatezoomxy( irotodir*ikatos, rx, ry );
		} else {
			@r = (ilerotos-idrotos);
			@rx = rzoomx + rzoomstepx*r;
			@ry = rzoomy + rzoomstepy*r;
			ftroto.rotatezoomxy( irotodir*ikatos, rx, ry );
			r = idrotos/ilerotos;
		}
		if( istartalfa<255 )	{
			real iop = istartalfa;
			ftroto.setopacity( iop + (255.0-iop) * r );
		}
		//.move(rmovx, rmovy);
		real r1 = (iendx - .getposx) * r * rx;
		real r2 = (iendy - .getposy) * r * ry;
		.move(r1, r2);
		idrotos++;
		if( idrotos<ilerotos ) true;
		else {
			ftroto.unlink;
			.rototaker_endroto;
			false;
		}
	}
	rototaker_startact(int endx, int endy, def sact)	{
		string sact2;
		if( sact.gettype!="string" )	{
			sact2 = .nameofaction(sact);
		} else sact2 = sact;
		.rototaker_start( .getpx, .getpy, endx, endy, .getw, .geth, sact2 );
	}
	rototaker_start(int startx, int starty, int endx, int endy, real startw, real starth, string sact)	{
		.setframe(sact,0);
		.setpos(startx,starty);
		.rototaker_startwh(endx, endy, startw, starth, .getw, .geth);
	}
	rototaker_startwh(int endx, int endy, real startw, real starth, real endw, real endh)	{
		iendx = endx;
		iendy = endy;
		rmovx = ( endx-.getcx)->to_r/ilerotos;
		rmovy = ( endy-.getcy)->to_r/ilerotos;
		
		if( endw>startw )	{
			rzoomx = startw/endw;
			rzoomstepx = (endw-startw)/endw;
			izoomdir=1;
		} else {
			izoomdir=0;
			rzoomx = endw/startw;
			rzoomstepx = (1.0-rzoomx)/ilerotos;
		}
		if( endh > starth )	{
			rzoomy = starth/endh;
			rzoomstepy = (endh-starth)/endh;
		} else {
			rzoomy = endh/starth;
			rzoomstepy = (1.0-rzoomy)/ilerotos;
		}
		
		ftroto.link(this);
		
		idrotos = 0;
		if( .rototaker_setroto )
			timrotocenter.play;
	}
}


class CalcFPS	{
	init	{
		new real rfps1;
		new real rfps2;
		new real rfps3;
		new real rsec = 1000.0;
		new real rstart = 1.0;
		.cycle = ("tickfps", func {	<.getbuildername>.tick; .play;	});
	}
	stdset(int size, int posx, int posy)	{	.set(.stdfont(size), .white, posx, posy, 1000);	}
	set(string sfont, int r, int g, int b, int posx, int posy, int z)	{
		.newtext("txtfps", 0, sfont, r,g,b);
		txtfps.setz(z);
		.setpos(posx,posy);
	}
	setpos(int x, int y)	{ txtfps.setpos(x,y);	}
	tick	{
		real rstop = engine.getticks;
		if( rstop>rstart )	{
			rfps1 = rfps2;
			rfps2 = rfps3;
			rfps3 = rsec/(rstop-rstart);
			//txtfps.txtset( rsec/(rstop-rstart) );
			txtfps.txtset( "delay: "+(rstop-rstart)+ " fps: "+ (rfps1+rfps2+rfps3)/3);
		} else txtfps.txtset( "inf" );
		rstart = rstop;
	}
	play	{	tickfps.play;	}
	stop	{	tickfps.stop(false);	}
}

class Film : gfxObject	{
	init	{
		new img imfilm;
		imfilm.buildfullname;
		gfxObject::init("imfilm");
		
		new string sfilmpath;
		new db dbfilm;
		new db dbfilm2;
		
		new int istartklatka;
		new int iklatka;
		new int iendklatka;
		new string sprefilm;
		new int ifilmcycle; 
		new string smusic;
		
		new int igameloopdelay = igmdelay;
		
		new gmobjvec grsfx;
		new gmimgvec grbuf;
		
		.vars2(A, "bcenter", 0, "bborders", 0, "musicclass", null, "bbuffer", 0, "sfileformat", "jpg" );
		
		.cycle = ("timfilm", func {
			.nextframe;
			if( iklatka<=iendklatka )	{
				timfilm.play;
			} else {
				.retfps;
				@s = .getbuildername;
				if( <s>.hasaddedmet("onfinish") )	{
					<s>.onfinish;
				}
			}
			} );
	}
	bufferfilm	{
		
	}
	retfps	{	engine.setloopdelay(igameloopdelay);	}
	setfilmfps	{
		igameloopdelay = engine.getloopdelay;
		int ifps = dbfilm.dbgetint("fps:");
		if( ifps>0 )
			engine.setfps(ifps);
	}
	setcycle(int icycle)	{
		timfilm.setcycle(icycle);
		ifilmcycle=icycle;
	}
	nextframe	{
		.<"film_onsetframe_"+iklatka>;
		.loadframe;
		iklatka++;
	}
	loadframe	{
		@id = dbfilm.findbyrow(iklatka);
		if( id>=0 )	{
			for( int i=1; i<dbfilm.getcolsno(id); i++)	{
				match( dbfilm.get(id,i) )	{
					"fadeout:" => {
						i++;
						if( musicclass!=null )
							<musicclass>.fadeout( dbfilm.get(id,i) );
					}
					? => {
						@s = dbfilm.get(id,i);
						<s>.setvol( dbfilm.<"volume_"+id+"_"+i> );
						<s>.play;
					}
				}
			}
		}
		@z = imfilm.getz;
		@x = imfilm.getpx;
		@y = imfilm.getpy;
		if( bbuffer )	{
			@s = grbuf.get(iklatka-istartklatka);
			<s>.createfrombuffer;
			imfilm.copy(s);
			<s>.hide;
			imfilm.show;
			if( iklatka>istartklatka )	{
				<grbuf.get(iklatka-istartklatka-1)>.free;
			}
		} else {
			imfilm.load( sfilmpath + sprefilm +iklatka+"."+sfileformat );
			imfilm.show;
		}
		imfilm.setz(z);
		if( bcenter )	imfilm.setpos( (igmappw-imfilm.getw)/2, (igmapph-imfilm.geth)/2 );
		else imfilm.setpos(x,y);
	}
	playfilm(string spath, string sdbfile)	{
		.load(spath, sdbfile);
		.play;
	}
	load(string spath, string sdbfile)	{
		if( .isplaying ) .free;
		sfilmpath = spath;
		
		dbfilm.load( spath + sdbfile + ".db" );
		
		istartklatka = dbfilm.dbgetint("start:");
		iklatka = istartklatka;
		iendklatka = dbfilm.dbgetint("end:");
		sprefilm = dbfilm.dbget("prefix:");
		smusic = dbfilm.dbget("music:");
		@id = dbfilm.findbyrow("format:");
		if( id>=0 ) sfileformat = dbfilm.get(id,1);
		
		bbuffer = dbfilm.dbgetint("buffer:");
		if( bbuffer )	{
			for( int i=istartklatka; i<=iendklatka; i++)	{
				@s = "imbuf"+i;
				new img <s>;
				<s>.loadbuffer( sfilmpath + sprefilm +i+"."+sfileformat );
				grbuf.add(s);
			}
		}
		
		for( int i=0; i<dbfilm.getrowsno; i++)	{
			@s = dbfilm.get(i,0);
			if( StringChecker::isdigit(s) )	{
				for( int j=1; j<dbfilm.getcolsno(i); j++)	{
					@s2 = dbfilm.get(i,j);
					match( s2 )	{
						"fadeout:" => {
							j++;
						}
						? => {
							s = "fx" + s2.strgetto(" ");
							int vol = 100;
							if( !.hasvar(s) )	{
								.sfx = (s2);
								vol = <s>.getvol;
							} else if ( s2.contains(" ") )	{
								vol = s2.strgetfrom(" ");
							}
							dbfilm.var2("volume_"+i+"_"+j, vol);
							dbfilm.set(i,j, s );
							grsfx.addonce(s);
						}
					}
				}
			}
		}
	}
	loadborders	{
		if( bborders && !.hasvar("imramkaup"))	{
			new img imramkaup;
			new img imramkadown;
			new img imramkaleft;
			new img imramkaright;
			int dh = 0.5 + (igmapph-imfilm.geth)->to_r/2.0;
			@z = .getz - 1;
			if( dh > 0 )	{
				imramkaup.create(igmappw, dh, .black, 255);
				imramkaup.setz(z);
				
				//imramkadown.create(igmappw, dh, .black, 255);
				imramkadown.copy("imramkaup");
				imramkadown.setpos(0, igmapph-dh);
			}
			int dw = 0.5 + (igmappw-imfilm.getw)->to_r/2.0;
			if( dw > 0 )	{
				imramkaleft.create(dw, igmapph, .black, 255);
				imramkaleft.setz(z);
				
				imramkaright.copy("imramkaleft");
				imramkaright.setpos( igmappw-dw, 0 );
			}
		}
	}
	play	{
		iklatka = istartklatka;
		.nextframe;
		.loadborders;
		if( smusic!=null && musicclass!=null )	{
			<musicclass>.playstr(smusic);
		}
		.setfilmfps;
		timfilm.play;
	}
	free	{
		imfilm.free;
		for( int i=0; i<grsfx.size; i++ )	{
			delete <grsfx.get(i)>;
		}
		for( i=0; i<grbuf.size; i++)
			delete <grbuf.get(i)>;
		grbuf.free;
		grsfx.free;
		.retfps;
	}
	showframe(int idframe)	{
		if( idframe < istartklatka ) idframe=istartklatka;
		else if (idframe > iendklatka ) idframe = iendklatka;
		iklatka = idframe;
		.loadframe;
	}
	showfirstframe	{	.showframe(istartklatka);	}
	showlastframe	{	.showframe(iendklatka);		}
	isplaying	{	timfilm.isplaying;	}
	stop(bool b)	{
		.retfps;
		if( b )	{
			iklatka=iendklatka;
		}
		timfilm.stop(b);
	}
	getimg	{	imfilm.getfullname;	}
}




// advpocket.dag
new snd _fx_pocket;
_fx_pocket.load("sounds/sfx/harfa.wav");

// buttons.dag
new snd sndfxmoveonms;
sndfxmoveonms.load("sounds/sfx/butmoveon.ogg");
sndfxmoveonms.setvol(30);

new snd sndfxmoveon2;
sndfxmoveon2.load("sounds/sfx/butmoveon2.ogg");
sndfxmoveon2.setvol(50);

new snd sndfxbutclick1;
sndfxbutclick1.load("sounds/sfx/butclick1.ogg");
sndfxbutclick1.setvol(50);


class classmoddbg : classlocker	{
	init()	{
		classlocker::init();
		
		new string sstate = "init";
		new int ilastx;
		new int ilasty;
		new text txtpos;
		txtpos.setz(5000);
		txtpos.setpos( 0, 0 );
		txtpos.setbkg(0,0,64,16, 0,0,0,192);
		
		new text txtmsg;
		
		txtmsg.setz(5000);
		txtmsg.setpos(220+igmoffsetx,10);
		txtmsg.setbkg(0,0,500,16, 0,0,0,192);
		txtmsg.hide;
		new timer timmsg;
		timmsg.setdelay(4000);
		timmsg.addmethod("onfinish", func { txtmsg.hide; } );

		new text txtpod;
		txtpod.setz(5000);
		txtpod.setbkg(0,0,128,16, 0,0,0,192);
		
		new img impod;
		new string slastimpod = null;
		
		this.disable();

	}
	public enable()	{
		this.unlock();
		txtpos.show();
		txtpod.show();
	}
	public disable()	{
		this.lock();
		txtpos.hide();
		txtpod.hide();
		impod.hide;
	}
	public updatetxtpos(int x, int y)	{
		if( engine.varexist("clcamera") )
			txtpos.set("" + ( x-clcamera.getposx() ) + "," + ( y-clcamera.getposy() ));
		else txtpos.set("" + x + "," + y);
		txtpos.setpos(x-txtpos.getw-advmouse.lodx,y-txtpos.geth-advmouse.lody);
		txtpod.setpos(x-txtpod.getw-advmouse.lodx,y-2*txtpod.geth-advmouse.lody);
		string s = engine.getimg(x,y,true,true,-2000,2000);
		txtpod.set( s );
		if( s==null || s=="imgbkg" ) impod.hide;
		else if( engine.varexist(s))	{
			if( s!=slastimpod || (s==slastimpod && !impod.isvisible) || <s>.getw != impod.getw || <s>.geth != impod.geth )	{
				impod.create( <s>.getw, <s>.geth, 255,255,0,64 );
				impod.show;
				impod.setz(2010);
				slastimpod = s;
			}
			impod.setpos( <s>.getpx, <s>.getpy );
		}
		y = txtpos.getey - iResY;
		if( y>0 )	{	txtpos.move(0,-y); txtpod.move(0,-y);	}
		x = txtpod.getex - iResX;
		if( x>0 )	{	txtpos.move(-x,0); txtpod.move(-x,0);	}
		x = -txtpod.getpx;
		if( x>0 )	{	txtpos.move(x,0); txtpod.move(x,0);	}
	}
	msminit(int x, int y)	{	this.updatetxtpos(x,y);	}
	msmmove(int x, int y)	{
		if( engine.varexist("clcamera") )
			clcamera.moveplans(x-ilastx, y-ilasty);
		this.updatetxtpos(x,y);
	}
	public msmove()	{
		if( this.getlock() )	{	return;	}
		int x = mouse.getpx();
		int y = mouse.getpy();
		this.<"msm"+sstate>(x,y);
		ilastx=x;
		ilasty=y;
	}
	public mslclick()	{
		if( this.getlock() )	{	return;	}
		if( keyboard.iskeydown("space") )	{
			sstate="move";
		}
	}
	public mslrel()	{
		if( this.getlock() )	{	return;	}
		sstate = "init";
	}
	msrclick()	{
		int x = mouse.getpx();
		int y = mouse.getpy();
		int id = grbuts.isin(x,y,true,true);
		if( id!=false )	{
			string s = grbuts.get(id-1);
			s.print();
		} 
//		txtpod.set( engine.getimg(x,y,true,true,-1000,1000));
	}
	msg(string s)	{
		txtmsg.show;
		txtmsg.set(s);
		txtmsg.setpos(igmoffsetx+100,10);
		timmsg.play;
	}
	dbkeydown(){
		if( !igmdebug ) return;
		if( keyboard.iskeydown("lctrl") ) {
			if( keyboard.iskey("l") )	{
				@s = "cache";
				if( keyboard.iskeydown("1") ) s+="1";
				else if (keyboard.iskeydown("2") ) s+="2";
				else if (keyboard.iskeydown("3") ) s+="3";
				else if (keyboard.iskeydown("4") ) s+="4";
				else if (keyboard.iskeydown("5") ) s+="5";
				else if (keyboard.iskeydown("6") ) s+="6";
				else if (keyboard.iskeydown("7") ) s+="7";
				else if (keyboard.iskeydown("8") ) s+="8";
				else if (keyboard.iskeydown("9") ) s+="9";
				._load_game(s);
				.msg("game loaded from "+s);
			} else if( keyboard.iskey("s") )	{
				@s = "cache";
				if( .can_save )	{
					if( keyboard.iskeydown("1") ) s+="1";
					else if (keyboard.iskeydown("2") ) s+="2";
					else if (keyboard.iskeydown("3") ) s+="3";
					else if (keyboard.iskeydown("4") ) s+="4";
					else if (keyboard.iskeydown("5") ) s+="5";
					else if (keyboard.iskeydown("6") ) s+="6";
					else if (keyboard.iskeydown("7") ) s+="7";
					else if (keyboard.iskeydown("8") ) s+="8";
					else if (keyboard.iskeydown("9") ) s+="9";
					._save_game(s);
					.msg("game saved to "+s);
				} else {
					.msg("could not save game to "+s+" , sgmstate=" + sgmstate);
				}
			} else if( keyboard.iskey("b") )	{
				<gameapi.getgamename>.cgetscreenshoot("saves/cache.bmp", 1);
				.msg("screenshoot in saves/cache.bmp");
			} else if( keyboard.iskey("p") )	{
				.dprint("debugger: ");
			}
		}
		if( keyboard.iskey("d") )	{
			if(.getlock)	{
				this.enable();
				.msg("debug mode on: ^c-b: screenshoot, ^c-s: save, ^c-l: load, d: debug on/off");
			} else {
				this.disable();
				.msg("debug mode off");
			}
		}
	}
}

new classmoddbg moddbg;
/************ template game Painter **************/
class TPainter {
	init()	{}
	tinit(string sndbase, string spath, string sfilebg, string sfilebrush, string sfile, string sfarby, @dir, string ssavefile)	{
		if( sndbase!=null )
			GameController::init(sndbase);
		this.unlock();
		if( spath!=null )
			this.setgraphpath(spath);
		
		if( sfilebg!=null )
			this.newanima("anbkg",sfilebg,0);
			
		new int paintmode = 0;
		
		this.newanima("anbrush1", sfilebrush, 3000);
		this.copyanima("anbrush1","anbrush2");
		anbrush2.setframe(0,1);
		anbrush2.setz(anbrush1.getz-1);
		anima_pack::resizemethods("anbrush1");		// galka
		anima_pack::resizemethods("anbrush2");		// pedzel
		int x, int y;
		match( dir )	{
			"ru" => { x = anbrush2.getex;
				y = anbrush2.getpy; }
			"rd" => { x = anbrush2.getex;
				y = anbrush2.getey; }
			"ld" => { x = anbrush2.getpx;
				y = anbrush2.getey; }
			? => { x = anbrush2.getpx;
				y = anbrush2.getpy; }
		}
		anbrush1.saverelpos(x, y);	// lewy dolny rog - kursor myszy
		anbrush2.saverelpos(x, y);	// lewy dolny rog - kursor myszy
		mouse.hide();
		
		this.newanima("anfg", sfile, 100);
		anfg.setframe("foreground",0);
		
		new gmimgvec grdraw;
		_ = this.newanframesgr("anfg", "andraw", anfg.actionnr("draw"), "grdraw");
		grdraw.setz(10);
		
		if( sfarby.contains(".pyz") )	{
			new gmimgvec grpaleta;
			"grpaleta" ..< sfarby;
			grpaleta.setz(20);
		} else if( sfarby != "grpaleta" ) {
			<sfarby>.addtogamevars("grpaleta");
		}
		
		new int _ibrx = anbrush2.getpx();
		new int _ibry = anbrush2.getpy();
		while( !anbrush2.isin(_ibrx, _ibry, false, true) )	{
			_ibrx++;
			if( _ibrx==anbrush2.getex() ) {
				_ibrx = anbrush2.getpx();
				_ibry++;
			}
		}
		_ibrx-=anbrush2.getpx();
		_ibry-=anbrush2.getpy();
		TPainter::tp_mouse_move;		// ustawienie pedzla w pozycji myszy
		
		if( ssavefile!=null )	{
			new string savefile = ssavefile;
			new db dbkolory;
			@s = ssavefile;
			//if( engine.fileexist(s) )	{
			if( .saveexist(s) )	{
				dbkolory.vecload(s);
				grdraw.each( func { (@id)
					.paint( dbkolory.get(id,0), dbkolory.get(id,1), dbkolory.get(id,2), 255, 0);
					} );
			} else {
				grdraw.each( func { (@id)
					.paint(.white,255,0);
					dbkolory.dbaddstringrow("255 255 255"," ");
					} );
				.tp_savekols;
			}
		}
	}
	game_exit()	{
		mouse.show();
		GameController::game_exit();
	}
	tp_exit	{
		mouse.show;
	}
	tp_mouse_move()	{
		anbrush1.mssetrelpos();
		anbrush2.mssetrelpos();
	}
	tp_mouse_lclick()	{
		if( !this.getlock() )	{
			|int x, int y| = mouse.getpos();
			if( grdraw.isin(x,y,true,true) )	{
				<grdraw.getsfound()>.paint( anbrush2.getrgba(anbrush2.getpx()+_ibrx,anbrush2.getpy()+_ibry), paintmode );
				.onpaint;
			} else if ( grpaleta.isin(x,y,false,true) )	{
				|@c[4]| = <grpaleta.getsfound()>.getrgba(x,y);
				c3 = 255;
				anbrush2.paint( c0, c1, c2, c3, paintmode );
				.onsetbrush;
			}
		}
	}
	tp_savekols	{
		if( !<GAME>.hasvar("dbkolory") ) return;
		grdraw.each( func { (@id)
			int c[4];
			//|c0, c1| = .anfirstnontr;
			int ex = .getex , int ey = .getey;
			int x = .getpx, int y=.getpy;
			while( x!=ex && y!=ey )	{
				if( .isin(x,y,false,true) ) { c0=x; c1=y; x=ex; }
				else x++;
			}
			|c0,c1,c2,_| = .getrgba(c0,c1);
			dbkolory.set(id,0,c0);
			dbkolory.set(id,1,c1);
			dbkolory.set(id,2,c2);
			} );
		dbkolory.vecsave( savefile );
	}
	tp_default_erase	{	.tp_erase(.white,255);	}
	tp_erase(int r, int g, int b, int a)	{
		for( int i=0; i< grdraw.size; i++)	{
			<grdraw.get(i)>.paint(r,g,b,a,paintmode);
			dbkolory.set(i,0,255);
			dbkolory.set(i,1,255);
			dbkolory.set(i,2,255);
		}
		.tp_savekols;
	}
}

class TPainterCon : TPainter, GameController	{
	init	{}
}
new string sAskerGame;
new int idymekdelay = 300;
new bool bHorizon = .readcfg("bHorizon:",true);

class StdGame : classadv, Localize	{
	init(string s)	{
		AdventureGame = false;
		classadv::init(s);
		Localize::init;
		.path = (s);
		
		advmouse.setstd;
		
		if( PrzygodaMode )	{
			.advsaveonstart;
			.advsave_game;
		}
	}
	//-------------- adv -------------------------------
	loadasker	{
		if( bHorizon )
			.newanima("anaskerbg", "$scripts/common/asker.pyz", 1990);
		else
			.newanima("anaskerbg", "$scripts/common/asker_pion.pyz", 1990);
		anaskerbg.hide;
		.copyanima("anaskerbg", "anaskeryes");
		anaskeryes.setframe("yes",0);
		.copyanima("anaskerbg", "anaskerno");
		anaskerno.setframe("no",0);
		anaskeryes.Button_std;
		anaskeryes.addmethod("butclick", func {
			if( sgmstate=="state_askexit" )	{
				if( sAskerGame!=null ) {
					if( sAskerGame=="exit" ) {
						sgmstate = "state_exitgame";
						.closexit;
					} else {
						.stdexit(sAskerGame);
					}
				} else .Button_butclick;
			}
			} );
		anaskerno.Button_std;
		anaskerno.addmethod("butclick", func {
			anaskerbg.anzoomout(idymekdelay,"advsetstdstate");
			anaskeryes.anzoomout(idymekdelay,null);
			anaskerno.anzoomout(idymekdelay,null);
			} );
		butgame.add("anaskeryes");
		butgame.add("anaskerno");
	}
	closexit	{
		ccs.buildblack;
		ccs.close( func { gameapi.exit; } );
	}
	askfor(string s)      {
		sgmstate = "state_askexitstart";
		sAskerGame=s;
		anaskerbg.anzoomin(idymekdelay, func { sgmstate = "state_askexit"; } );
		anaskeryes.anzoomin(idymekdelay,null);
		anaskerno.anzoomin(idymekdelay,null);
	}
	stdenter	{
		ccs.enter( "refreshstdstate" );
	}
	refreshstdstate	{
		.advsetstdstate;
		butgame.refresh;
	}
	timfinito	{
		if( !<GAME>.hasvar("_timfinito") )	{
			<GAME>.timer = ("_timfinito", 1000, func {
				if( .advstdstate ) .mend;
				} );
		}
		_timfinito.play;
	}
	//--------------------- buttons ------------------------
	Button_stdoff	{
		.addmethod("butmoveoff", func {
			if( .advstdstate )
				advmouse.setstd;
			} );
	}
	buildfadebut(bool balpha)	{
		@s = this + "_copy";
		<GAME>.copyanima(this, s);
		<s>.setframe(-1,1);
		<s>.hide;
		if( balpha ) .Button_isinalpha;
		else .Button_isin;
		.var2("sanbutcopy", s);
		.addmethod("butmoveon", func {
			if( .advstdstate )	{
				advmouse.setact;
				<sanbutcopy>.anfadein(300, null );
			}
			.Button_butmoveon;
			} );
		.addmethod("butmoveoff", func {
			advmouse.setstd;
			if( <sanbutcopy>.isvisible )
				<sanbutcopy>.anfadeout(300, "hide");
			.Button_butmoveoff;
			} );
		.Button_stdclick;
		butgame.add(this);
	}
	//-------------- helpful -------------------------------
	crect(int wleft, int hup, int wright, int hdown)	{
		new Rect rec( igmoffsetx+wleft.igetsc, igmoffsety+hup.igetsc, igmoffsetx+iResX-wright.igetsc, igmoffsety+iResY-hdown.igetsc);
	}
	mkchmura(string san, real rdx)	{
		@s = "canmov"+san;
		new AnMover <s>( san, rdx, 0);
		<s>.enableroll;
		<s>.play;
	}
	//-------------- sys -------------------------------
	key_down	{
		if( igmdebug && keyboard.iskeydown("lctrl") && keyboard.iskey("r") )	.crestart;
	}
}



new classgamepause clpause;


class classplacepointer2 : classplacepointer    {
	init()  {
		classplacepointer::init();
		this.load("scripts/common/strzalka.pyz");
	}
}

gameapi.play("MainLoader");
game MainLoader : StdGame       {
	init    {
		StdGame::init("mainloader");
		
		//_fxtakeitem.load( .getsndpath + "getitem" );
		
		// ADV
		if( engine.varexist("modadv") )	{
			modadv.load("scripts/scripts/defaults.adv");
			modadv.loadsounds("scripts/scripts/sounds.db");
			modadv.settalktype("snd");
			modadv.loadscript("scripts/scripts/initscript.dsc");
		}
		clsave.load("global.txt");
		sgmlastscene = this;
		
		gameapi.play( dbconf.dbget("startgame:") );
	}
}


new bool bMusic = true;
new string sgmkolopref = sgmproject.strsubbs("Colour")->to_l;
new string sgmbutorient = "right";

public bool gmbutleft	{	igmandroid || sgmbutorient=="left";	}

class MermaidStd : StdGame	{
	init(string s)	{
		StdGame::init(s);
		.path = (sgmkolopref + "/" + s);
	}
	cwideversion	{	true;	}
	cbutexit	{
		.newanima("anbutexit", "$scripts/common/butexit.pyz", 300);
		if( .gmbutleft )
			anbutexit.ansetbpos( igmoffsetx + 10->igetsc, igmoffsety );
		else
			anbutexit.ansetbpos( igmoffsetx + iResX - 20->igetsc - anbutexit.getw, igmoffsety );
		anbutexit.Button_addstdstate;
	}
	cbutexitoverlay	{
		.cbutexit;
		.cblinkbutexit;
	}
	cblinkbutexit	{
		if( !.checktouchpad )
			anbutexit.imgbuildoverlay(.yellow,64,1200);
	}
	cblinkbut	{
		if( !.checktouchpad )
			.imgbuildoverlay(.white,64,1200);	
	}
	cbuthelp	{
		.newanima("anbuthelp", "$scripts/common/help.pyz", 300);
		if( .gmbutleft )
			anbuthelp.ansetbpos( anbutexit.getex + 5->igetsc, igmoffsety );
		else
			anbuthelp.ansetbpos( anbutexit.getpx - anbuthelp.getw - 5->igetsc, igmoffsety );
		anbuthelp.Button_addstdstate;
	}
	cbutmusic	{	.cbutmuz;	}
	cbutmuz		{
		.newanima("anbutmuz", "$scripts/common/butmuz.pyz", 300);
		@s = "anbutexit";
		if( engine.varexist("anbuthelp") ) s = "anbuthelp";
		if( .gmbutleft )
			anbutmuz.ansetbpos( <s>.getex + 5->igetsc, igmoffsety );
		else
			anbutmuz.ansetbpos( <s>.getpx - anbutmuz.getw - 5->igetsc, igmoffsety );
		anbutmuz.Button_addstdstate;
		anbutmuz.setframe( bMusic ? "on" : "off", 0 );
	}
	butclick_anbutmuz	{
		if( bMusic )	{
			bMusic = false;
			music.fadeout(500);
			anbutmuz.setframe("off",0);
		} else {
			bMusic = true;
			anbutmuz.setframe("on",0);
			.butmuz_playmusic;
		}
	}
	butmuz_playmusic	{	.playmainmusic;	}
	cloadboki(int z)	{
		.newanima("an1366bokl", "$scripts/common/boki.pyz", z);
		.copyanima("an1366bokl", "an1366bokr");
		an1366bokr.setframe(1,0);
	}
	caddymek	{
		<GAME>.copyanima(this, this+"2");
		for( int i=0; i < .nofactions-2; i++ )	{
			@saniko = this+"iko"+i;
			<GAME>.copyanima(this, saniko);
			<saniko>.hide;
			<saniko>.setz( .getz + 1 );
			<saniko>.setframe(i+2,0);
			.var2("saniko"+i, saniko);
		}
		.vars2(A, "ilesaniko", i, "sancopy", this + "2");
		<sancopy>.hide;
		.addmethod("isbutin", func { (int x, int y)
			<sancopy>.isin(x,y,0,0);
			} );
		.addmethod("butmoveon", func {
			if( .advstdstate )	{
				advmouse.setact;
				.play(1);
				for( int i=0; i<ilesaniko; i++ )	{
					< ["saniko"+i] >.anzoomin((10.0+i)/10.0*idymekdelay,null);
				}
				.Button_butmoveon;
			}
			} );
		.addmethod("butmoveoff", func {
			if( .advstdstate )	{
				advmouse.setstd;
				.play(0);
				for( int i=0; i<ilesaniko; i++ )	{
					< ["saniko"+i] >.anzoomout((10.0+i)/10.0*idymekdelay,null);
				}
			}
			} );
		.addmethod("butclick", func {
			if( .advstdstate )
				.Button_butclick;
			} );
		butgame.add(this);
		.play(0);
	}
	cbuildbzyczek(string san)	{	<GAME>.cbzyczek(san, <san>.getpx, <san>.getpy);	}
	cplaybzyczek(string san)	{	.cbuildbzyczek(san); <san>.play(-1);	}
	anplaybzyczek	{	.cplaybzyczek(this);	}
	cbzyczek(string san, int xstart, int ystart)	{
		<san>.ansetbpos( xstart, ystart );
		@s = "ftbzyk"+san;
		new filter <s>;
		<s>.link(san);
		<san>.var2("iliczbzyk",0);
		<san>.addmethod("onendframe", func {
			iliczbzyk++;
			if( iliczbzyk==1 )	{
				@s = "ftbzyk"+this;
				iliczbzyk=0;
				real kat = 12-21->rand;
				real dt = 5;
				real kat2 = <s>.getangle;
				real x = kat2->sin * dt;
				real y = kat2->cos * dt;
				<s>.rotate(kat);
				.move(-x,-y);
			}
			} );
	}
}



new int iKoloId = 1;
new int iIleKolo = .readcfg("iIleKolo:",iKoloId);

new bool bPlayMusic = true;
new int igmogg = true;

public playmainmusic	{
	music.smixer = ("engine");
	music.playstr("bajka2.ogg -l -v 50");
}

game MenuImg : MermaidStd	{
	init	{
		MermaidStd::init("menu_img");
		
		.imgs = (A, "butok.pyz 30", "butnext.pyz 30", "putprev.pyz 30", "cien.pyz 10", "bgmenuimg.jpg",
			"$scripts/common/cyfry.pyz 30");
		
		.cbutexit;
		.loadasker;
		.cbutmusic;
		
		anbutok.imgbuildoverlay(.yellow,64,1200);
		
		new gmimgvec grnr;
		int ile = .mputnumber(null,iIleKolo);
		int w = 1.1 * ancyfry.getw;
		for( int i=0; i<ile; i++ )	{
			@s = "anilepuz"+i;
			.copyanima("ancyfry", s);
			<s>.setpos( anbutok.getpx - w*(i+1), ancien.getey + 10->igetsc );
			s = "annr"+i;
			.copyanima("ancyfry", s);
			<s>.setpos( anbutok.getpx - w*(i+ile+2), ancien.getey + 10->igetsc );
			<s>.hide;
			grnr.add(s);
		}
		_ = .mputnumber("anilepuz", iIleKolo);
		ancyfry.setframe(1,0);
		ancyfry.setpos( anbutok.getpx - w*(ile+1), ancien.getey + 10->igetsc );
		
		new img imgpic1;
		new img imgpic2;
		new string spic1 = "imgpic1";
		new string spic2 = "imgpic2";
		<spic1>.mload;
		.mustawnr;
		new int ispeed;
		
		.cycle=("timrew", func {
			<spic1>.move( 0, ispeed );
			<spic2>.move( 0, ispeed );
			@dy = <spic2>.getpy;
			if( (ispeed<0 && dy<0 ) || (ispeed>0 && dy>0) )	{
				<spic1>.hide;
				<spic2>.mustaw;
				@s = spic1;
				spic1 = spic2;
				spic2 = s;
				.advsetstdstate;
				ancien.show;
				.mustawnr;
			} else .play;
			} );
		
		anbutnext.Button_addstdstate;
		anputprev.Button_addstdstate;
		
		anbutok.Button_addstdstate;
		
		.stdenter;
	}
	butclick_anbutnext	{	<GAME>.mnext(1);	}
	butclick_anputprev	{	<GAME>.mnext(-1);	}
	butclick_anbutok	{	ccs.showloading; .stdexit("Kolo");	}
	mustaw	{	.ansetcpos( ancien.getcx, ancien.getcy-1 );	}
	mload	{
		.load( "scripts/" + sgmkolopref + "/imgscol/colcol_" + iKoloId + ".jpg" );
		.anzoom( 500.0 / 912.0 );
		.setz( 20 );
		.anclipob("ancien");
		.show;
		.mustaw;
	}
	mnext(int id)	{
		iKoloId += id;
		if( iKoloId < 1 ) iKoloId = iIleKolo;
		else if ( iKoloId > iIleKolo ) iKoloId = 1;
		<spic2>.mload;
		ispeed = 0.4*<spic1>.geth;
		int dy = 5;
		if( id>0 ) {
			ispeed = -ispeed;
			<spic2>.move( 0, <spic1>.geth + dy );
		} else {
			<spic2>.move( 0, - <spic2>.geth - dy );
		}
		sgmstate = "state_rewind";
		//ancien.hide;
		timrew.play;
	}
	int mputnumber(string spref, int number)	{
		int id = 0;
		while( number>0 )	{
			if( spref!=null )	{
				@s = spref + id;
				<s>.setframe( 0, number%10 );
				<s>.show;
			}
			number = number/10;
			id++;
		}
		id;
	}
	mustawnr	{
		grnr.hide;
		_ = .mputnumber("annr", iKoloId);
	}
	butclick_anbutexit	{	.askfor("Outro");	}
}

game Intro : MermaidStd	{
	init	{
		MermaidStd::init("intro");
		.imgs = (A, "bkg.jpg", "tytul.pyzGH 10");
		
		new int idtyt = 0;
		ccs.enter( func {
			.advsetstdstate;
			.mtytgo;
			} );
		
		.playmainmusic;
	}
	mend	{
		.stdexit("MenuImg");
	}
	mouse_lclick	{
		.mend;
	}
	mtytgo	{
		if( idtyt >= grtytul.size )	{
			.mend;
		} else {
			int time = ( idtyt == grtytul.size-1 ? 4000 : 1000 );
			<grtytul.get(idtyt)>.anfadein(time, "mtytgo");
			idtyt++;
		}
	}
}

game Outro : MermaidStd	{
	init	{
		MermaidStd::init("outro");
		
		if( sgmkolopref.in(A, "nestor") )	{
			.img = ("outrobg.jpg");
		} else {
			.imgs=(A, "bkg.pyz", "bg2.pyz 5", "farm1.pyzG 10", "coralreef.pyzG 10", "tytul_logo.pyzG 20");
			
			<grfarm1.getsac("download")>.mlinker("linkfarm:");
			<grcoralreef.getsac("download")>.mlinker("linkcoral:");
		}
		
		.stdenter;
		.timplay("timfinish", 12000, "mend");
	}
	mlinker(string slink)	{
		if( .isapple ) {
			.cblinkbut;
			.Button_stdalpha;
			.addmethod("butclick", func {
				if( (igmmac || igmipad) && .advstdstate )	{
					engine.system("open "+.readcfg(slink, "http://www.daamdaam.com"));
				}
				} );
			butgame.add(this);
		} else .hide;
	}
	mend	{
		if( .advstdstate )	{
			sgmstate = "state_exit";
			music.fadeout(800);
			.closexit;
		}
	}
	mouse_lclick	{
		.mend;
	}
}



game Kolo : MermaidStd {
	init	{
		if( igmandroid )
			MermaidStd::init("koloandro");
		else
			MermaidStd::init("kolo");
		
		.imgsgr = (A, "bkg.jpg", "light.pyz 15", "ramka.pyzG 10", "brush.pyzG 15", "paint.pyzH 50",
			"specbrush.pyz 20", "czysc.pyz 20", "save.pyz 20", "eraser.pyz 20", "dec.pyz 20", "inc.pyz 20", "size.pyz 15",
			"napisy.pyzG 30", "imgpos.pyzH",
			"grall");
		
		
		if( !igmandroid )	{
			int dy = 16->igetsc;
			grall.move( 0, -dy );
			dy /= 2;
			if( dy > 0 )	{
				new img imgbkg2;
				imgbkg2.create( imgbkg.getw, dy, .transparent );
				imgbkg2.setpos( imgbkg.getpx, imgbkg.getey-dy );
				imgbkg2.blit("imgbkg");
				imgbkg2.setpos( imgbkg.getpx, imgbkg.getey );
				new img imgbkg3;
				imgbkg3.copy("imgbkg2");
				imgbkg3.setpos( imgbkg.getpx, imgbkg2.getey );
			}
		}
		
		.cbutexit;
		if( !.gmbutleft )
			anbutexit.ansetbpos( aneraser.getpx, igmoffsety );
		.loadasker;
		
		.sfxs = (A, "lira2", "pedzel", "pedzel2");
		
		new gmimgvec grf;
		"grf" ..< "farby.pyz";
		if( !igmandroid )	{
			grf.move( 0, -16->igetsc );
		}
		
		anczysc.hide;
		ansave.hide;
		<grnapisy.getsac("clear")>.hide;
		<grnapisy.getsac("save")>.hide;
		
		new int xbrush;
		new int ybrush;
		new img imbrush;
		new img imbrush2;
		new bool bcandraw = true;
		new int ibrushsize = 50;
		.newtext("txtsize", "", .stdfont(24->igetsc), .white);
		txtsize.setz( 25 );
		new string slastcol = null;
		
		grf.eval( func {
			.setz(20);
			.Button_stdms;
			.addmethod("butclick", func {
				if( .advstdstate )	{
					bcandraw = false;
					.msetfarba(this);
					fxpedzel.play;
				}
				} );
			butgame.add(this);
			} );
		<grf.last>.paint(.white,255,0);
		
		grbrush.eval( func {
			.Button_stdms;
			.addmethod("butclick", func {
				if( .advstdstate )	{
					bcandraw = false;
					.msetbrush(this);
					fxpedzel2.play;
				}
				} );
			butgame.add(this);
			} );
		
		aninc.Button_stdms;
		aninc.addmethod("butclick", func {
			if( .advstdstate )	{
				bcandraw = false;
				.mbrushsize(10);
				sndfxmoveon2.play;
			}
			} );
		butgame.add("aninc");
		andec.Button_stdms;
		andec.addmethod("butclick", func {
			if( .advstdstate )	{
				bcandraw = false;
				.mbrushsize(-10);
				sndfxmoveon2.play;
			}
			} );
		butgame.add("andec");
		
		aneraser.Button_stdms;
		aneraser.addmethod("butclick", "mnewbrushclick" );
		butgame.add("aneraser");
		
		anspecbrush.Button_stdms;
		anspecbrush.addmethod("butclick", "mnewbrushclick" );
		butgame.add("anspecbrush");
		
		.newimg("ancol1", "$scripts/"+sgmkolopref+"/imgsbw/colbw_" + iKoloId + ".jpg", 7);
		ancol1.move(animgpos.getpx,animgpos.getpy);
		.newimg("ancol2", "$scripts/"+sgmkolopref+"/imgscol/colcol_" + iKoloId + ".jpg", 7);
		ancol2.move(animgpos.getpx,animgpos.getpy);
		ancol2.hide;
		
		new img implotno;
		if( igmenablesave && engine.fileexist(.mgetfile) )	{
			implotno.create( ancol1.getw, ancol1.geth, .transparent );
			implotno.loadnoscale( .mgetfile );
		} else {
			implotno.create( ancol1.getw, ancol1.geth, .transparent );
		}
		implotno.setpos( ancol1.getpx, ancol1.getpy );
		implotno.setz( 8 );
		
		new bool bclicked = false;
		.cycle = ("timpaint", func {
			if( .advstdstate &&  bclicked ) {
				real x = imbrush.getpx;
				real y = imbrush.getpy;
				real len = x.length( x-xbrush, y-ybrush );
				int ile = len / (imbrush.getw/2);
				if( ile < 1 ) ile=1;
				real rx = xbrush;
				real ry = ybrush;
				real dx = (x-rx)/ile;
				real dy = (y-ry)/ile;
				for( int i=1; i<=ile; i++ )	{
					if( i==ile )	{
						xbrush = x;
						ybrush = y;
					} else {
						rx += dx;
						ry += dy;
						xbrush = rx;
						ybrush = ry;
					}
					imbrush.setpos( xbrush, ybrush );
					if( anspecbrush.framenr )
						implotno.paintfromsrc("ancol2", "imbrush");
					else if( aneraser.framenr )
						implotno.erase("imbrush");
					else implotno.paintfromgrey("ancol1", "imbrush");
				}
			}
			.play;
			} );
		
		
		.msetbrush( grbrush.first );
		.msetfarba( grf.first );
		timpaint.play;
		
		.checkbrushpos;
		
		ccs.hideloading;
		.stdenter;
	}
	mgetfile	{
		.getsavepath + "kolo"+iKoloId+".k16";
	}
	msavefile	{
		if( igmenablesave )	{
			int x = implotno.getpx;
			int y = implotno.getpy;
			implotno.setpos(igmoffsetx,igmoffsety);
			implotno.save( .mgetfile );
			implotno.setpos(x,y);
		}
	}
	mnewbrushclick	{
		if( .advstdstate )	{
			bcandraw = false;
			if( this=="aneraser" ) {
				anspecbrush.setframe(-1,0);
				sndfxmoveon2.play;
			} else {
				aneraser.setframe(-1,0);
				fxlira2.play;
			}
			if( .framenr )	{
				.setframe(-1,0);
				//.mupdatecol;
				.mretcol;
			} else {
				.setframe(-1, 1 );
				.mresetcol;
			}
		}
	}
	mbrushsize(int id)	{
		ibrushsize = .between(10, ibrushsize+id, 100);
		imbrush2.imgclone("anpaint");
		imbrush2.anzoom( 0.01 * ibrushsize );
		imbrush.imgclone("imbrush2");
		imbrush2.hide;
		imbrush.show;
		txtsize.txtset( "" + ibrushsize + "%" );
		txtsize.imgputoncenter( "ansize" );
		.mupdatecol;
		.setbrushpos;
	}
	mouse_lclick	{
		if( .advstdstate )	{
			if( bcandraw )	{
				bclicked = true;
				.setbrushpos;
				xbrush = imbrush.getpx;
				ybrush = imbrush.getpy;
			} else {
				bcandraw = true;
			}
		}
	}
	mouse_lrel	{
		bclicked = false;
		.checkbrushpos;
	}
	msetfarba(string s)	{
		aneraser.setframe(0,0);
		anspecbrush.setframe(0,0);
		anlight.setframe( <s>.actionnr(-1), 0 );
		anlight.ancenterimg( s );
		anlight.show;
		slastcol = s;
		.mupdatecol;
	}
	mretcol	{	.msetfarba(slastcol);	}
	mupdatecol	{
		if( aneraser.framenr || anspecbrush.framenr )
			.mresetcol;
		else if( slastcol!=null )
			imbrush.paint( <slastcol>.getrgb( <slastcol>.getcx, <slastcol>.getcy ), 255, 0 );
	}
	mresetcol	{
		anlight.hide;
		imbrush.paint( .black, 255, 0 );
	}
	mouse_move	{
		.setbrushpos;
	}
	setbrushpos	{
		if( .checktouchpad )
			imbrush.setpos(mouse.getpx-imbrush.getw/2, mouse.getpy-imbrush.geth/2);
		else
			imbrush.setpos(mouse.getpx-imbrush.getw, mouse.getpy-imbrush.geth);
	}
	msetbrush(string s)	{
		grbrush.setframe(-1,0);
		<s>.setframe(-1,1);
		anpaint.setframe( 0, <s>.actionnr(-1) );
		.mbrushsize(0);
	}
	checkbrushpos	{
		if( igmandroid )	{
			imbrush.scpos(1140, 520);
			imbrush.move( -imbrush.getw/2, -imbrush.geth/2 );
		} else if( .checktouchpad )	{
			imbrush.scpos(970, 650);
			imbrush.move( -imbrush.getw/2, -imbrush.geth/2 );
		}
	}
	butclick_anbutexit	{
		bcandraw = false;
		.msavefile;
		.askfor("MenuImg");
	}
}


