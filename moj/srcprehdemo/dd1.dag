/******** konstrukcje  ********************/
new string	A = "!!!";
new real		PI = 3.14159265358979323846;
new int		BYTE0 = "0"->getbyte(0);
new int		BYTE9 = "9"->getbyte(0);
new int		BYTEa = "a"->getbyte(0);
new int		BYTEz = "z"->getbyte(0);
new int		BYTEA = "A"->getbyte(0);
new int		BYTEZ = "Z"->getbyte(0);
new int		BYTE_ = "_"->getbyte(0);

public varget(string svar)				{	[svar];				}
public varset(string svar, def val)			{	<svar> = val;			}
public varnew(string styp, string svar)	{	new <styp> <svar>;	}
public varnewif(string styp, string svar)	{	if( !.hasvar(svar) )	.varnew(styp,svar);}
public vardelif(string svar)				{	if( .hasvar(svar) )	.vardel(svar);		}
public vardel(string svar)				{	delete <svar>;		}
public reader(string sname)	{
	.varnewif("def", sname);
	.addmethod( sname, func { [.methodname]; } );
}
public writer(string sname)	{
	.varnewif("def", sname);
	.addmethod( sname+"=", func { (def val) <.methodname->strsube(1)> = val; } );
}
public var(string sname)	{
	.reader(sname);
	.writer(sname);
}
public var2(string sname, def val)	{
	.var(sname);
	<sname> = val;
}
public withlist(string sfun)	{
	@s = _;
	while( A != s )	{
		.<sfun>(s);
		@s = _;
	}
}
public withlist2(string sfun)	{
	@s = _;
	while( A != s )	{
		@s1 = _;
		.<sfun>(s1,s);
		@s = _;
	}
}
public vars	{	.withlist("var");}
public vars2	{	.withlist2("var2");}
/*****************************************************/
public bool in	{
	bool b = false;
	@x = .get;
	@y = _;
	while( A != y )	{
		if( !b )	b = x==y;
		@y=_;
	}
	b;
}
public with(string sfun)	{
	string sob = _;
	while( sob!=A )	{
		<sob>.<sfun>();
		sob=_;
	}
}
public copycall(string sfun, string sob)	{
	string s = "__call" + sfun;
	new string <s>;
	<s> = sob;
	.addmethod( sfun, func {
		string sf = .methodname;
		< [ "__call" + sf ] >.<sf>();
		});
}
public copycalls(string sobj)	{
	string s = _;
	while( s!=A )	{
		.copycall( s, sobj ); 
		s=_;
	}
}
/***********************************/
public mresize()	{	< .gettype + "_pack">::resizemethods( this );	}
/******** petle ********************/
public times(string sfun)		{	this.for_plus(0, this.get()-1, sfun );		}
public upto(int ito, string sfun)	{	this.for_plus( this.get(), ito, sfun );	}
public downto(int ito, string sfun)	{	this.for_minus( this.get(), ito, sfun );	}
public for_plus(int ifrom, int ito, string sfun)	{
	if( ito-ifrom<=0 )	return;
	for( ; ifrom<=ito; ifrom++)	this.<sfun>(ifrom);
}
public for_minus(int ifrom, int ito, string sfun)	{
	if( ifrom-ito<=0 )	return;
	for( ; ifrom>=ito; ifrom--)	this.<sfun>(ifrom);
}
public double_for(int w, int h, string sfun)	{
	int j;
	for( int i=0; i<w; i++)	{
		for( j=0; j<h; j++)	{
			this.<sfun>(i,j);
		}
	}
}
/****************************************/

// klasa do np. dynamicznego tworzenia obiektow z prefixem+id
class classobjcounter	{
	init(string sprefix)	{
		new string _sprefix=sprefix;
		new int _iile=0;
	}
	string get()	{
		_iile++;
		return _sprefix + (_iile-1);
	}
	int size()	{_iile;}
}

/*class classvsigobj	{
	init()	{
		new bool bplaying=false;
	}
	virtual play()	{	bplaying=true;	}
	virtual stop(bool bstop)	{ 
		bplaying=false;
		if( bstop )	{	this.onfinish();	}
	}
	virtual bool isplaying()	{	bplaying;	}
}*/

/***************************************************************************/

class classsignals	{
	init()	{}
	/********** std obj **********************/
	stdfinish(string sob) { <sob>.addmethod("onfinish",func { this.<this.getname()+"_FINISH">();}); }
	stdstart(string sob) { <sob>.addmethod("onstart",func { this.<this.getname()+"_START">(); }); }
	stdsigs(string sob)	{
		this.stdstart(sob);
		this.stdfinish(sob);
	}
	/********** anima **********************/
	buildanima(string san)	{
		this.stdsigs(san);
		<san>.addmethod("onendframe", func { this.<this.getname()+"_ENDFRAME">(); } );
	}
	/********** snd **********************/
	buildsnd(string ssnd)	{	this.stdsigs(ssnd);		}
	/********** timer **********************/
	buildtimer(string stimer)	{
		this.stdsigs(stimer);
		<stimer>.addmethod("ontick", func { this.<this.getname()+"_TICK">(); });
	}
	/********** button *******************/
	buildbut(string sbut)	{
		<sbut>.addmethod("onclick", func { this.<this.getname()+"_CLICK">(); });
		<sbut>.addmethod("onrel", func { this.<this.getname()+"_REL">(); });
		<sbut>.addmethod("onmoveon", func { this.<this.getname()+"_MOVEON">(); });
		<sbut>.addmethod("onmoveoff", func { this.<this.getname()+"_MOVEOFF">(); });
	}
}

/******************************************************************/

class classlocker	{
	init()	{
		new bool _block = true;
	}
	public lock()	{	_block=true;	}
	public unlock()	{	_block=false;	}
	public setlock(bool b)	{	_block=b;	}
	public bool getlock()	{	return _block;	}
	public bool unlocked	{	_block==false;	}
}

/***************************************************************************/

module classdbreader	{
	init()	{
		new db dbl;
	}
	readdb( string sfunc )	{
		int id = 0;
		int ile = dbl.getrowsno();
		while( id < ile )	{
			this.<sfunc>( id );
			id++;
		}
	}
	readrow( string srow, string sfunc )	{
		int ipos = dbl.findbyrow( srow );
		if( ipos >= 0 )	{
			this.<sfunc>( ipos );
		}
	}
}

/***************************************************************************/


/***************************************************************************/
class collection	{
	init(string styp)	{	new string stype=styp;	}
	public string type()	{	return stype;		}
}

class array : collection {
	init(string styp, int idimens, int isiz)	{
		collection::init(styp);
		new int idim = idimens;
		new int isize = isiz;
		new vector vec;
		vec.type(styp);
		if( idimens<=0 || isiz<=0 )	return;
		//vec.resize( isiz.pow(isiz,idimens), 0 );
		vec.resize( isiz.pow(idimens), 0 );
	}
	int getid()	{
		int pos=0;
		int dim=idim-1;
		while(dim>0)	{
			pos+=_;
			pos*=isize;
			dim--;
		}
		return pos+_;
	}
	public def get()	{	return vec.get( this.getid() );	}
	public set(def svar)	{	vec.set( this.getid(), svar);	}
	public int getsize()	{	return isize;			}
	public int getdim()	{	return idim;			}
}

class stack : collection	{
	init(string styp)	{
		collection::init(styp);
		new vector vec;
		vec.type(styp);
		new <styp> var;
	}
	public push(string svar){	vec.add(svar);		}
	public def top()	{	return vec.last();	}
	public def pop()	{
		var = this.top();
		vec.removeat( vec.size()-1 );
		return var;
	}
	public free	{	vec.free;	}
}

class map : collection	{
	init(string styp)	{
		collection::init(styp);
		new int isize=0;
	}
	set(string svar, def val)	{
		if( !this.hasvar(svar) )	this.add(svar);
		<"v"+svar>.set(val);
	}
	add(string svar)	{	new <stype> <"v"+svar>;		}
	def get(string svar)	{	return ["v"+svar];		}
	remove(string svar)	{	delete <"v"+svar>;		}
	bool contains(string svar){	return this.hasvar("v"+svar);	}
}
class map2 : collection	{
	init(string styp)	{
		collection::init(styp);
		new vector vn;
		vn.type("string");
		new vector vec;
		vec.type(styp);
	}
	add(string svar, def val)	{	vn.add(svar);	vec.add(val);	}
	set(string svar, def val)	{	vec.set( vn.find(svar), val );	}
	bool contains(string svar)	{	return vn.contains(svar);	}
	def get(string svar)		{	return vec.get( vn.find(svar) );}
	remove(string svar)	{
		int id = vn.find(svar);
		if( id>=0 )	{
			vec.removeat( id );
			vn.removeat(id);
		}
	}
	free()	{	vn.free();	vec.free();	}
}


/***************************************************************************/
class classgamemusic : classdbreader	{
	init()	{
		classdbreader::init();
		new string smuspath = "";
		new string sbgrpath = "";
		new snd _sndbgr;
		_sndbgr.addmethod("onfinish", "_stdsndloop");
	}
	reset()	{
		gameapi.stopmusic();
		this.stopbgr();
	}
	_stdsndloop()	{	this.play(); }
	load(string sfile)	{	dbl.loadscript( sfile );	}
	musicpath(string s)	{	smuspath = s;	}
	sndbgrpath(string s)	{	sbgrpath=s;	}
	_play(int ipos)	{
		int i[3], string s[2];
		i0 = 1;
		i1 = dbl.getcolsno( ipos );
		while( i0 < i1 )	{
			s0 = dbl.get( ipos, i0 );	i0++;
			if( s0 == "music" )	{
				s1 = smuspath + dbl.get( ipos, i0 );
				i0++;
				if( i0 < i1 )	{
					if( dbl.get( ipos, i0 )=="vol" )	{
						i0++;
						gameapi.setmusicvol( dbl.get( ipos, i0 ) );
						i0++;
					}
				} else {
					gameapi.setmusicvol( 100 );
				}
				gameapi.playmusic( s1 );
			} else if (s0 == "bgr")	{
				_sndbgr.load( sbgrpath + dbl.get( ipos, i0 ) );
				i0++;
				if( i0 < i1 )	{
					if( dbl.get( ipos, i0 )=="vol" )	{
						i0++;
						_sndbgr.setvol( dbl.get( ipos, i0 ) );
						i0++;
					}
				} else {
					_sndbgr.setvol( 100 );
				}
				this.playbgr();
			} else {	i0++;	}
		}
	}
	play()	{
		this.reset();
		this.readrow( gameapi.getgamename(), "_play" );
	}
	playbgr()		{	_sndbgr.play();	}
	stopbgr()	{	_sndbgr.stop(false);	}
}

/**************************************************************/
	// zmienne globalna - stany gry
new int igmstate;
new int igmdebug;
new int igmeasy;
new int igmdemo;
new int igmbegin;
new string sgmfontfile = "configs/fonts/ala.ttf";
new string sgmfontmono = "configs/fonts/mono.ttf";
new string SFXPATH = "sounds/sfx/";
new string BGRPATH = "sounds/bgr/";
new string MUSICPATH = "sounds/music/";
new string LANG = "pl";	// pl, eng, cze, slo
new string SNDPATH = "sounds/";
if( LANG=="pl" ) LANG="";
if( LANG.length > 0 ) SNDPATH += LANG + "/";

new int iResX = 1024;
new int iResY = 768;

/**************************************************************/
	// standardowa klasa do tworzenia zmiennych
class newvars		{
	init()	{
		new string _sclpath = "";
		new string _sclwavpath = "";
	}
	string _checkfont(string sfont, int isize, string sfnt)	{
		if( sfont==null )	sfont=sgmfontfile;
		if( sfont.contains(".ttf") )	{
			new font <sfnt>;
			<sfnt>.load( sfont, isize );
			sfont = sfnt;
		}
		sfont;
	}
	string checkfont(string sfont, int isize)	{
		._checkfont(sfont, isize, "_fnt");
	}
	bool begingame()	{
		igmbegin = !igmbegin;
		!igmbegin;
	}
	newarray(string styp, string sbase, int size)	{
		if( size<= 0 )	return;
		size--;
		while(size>=0)	{
			new <styp> <sbase+size>;
			size--;
		}
	}
	setgraphpath(string spath)	{	_sclpath = spath;	}
	setwavpath(string spath)	{ _sclwavpath = spath; }
	string getgraphpath()	{	return _sclpath; }
	string getsndpath()	{	return _sclwavpath; }
	newanima(string sname, string sfile, int z)	{
		new anima <sname>;
		<sname>.load(this.getgraphpath() + sfile);
		<sname>.setz(z);
	}
	newstdanima(string sname, string sfile, int z)	{
		this.newanima(sname, sfile, z);
		this.stdanaction(sname);
	}
	copyanimaactz(string ssrc, string sdest, string saction, int z)	{
		this.copyanimaact(ssrc, sdest, saction);
		<sdest>.setz(z);
	}
	copyanimaact(string ssrc, string sdest, string saction)	{
		this.copyanima(ssrc, sdest);
		<sdest>.setframe( saction, 0 );
	}
	copyanima(string ssrc, string sdest)	{
		new anima <sdest>;
		<sdest>.copy( ssrc );
	}
	copyanimas(string san, string sname, int istart, int ilosc)	{
		if (ilosc<0)	return;
		for(int i=0; i<ilosc; i++)	this.copyanima( san, sname + (istart + i)  );
	}
	newanimas(string sname, string sfile, int z, int ilosc)	{
		if(ilosc<0) return; 
		this.newanima(sname+"0", sfile, z);		// pierwsza load z zerem
		this.copyanimas(sname+"0", sname, 1, ilosc-1);		// pozostale kopiowane z niej
	}
	int newanframesgr(string san, string sname, int iaction, string sgr)	{	// tworzy animacje z klatek
		int ile = <san>.nofframes( iaction );
		this.copyanimas( san, sname, 0, ile );
		for(int i=0; i<ile; i++)	{
			<sname+i>.setframe(iaction, i);
			if( sgr!=null )	{	<sgr>.add( sname+i );	}
		}
		return ile;		// zwraca ilosc stworzonych animacji
	}
	int newanframes(string san, string sname, int iaction)	{	// tworzy animacje z klatek
		return this.newanframesgr(san,sname,iaction,null);
	}
	newcanvas(string sname, int w, int h, int r, int g, int b, int a, int z)	{
		new img <sname>;
		<sname>.create(w,h,r,g,b,a);
		<sname>.setz(z);
	}
	newimg(string sname, string sfile, int z)	{
		new img <sname>;
		<sname>.load(this.getgraphpath() + sfile);
		<sname>.setz(z);
	}
	copyimg(string ssrc, string sdest)	{
		new img <sdest>;
		<sdest>.copy(ssrc);
	}
	playmusic(string sfile)	{gameapi.playmusic( MUSICPATH + sfile );	}
	newsndfree(string sname, string sfile)	{
		new snd <sname>;
		<sname>.setstartstopflag(false, true);
		<sname>.load( this.getsndpath() + sfile);
	}
	snewsnd(string sname, string sfile)	{
		this.newsnd(sname,sfile);
		<sname>.addmethod("onfinish","__std_finish");
	}
	_newsnd(string sname, string sfile)	{
		new snd <sname>;
		<sname>.load( sfile);
	}
	newsfx(string sname, string sfile)	{	._newsnd(sname, SFXPATH + sfile);	}
	newbgr(string sname, string sfile)	{	._newsnd(sname, BGRPATH + sfile);	}
	newbgrloop(string s, string s2)	{	.newbgr(s,s2); .sndplayloop(s);	}
	newsnd(string sname, string sfile)	{	._newsnd(sname, .getsndpath+sfile);	}
	newsndloop(string sname, string sfile)	{
		this.newsnd(sname,sfile);
		this.looponfinish1( sname );
	}
	looponfinish1( string sob )	{<sob>.addmethod("onfinish","_stdsndloop");	}
	sndplayloop(string sob)	{
		this.looponfinish1( sob );
		<sob>.play();
	}
	newsnds(string sbase, int inamestart, string sfilebase, int ifilefrom, int ifileto)	{
		string s;
		int ile = ifileto-ifilefrom+1;
		for(int i=0; i<ile; i++)	{
			s = sbase + (inamestart + i);
			new snd <s>;
			<s>.load( this.getsndpath() + sfilebase + (ifilefrom+i) + ".wav" );
		}
	}
	newtimer(string sname, int idelay, int iticks)	{
		new timer <sname>;
		<sname>.settick(iticks);
		<sname>.delay(idelay);
	}
	newtimercycle(string sname, int icycle, int iticks)	{
		new timer <sname>;
		<sname>.settick(iticks);
		<sname>.setcycle(icycle);
	}
	stdanaction(string san)	{
		string s = <san>.actionname();
		if( s.contains("L")  )	this.looponfinish(san);
		else if( s.contains("H")  )	this.hideonfinish(san);
		if( s.contains("P")  )	<san>.play(-1);
	}
	int newanactionsgr(string san, string sname, string sgr)	{
		int ile = <san>.nofactions();
		this.copyanimas( san, sname, 0, ile );
		string s;
		for(int i=0; i<ile; i++)	{
			s = sname+i;
			<s>.setframe(i,0);
			this.stdanaction(s);
			if( sgr!=null )	{<sgr>.add( s );}
		}
		return ile;
	}
	int newanactions(string san, string sname)	{return this.newanactionsgr(san,sname,null);	}
	int newanfrbyactgr(string san, string sname, string sgr)	{
		int ile = <san>.nofactions();
		for( int i=0; i<ile; i++)	_ = this.newanframesgr(san, sname+i+"_", i, sgr);
		return ile;
	}
	int newanfrbyact(string san, string sname)	{return this.newanfrbyactgr(san,sname,null);	}
	int loadanfrbyact(string san, string sfile, int z)	{
		string s = "_"+san;
		this.newanima(s,sfile,z);
		int ile = this.newanfrbyact(s, san);
		<s>.hide();
		return ile;
	}
	int loadanactions(string san, string sfile, int z)	{
		string s = "_"+san;
		this.newanima(s, sfile, z);
		int ile = this.newanactions(s, san);
		<s>.hide();
		return ile;
	}
	int loadanframes(string san, string sfile, int iaction, int z)	{
		string s = "_"+san;
		this.newanima(s, sfile, z);
		int ile = this.newanframes(s, san, iaction);
		<s>.hide();
		return ile;
	}
	newbutimg(string sbut, string sstd, string smov, string sclick, string smouse)	{
		new button <sbut>;
		<sbut>.set(sstd, smov, sclick);
		<sbut>.setmouse(smouse);
	}
	newbutan(string sbut, string sanstd, string sanmov, string sanclick, string smouse)	{
		new button <sbut>;
		<sbut>.setan(sanstd, sanmov, sanclick);
		<sbut>.setmouse(smouse);
	}
	/*****************************************************/
	newdb(string sdb, string sfile)	{
		new db <sdb>;
		<sdb>.load( this.getgraphpath() + sfile );
	}
	newdbscript(string sdb, string sfile)	{
		new db <sdb>;
		<sdb>.loadscript( this.getgraphpath() + sfile );
	}
	vargmset(string svar, def val)	{
		string sg = gameapi.getgamename();
		if( !<sg>.hasvar(svar) )	<sg>.varnew( val.gettype(), svar );
		<svar> = val;
	}
}

/**************************************************************/
new img imglobcurs;		// globalny kursor aktywnosci
bsms.load("configs/kursorstd.png","configs/kursoract.png" );
	// modul obslugi standardowych kursorow myszy
module bsms {
	init()	{
		new img imgstd;
		new img imgact;
		new int msid = 0;		// 0- brak kursora 1-std lapka 2- active lapka 3- wlasny (wczytany w jakiejs grze)
	}
	load(string spath1, string spath2)	{
		imgstd.load(spath1);
		imgact.load(spath2);
		imglobcurs.copy("imgact");
		imglobcurs.hide();
		imgstd.hide();
		imgact.hide();
		this.reset();
		engine.stdbutcursor("imgstd");
	}
	setinitial()	{	mouse.stdcursor();	msid = 0;	}
	setstd()	{
		mouse.setcursor("imgstd");
		engine.stdbutcursor("imgstd");
		msid = 1;
	}
	setact()	{	mouse.setcursor("imgact");	msid = 2;	}
	setown()	{	msid=3;	}
	bool isinitial()	{	msid==0;	}
	bool isstd()	{	msid==1;	}
	bool isact()	{	msid==2;	}
	bool isown()	{	msid==3;	}
}

/***************************************************************************/

module clsurf	{
	init()	{}
	bool isin(int x, int y, int x1, int y1, int x2, int y2)	{	x >= x1 && x<=x2 && y>=y1 && y<=y2;	}
	bool isin2(int x, int y, int x1, int y1, int w, int h)	{	x >= x1 && x < x1+w && y>=y1 && y<y1+h;	}
	bool inscreen(int x, int y, int dx, int dy)	{	this.isin( x, y, 0-dx, 0-dy, 800+dx, 600+dy );	}
	bool insurf(int x, int y, string simg) { .isin(x,y,<simg>.getpx, <simg>.getpy, <simg>.getex-1, <simg>.getey-1);}
	bool issurfin(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)	{
		this.isin(x1,y1, x3,y3,x4,y4) || this.isin(x2,y1, x3,y3,x4,y4) ||
				this.isin(x1,y2, x3,y3,x4,y4) || this.isin(x2,y2, x3,y3,x4,y4);
	}
	bool commonsurface(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)	{
		this.issurfin(x1,y1,x2,y2, x3,y3,x4,y4) || 
				this.issurfin(x3,y3,x4,y4, x1,y1,x2,y2);
	}
	bool commonimgs(string simg1, string simg2)	{
		this.commonsurface(<simg1>.getpx(), <simg1>.getpy(), <simg1>.getex()-1, <simg1>.getey()-1,
				<simg2>.getpx(), <simg2>.getpy(), <simg2>.getex()-1, <simg2>.getey()-1 );
	}
	bool surfwithinsurf(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)	{
		this.isin(x1,y1, x3,y3,x4,y4) && this.isin(x2,y1, x3,y3,x4,y4) &&
				this.isin(x1,y2, x3,y3,x4,y4) && this.isin(x2,y2, x3,y3,x4,y4);
	}
	bool imgwithinimg(string simg1, string simg2)	{
		this.surfwithinsurf(<simg1>.getpx(), <simg1>.getpy(), <simg1>.getex()-1, <simg1>.getey()-1,
				<simg2>.getpx(), <simg2>.getpy(), <simg2>.getex()-1, <simg2>.getey()-1 );
	}
}

/* modul do obliczen odleglosci */

module cllen	{
	init()	{
		new int il1;
		new int ilx;
		new int ily;
	}
	int ilenx()	{ return ilx; }
	int ileny()	{ return ily; }
	int ilen4(int x1, int x2)	{	return (x1-x2)->abs();	}
	int ilen3(string simg1, string simg2)	{
		return this.ilen( <simg1>.getcx(), <simg1>.getcy(), <simg2>.getcx(), <simg2>.getcy() );
	}
	int ilen5(string simg1, string simg2)	{
		return this.ilen( <simg1>.getpx(), <simg1>.getpy(), <simg2>.getpx(), <simg2>.getpy() );
	}
	int ilen2(string simg1, int x, int y)	{return this.ilen( <simg1>.getcx(), <simg1>.getcy(), x,  y );	}
	int ilen(int x1, int y1, int x2, int y2)	{
		ilx = x1-x2;
		ily = y1-y2;
		return il1.length( ilx, ily );
	}
	int iclenx(string simg1, int x)	{	return <simg1>.getcx() - x;	}
	int iclenx2(string simg1, string simg2)	{	return <simg1>.getcx() - <simg2>.getcx();	}
	int icleny(string simg1, int y)	{	return <simg1>.getcy() - y;	}
	int icleny2(string simg1, string simg2)	{	return <simg1>.getcy() - <simg2>.getcy();	}
	int isbetween2(string simg1, string simg2, int x1, int y1, int x2, int y2)	{
		return this.isbetween(simg1, <simg2>.getcx(), <simg2>.getcy(), x1, y1, x2, y2);
	}
	int isbetween(string simg1, int xx, int yy, int x1, int y1, int x2, int y2)	{
		il1 = this.ilen( simg1, xx, yy );
		return ilx>=x1 && ilx<=x2 && ily>=y1 && ily<=y2;
	}
	int ilodlen(string s1, string s2)	{	.ilen(<s1>.lodx,<s1>.lody, <s2>.lodx, <s2>.lody);	}
	int iposlen(string simg1, string simg2)	{
		.ilen( <simg1>.getpos, <simg2>.getpos );
	}
}

/****************************************************/
class classansearcher	{
	init()	{}
	def _findnotr(string san, int x, int y, int dx, int dy)	{
		int ex = <san>.getex() , int ey = <san>.getey();
		while( x!=ex && y!=ey )	{
			if( <san>.isin(x,y,false,true) ) return x,y;
			x+=dx;	y+=dy;
		}
		return -1,-1;
	}
	def firstnotrx1y(string san)	{	return ._findnotr(san,<san>.getpx(), <san>.getpy(), 1, 0);	}
	def firstnotrexy1(string san)	{	return ._findnotr(san,<san>.getex()-1, <san>.getpy(), 0, 1);	}
	def firstnotrxy1(string san)	{	return ._findnotr(san,<san>.getpx(), <san>.getpy(), 0, 1);	}
	def firstnotrx1ey(string san)	{	return ._findnotr(san,<san>.getpx(), <san>.getey()-1, 1, 0);	}
}

class signal_pack	{
	init()	{}
	addsignals(string san)	{
		<san>.addmethod("operator<", func { (string sfun) this.addmethod("onfinish", sfun ); } );
	}
}
/***************************************************************************/
	// rozszerzenia dla animcaji
class anima_pack : signal_pack	{
	init()	{}
	public resizemethods(string san)	{
		<san>.addmethod("_clanbuildpomvars", func { new int _ixp; new int _iyp; } );
		<san>._clanbuildpomvars();
		<san>.addmethod("setbpos", func {(int x, int y) .setpos( x-.lodx, y-.lody ); });
		<san>.addmethod("saverelpos", func {(int x,int y)_ixp=x-.getpx;_iyp=y-.getpy;} );
		<san>.addmethod("setrelpos", func{(int x, int y) .setbpos( x - _ixp, y - _iyp );});
		<san>.addmethod("mssaverelpos", func {.saverelpos( mouse.getpos );} );
		<san>.addmethod("mssetrelpos", func {.setrelpos( mouse.getpos );});
		<san>.addmethod("rplay", func {(string sact)if( !.isplaying(sact) ) .play(sact);});
		<san>.addmethod("setcpos", func {(int x, int y).setbpos( x-.getw/2, y-.geth/2 );});
		<san>.addmethod("operator=", func { (string s) .copy(s); } );
		<san>.addmethod("operator==", func { (string s)
			.actionnr==<s>.actionnr && .framenr==<s>.framenr; } );
		this.addsignals(san);
	}
}

class timer_pack : signal_pack	{
	init()	{}
	resizemethods(string sob)	{
		this.addsignals(sob);
	}
}
/***************************************************************************/
class vector_pack	{
	init()	{}
	each(string sfun)	{	for( int i=0; i<.size; i++) this.<sfun>(.get(i));	}
	resizemethods(string svec)	{
		<svec>.addmethod("each", "each");
		<svec>.addmethod("operator-", func { (def x) this.remove(x); this; } );
		<svec>.addmethod("operator+", func { (def x) this.add(x); this; } );
	}
}

/***************************************************************************/

public new_object(string styp, string sob)	{
	new <styp> <sob>;
	<styp+"_pack">::resizemethods(sob);
}
public new_anima(string s)	{	.new_object("anima",s);	}
public new_vector(string s)	{	.new_object("vector",s);	}

/***************************************************************************/

class classanfilter	{
	init()	{}
	buildanfilter()	{
		new filter ft;
		ft.link( this.getname() );
		ft.setpivottype(1);
	}
	public build(string san)	{
		<san>.addmethod("buildanfilter","buildanfilter");
		<san>.buildanfilter();
		<san>.addmethod("setopacity",	func {	(int iop) ft.setopacity(iop); }		);
		<san>.addmethod("setzoom",		func {	(real r) ft.setzoom(r); }			);
		<san>.addmethod("setangle",		func {	(real r) ft.setangle(r); }			);
		<san>.addmethod("getangle",		func {	return ft.getangle; }			);
		<san>.addmethod("rotate",		func {	(real r)	ft.rotate(r); }			);
		<san>.addmethod("setpivottype",	func {	(int ityp) ft.setpivottype(ityp); }	);
		<san>.addmethod("unlink",		func {	ft.unlink(); }					);
		<san>.addmethod("link",			func {	ft.link(this); }					);
		<san>.addmethod("blend",		func {	(string s) ft.blend(s); }			);
		<san>.addmethod("mask",		func {	(string s) ft.mask(s); }			);
	}
}

/***************************************************************************/

class classancounter	{
	init()	{
		new int iile;
		new int id;
		new string _san;
		new vector _vs;
		new int _pos;
	}
	set(string sname, int ile)	{
		_san = sname;
		iile = ile;
		id = 0;
		_pos = sname.length();
		_vs.resize( ile, false );
	}
	string get()	{
		string s = _san+id;
		id = (id+1)%iile;
		return s;
	}
	string getf()	{
		for(int i=0; i<iile; i++)	{
			if( !_vs.get(i) )	{
				_vs.set(i, true);
				return _san+i;
			}
		}
		return null;	// brak wolnych
	}
	retf(string s)	{	_vs.set( s.getb( _pos, 10 ), false );	}
	isfree(int pos)	{	return _vs.get(pos);	}
	int getile()	{	return iile;	}
}

/**************************************************************/
	// operacje na obrazach, dzwiekach, timerach i animacjach
class gmobjvec {
	init()	{
		new vector lsim;
		lsim.type("string");
	}
	operator=(string sgr)	{
		if( engine.varexist(sgr) )	{
			match(<sgr>.gettype())	{
				"vector" => this.copy(sgr);
				"gmobjvec" => this.copy(sgr);
				"gmimgvec" => this.copy(sgr);
				? => {	this.free(); this.add(sgr); }
			}
		} else {
			this.free();
			this.add(sgr);
		}
	}
	operator+(string sob)	{	this.add(sob);		return this;	}
	operator-(string sob)	{	this.remove(sob);	return this;	}
	removegr(string sgr)	{	for( int i=0; i < <sgr>.size; i++)	.remove( <sgr>.get(i) );	}
	addtogr(string sgr)	{	for( int i=0; i<this.size(); i++)	<sgr>.add(this.get(i));	}
	addgr(string sgr)	{	for( int i=0; i< <sgr>.size(); i++)	this.add( <sgr>.get(i) );	}
	addgroups	{	.withlist("addgr");	}
	copy(string sgr)	{
		this.free();
		this.addgr(sgr);
	}
	free()	{ lsim.free();	}
	int size()	{ return lsim.size(); }
	bool empty()	{	return this.size()==0;	}
	hash()	{ lsim.hash(); }
	string first()	{ return lsim.get(0); }
	string last()	{ return lsim.get( lsim.size()-1 ); }
	print()	{	lsim.print();	}
	string get(int i)	{ return lsim.get(i); }
	add(string simg)	{	lsim.add(simg);	}
	additer(string s, int ifrom, int iile)	{
		while( iile>0 )	{
			.add(s+ifrom);
			ifrom++;
			iile--;
		}
	}
	buildarray(string styp, string sname, int ilosc)	{
		<gameapi.getgamename>.newarray(styp,sname,ilosc);
		.additer(sname,0,ilosc);
	}
	deleteall	{	for( int i=0; i<.size; i++)	delete <.get(i)>;	}
	deleteallgm	{
		@s = gameapi.getgamename;
		for( int i=0; i<.size; i++)	<s>.vardel(.get(i));
	}
	addbegin(string simg)	{	lsim.addbegin(simg);	}
	swap(int i, int j)	{	lsim.swap(i,j);	}
	addonce(string simg)	{	if( !lsim.contains(simg) )	lsim.add(simg);	}
	sepadd(string separator)	{
		string s = _;
		while( s!=separator )	{
			this.addbegin(s);
			s = _;
		}
	}
	addlist	{	.sepadd(A);	}
	insertat(string sob, int pos)	{
		@ile = .size;
		if( pos<=0 )	.addbegin(sob);
		else if (pos>=ile)	.add(sob);
		else {
			.add(null);
			for( @i=ile; i>pos; i--)	.set( i, .get(i-1) );
			.set(pos, sob );
		}
	}
	remove(string simg)	{	lsim.remove(simg);	}
	removeat(int pos)		{	lsim.removeat(pos);	}
	removefirst			{	lsim.removeat(0);	}
	removelast			{	lsim.removeat(.size-1);	}
	removealloccurs(string simg)	{	while(this.contains(simg))	this.remove(simg);	}
	removeif(string sfun)	{
		for( int i=0; i<.size; i++)
			if( <.get(i)>.<sfun>() )  .removeat(i);
	}
	int find(string simg)	{ return lsim.find(simg); }
	int contains(string simg)	{ return lsim.contains(simg); }
	addgroup(string sob, int ile)	{	this.addgroup2( sob, 0, ile-1 );	}
	addgroup2(string sob, int ifrom, int ito)	{
		while( ifrom <= ito )	{
			this.add( sob+ifrom );
			ifrom++;
		}
	}
	string rand()	{
		int ile = .size;
		ile>0 ? .get(ile.rand) : null;
	}
	string randdiff(string s)	{
		int ile = .size;
		if( ile>0 )	{
			int id = ile.rand;
			int i = id;
			while( .get(id)==s )	{
				id = (id+1)%ile;
				if( id==i )	return null;
			}
			return .get(id);
		}
		null;
	}
	buildfullvars	{	.each( func { (@id) .buildfullname; } );	}
	buildvars		{	.each( func { (@id) .addtogamevars(this); } );	}
	/******************* metody na obiektach grupy *****************************/
	movefrom(string simg, int x, int y)	{
		int i = this.find(simg);
		if( i>=0 )	{
			while( i<lsim.size() )	{
				<lsim.get(i)>.move(x,y);
				i++;
			}
		}
	}
	move(int x, int y)	{	this.eval2("move",x,y);	}
	setpos(int x, int y)	{	this.eval2("setpos",x,y);	}
	show()	{	this.eval("show");	}
	hide()	{	this.eval("hide");	}
	stop(int fin)	{	this.eval1("stop",fin);	}
	play()	{	this.eval("play");	}
	setdelay(int d)	{	this.eval1("setdelay",d);	}
	graddmethod(string sdest, string ssrc)	{	this.eval2("addmethod",sdest,ssrc);	}
	string getimg(int x, int y, int bignorehidden, int bignorealpha)	{
		for( int i=lsim.size()-1; i>=0; i--)	{
			if( <lsim.get(i)>.isin( x,y,bignorehidden,bignorealpha ) )	return lsim.get(i);
		}
		return null;
	}
	int isin(int x, int y, bool bignorehidden, bool bignorealpha)	{
		for( int i=lsim.size()-1; i>=0; i--)	{
			if( <lsim.get(i)>.isin( x,y,bignorehidden,bignorealpha ) )	return i+1;
		}
		return false;
	}
	setframe(def ac, int ifr)	{	this.eval2("setframe",ac,ifr);	}
	setz(int z)	{	this.eval1("setz",z);	}
	/**************/
	eval(string sfunc)	{
		for(int i=0; i<lsim.size(); i++)	{<lsim.get(i)>.<sfunc>();	}
	}
	eval1(string sfunc, def darg)	{
		for(int i=0; i<lsim.size(); i++)	{<lsim.get(i)>.<sfunc>(darg);}
	}
	eval2(string sfunc, def darg1, def darg2)	{
		for(int i=0; i<lsim.size(); i++)	{<lsim.get(i)>.<sfunc>(darg1, darg2);}
	}
	eval3(string sfunc, def darg1, def darg2, def darg3)	{
		for(int i=0; i<lsim.size(); i++)	{<lsim.get(i)>.<sfunc>(darg1, darg2, darg3);}
	}
	int _find(string sfun, def id)	{
		for( int i=0; i<this.size; i++) if ( <this.get(i)>.<sfun>()==id ) return i;
		-1;
	}
	int _find1(string sfun, @id)	{
		for( int i=0; i<.size; i++) if ( <this.get(i)>.<sfun>(id) ) return i;
		-1;
	}
	each(string sfun)	{	for( int i=0; i<.size; i++) <.get(i)>.<sfun>(i);	}
	each1(string sfun, @d1)	{	for( int i=0; i<.size; i++) <.get(i)>.<sfun>(i, d1);	}
	each2(string sfun, @d1, @d2)	{	for( int i=0; i<.size; i++) <.get(i)>.<sfun>(i, d1, d2);	}
	bool ineach(string sfun)	{
		for( int i=0; i<.size; i++) if( !<.get(i)>.<sfun>(i) )	return false;
		true;
	}
	int find_closest(string sob, string sfun)	{
		if( .empty ) return;
		int id = 0, real il;
		real ilen = <.get(0)>.<sfun>(sob);
		for( int i=1; i<.size; i++)	{
			il = <.get(i)>.<sfun>(sob);
			if( il < ilen )	{
				id = i;
				il = ilen;
			}
		}
		id;
	}
	/**************/
	sortimgsfun(string sfun)	{	lsim.vecsort(sfun);	}
	sortimgs()	{	// sortowanie od najmniejszych
		lsim.vecsort("_scmpimg1");
	}
	bool _scmpimg1(string s0, string s1)	{
		return ( <s0>.getz() < <s1>.getz() || ( <s0>.getz()==<s1>.getz() && <s0>.getidobj() < <s1>.getidobj() ) );
	}
}

class gmimgvec : gmobjvec	{
	init()	{
		gmobjvec::init();
		new int _ix = 0;
		new int _iy = 0;
		new int _iz = 0;
		new int _ifound = -1;
	}
	_setpos(int x, int y)	{	|_ix, _iy| = x,y;	}
	int lodx()	{0;}
	int lody()	{0;}
	int getposx()	{	return _ix;	}
	int getposy()	{	return _iy;	}
	int getpos()	{	return _ix, _iy;	}
	int getpx() {	return _ix;	}
	int getpy() {	return _iy;	}
	int getw()	{	return this.getex()-this.getpx();	}
	int geth()	{	return this.getey()-this.getpy();	}
	int getcx() {	return this.getpx()+this.getw()/2;	}
	int getcy() {	return this.getpy()+this.geth()/2;	}
	int getz()	{	return _iz;	}
	int getex()	{
		int ile = this.size();
		if( ile<=0 )	{	return _ix;	}
		int x = <this.get(0)>.getex();
		int x2;
		for( int i=1; i<ile; i++)	{
			x2 = <this.get(i)>.getex();
			if( x2>x )	{	x=x2;	}
		}
		return x;
	}
	int getey()	{
		int ile = this.size();
		if( ile<=0 )	{	return _iy;	}
		int y = <this.get(0)>.getey();
		int y2;
		for( int i=1; i<ile; i++)	{
			y2 = <this.get(i)>.getey();
			if( y2>y )	{	y=y2;	}
		}
		return y;
	}
	int _getpx()	{
		int ile = this.size();
		if( ile<=0 )	{	return _ix;	}
		int x = <this.get(0)>.getpx();
		int x2;
		for( int i=1; i<ile; i++)	{
			x2 = <this.get(i)>.getpx();
			if( x2<x )	{	x=x2;	}
		}
		return x;
	}
	int _getpy()	{
		int ile = this.size();
		if( ile<=0 )	{	return _iy;	}
		int y = <this.get(0)>.getpy();
		int y2;
		for( int i=1; i<ile; i++)	{
			y2 = <this.get(i)>.getpy();
			if( y2<y )	{	y=y2;	}
		}
		return y;
	}
	/*minx	{	.find_closest(null, func {(@s) .getpx; } );	}
	miny	{	.find_closest(null, func {(@s) .getpy; } );	}
	countborders	{
		_ix = .minx;
		_iy = .miny;
	}*/
	setz(int z)	{
		_iz = z;
		this.eval1("setz",z);
	}
	move(int x, int y)	{
		_ix +=x;
		_iy +=y;
		this.eval2("move",x,y);
	}
	setpos(int x, int y)	{
		_ix = x;
		_iy = y;
		this.eval2("setpos",x,y);
	}
	setpos2(int x, int y)	{
		_ix = x;
		_iy = y;
		if( !.empty )	{
			x -= <.get(0)>.getpx;
			y -= <.get(0)>.getpy;
			.move(-x,-y);
		}
	}
	changeframe(int ifr) {
		string s;
		for( int i=0; i<.size; i++)	{
			s = .get(i);
			<s>.setframe( <s>.actionnr(-1), ifr );
		}
	}
	txtreset	{	for( int i=0; i<.size; i++) <.get(i)>.txtset("");	}
	anputgr()	{	this.eval("anputgr");	}
	anputy(int ypos)	{	this.eval1("anputy", ipos);	}
	int isin(int x, int y, bool bignorehidden, bool bignorealpha)	{
		for( int i=lsim.size()-1; i>=0; i--)	{
			if( <lsim.get(i)>.isin( x,y,bignorehidden,bignorealpha ) )	{
				_ifound=i;
				return i+1;
			}
		}
		_ifound = -1;
		return false;
	}
	int isinfunc(int x, int y, string sfunc)	{
		for( int i=lsim.size()-1; i>=0; i--)	{
			if( <lsim.get(i)>.<sfunc>( x,y ) )	{
				_ifound=i;
				return i+1;
			}
		}
		_ifound = -1;
		return false;
	}
	int isincut(int x, int y, bool bignorehidden, bool bignorealpha)	{
		for( int i=lsim.size()-1; i>=0; i--)	{
			if( <lsim.get(i)>.withincut(x,y) && <lsim.get(i)>.isin( x,y,bignorehidden,bignorealpha ) )	{
				_ifound=i;
				return i+1;
			}
		}
		_ifound = -1;
		return false;
	}
	int findif(string sfunc)	{	._find( sfunc,true);	}
	int getfound()	{	return _ifound;	}
	string getsfound()	{	return this.get(_ifound);	}
	int findfr(int id)	{	._find("framenr", id);	}
	int findsfr(string s)	{	._find("framename", s);	}
	int findac(int id)	{	._find("actionnr", id);	}
	int findsac(string sac)	{	._find("actionname", sac);	}
	int nearest_to(string sob)	{
		//.find_closest(sob, func {(string s) 0->length( .getpx-<s>.getpx, .getpy-<s>.getpy ); } );
		.find_closest(sob, func {(string s) cllen.ilen5(this,s); } );
	}
	/*def find_min(string s)	{
		if( .empty ) return;
		int x = <s>.getpx;
		int y = <s>.getpy;
		int id = 0, int il;
		int ilen = id.length( <.get(0)>.getpx-x, <.get(0)>.getpy-y );
		for( int i=1; i<.size; i++)	{
			il = id.length( <.get(i)>.getpx-x, <.get(i)>.getpy-y );
			if( il < ilen )	{
				id = i;
				il = ilen;
			}
		}
	}*/
	/****************************/
	loadallan(string sname, string sfile, int z)	{
		string s = gameapi.getgamename();
		<s>.newanima(sname,sfile,z);
		_ = <s>.newanfrbyactgr(sname, sname, this);
		<sname>.hide();
	}
	operator*(string s)	{
		string sg = gameapi.getgamename;
		string san;
		if ( s.contains(".pyz") ) {
			san = "an" + s.strsubes(".pyz");
			<sg>.newanima(san,s,0);
		} else san = s;
		_ = <sg>.newanactionsgr(san, san, this);
		<san>.hide();
	}
	operator<(string s)	{
		string sg = gameapi.getgamename;
		string san;
		if ( s.contains(".pyz") ) {
			san = "an" + s.strsubes(".pyz");
			<sg>.newanima(san,s,0);
		} else san = s;
		_ = <sg>.newanfrbyactgr(san, san, this);
		<san>.hide();
	}
}

class gmmaskvec : gmimgvec	{
	init()	{
		gmimgvec::init();
	}
	int isin(int x, int y, bool bigvis, bool bigalpha)	{
		return gmimgvec::isin(x,y,false,bigalpha);
	}
}


class classsound {
	init()	{
		new string _csplay = null;
	}
	creset()	{ _csplay = null; }
	string cgetactsnd()	{ return _csplay; }
	crselfplay(string ssnd)	{
		if( !this.cisplaying() )	this.cbplay(ssnd);
		else if ( this.cgetactsnd()!=ssnd )	this.cbplay(ssnd);
	}
	cbselfplay(string ssnd)	{
		if( !.cisplaying || .cgetactsnd!=ssnd )	.cbplay(ssnd);
	}
	cbplay(string ssnd)	{
		if(this.cisplaying())	<_csplay>.stop(true);
		_csplay = ssnd;
		if( ssnd!=null )	<ssnd>.play();
	}
	cbplay2(string ssnd)	{
		if(this.cisplaying())	<_csplay>.stop(false);
		_csplay = ssnd;
		if( ssnd!=null )	<ssnd>.play();
	}
	crplay(string ssnd)	{
		if(_csplay!=null && <_csplay>.isplaying() )	return;
		_csplay = ssnd;
		if( ssnd!=null )	<ssnd>.play();
	}
	crbgplay(string ssnd)	{	if( ssnd != null && !<ssnd>.isplaying() )	<ssnd>.play();	}
	crandplay(string ssnd, int irand, string styp)	{
		if( irand.rand()==0 )	this.<"c"+styp+"play">( ssnd );
	}
	cplayf(string styp, string ssnd, string sfun)	{
		this.<"c"+styp+"play">(ssnd);
		if( <ssnd>.isplaying() && sfun!=null)	<ssnd>.addmethod("onfinish",sfun);
	}
	//cactsndstop(bool bfin)	{	if(_csplay!=null)	<_csplay>.stop(bfin);	}
	cactsndstop(bool bfin)	{
		if(.cisplaying)	<_csplay>.stop(bfin);
	}
	cstopsnds(bool b)	{
		if( _csplay.in && .cisplaying )
			.cactsndstop(b);
	}
	bool cisplaying()	{	_csplay!=null ? <_csplay>.isplaying() : false;	}
}

/***************************************************************************/
class classsndbank	{
	init()	{
		new int itype;
		new int ilicz = 0;
		new int iile;
		new string splay=null;
		new string ssnd = "snd";
	}
	/********************************/
	loadsingle(string sfile, int ile)	{
		if( ile<=0)	{	iile=0;	return;	}
		iile=ile;
		itype=0;
		for( int i=0; i<ile; i++)	newvars::newsnd( ssnd+i, sfile );
	}
	/********************************/
	load(string sfilebase, int ifilefrom, int ifileto, int ityp, int itypstart)	{
		iile = ifileto-ifilefrom+1;
		if(iile<=0)	{
			iile = 0;
			return;
		}
		newvars::newsnds( ssnd, 0, sfilebase, ifilefrom, ifileto);
		itype = ityp;			// 0 - po kolei, 1 - random
		if(itypstart==1)	{	// 0 - od pierwszego, 1 - randomowy
			ilicz = iile.rand( );
		}
	}
	addmethod(string ssig, string sfunc)	{
		for( int i=0; i<iile; i++)	<ssnd+i>.addmethod( ssig, sfunc );
	}
	stop(int ifin)	{	if(splay!=null)	<splay>.stop(ifin);	}
	int isplaying()	{	splay!=null ? <splay>.isplaying() : false;	}
	randplay( int irand )	{	if( irand.rand()==0 )	this.play();	}
	playid(int id)	{
		ilicz=id%iile;
		this.play();
	}
	play()	{
		this.stop(false);
		this.bgplay();
	}
	reset()	{	ilicz=0;	}
	/************************************************/
	rbgplay()	{	if( !this.isplaying() )	this.bgplay();	}
	rplay()	{	if( !this.isplaying() )	this.play();	}
	bgplay()	{
		splay = ssnd + ilicz;
		<splay>.play();
		if( itype==0)	ilicz = (ilicz+1)%iile;
		else if (itype==1)	ilicz = iile.rand();
	}
	setvol(int vol)	{	for( int i=0; i<iile; i++)	<ssnd+i>.setvol( vol );	}
}

/**************************************************************/
	// standardowe czynnosci przy grach, popakowane w metody
class classgame : newvars , classsound {
	init()	{
		newvars::init();
		classsound::init();
		new int _iconstid;
	}
	/**************************************************************/
	bkg=(@sfile)	{
		if( sfile.contains(".pyz") ) .newanima("anbkg", sfile, 0);
		else .newimg("imgbkg",sfile,0);
	}
	bgr=(@sfile)	{
		//this.csndplayloop("sndbgr",sfile);
		.csndbgr(sfile);
	}
	path=(@s)	{	.setgraphpath("scripts/"+s+"/");	}
	cycle=(@stimer, @sfun)	{	.cnewtimercyclefin(stimer,1,1,sfun);	}
	timer=(@stimer, @itime, @sfun) { .cnewtimerfin(stimer,itime,1,sfun);	}
	def _getflags(string s)	{
		@bloop = false;
		if( s.contains("L") )	{
			s.strremove("L");
			bloop=true;
		}
		@bplay = false;
		if( s.contains("P") )	{
			s.strremove("P");
			bplay=true;
		}
		@bhide = false;
		if( s.contains("H") )	{
			s.strremove("H");
			bhide=true;
		}
		return s,bloop,bplay,bhide;
	}
	img=(@sfile)	{
		|sfile,@bloop,@bplay,@bhide| = ._getflags(sfile);
		@iz = 0;
		if( sfile.contains(" ") )	{
			iz = sfile.strgetfrom(" ");
			sfile = sfile.strgetto(" ");
		}
		string sname = sfile.strsube(4);
		string s;
		if( sfile.contains(".pyz") ) {
			s = "an" + sname;
			.newanima(s, sfile, iz);
		} else {
			s = "img" + sname;
			.newimg(s, sfile, iz);
		}
		if( bloop ) <s>.anloopfin;
		if( bplay ) <s>.play(-1);
		if( bhide ) <s>.hide;
	}
	imgs=	{	.withlist("img=");	}
	clone(string sob)	{
		<gameapi.getgamename> (this, .gettype, sob) { (@sthis, @styp, @sob)
			new <styp> <sob>;
			<sob>.copy(sthis);
		};
	}
	clones=	{	.withlist("clone");	}
	list=(@sname)	{
		@s=_;
		new gmobjvec <sname>;
		while(A!=s)	{
			<sname>.addbegin(s);
			s = _;
		}
	}
	list2={
		@s = .newconst("gmobjvec");
		.list=(s);
		s;
	}
	debug=(@b)	{	engine.setdebugstate(b);	}
	sfx=(string s)	{
		|s,@bloop,@bplay,_| = ._getflags(s);
		@ivol = 100;
		if( s.contains(" ") )	{
			ivol = s.strgetfrom(" ");
			s = s.strgetto(" ");
		}
		string sf = "fx"+s;
		//.newsnd(sf, "sfx/"+s+".wav");
		.newsfx( sf, s+".wav");
		<sf>.setvol( ivol );
		if( bloop ) <sf>.addmethod("onfinish","_stdsndloop");
		if( bplay ) <sf>.play;
	}
	sfxs=	{	.withlist("sfx=");	}
	tickstart	{
		if( !.hasvar("__timspeed") )	new TicksCounter __timspeed;
		__timspeed.start;
	}
	tickstop	{	__timspeed.print("ticker: ");	}
	/**************************************************************/
	csndplayloop(string ssnd, string sfile)	{
		this.newsndloop(ssnd,sfile);
		<ssnd>.play();
	}
	csndbgr(string sfile)	{
		//this.csndplayloop("sndbgr",sfile);
		.newbgr("sndbgr", sfile );
		.sndplayloop("sndbgr");
	}
	cloadcursor(string sfile)	{
		if( sfile.contains(".") )	{
			.newimg("imgkursor", sfile,0);
			sfile = "imgkursor";
		}
		<sfile>.hide();
		mouse.setcursor(sfile);
		engine.stdbutcursor(sfile);
		bsms.setown();
	}
	/****************************************************************/
	newimgarray(string sname, string styp, string sn, int ile)	{
		new gmimgvec <sname>;
		<sname>.buildarray(styp,sn,ile);
	}
	newfont(string sfnt, string sfile, int isize)	{
		new font <sfnt>;
		<sfnt>.load( sfile, isize );
	}
	monofont(string sfnt, int isize)	{	.newfont(sfnt, sgmfontmono, isize);	}
	string snewfont(string sfontfile, int isize)	{
		string s = .newconst("font");
		<s>.load( sfontfile, isize );
		return s;
	}
	string stdfont(int isize)	{	.snewfont( sgmfontfile, isize	);	}
	int getconstid	{	_iconstid++;	_iconstid-1;	}
	string newconst(string styp)	{
		string s = "const"+styp+.getconstid;
		new <styp> <s>;
		return s;
	}
	string consttext(string stext, int x, int y, int isize, int r, int g, int b)	{
		string s = this.newconst("text");
		string sf = .stdfont(isize);
		<s>.setfont(sf);
		<s>.set(stext);
		<s>.createtxt(r,g,b);
		<s>.setpos(x,y);
		return s;
	}
	newtext(string stxt, string stext, string sfont, int r, int g, int b)	{
		new text <stxt>;
		<stxt>.set(stext);
		<stxt>.setfont(sfont);
		<stxt>.createtxt(r,g,b);
	}
	newtextposz(string stxt, string stext, string sfont, int r, int g, int b, int x, int y, int z)	{
		.newtext(stxt,stext,sfont,r,g,b);
		<stxt>.anposz(x,y,z);
	}
	/****************************************************************/
	cfinmethod(string sobj, string sfuncfin)	{	<sobj>.addmethod("onfinish", sfuncfin);	}
	cnewsndfin(string sname, string sfile, string sfunc)	{
		this.newsnd(sname,sfile);
		this.cfinmethod(sname,sfunc);
	}
	cnewsndsfin(string sbase, int inamestart, string sfilebase, int ifilefrom, int ifileto, string sfunc)	{
		this.newsnds(sbase, inamestart, sfilebase, ifilefrom, ifileto);
		this.caddobjsfunfin(sbase, inamestart, inamestart+( ifileto-ifilefrom), sfunc);
	}
	cnewsndfinbplay(string sname, string sfile, string sfunc)	{
		this.cnewsndfin(sname,sfile,sfunc);
		this.cbplay(sname);
	}
	cnewtimerfin(string sname, int idelay, int iticks, string sfunc)	{
		this.newtimer(sname,idelay,iticks);
		this.cfinmethod(sname,sfunc);
	}
	cnewtimercyclefin(string sname, int icycle, int iticks, string sfunc)	{
		this.newtimercycle(sname,icycle,iticks);
		this.cfinmethod(sname,sfunc);
	}
	/****************************************************************/
	caddobjsfun(string ssnd, int ifrom, int ito, string ssig, string sfunc)	{
		while( ifrom <= ito )	{
			<ssnd+ifrom>.addmethod( ssig, sfunc+ifrom );
			ifrom++;
		}
	}
	caddobjsfunfin(string ssnd, int ifrom, int ito, string sfunc)	{
		this.caddobjsfun( ssnd, ifrom, ito, "onfinish", sfunc );
	}
	/****************************************************************/
	newancounter(string scounter, string sname, string sfile, int z, int ile)	{
		this.newanimas( sname, sfile, z, ile);
		new classancounter <scounter>;
		<scounter>.set( sname, ile );
	}
	newancounterh(string scounter, string sname, string sfile, int z, int ile)	{
		this.newancounter( scounter, sname, sfile, z , ile );
		for( int i=0; i<ile; i++)	<sname+i>.hide();
	}
	newancounterf(string scounter, string sname, string sfile, int z, int ile, string sfun)	{
		this.newancounter( scounter, sname, sfile, z , ile );
		for( int i=0; i<ile; i++)	<sname+i>.addmethod("onfinish", sfun);
	}
	newancounterhf(string scounter, string sname, string sfile, int z, int ile, string sfun)	{
		this.newancounter( scounter, sname, sfile, z , ile );
		for( int i=0; i<ile; i++)	{
			<sname+i>.addmethod("onfinish", sfun);
			<sname+i>.hide();
		}
	}
	cnewanimafin(string sname, string sfile, int z, string sfunc)	{
		this.newanima(sname, sfile, z);
		<sname>.addmethod("onfinish", sfunc );
	}
	ccopyanimafin(string sname, string snew, string sfunc)	{
		this.copyanima(sname, snew);
		<snew>.addmethod("onfinish", sfunc );
	}
	/****************************************************************/
	cloadwavs(string sdb, string sfile)	{
		this.newdb( sdb, sfile );
		int id = 0;
		int ile = <sdb>.getrowsno();
		int i[6], string s[5];
		while( id < ile )	{
			i1 = <sdb>.getcolsno(id);
			i2 = 0;
			s1 = <sdb>.get( id, i2 );	i2++;
			if( s1.getb(0,1)!="#" )	{
				s3 = <sdb>.get( id, i2 );	i2++;
				if( s1=="wav" || s1=="sfx" )	{
					s2 = <sdb>.get( id, i2 );	i2++;
					if( s1=="sfx")	{
						this.newsfx( s3, s2 );
					} else { this.newsnd( s3, s2 ); }
					if( i2 < i1 )	{
						s1 = <sdb>.get( id, i2 );	i2++;
						s2 = <sdb>.get( id, i2 );	i2++;
						if( s1=="method" )	{
							<s3>.addmethod("onfinish", s2 );
						} else if (s1.gete(0,4)=="play")	{
							this.<"c"+s1.gete(4,10)+"playonfin">(s3, s2);
						} else if ( s1=="vol" )	{
							<s3>.setvol( s2 );
						}
					}
				} else if (s1=="group")	{
					s2 = <sdb>.get( id, i2 );	i2++;
					i3 = <sdb>.get( id, i2 );	i2++;
					i4 = <sdb>.get( id, i2 );	i2++;
					if( i2 < i1 )	{		// jest method
						s1 = <sdb>.get( id, i2 );	i2++;
						if( s1=="method" )	{
							s4 = <sdb>.get( id, i2 );	i2++;
							this.cnewsndsfin( s3, i3, s2, i3, i4, s4 );
						}
					} else {
						this.newsnds( s3, i3, s2, i3, i4 );
					}
				} else if (s1=="bank")	{
					s2 = <sdb>.get( id, i2 );	i2++;
					i0 = <sdb>.get( id, i2 );	i2++;
					i3 = <sdb>.get( id, i2 );	i2++;
					i4 = <sdb>.get( id, i2 );	i2++;
					i5 = <sdb>.get( id, i2 );	i2++;
					new classsndbank <s3>;
					<s3>.load( s2, i0, i3, i4, i5);
					if( i2<i1)	{
						s1 = <sdb>.get( id, i2 );	i2++;
						if( s1=="method")	{
							s4 = <sdb>.get( id, i2 );	i2++;
							<s3>.addmethod( "onfinish", s4 );
						} else if (s1=="vol")	{
							<s3>.setvol( <sdb>.get( id, i2 ) );
						}
					}
				} else if ( s1=="method" )	{
					s2 = <sdb>.get( id, i2 );	i2++;
					i3 = <sdb>.get( id, i2 );	i2++;
					i4 = <sdb>.get( id, i2 );	i2++;
					while( i3<=i4)	{
						<s2+i3>.addmethod("onfinish", s3);
						i3++;
					}
				} else if ( s1=="singlebank")	{
					s2 = <sdb>.get( id, i2 );	i2++;
					i3 = <sdb>.get( id, i2 );	i2++;
					new classsndbank <s3>;
					<s3>.loadsingle( s2, i3 );
				} else if ( s1=="bgr" )	{
					this.csndbgr( s3 );
					if( i2 < i1 )	{
						if( <sdb>.get( id, i2 )=="vol" )	{
							i2++;
							sndbgr.setvol( <sdb>.get( id, i2 ) );
							i2++;
						}
					}
				} else if ( s1=="music" )	{
					this.playmusic( s3 );
					if( i2 < i1 )	{
						if( <sdb>.get( id, i2 )=="vol" )	{
							i2++;
							sndbgr.setvol( <sdb>.get( id, i2 ) );
							i2++;
						}
					}
				}
			}
			id++;
		}
	}
	/****************************************************************/
	crestart()	{	gameapi.play( gameapi.getgamename() );	}
}


/***************************************************************************/

class clfindfunc	{
	init()	{}
	int _stdfindfunc(string sobj, int ifirst, int ilast, string sname, string sfunc)	{	
		while(ifirst<=ilast)	{
			if( <sobj + ifirst>.<sfunc>() ==sname )	return ifirst;
			ifirst++;
		}
		-1;
	}
	int _stdfindfunc2(string sobj, int iile, string sname, string sfunc)	{	
		._stdfindfunc(sobj, 0, iile-1, sname, sfunc);
	}
	/****************************************************************/
	cfindandeval2(string sobj, int iile, string sname, string sfunc, string seval)	{	
		.cfindandeval(sobj, 0, iile-1, sname, sfunc, seval);
	}
	cfindandeval(string sobj, int ifirst, int ilast, string sname, string sfunc, string seval)	{	
		int pos = ._stdfindfunc(sobj, ifirst, ilast, sname, sfunc);
		if(pos>=0)	<sobj+pos>.<seval>();
	}
}



/*****************************************************************/
class classbutton 	{
	init()	{
		new string san = "anbut";
		new string sbut = "but";
		new int iilebut = 0;
		new string sfxmon = null;
	}
	_cbuildbutname(string sname)	{	new string _sbutname=sname; }
	string cgetbutname()	{ return _sbutname; }
	build(string sfile, int z, string smouse)	{this.build2(sfile,z,smouse,null);	}
	build2(string sfile, int z, string smouse, string sgrp)	{	// wczytuje animacje i buduje z niej przyciski
		string smain = "_" + san;
		new anima <smain>;
		<smain>.load( sfile );
		<smain>.setz(z);
		int ile = <smain>.nofactions();
		int j;	int k;
		int iliczans = 0;
		string sn1, string sn2, string sn3;
		string spom;
		for(int i=0; i<ile; i++)	{
			sn1 = null;	sn2 = null;	sn3 = null;
			j = <smain>.nofframes(i);
			for(k=1; k<=j; k++)	{
				spom = san + iliczans;
				if(k==1)	{	sn1=spom; } 
				else if (k==2)	{ sn2 = spom; }
				else if (k==3)	{ sn3 = spom; }
				newvars::copyanima( smain, spom );
				<spom>.setframe( i, k-1 );
				iliczans++;
			}
			if( sgrp!=null && <sgrp>.contains( <smain>.nameofaction(i)) ) {
				<sn1>.setz(z-1);
			} else this.addbut(sn1, sn2, sn3, smouse);
		}
		<smain>.hide();
	}
	/***************************** \/ \/ \/ \/ \/ wewnetrzne \/ \/ \/ \/ \/ *************************************************/
	_buildfuncclick( string sname )	{	new string _sfunclick = sname; }
	_stdbutclick()	{	this.<_sfunclick>( this.getbutname() );		}
	_buildfuncrel( string sname )	{	new string _sfuncrel = sname; }
	_stdbutrel()	{	this.<_sfuncrel>( this.getbutname() );	}
	_buildfuncmovon( string sname )	{	new string _sfunmovon = sname; }
	_stdbutmovon()	{
		if( sfxmon!=null )	<sfxmon>.play();
		this.<_sfunmovon>( this.getbutname() );
	}
	_buildfuncmovoff( string sname )	{	new string _sfunmovoff = sname; }
	_stdbutmovoff()	{	this.<_sfunmovoff>( this.getbutname() );	}
	butsigfun(string sb, string sfunc, string ssig, string sfun1, string sfun2)	{
		if( sfunc==null )	return;
		<sb>.addmethod(sfun1, sfun1);
		<sb>.<sfun1>( sfunc );
		<sb>.addmethod(ssig, sfun2);
	}
	sigfunc(string sfunc, string ssig, string sfun1, string sfun2)	{
		for(int i=0; i<iilebut; i++)	this.butsigfun(sbut + i, sfunc, ssig, sfun1, sfun2);
	}
	print()	{for(int i=0; i<iilebut; i++)	engine.print( <sbut+i>.getbutname() );}
	setrect()	{
		string s;
		for( int i=0; i<iilebut; i++)	{
			s = <sbut+i>.getimg;
			<sbut+i>.setrect( <s>.getpx, <s>.getpy, <s>.getex, <s>.getey );
		}
	}
	setflags(bool bvis, bool balph)	{	for(int i=0; i<iilebut; i++)	<sbut+i>.setflags(bvis,balph);	}
	/***************************** /\ /\ /\ /\ /\ wewnetrzne /\ /\ /\ /\ /\ ************************************************/
	sfxonmovon(string ssnd)	{	sfxmon=ssnd;	}
	clickfunc(string sfunc)	{this.sigfunc(sfunc,"onclick", "_buildfuncclick", "_stdbutclick");	}
	relfunc(string sfunc)	{this.sigfunc(sfunc,"onrel", "_buildfuncrel", "_stdbutrel");	}
	movonfunc(string sfunc)	{this.sigfunc(sfunc,"onmoveon", "_buildfuncmovon", "_stdbutmovon");	}
	movofffunc( string sfunc)	{this.sigfunc( sfunc,"onmoveoff", "_buildfuncmovoff", "_stdbutmovoff");}
	/*****************************************************************/
	int ilebuts()	{	return iilebut;	}
	/*****************************************************************/
	int ifind(string sname)	{return clfindfunc::_stdfindfunc2(sbut, iilebut, sname, "getbutname");	}
	string sfind(string sname)	{
		int pos = clfindfunc::_stdfindfunc2(sbut, iilebut, sname, "getbutname");
		return pos>=0 ? sbut+pos : null;
	}
	/*****************************************************************/
	_cbutfun(string sname, string sfunc)	{
		clfindfunc::cfindandeval2(sbut, this.ilebuts(), sname, "getbutname", sfunc );
	}
	_callbutfunc(string sfunc)	{	for(int i=0; i<iilebut; i++)	<sbut+i>.<sfunc>();	}
	_cibutfunc(string sfunc, int ile)	{
		if( ile > iilebut )	ile = iilebut;
		for(int i=0; i<ile; i++)	<sbut+i>.<sfunc>();
	}
	ienable( int ile )	{	this._cibutfunc("enable", ile);	}
	benableall()	{	this.resumeall();	this.enableall();	}
	pauseall()	{	this._callbutfunc("pause");	}
	resumeall()	{	this._callbutfunc("resume");	}
	enableall()	{	this._callbutfunc("enable");	}
	disableall()	{	this._callbutfunc("disable");	}
	disabled	{	<sbut+0>.disabled;	}
	
	benable(string sname)	{	this.resume(sname);	this.enable(sname);	}
	disable(string sname)	{	this._cbutfun( sname, "disable");	}
	enable(string sname)	{	this._cbutfun( sname, "enable");	}
	pause(string sname)	{	this._cbutfun( sname, "pause");	}
	resume(string sname)	{	this._cbutfun( sname, "resume");	}
	/*****************************************************************/
	string getimg(string sname)	{
		string s= this.sfind(sname);
		return s!=null ? <s>.getimg() : null;	
	}
	/*****************************************************************/
	newmouse(string sname, string snewmouse)	{
		string s = this.sfind(sname);
		if(s!=null)	<s>.setmouse( snewmouse );
	}
	addbut(string san1, string san2, string san3, string smouse)	{
		string spom = sbut + iilebut;
		newvars::newbutan( spom, san1, san2, san3, smouse);
		<spom>.addmethod("getbutname","cgetbutname");
		<spom>._cbuildbutname( <san1>.actionname() );	// nazwa buttonu to nazwa akcji
		iilebut++;
	}
	/*****************************************************************/
	_addfunc(string s, string sfclick, string sfrel, string sfmvon, string sfmvoff)	{
		if( s== null)	return;
		this.butsigfun( s, sfclick, "onclick", "_buildfuncclick", "_stdbutclick");
		this.butsigfun( s, sfrel, "onrel", "_buildfuncrel", "_stdbutrel");
		this.butsigfun( s, sfmvon, "onmoveon", "_buildfuncmovon", "_stdbutmovon");
		this.butsigfun( s, sfmvoff, "onmoveoff", "_buildfuncmovoff", "_stdbutmovoff");
	}
	addfuncto(string sname, string sfclick, string sfrel, string sfmvon, string sfmvoff)	{
		this._addfunc( this.sfind(sname), sfclick, sfrel, sfmvon, sfmvoff);
	}
	addfunctolast(string sfclick, string sfrel, string sfmvon, string sfmvoff)	{
		this._addfunc( sbut + (iilebut-1) , sfclick, sfrel, sfmvon, sfmvoff);
	}
	/*****************************************************************/
	_transmet(string sob, string sfunc, string smet, string s)	{
		new string <"_sob" + s> = sob;
		new string <"_sf" + s> = sfunc;
		this.<smet>( "_trf"+s );
	}
	transclickfunc(string sob, string sfunc)	{this._transmet( sob, sfunc, "clickfunc", "cl" );	}
	transrelfunc(string sob, string sfunc)	{this._transmet( sob, sfunc, "relfunc", "rl" );	}
	transmovonfunc(string sob, string sfunc){this._transmet( sob, sfunc, "movonfunc", "mn" );	}
	transmovofffunc(string sob, string sfunc){this._transmet( sob, sfunc, "movofffunc", "mf" );	}
	_trfcl(string s)	{	<_sobcl>.<_sfcl>(s);		}
	_trfrl(string s)	{	<_sobrl>.<_sfrl>(s);		}
	_trfmn(string s)	{
		if( sfxmon!=null )	<sfxmon>.play();
		<_sobmn>.<_sfmn>(s);
	}
	_trfmf(string s)	{	<_sobmf>.<_sfmf>(s);		}
}

class classsimplebutton	{
	init()	{
		new string simgob=null;
		new gmimgvec grbut;
	}
	public stdbuild(string sfile, string smouse, int z)	{this.build(this.getgraphpath()+sfile, smouse, 0, 0, z, 0);	}
	public getimgfunc(string sfunc)	{	simgob==null ? 0 : <simgob>.<sfunc>();	}
	public setbutpos(int x, int y)	{	grbut.setpos(x,y);	}
	public build(string sfile, string smouse, int x, int y, int z, int iact)	{
		new button but1;
		but1 (this.getname()) {(string s) new string sbut = s; };
		but1.addmethod("onclick", func { this.<sbut+"_CLICK">(); });
		but1.addmethod("onrel", func { this.<sbut+"_REL">(); } );
		but1.addmethod("onmoveon", func { this.<sbut+"_MOVEON">(); });
		but1.addmethod("onmoveoff", func { this.<sbut+"_MOVEOFF">(); });
		
		if( sfile.contains(".pyz") )	{
			new anima anbut0;
			anbut0.load( sfile );
			anbut0.setpos(x,y);
			anbut0.setz(z);
			anbut0.setframe(iact,0);
			simgob="anbut0";
			grbut.add(simgob);
			string s0="anbut0";
			string s1=null;
			string s2=null;
			int ile = anbut0.nofframes(iact);
			if( ile>1 )	{
				new anima anbut1;
				anbut1.copy("anbut0");
				anbut1.setframe(iact,1);
				s1 = "anbut1";
				grbut.add(s1);
			}
			if (ile>2)	{
				new anima anbut2;
				anbut2.copy("anbut0");
				anbut2.setframe(iact,2);
				s1 = "anbut2";
				grbut.add(s1);
			}
			but1.setan(s0,s1,s2);
		} else {
			new img imgbut;
			simgob="imgbut";
			grbut.add(simgob);
			imgbut.load(sfile);
			imgbut.setpos(x,y);
			imgbut.setz(z);
			but1.set("imgbut",null,null);
		}
		but1.setmouse(smouse);
	}
}

/*****************************************************************/

class classmask : classbutton	{
	init()	{
		classbutton::init();
	}
	buildmask(string sfile, string smouse)	{
		this.build(sfile, 0, smouse);
		int ile = this.ilebuts();
		for(int i=0; i<ile; i++)	{
			<sbut+i>.setflags(false, false);
			<sbut+i>.hide();
		}
	}
	buildmaskfunc(string sfile, string smouse, string sfunc)	{
		this.buildmask(sfile, smouse);
		this.clickfunc(sfunc);
	}
	addmask(string sanim, string sname, string smouse, int bhide)	{		// dodanie np. ludka jako maski
		string spom = sbut + iilebut;
		newvars::newbutan( spom, sanim, null, null, smouse);
		<spom>.addmethod("getbutname","cgetbutname");
		sname==null ? <spom>._cbuildbutname(<sanim>.actionname()) : <spom>._cbuildbutname(sname);
		if(bhide)	{
			<spom>.setflags(false, false);
			<spom>.hide();
		}
		iilebut++;
	}
	addadvmask(string sanim, string sname, string smouse, string sfuncclick)	{
		this.addmask( sanim, sname, smouse, false );
		this.addfunctolast( sfuncclick, null, null, null);	
	}
}

/*****************************************************/
public callfun(string sob, string sfun)	{if( sfun!=null ) sob==null ? this.<sfun>() : <sob>.<sfun>();}
public _stdanloop()	{	this.play(-1); }
public _stdanhide()	{	this.hide();	}
public _stdsndloop()	{	this.play(); }
public __std_finish()	{	this.<this+"_FINISH">();	}
public looponfinish(string san)	{	<san>.addmethod("onfinish", "_stdanloop");	}
public hideonfinish(string san)	{	<san>.addmethod("onfinish", "_stdanhide");	}
/*****************************************************/
public string strsube(int ile)	{	return this.getb( 0, this.length()-ile );	}
public string strsubb(int ile)	{	return this.getb( ile, this.length() - ile );	}
public string strsubbs(string s)	{	return this.strsubb( s.length() );	}
public string strsubes(string s)	{	return this.strsube( s.length() );	 }
public string strgetto(string schar)	{
	@id = .find(schar);
	id<0 ? .get : .getb(0, id);
}
public string strgetfromto(int ipos, string schar)	{	return this.getb(ipos, this.find(schar));	}
public string strgetfrom(string schar)	{	return .getb(.find(schar)+schar.length, .length );	}
public strremove(string s)	{	.set( .strgetto(s) + .strgetfrom(s) ); }
public bool strisbetween(int b1, int b2)	{
	int ib;
	for(int i=0; i<.length; i++)	{
		ib = .getbyte(i);
		if( ib<b1 || ib>b2 )	return false;
	}
	true;
}
public bool strisint		{	.strisbetween(BYTE0, BYTE9);	}
public bool strisbin	{	.strisbetween(BYTE0, BYTE0+1);	}
public bool strisalpha	{	.strisbetween(BYTEa, BYTEz);	}
public streach(string sfun)	{
	string s;
	for( int i=0; i<.length; i++) {
		s = .getb(i,1);
		<s>.<sfun>(i);
	}
}
/*****************************************************/
public swap(string s1, string s2)	{
	[s1];
	<s1> = [s2];
	<s2> = _;
}
public bool stats(int ile)	{	(ile <= 0) ? false : ( 100->rand <= ile );}
public int between(int i1, int i, int i2)	{	( i < i1 ) ? i1 : (i>i2) ? i2 : i;}
public def max(def val1, def val2)	{	val1>val2 ? val1 : val2;	}
public def min(def val1, def val2)		{	val1<val2 ? val1 : val2;	}
/*************** do wykorzystania na obiektach!! ***********************************/
public anresizemets()	{	anima_pack::resizemethods(this.getname());	}
//public def anfirstnontr	{	classansearcher::firstnotrx1y(this);	}
public def anfirstnontr	{	classansearcher::_findnotr(this,.getpx, .getpy, 1, 0);	}
public anloopfin()	{	this.addmethod("onfinish", "_stdanloop");	}
public anloopplay(int iact)	{	this.anloopfin();	this.play(iact);	}
public anloopsplay(string sact)	{	this.anloopfin();	this.play(sact);	}
public anhidefin()	{	this.addmethod("onfinish","_stdanhide");	}
public anputgr()	{	this.setz( this.getey() );	}
public anputy(int ypos)	{	this.move(0, ypos - this.geth() - this.getpy());	}
public anputx(int xpos)	{	this.move(0, xpos - this.geth() - this.getpy());	}
public ansetposgr(int x, int y)	{	this.setpos(x,y);	this.anputgr();	}
public anplayz(int id, int z)	{	this.setz(z);	this.play(id);	}
public anplaygr(int id)	{	this.play(id);	this.anputgr();	}
public anplayzpos(int id, int z, int x, int y)	{	this.setpos(x,y);	this.anplayz(id,z);	}
public anplaypos(int x, int y)	{	this.setpos(x,y);	this.play(-1);	}
public anplayposgr(int x, int y)	{	this.ansetposgr(x,y);	this.play(-1);	}
public anplaypos2(int x, int y, string sact)	{	this.setpos(x,y);	this.play(sact);	}
public anplaypos3(int x, int y, int iact)	{	this.setpos(x,y);	this.play(iact);	}
public anhide()	{	this.stop(false);	this.hide();	}
public andownpos(int x, int y)	{	this.setpos( x, y-this.geth() );	}
public ansetbpos(int x, int y)	{	this.setpos( x-this.lodx(), y-this.lody() );	}
public ansetcpos(int x, int y)	{	.ansetbpos( x - .getw/2, y - .geth/2 );	}
public ansetframe(int id)	{	this.setframe( this.actionnr(-1), id );	}
public ansetsframe(def d, string s)	{
	.setframe(d,0);
	int id = 0;
	while( id < .nofframes(-1) && .framename!=s )	{
		id++;
		.setframe(-1,id);
	}
}
public int anonscreen()	{	return clsurf.inscreen(this.getcx(), this.getcy(), this.getw()/2, this.geth()/2);	}
public objplayfin(string sfun)	{	this.addmethod("onfinish", sfun);	this.play();	}
public objloop()	{	this.addmethod("onfinish","_stdsndloop");	}
public objplayloop()	{	this.objloop;	this.play();	}
public anplayfin(int iact, string sfun)	{	this.addmethod("onfinish", sfun);	this.play(iact);	}
public anytoz()	{	this.setz(this.getposy());	}
public anposz(int x, int y, int z)	{	.setpos(x,y);	.setz(z);	}
public string annextaction(string sact)	{return this.nameofaction( (this.actionnr(sact)+1)%this.nofactions() );}
public ansetnextact	{	.setframe( (.actionnr(-1)+1)%.nofactions, 0 ); }
public ansetnextfr		{	.setframe( -1, (.framenr+1)%.nofframes(-1)); }
public anaddfilter()	{	classanfilter::build(this.getname());	}
public anaddfx	{	AnimaFx::build( this );	}
public anputc(int x1, int y1, int x2, int y2)	{
	.ansetbpos(x1,y1);
	.move( (x2-x1-.getw)/2, (y2-y1-.geth)/2 );
}
public aninlod(int itoler)	{	itoler.length( .getpx - .lodx, .getpy - .lody ) <= itoler; }
public angetcpos	{	return .getcx, .getcy;	}
public angetcrgba	{	.getrgba(.getcx, .getcy);	}
/***************** text ****************/
public txtset(string s)	{	.set(s);	.create;	}
public txtsetcol(string s, int r, int g, int b)	{	.set(s);	.createtxt(r,g,b);	}
public txtshadow(int w, string sfont)	{
	if( !.hasvar("txts") )	{
		new text txts;
		txts.setfont(sfont);
	}
	txts.set(.get);
	txts.setpos(.getpx+w, .getpy+w);
	txts.setz(.getz-1);
	txts.show;
	txts.createtxt(0,0,0);
}
public txthides	{	.hide; if(.hasvar("txts")) txts.hide; }
public txtisin(int x, int y)	{
	x>=.getpx && x<.getpx+.getw && y>=.getpy && y<=.getpy+.geth;
}
/***************** vector ****************/
public vecinc(int pos)	{	this.set( pos, this.get(pos)+1 );	}
public vecdec(int pos)	{	this.set( pos, this.get(pos)-1 );		}
public vecnewint(int ile)	{
	this.free();
	if( ile>0 )	for( int i=0; i<ile; i++)	{	this.add(i);	}
}
public veccopy(string svec)	{
	this.free();
	for( int i=0; i< <svec>.size(); i++ )	this.add( <svec>.get(i) );
}
public int vecnextid(def val)	{
	int id = .find(val);
	if( id>=0 )	id = (id+1)%.size;
	id;
}
public int vecprevid(def val)	{
	int id = .find(val);
	if( id>0 )	id--;
	else if (id==0)	id = .size-1;
	id;
}
public def vecget(int id)	{
	( id>=0 && id<.size) ? .get(id) : null;
}
public def vecnext(def val)	{	.vecget( .vecnextid(val) );	}
public def vecprev(def val)	{	.vecget( .vecprevid(val) );	}
public def veclast()	{
	int ile = this.size();
	ile>0 ? this.get(ile-1) : null;
}
public def vecpop()	{
	@x = .last;
	.removeat( .size - 1 );
	x;
}
public veclimes(int ile)	{	while( .size > ile )	_ = .vecpop;	}
public def vecpopfront()	{
	def x = this.get(0);
	this.removeat( 0 );
	return x;
}
public insertsort(int ile, string sgetfun, string scomparefun, string sswapfun)	{
	if( ile<=1 )	{	return;	}
	def s[2], int id, int i, int j;
	for( i=0; i<ile; i++)	{
		s0 = this.<sgetfun>(i);
		id = i;
		for( j=i+1; j<ile; j++)	{
			s1 = this.<sgetfun>(j);
			if( this.<scomparefun>(s1,s0) )	{
				s0 = s1;
				id = j;
			}
		}
		this.<sswapfun>(i,id);
	}
}
public obbuildfromstring(string s, string separator, string sfunadd)	{
	int pos = s.find(separator);
	while( pos>-1 )	{
		this.<sfunadd>( s.getb(0,pos) );
		s = s.strsubb(pos+1);
		pos = s.find(separator);
	}
	if( s.length()>0 )	{	this.<sfunadd>(s);	}
}
public obbuildfromstring2(string s, string separator, string sfunadd)	{
	int pos = s.find(separator);
	while( pos>-1 )	{
		if( pos>0 )	this.<sfunadd>( s.getb(0,pos) );
		s = s.strsubb(pos+1);
		pos = s.find(separator);
	}
	if( s.length()>0 )	{	this.<sfunadd>(s);	}
}
public vecsort(string scomparefun)	{ .insertsort( .size, "get", scomparefun,"swap" ); }
public string vecbuildfromstring(string s, string separator)	{
	this.free();
	this.obbuildfromstring(s,separator,"add");
}
public string vecbuildfromstring2(string s, string separator)	{
	this.free();
	this.obbuildfromstring2(s,separator,"add");
}
public vecremoveto(int ito)		{	for( int i=0; i<ito; i++ ) this.removeat(0);		}
public vecremovefrom(int ifrom)	{	while( ifrom<this.size() ) this.removeat(ifrom);	}
public vecposfromto(int i1, int i2)	{
	if( i1==i2 || .size==0 )	return;
	def x = .get(i1);
	if( i1>i2 )	for( int i=i1; i>i2; i--)	{	.set(i, .get(i-1));		}
	else if (i1<i2)	for( int i=i1; i<i2; i++)	{	.set(i, .get(i+1));	}
	.set(i2,x);
}
public vecposfirst( def x )	{
	int id = .find(x);
	if( id>=0 )	.vecposfromto(id, 0);
	else	.addbegin(x);
}
public vecposlast( def x )	{
	int id = .find(x);
	if( id>=0 )	.vecposfromto(id, .size-1);
	else	.addbegin(x);
}
public vecset(def x, def d2)	{
	int id = .find(x);
	if( id>=0 )	.set(id,d2);
}
public bool veceq(string svec)	{
	int id = .size;
	if( id != <svec>.size  )	return false;
	for( int i=0; i< id; i++)	if( .get(i)!=<svec>.get(i) ) return false;
	true;
}
public vecbuild	{	.withlist("addbegin");}
public bool veceq2	{
	new vector ___v;
	___v.type(.getvectype);
	___v.vecbuild;
	bool b = .veceq("___v");
	delete ___v;
	b;
}
public veccopydbrow(string sdb, int irow)	{
	.free;
	for( int i=0; i< <sdb>.getcolsno(irow); i++)	.add( <sdb>.get(irow,i) );
}
/************** db ************************/
public dbbuild(int icol)	{
	if( icol<=0 )	return;
	icol--;
	.free;
	string s = _, int id;
	for( int i = 0; s!=A; )	{
		if( i==0 )	id = this.addbeginrow() - 1;
		this.addbegin(0,s);
		s = _;
		i = (i<icol)? i+1 : 0;
	}
}
public dbbuild2	{
	.free;
	string s = _;
	while( s!=A )	{
		if( s==null )	_ = .addbeginrow;
		else .addbegin(0,s);
		s = _;
	}
}
public dbcopy(string sdb)	{
	this.free;
	int i, int j;
	for( i =0; i< <sdb>.getrowsno; i++)	{
		_ = .addrow;
		for( j=0; j< <sdb>.getcolsno(i); j++)	{
			.add( i, <sdb>.get(i,j) );
		}
	}
}
public dbremovelast()	{
	.removerow( .getrowsno-1 );
}
public dbcuttosize(int isize)	{
	if( isize>0 ) while( .getrowsno > isize )	.dbremovelast;
	else	.free;
}
public dbaddlast(string svar)	{	this.add( this.getrowsno()-1, svar );	}
public dbaddstringrow(string s, string separator)	{
	_ = this.addrow();
	this.obbuildfromstring(s,separator,"dbaddlast");
}
public dbaddrow	{
	@id = .addrow - 1;
	@s = _;
	while(A!=s)	{
		.addbegin(id, s);
		@s = _;
	}
}
public dbaddrowfrom(string sdb, int irow, int icol)	{
	if( <sdb>.rowinrange(irow) && icol>=0)	{
		int id = this.addrow()-1;
		int ile = <sdb>.getcolsno(irow);
		while( icol < ile )	{
			this.add( id, <sdb>.get( irow, icol ) );
			icol++;
		}
	}
}
public string dbchecknext(int irow, int icol)	{
	icol++;
	icol < this.getcolsno(irow) ? this.get(irow,icol) : null;
}
public string dbgets(string s, int icol)	{return this.get( this.findbyrow(s), icol );}
public int dbinsertless(int i1)	{
	int id = this.addrow()-1;
	this.add(id,i1);
	this.dbsort("cmpless");
	while( id>=0 )	{
		if( i1==this.get(id,0) )	return id;
		id--;
	}
	return -1;
}
public bool dbdelvar(int irow, string svar)	{return this.dbdelvarn(irow,svar,1);}
public bool dbdelvarn(int irow, string svar, int n)	{
	int id = this.dbfindinrow(irow,svar);
	if( id>=0 )	{
		this.removen(irow,id,n);
		return true;
	}
	return false;
}
public int dbfindinrow(int irow, string svar)	{
	if( this.rowinrange(irow) )	{
		for( int i=0; i<this.getcolsno(irow); i++)	if( this.get(irow,i)==svar )	return i;
	}
	return -1;
}
public int dbfindbycol(int icol, string svar)	{
	for( int i=0; i<this.getrowsno(); i++)	{if( this.get(i,icol)==svar ) return i;}
	return -1;
}
public bool dbrowcontains(int irow, string svar)	{	return this.dbfindinrow(irow,svar)!=-1;	}
public string dbfirst(int id)		{	return this.get(id,0);	}	
public bool cmpless(int i1, int i2)	{	return i1<i2;	}
public bool cmpabove(int i1, int i2)	{	i1>i2;	}
public bool dbfirstless(int i1, int i2)	{	.get(i1,0) < .get(i2,0);	}
public dbsort(string scomparefun)	{	.insertsort( .getrowsno, "dbfirst",scomparefun, "swap" ); }
public dbsetall(string svar)	{	for( @i=0; i<.getrowsno; i++)	for(@j=0; j<.getcolsno(i); j++)	.set(i,j,svar);	}
public dbeach_row(string sfun)	{	for( @i=0; i<.getrowsno; i++) .<sfun>(i);	}
/************** int ************************/
public int randdiff(int zakres, int odjakiej)	{
	if( zakres<=1 )		return -1;
	for( int i1 = zakres.rand; i1==odjakiej; i1= zakres.rand )	{}
	return i1;
}
public int bin_to_i	{
	string s = .get;
	int idwa = 1;
	int iout = 0;
	for( int i=s.length-1; i>=0; i--)	{
		if( s.getb(i,1)=="1") iout+=idwa;
		idwa*=2;
	}
	iout;
}

/***************************************************************************/
class classgamepause	{
	init()	{
		new button butpause;
		butpause.setrect( 0, 0, 800, 600 );
		butpause.addmethod("onclick", "resume");
		butpause.disable();
	}
	resume()	{
		butpause.disable();
		gameapi.resume();
	}
	pause()	{
		gameapi.pause();
		butpause.enable();
		butpause.resume();
	}
}

class TicksCounter	{
	init()	{
		new int istart;
	}
	start()	{	istart = engine.getticks();	}
	stop()	{	istart = engine.getticks() - istart;	}
	get()		{	return istart;	}
	int stopget()	{	this.stop();	return this.get();	}
	print(string s)	{	engine.print(s+" delay: "+this.stopget()+" ms");	}
	put()	{	.print("");	}
}

class ObjController	{
	init()	{
		new string _sme = this.getname();
		<GAME>.addgmobj(_sme);
	}
	removefromgame	{	<GAME>.removegmobj(_sme); }
}
class LObjController : ObjController, classlocker	{
	init()	{
		ObjController::init;
		classlocker::init;
	}
}

class gmbankvec : gmobjvec	{
	init	{
		gmobjvec::init;
		.var2("iid", -1);
	}
	startrand	{	if(.size>0) iid=.size->rand;	}
	play()	{
		this.stop(false);
		int ile = this.size();
		if( ile==0 ) return;
		iid = (iid+1)%ile;
		<this.get(iid)>.play();
	}
	onfinish()	{}
	stop(bool bfin)	{
		if( this.isplaying() )	{
			<this.getplay()>.stop(bfin);
			if( bfin ) this.onfinish();
		}
	}
	isplaying	{	( iid>=0 )	? <.getplay>.isplaying : false;	}
	getplay()	{	return this.get(iid);	}
}

class GameController : classlocker {
	init(string ssndbase)	{
		classlocker::init();
		new gmobjvec __grobj;
		
		new db _dbsnd;
		_dbsnd.setseparator("|");
		new string _sndbase = ssndbase;
		new string GAME = this;
	}
	public game_exit()	{
		//this.stdexportsnd();
	}
	/*************************************************/
	public setsndbase(string sb)	{	_sndbase=sb;	}
	public say(string styp, string stxt)	{	this.sayf(styp,stxt,null);	}
	public sayf(string styp, string stxt, string sfun)	{
		string s = this.getsndtxt(stxt);
		<s>.setstartstopflag(false,true);
		this.cplayf(styp, s, sfun);
	}
	public string getsndtxt(string stxt)	{
		string ssnd = "snd" + _sndbase + _dbsnd.getrowsno();
		this.addsnd( ssnd, stxt );
		return ssnd;
	}
	_sndtimerstart()	{
		int id = _dbsnd.dbfindbycol(1,this.getname());
		if( id>=0 )	engine.print( _dbsnd.get( id,2) );
		else 		engine.print( this.getname() + " not in _dbsnd");
		engine.print("");
	}
	public addsndf(string ssnd, string stxt, string sfun)	{
		this.addsnd(ssnd,stxt);
		if( sfun!=null )
			<ssnd>.addmethod("onfinish", sfun );
	}
	public asf(string ssnd, string stxt)	{	this.addsndff( "snd" + ssnd, stxt, "end" + ssnd);	}
	public addsndff(string ssnd, string stxt, string sfun)	{
		this.addsndf(ssnd,stxt,sfun);
		//<ssnd>.setstartstopflag(false,true);
	}
	gmconsnd(string ssnd, string swav)	{
		new snd <ssnd>;
		<ssnd>.setstartstopflag(false,true);
		<ssnd>.load( .getsndpath+swav );
	}
	public addsnd(string ssnd, string stxt)	{
		int id = _dbsnd.addrow()-1;
		string swav = _sndbase + id + ".wav";
		string sg = gameapi.getgamename();
		if( engine.fileexist( this.getsndpath() + swav ) )	{
			<sg>.gmconsnd( ssnd, swav );
		} else {
			<sg>.newtimer( ssnd, stxt.length()*40, 1);
			<ssnd>.addmethod("onstart", "_sndtimerstart");
			<ssnd>.addmethod("setstartstopflag", func { (bool b1, bool b2) ; });
		}
		_dbsnd.add(id, swav);
		_dbsnd.add(id, ssnd);
		_dbsnd.add(id, stxt);
	}
	public addbank(string sbank, string sfunc)	{
		new gmbankvec <sbank>;
		string s = _;
		string s2;
		while( s!=A )	{
			s2 = this.getsndtxt(s);
			<sbank>.addbegin( s2 );
			if( sfunc!=null ) <s2>.addmethod("onfinish", sfunc );
			s = _;
		}
	}
	public exportbank(string sbase)	{
		new db <"__db"+sbase> (sbase)	{ (@sbase)
			.dbbuild(1);
			.setseparator("|");
			.dbeach_row( func { (@id)
				@s = this->strsubbs("__db");
				.addbegin(id, "snd"+s+id);
				.addbegin(id, s+id+".wav");
				} );
			if( igmdebug )
				.save("exports/"+sbase+".dlg");
		};
		delete <"__db"+sbase>;
	}
	public importbank(string sbank, string sbase, string sfun)	{
		new gmbankvec <sbank>;
		.importgroupto(sbase, sfun, null, sbank);
	}
	public exportsnd(string sfile)	{	if( igmdebug) _dbsnd.save(sfile);	}
	public stdexportsnd()	{	this.exportsnd( "exports/" + _sndbase + ".dlg" );	}
	public sounds=()	{	.buildsnds;	}
	public sounds_from(string sbase)	{
		new db __tmpdb;
		@stmpbase = _sndbase;
		.setsndbase(sbase);
		__tmpdb.load("exports/"+sbase+".dlg");
		_dbsnd.free;
		@s = _;
		int id, string sf;
		while( A!=s )	{
			@s1 = _;
			id = __tmpdb.dbfindbycol(1, s1);
			if( id>=0 )	{
				sf = .getsndpath + __tmpdb.get(id,0);
				if( engine.fileexist( sf ) )	{
					<GAME>.gmconsnd( s1, __tmpdb.get(id,0) );
					<s1>.addmethod("onfinish", s );
				} else	.addsndf( s1, __tmpdb.get(id,1), s );
			}
			@s = _;
		}
		_dbsnd.free;
		delete __tmpdb;
		.setsndbase(stmpbase);
	}
	public buildsnds()	{
		_dbsnd.free;
		new db __dbsnd;
		__dbsnd.dbbuild(3);
		.buildfromdb("__dbsnd");
		delete __dbsnd; 
	}
	public buildfromdb(string sdb)	{
		for( int i=0; i< <sdb>.getrowsno; i++)	{
			.addsndf( <sdb>.get(i,0), <sdb>.get(i,1), <sdb>.get(i,2) );
		}
		.stdexportsnd;
	}
	public importsnd(string sbase, string sfun)	{	this.importgroup(sbase, sfun, null );	}
	public importgroup(string sbase, string sfun, string sgr)	{	.importgroupto(sbase,sfun,sgr,null);	}
	public importgroupto(string sbase, string sfun, string sgr, string sgrto)	{
		new db __tmpdb;
		@stmpbase = _sndbase;
		.setsndbase(sbase);
		__tmpdb.load("exports/"+sbase+".dlg");
		_dbsnd.free();
		string s;
		for( int i=0; i<__tmpdb.getrowsno(); i++)	{
			s = __tmpdb.get(i,1);
			if( sgr==null || <sgr>.contains(s) )	{
				.addsndf( s, __tmpdb.get(i,2), sfun );
				if( sgrto!=null ) <sgrto>.add(s);
			}
		}
		_dbsnd.free();
		__tmpdb.free();
		delete __tmpdb;
		.setsndbase(stmpbase);
	}
	public freesnd()	{	_dbsnd.free();	}
	/*************************************************/
	public addgmobj(string s)		{	__grobj.add(s);		}
	public removegmobj(string s)	{	__grobj.remove(s);	}
	public deletegmobj(string s)	{
		if( .hasvar(s) )	{
			.removegmobj(s);
			delete <s>;
		}
	}
	public lockall()		{
		__grobj.eval("lock");
		this.lock();	
	}
	public unlockall()		{
		__grobj.eval("unlock");
		this.unlock();
	}
	public gmunlockall	{	<GAME>.unlockall;	}
	public gmlockall	{	<GAME>.lockall;	}
	mousemove()	{
		__grobj.eval("onmousemove");
		this.mouse_move();
	}
	mouselclick()	{
		__grobj.eval("onmouselclick");
		this.mouse_lclick();	
	}
	mouserclick()	{
		__grobj.eval("onmouserclick");
		this.mouse_rclick();
	}
	mouselrel()	{
		__grobj.eval("onmouselrel");
		this.mouse_lrel();
	}
	mouserrel()	{
		__grobj.eval("onmouserrel");
		this.mouse_rrel();
	}
	keydown()	{
		__grobj.eval("onkeydown");
		this.key_down();
	}
}

/* classadv : klasa do przygodowek	*/

class classadv : classgame {
	init()	{
		classgame::init();
	}
	/**************************************************************************/
	newclpathf(string spt, string san, string sfile, int x, int y, real rstep, int ityp)	{
		new classpathf <spt>;
		<spt>.build(san, this.getgraphpath() + sfile, x, y, rstep, ityp);
	}
	newclpathfcopy(string spt, string san, string sptf, real rstep)	{
		new classpathf <spt>;
		<spt>.buildfrom( san, sptf, rstep );
	}
	newpathf(string spathf, string sfile, int x, int y)	{
		new path <spathf>;
		<spathf>.build( this.getgraphpath() +sfile, x, y, 2.0, 1 );
	}
	/**************************************************************************/
	newclbut(string sbut, string sfile, int z, string smouse)	{
		new classbutton <sbut>;
		<sbut>.build( this.getgraphpath() + sfile, z, smouse );
	}
	newclmask(string sm, string sfile, string smouse)	{
		new classmask <sm>;
		<sm>.buildmask( this.getgraphpath() + sfile, smouse );
	}
	newclmaskfunc(string sm, string sfile, string smouse, string sfunc)	{
		new classmask <sm>;
		<sm>.buildmaskfunc( this.getgraphpath() + sfile, smouse, sfunc );
	}
}

class classquest	{
	init()	{
		new vector vqst;
		vqst.type("string");
	}
	int isdone(string sqst)	{	return vqst.contains(sqst);	}
	int notdone( string sqst )	{	return !vqst.contains(sqst);	}
	done(string sqst)	{	if( !vqst.contains(sqst) )	vqst.add(sqst);		}
	reset()	{	vqst.free();	}
	save(string sfile)	{	vqst.save( sfile );	}
	load(string sfile)	{	vqst.load( sfile );	}
}

new classquest clqs;

/***************************************************************************/

class classfullsave	{
	init(string sfile)	{
		new db dbsav;
		new string sstdfile;
		.setfile(sfile);
	}
	public save(string sfile)	{	dbsav.save(sfile);	}
	public load(string sfile)	{
		if( engine.fileexist(sfile) )
			dbsav.load(sfile);
	}
	public print()	{	dbsav.print();	}
	public setfile(string sf)	{	sstdfile = sf;	}
	public stdload()	{	this.load(sstdfile);	}
	public stdsave()	{	this.save(sstdfile); }
	public free()	{	dbsav.free();	}
	public set(string sname, string svar)	{
		int id = dbsav.findbyrow(sname);
		if( id>=0 )	{
			dbsav.set(id,1,svar);
		} else {
			id = dbsav.addrow()-1;
			dbsav.add( id, sname );
			dbsav.add( id, svar );
		}
		this.stdsave();
	}
	public bset(string sname)	{	this.set(sname,true);	}
	public string get(string sname)	{
		int id = dbsav.findbyrow(sname);
		return id>=0?dbsav.get(id,1):null;
	}
	public bool is(string sname, string svar)	{
		int i = dbsav.findbyrow(sname);
  		return i>=0?dbsav.get(i,1)==svar:false;
	}
	public bool bis(string sname)	{	return this.is(sname,true);	}
}


public transparent	{	return 0,0,0,0;	}
public red		{	return 255,0,0;	}
public green		{	return 0,255,0;	}
public blue		{	return 0,0,255;	}
public white		{	return 255,255,255; }
public black		{	return 0,0,0;		}
public grey(int c)	{	return c,c,c;		}

class Color	{
	init	{
		.vars(A,"r","g","b","a");
	}
	operator=(string scol)	{	this.set( <scol>.get() );	}
	img=(@simg)	{
		|r,g,b,a| = <simg>.getrgba( classansearcher::firstnotrx1y(simg) );
	}
	get			{	return r,g,b,a;	}
	set(int r2, int g2, int b2, int a2)	{	|r,g,b,a| = r2,g2,b2,a2;	}
	rgb=(int r2, int g2, int b2)	{	|r,g,b|=r2,g2,b2;	}
	rgb	{	return r,g,b;	}
	print	{	engine.print("Color::" + this + " (r,g,b,a) = ("+r+","+g+","+b+","+a+")");	}
}

/***************************************************************************/

class classasker : newvars	{
	init()	{
		newvars::init();
		new string sfuncyes = null;
		new string sfuncno = null;
		new string ssndask;
		new string ssndyes;
		new string ssndno;
		new classsound clsnd;
	}
	reset()	{	sfuncyes=null;	sfuncno=null;	}
	setfuncs(string syes, string sno)	{
		sfuncyes = syes;
		sfuncno = sno;
	}
	fxonmovon(string ssnd)	{	buts.sfxonmovon(ssnd);	}
	setmouse(string smouse)	{
		buts.newmouse("yes", smouse);
		buts.newmouse("no", smouse);
	}
	load(string sfile, int z)	{
		new classbutton buts;
		buts.build(sfile, z, null);
		buts.transclickfunc( engine.actclassname(), "butclick");
		buts.transmovonfunc( engine.actclassname() , "butmovon");
		buts.disableall();
	}
	ask( string sask, string syes, string sno, string sf1, string sf2 )	{
		this.setfuncs(sf1,sf2);
		this.ask2( sask, syes, sno );
	}
	ask2( string sask, string syes, string sno )	{
		ssndask=sask;
		ssndyes = syes;
		ssndno = sno;
		gameapi.pause();
		buts.benableall();
		buts.pause("bkg");
		clsnd.creset();
		clsnd.cbplay( sask );
		.<this+"_ask">;
	}
	/**********************************************/
	butmovon(string sc)	{
		/*if( ssndask!=null )	{
			if( <ssndask>.isplaying()==true )	{
				return;
			}
		}*/
		if( sc=="yes" )	{
			<ssndask>.stop(false);
			clsnd.cbplay( ssndyes );
		} else if (sc=="no")	{
			<ssndask>.stop(false);
			clsnd.cbplay( ssndno );
		}
	}
	butclick(string sc)	{
		if( sc=="bkg" )	return;
		gameapi.resume();
		buts.disableall();
		clsnd.cactsndstop(false);
		if( sc=="yes" && sfuncyes!=null)	{
			this.<sfuncyes>();
			.<this+"_yes">;
		} else if( sc=="no" && sfuncno!=null)	{
			this.<sfuncno>();
			.<this+"_no">;
		}
	}
	disabled	{	buts.disabled;	}
}

/***************************************************************************/
class classplacepointer	{
	init()	{
		new anima anpointer;
		anpointer.addmethod("onfinish", func { this.play(-1); } );
		new int _iz = 1000;
	}
	public load(string sfile)	{
		anpointer.load(sfile);
		this.setz(_iz);
		anpointer.hide();
	}
	public setz(int iz)	{
		_iz = iz;
		anpointer.setz(iz);
	}
	public stop()	{	anpointer.stop(false);	}
	public stoph()	{	anpointer.stop(false);	anpointer.hide();	}
	public show(int x, int y, string sdir)	{
		anpointer.setpos(x,y);
		anpointer.play(sdir);
	}
	move(@x, @y)	{	anpointer.move(x,y);	}
	public showob(string sob, string sdir)	{	this.show(<sob>.getcx(), <sob>.getcy(), sdir);	}
	public showpob(string sob, string sdir)	{	this.show(<sob>.getpx(), <sob>.getpy(), sdir);	}
}

/***************************************************************************/

class classfadeinout		{
	init()	{
		new timer timf;
		new string _sob;
		new int _istep;
		new int _ival;
		new int _ib1;
		new int _ib2;
		new string _sfun;
		new string _sfunfin;
		timf.addmethod("onfinish", "_ctimffin");
	}
	/***************\/\/\/\/\/ wewnetrzne \/\/\/\/\/\/************************************/
	_cfinito(int v)	{
		<_sob>.<_sfun>( v );
		if( _sfunfin!=null)	this.<_sfunfin>();
	}
	_ctimffin()	{
		_ival+=_istep;
		if( _ival >= _ib2 )	{
			this._cfinito( _ib2 );
		} else if( _ival<=_ib1 )	{
			this._cfinito( _ib1 );
		} else {
			<_sob>.<_sfun>( _ival );
			this.play();
		}
	}
	_play( int icycle, int istep, string sob, string sfun, int ib1, int ib2, string sfun2 )	{
		_sfunfin = sfun2;
		_ib1 = ib1;
		_ib2 = ib2;
		int i = istep.abs();
		if( icycle <= 0 || i==ib1 || i>ib2 )	return;
		_sfun = sfun;
		timf.setcycle( icycle );
		_sob = sob;
		if( istep>0 )	_ival = _ib1;
		else if( istep<0 )	_ival=_ib2;
		else return;
		<sob>.<sfun>( _ival );
		_istep = istep;
		timf.play();
	}
	/******************* /\/\/\/\/\/\/\ wewnetrzne /\/\/\/\ ****************************/
	imgtransparency(int icycle, int istep, string simg, string sfun)	{
		this._play( icycle, istep, simg, "transparency", 0, 255, sfun );
	}
	setopacity(int icycle, int istep, string simg, string sfun)	{
		this._play( icycle, istep, simg, "setopacity", 0, 255, sfun );
	}
	sndvolume(int icycle, int istep, string ssnd, string sfun)	{
		this._play( icycle, istep, ssnd, "setvol", 0, 100, sfun );
	}
	/***************************************************/
}

class SimpleCounter	{
	init(int ilength)	{
		.var2("length", ilength );
		new int iid = 0;
	}
	int next()	{	iid = (iid+1)%length;		iid;	}
	set(int i)	{	iid=i;	}
	reset()	{	iid=0;	}
	get()	{	iid;	}
}

/******************************************/

module clstrdigit	{
	init()	{}
	public string getdigit(int idigit, int ilepozycji)	{
		string s = idigit;
		while( s.length() < ilepozycji )	s = "0" + s;
		return s;
	}
	public string gettime(int itime, string smod)	{
		return this.getstime( this.geth(itime), this.getm(itime), this.gets(itime), 
			smod.contains("h"), smod.contains("m"), smod.contains("s") );
	}
	public string getstime(int ih, int im, int is, bool bh, bool bm, bool bs)	{
		string s = "";
		if( bh ) s+= ih;
		if( bm ) s+= (bh?":":"") + this.getdigit(im,2);
		if( bs ) s+= ((bh||bm)?":":"") + this.getdigit(is,2);
		return s;
	}
	public int geth(int itime)	{	return itime/3600;	}
	public int getm(int itime)	{	return (itime/60)%60;	}
	public int gets(int itime)	{	return itime%60;	}
	public string getns(int itime, int n)	{	return this.getdigit( this.gets(itime),n );	}
	public string getnm(int itime, int n)	{	return this.getdigit( this.getm(itime),n );	}
	string getbinary(int ival)	{
		string s = "";
		while(ival>0)	{
			s = "" + (ival%2) + s;
			ival/=2;
		}
		return s;
	}
}

public string getbinary			{	clstrdigit::getbinary(.get);		}
public string getdigit(int ile)		{	clstrdigit::getdigit(.get,ile);		}
public string getbindigit(int ile)	{	clstrdigit::getdigit( .getbinary,ile);	}

class Text	{
	init(string sfont, int ifontsize, int ifr, int ifg, int ifb, int x, int y, int z)	{
		if( sfont==null )	sfont = sgmfontfile;
		if( sfont.contains(".ttf") )	{
			new font _fnt;
			_fnt.load( sfont, ifontsize );
			sfont = "_fnt";
		}
		new int iR = ifr;
		new int iG = ifg;
		new int iB = ifb;
		new int iFontSize = ifontsize;
		new text txt;
		txt.setfont(sfont);
		txt.setz(z);
		txt.setpos(x,y);
		txt.show;
		
		new text txtbg;
		txtbg.hide();
	}
	public hide()	{	txt.hide;	}
	public show()	{	txt.show;	}
	public setpos(int x, int y)	{	txt.setpos(x,y);	}
	public set(string s)	{
		txt.set( s );
		txt.createtxt( iR, iG, iB );
	}
	public string get()	{	return txt.get;	}
	public setbg(int ir, int ig, int ib, int ia)	{
		txtbg.setbkg(txt.getpx()-iFontSize/2, txt.getpy()-iFontSize/2,
			txt.getw()+iFontSize, iFontSize*2, ir, ig, ib, ia );
		txtbg.setborders(1,255,255,255,128);
		txtbg.show();
	}
	operator=(string val)	{	this.set(val);	}
}

class Cypher : Text	{
	init(string sfont, int ifontsize, int ifr, int ifg, int ifb, int x, int y, int z)	{
		Text::init(sfont, ifontsize, ifr, ifg, ifb, x, y, z );
		this.set(0);
	}
	add(int dt)	{	this.set( dt + this.get );	}
	iget()		{	this.get->to_i;		}
	operator+(int val)	{	this.add(val);	}
	operator++()	{	this.add(1);	}
	operator--()	{	this.add(-1);	}
	operator-(int val)	{	this.add(-val);	}
	operator=(int val)	{	this.set(val);	}
	operator==(int val)	{	.get==val;	}
	operator!=(int val)	{	.get!=val;	}
	operator>(int val)	{	.get>val;	}
	operator<(int val)	{	.get<val;	}
}

class SecCounter	{
	init(string sdigits)	{
		new string sdigit = sdigits;
		new int itime;
		this.reset();
		this.cnewtimerfin("timcyk",1000,1, func { .update(1); .play; } );
	}
	public play()	{	timcyk.play();	}
	public stop()	{	timcyk.stop(false);	}
	public string sgettime()	{	return clstrdigit.gettime(itime, sdigit);	}
	public int gettime()	{	return itime;	}
	public reset()	{	this.update(-itime);	}
	public update(int isec)	{	itime+=isec;	}
}

class TextTimeCounter : Text, SecCounter	{
	init(string sfont, int ifontsize, int ifr, int ifg, int ifb, int x, int y, int z, string sdigits)	{
		Text::init(sfont, ifontsize, ifr, ifg, ifb, x, y, z);
		SecCounter::init(sdigits);
		.reset;
	}
	public update(int isec)	{
		SecCounter::update(isec);
		this.set( this.sgettime() );
	}
}

class gfxObject	{
	init(string sob)	{	new string sgfxobj = sob; }
	setpos		{	<sgfxobj>.setpos;	}
	move		{	<sgfxobj>.move;	}
	getpos		{	<sgfxobj>.getpos;	}
	getposx		{	<sgfxobj>.getposx;	}
	getposy		{	<sgfxobj>.getposy;	}
	getpx		{	<sgfxobj>.getpx;	}
	getpy		{	<sgfxobj>.getpy;	}
	getw			{	<sgfxobj>.getw;	}
	geth			{	<sgfxobj>.geth;	}
	getcx		{	<sgfxobj>.getcx;	}
	getcy		{	<sgfxobj>.getcy;	}
	getex		{	<sgfxobj>.getex;	}
	getey		{	<sgfxobj>.getey;	}
	lodx			{	<sgfxobj>.lodx;	}
	lody			{	<sgfxobj>.lody;	}
	setz			{	<sgfxobj>.setz;		}
	getz			{	<sgfxobj>.getz;	}
	show		{	<sgfxobj>.show;	}
	hide			{	<sgfxobj>.hide;	}
	isvisible		{	<sgfxobj>.isvisible;	}
	bool isin		{	<sgfxobj>.isin;		}
}

class gfxSquare : Color, gfxObject	{
	init(int x1, int y1, int w1, int h1)	{
		Color::init;
		.vars(A, "w", "h");
		w=w1; h=h1;
		new img imggfx;
		imggfx.setpos(x1,y1);
		gfxObject::init("imggfx");
	}
	build	{	imggfx.create(w,h,r,g,b,a);	}
	shadow(int dx, int dy, int alpha)	{
		|@x,@y| = imggfx.getpos;
		imggfx.setpos(0,0);
		new img _img1;
		new img _img2;
		if( imggfx.getw>0 )	{
			_img1.create(w,h,.transparent);
			_img1.blit("imggfx");
		} else _img1.create(w,h,.get);
		_img2.create(w,h,.black,alpha);
		if( dx<0 )	{
			_img1.move(-dx, 0);
			x+=dx;
		} else	_img2.move( dx, 0 );
		if( dy<0 )	{
			_img1.move(0,-dy);
			y+=dy;
		} else	_img2.move( 0, dy );
		w += dx.abs;
		h += dy.abs;
		imggfx.create(w, h, .transparent);
		imggfx.blit("_img2");
		imggfx.blit("_img1");
		delete _img1;
		delete _img2;
		imggfx.move(x,y);
	}
	blackborder(int width, int a2)	{	.border(width,width, .black,a2);	}
	border(int width, int height, int r2, int g2, int b2, int a2)	{
		|@x,@y| = imggfx.getpos;
		imggfx.setpos(0,0);
		new img _img;
		if( imggfx.getw>0 )	{
			_img.create(w,h,.transparent);
			_img.blit("imggfx");
		} else _img.create(w,h,.get);
		_img.move(width,height);
		w += 2*width;
		h += 2*width;
		imggfx.create(w,h,r2,g2,b2,a2);
		imggfx.blit("_img");
		delete _img;
		imggfx.move(x,y);
	}
}

class Rect	{
	init(int _x, int _y, int _w, int _h)	{
		.vars(A, "x", "y", "w", "h");
		.set(_x, _y, _w, _h);
	}
	x2	{	x+w;	}
	y2	{	y+h;	}
	set(int _x, int _y, int _w, int _h)	{ x=_x; y=_y; w=_w; h=_h; }
	fit(string simg)	{
		if( <simg>.gettype=="gmimgvec") {
			@dx = x-<simg>._getpx;
			if( dx>0 ) <simg>.move(dx,0);
			@dy = y-<simg>._getpy;
			if( dy>0 ) <simg>.move(0,dy);
		} else {
			@dx = x-<simg>.getpx;
			if( dx>0 ) <simg>.move(dx,0);
			@dy = y-<simg>.getpy;
			if( dy>0 ) <simg>.move(0,dy);
		}
		dx = .x2-<simg>.getex;
		if( dx<0 ) <simg>.move(dx,0);
		dy = .y2-<simg>.getey;
		if( dy<0 ) <simg>.move(0,dy);
	}
	fitrand(string simg)	{	<simg>.ansetbpos( x+(w-<simg>.getw)->rand, y+(h-<simg>.geth)->rand);	}
	fitgrouprand(string sgr)	{	for( int i=0; i< <sgr>.size; i++) .fitrand( <sgr>.get(i) );	}
	fitgroup(string sgr)	{	for( int i=0; i< <sgr>.size; i++) .fit( <sgr>.get(i) );	}
}
class TextTyper : classlocker, gfxObject {
	init(string sfont, int isize, int ir, int ig, int ib, string schars, int ilimit)	{
		classlocker::init();
		sfont = .checkfont(sfont, isize);
		new int iR = ir;
		new int iG = ig;
		new int iB = ib;
		new int iFontSize = isize;
		new string sChars = schars;
		new int iLimit = ilimit;		// 0 - unlimited
		
		new text txt1;
		txt1.setfont(sfont);
		txt1.set("");
		new text txt2;
		txt2.setfont(sfont);
		txt2.set("_");
		txt2.createtxt(iR,iG,iB);
		txt2.hide();
		
		new string _sob=null;
		new string _sfun=null;
		
		this.cnewtimerfin("timcyk",300,1,"fintimcyk");
		
		gfxObject::init("txt1");
	}
	public isin(int x, int y, bool bv, bool ba)	{	txt1.isin(x,y,bv,ba);	}
	getcol	{	return iR,iG,iB;	}
	fintimcyk()	{
		if( this.getlock() )	return;
		this.updatecyk();
		this.play();
	}
	updatecyk()	{
		if( txt2.isvisible() )	{
			txt2.hide();
		} else {
			txt2.setpos( txt1.getex(), txt1.getpy() );
			txt2.show();
		}
	}
	public enable()	{
		this.unlock();
		this.updatecyk();
		timcyk.play();
	}
	public disable()	{
		txt2.hide();
		timcyk.stop(false);
		this.lock();
	}
	public onenter(string sob, string sfun)	{	_sob=sob;	_sfun=sfun;	}
	public setpos(int x, int y)	{	txt1.setpos(x,y);	}
	public setz(int z)	{	txt1.setz(z);txt2.setz(z);	}
	public get()	{
		string s = txt1.get();
		( s.length()>0 ) ? s : "";
	}
	getpx	{	txt1.getpx;	}
	getpy	{	txt1.getpy;	}
	public length	{	txt1.get->length;	}
	public set(string s)	{	txt1.set(s);	}
	public txtset(string s)	{	txt1.txtsetcol(s,.getcol);	}
	public limit=(int il)	{	iLimit=il;	}
	public onkeydown()	{
		if( this.getlock() )	return;
		.<this+"_ontype">;
		if( keyboard.iskeydown("enter") )	{
			this.disable();
			this.callfun(_sob,_sfun);
			return;
		}
		string s;
		if( sChars.contains("t") && keyboard.iskey("tab") )	s = " ";
		else s = keyboard.getkey();
		string s2 = txt1.get();
		if( ( (keyboard.isalpha && sChars.contains("a") ) || ( keyboard.isdigit && sChars.contains("0") )
			|| sChars.contains(s) ) && (iLimit<=0 || iLimit>s2.length)  )	{
			txt1.set( s2+s );
			txt1.createtxt(iR,iG,iB);
			this.updatecyk();
		} else if (keyboard.iskey("backspace") && s2.length()>0)	{
			txt1.set( s2.strsube(1) );
			txt1.createtxt(iR,iG,iB);
			this.updatecyk();
		}
	}
}

class ConTextTyper : TextTyper, ObjController	{
	init()	{
		TextTyper::init();
		ObjController::init();
	}
}

class TextBoxTyper : LObjController	{
	init(string sfont, int ish, int isw, int ir, int ig, int ib, string schars, int x, int y, int w, int h, int dy)	{
		LObjController::init;
		new @Font = .checkfont(sfont, ish);
		.vars(A,"Cols", "Rows");
		Cols = w/isw;
		Rows = h/(ish+dy);
		new @Row = 0;
		new @X = x;
		new @Y = y;
		new @W = w;
		new @H = h;
		new @Size = ish;
		new @Dy = dy;
		new @Z = 0;
		string s;
		new gmimgvec grtt;
		new gmimgvec gren;
		for( int i=0; i<Rows; i++)	{
			s = "tt"+i;
			new TextTyper <s>(Font,ish,ir,ig,ib,schars,Cols);
			<s>.setpos( x, y+i*(ish+dy) );
			grtt.add(s);
		}
	}
	size	{	grtt.size;	}
	setz(int z)	{	Z = z; grtt.setz(z);	gren.setz(z); }
	getz	{	Z;	}
	show	{	grtt.show;	}
	hide		{	grtt.hide;		}
	enumerate(int dx)	{
		string s[2];
		for( int i=0; i<grtt.size; i++)	{
			s0 = "txte"+i;
			new text <s0>;
			gren.add(s0);
			<s0>.setz(Z);
			<s0>.setfont(Font);
			<s0>.txtsetcol(""+(i+1)+".", tt0.getcol);
			<s0>.setpos(X-<s0>.getw-dx,Y+i*(Size+Dy));
		}
	}
	cut(int id)	{	Rows=id;	}
	enable	{	.unlock;	.activateact;	}
	disable	{	.lock; grtt.eval("disable");	}
	actual	{	"tt"+Row;	}
	activate(int id)	{
		.unlock;
		if( id>=0 && id<Rows )	{
			.deactivate;
			Row = id;
			<"tt"+ Row>.enable;
		}
	}
	activateact	{	.activate(Row);	}
	deactivate	{	<"tt"+Row>.disable;	}
	onkeydown	{
		if(.getlock)	return;
		.<this+"_boxontype">;
		if( keyboard.iskeydown("enter") )		{
			@s = .getid(Rows-1);
			s.clear;
			if( s.length==0 )	{
				for( @i=Rows-1; i>Row+1; i--)	.setid( .getid(i-1), i);
				.setid("", Row+1);
			}
			.activate(Row+1);
		} else if (keyboard.iskey("up") && Row>0) .activate(Row-1);
		else if (keyboard.iskey("down") && Row<Rows-1) .activate(Row+1);
		else if (keyboard.iskey("backspace") && <.actual>.length==0 ) {
			for( @i=Row; i<Rows-1; i++)	.setid( .getid(i+1), i);
			.setid("",Rows-1);
			.activate(Row-1);
		} else grtt.eval("onkeydown");
	}
	onmouselclick	{
		if(.getlock)	return;
		|int x, int y| = mouse.getpos;
		
		if( clsurf.isin2(x,y,X,Y,W,H) )	{
			.deactivate;
			.activate( ((y-Y)*Rows)/H );
		} else {
			.<this+"_OUTSIDE">;
		}
	}
	string getid(int id)	{	<"tt"+id>.get;	}
	string get	{	.getfrom(0);	}
	string getfrom(int id)	{
		string s = "";
		for( int i=id; i<grtt.size; i++) s += <"tt"+i>.get;
		s;
	}
	int nonempty(int id)	{
		string s;
		for( ; id<grtt.size; id++)	{
			s = <"tt"+id>.get;
			s.clear;
			if( s.length > 0 ) return id;
		}
		-1;
	}
	clear	{	grtt.txtreset;	}
	setid(string s, int id)	{	if( grtt.size>=id )	<"tt"+id>.txtset(s);	}
	settext(int ile)	{
		while(ile>0)	{
			ile--;
			.setid(_,ile);
		}
	}
}

/****************************************************************/
class DelayTaker	{
	init()	{
		new bool bonrel = false;
		new bool bstart = false;
		this.cnewtimerfin("timwez",300,1, func { bonrel=true; } );
	}
	public setdelay(int idelay)	{	timwez.delay(idelay);	}
	public take()	{
		timwez.play();
		bstart=true;
		bonrel=false;
	}
	public ret()	{
		bonrel=false;
		bstart=false;
		timwez.stop(false);
	}
	public bool isonclick()	{
		this.stoptimer();
		( bstart && !bonrel );
	}
	public bool isonrel()	{
		this.stoptimer();
		( bstart && bonrel );
	}
	public bool istaken()	{	bstart;	}
	public stoptimer()	{	timwez.stop(false);	}
}


class ImgMover	{
	init()	{
		new string smoved=null;
		new int ilastx;
		new int ilasty;
		new int irelx;
		new int irely;
	}
	public mssetobj(string s)	{	this.setobj(s,mouse.getpos);	}
	public setobj(string s, int x, int y)	{	this.set(s,x,y,0,0);	}
	public set(string s, int x, int y, int dx, int dy)	{
		ilastx = <s>.getposx()-dx;
		ilasty = <s>.getposy()-dy;
		irelx = x-<s>.getpx();
		irely = y-<s>.getpy();
		smoved = s;
	}
	public msmove()	{	this.move(mouse.getpos);	}
	public msftmove()	{	this.ftmove(mouse.getpos);	}
	public move(int x, int y)	{
		if( smoved!=null )	<smoved>.setpos( x-<smoved>.lodx()-irelx, y-<smoved>.lody()-irely );
	}
	public ftmove( int x, int y)	{	if( smoved!=null )	<smoved>.setpos( x, y );	}
	public retobj()	{	this.ret(0,0);	}
	public ret(int dx, int dy)	{
		<smoved>.setpos(ilastx+dx, ilasty+dy);
		this.free();
	}
	public put(int x, int y)	{
		<smoved>.setpos(x,y);
		this.free();
	}
	public free()	{	smoved=null;	}
	public string getmover()	{	return smoved;	}
	public string getfree	{	@s = smoved; .free; s; }
	public bool moving()	{	return smoved!=null;	}
}

class ConImgMover : ImgMover, ObjController	{
	init()	{
		ImgMover::init();
		ObjController::init();
	}
	onmousemove()	{	this.msmove();	}
}

class DelayMover : ImgMover, LObjController	{
	init()	{
		ImgMover::init();
		LObjController::init();
		new DelayTaker cldt; 
	}
	_put()	{
		cldt.ret();
		this.<_sme+"_PUT">();
	}
	set(string s, int x, int y, int dx, int dy)	{
		ImgMover::set(s,x,y,dx,dy);
		cldt.take;
	}
	onmousemove()	{	this.msmove();	}
	onmouselclick()	{
		if( this.getlock() ) return;
		if( cldt.isonclick() )	this._put();
		else if (!cldt.istaken())
			this.<_sme+"_GET">();
	}
	onmouselrel()	{
		if( this.getlock() ) return;
		if( cldt.isonrel() )
			this._put();
	}
}

class Rewinder : classlocker	{
	init()	{
		classlocker::init();
		new string sarrowdir;
		new int ilenx;
		new int ileny;
		new string sgr;
		new string sorientation;
		new bool bvertical;
		new bool bfilteritem = false;
		
		// clip obiektow
		new int ibx1=0;
		new int ibx2=800;
		new int iby1=0;
		new int iby2=600;
		
		new int iodleg = 2;	// odleglosc pomiedzy przedmiotami
		
		new ImgMover clmv;
		
		this.cnewtimercyclefin("timtick", 1, 1, "timfin");
		
		new snd fxrew;
// 		fxrew.addmethod("onfinish", func { this.play(); } );
	}
	public movefilter()		{	bfilteritem=true;	}
	public movenormal()	{	bfilteritem=false;	}
	public setfxrew(string sfile)	{
		fxrew.load(this.getsndpath()+sfile);
	}
	public getitem(string s, int x, int y)	{
		/*clmv.set(s,x,y,<sgr>.getpx(),<sgr>.getpy());
		<s>.clip(0,0,800,600);
		<sgr>.movefrom(s, 0, -<s>.geth);
		<sgr>.remove(s);*/
		<s>.setz( <s>.getz+1 );
		clmv.set(s,x,y,<sgr>.getpx(),<sgr>.getpy());
		<s>.clip(0,0,800,600);
		if( sorientation=="up" || sorientation=="down")	{
			<sgr>.movefrom(s, -(<s>.getw+iodleg), 0 );
			<s>.move( <s>.getw,0 );
		} else {
			<sgr>.movefrom(s, 0, -(<s>.geth+iodleg));
			<s>.move(0, <s>.geth );
		}
		<sgr>.remove(s);
	}
	public bool pickup(int x, int y)	{
		if( <sgr>.isin(x,y,true,true) )	{
			this.getitem( <sgr>.getsfound(), x, y );
			return true;
		}
		return false;
	}
	public bool mspickup()	{	return this.pickup(mouse.getpos );	}
	public freeitem()	{	clmv.free();	}
	public moveitem()	{
		if( bfilteritem )		clmv.msftmove();
		else		clmv.msmove();
	}
	public retitem()	{
		string s = clmv.getmover();
		clmv.ret(<sgr>.getpx(),<sgr>.getpy());
		this.putitem(s);
	}
	public putitem(string s)	{
		if( sorientation=="up" || sorientation=="down")	{
			<s>.move( <sgr>.getex-<s>.getpx+iodleg, 0);
		} else {
// 			@dx = anupstd.getex - <s>.getw;
// 			<s>.setpos( dx - <s>.lodx, <sgr>.getey-<s>.lody);
			<s>.move( 0, <sgr>.getey-<s>.getpy+iodleg);
		}
		<sgr>.add(s);
		<s>.setz( <s>.getz-1 );
		<s>.clip(ibx1,iby1,ibx2,iby2);
	}
	public string getmoved()	{	return clmv.getmover();	}
	public int getbutw()	{	return anupstd.getw();	}
	public int getbuth()	{	return anupstd.geth();	}
	public movearrows(int x, int y)	{	grarrows.move(x,y);	}
	public build(string sfile, int z, string scursor, string sorient, int dt, string sgrelem)	{
		sgr = sgrelem;
// 		this.newanima("anupstd",sfile,z);
		new anima anupstd;
		anupstd.load(sfile);
		anupstd.setz(z);
		
		anupstd.setframe("up",0);
		this.copyanima("anupstd","anupact");
		anupact.setframe("up",1);
		this.copyanima("anupstd","andownact");
		andownact.setframe("down",1);
		this.copyanima("anupstd","andownstd");
		andownstd.setframe("down",0);
		this.newbutan("butup","anupstd","anupact",null,scursor);
		this.newbutan("butdown","andownstd","andownact",null,scursor);
		butup.addmethod("onmoveon","_rewbutmoveon");
		butdown.addmethod("onmoveon","_rewbutmoveon");
		butup.addmethod("onmoveoff","_rewstrzalkaoff");
		butdown.addmethod("onmoveoff","_rewstrzalkaoff");
		butup.addmethod("onclick","_rewbutclick");
		butdown.addmethod("onclick","_rewbutclick");
		butup.addmethod("onrel","_rewbutrel");
		butdown.addmethod("onrel","_rewbutrel");
		sorientation=sorient;
		new gmimgvec grarrows;
		_ = "grarrows" .+ "anupstd" .+ "anupact" .+ "andownact" .+ "andownstd";
		
		int dy, int dx, int ix, int iy;
		if( sorientation=="up" || sorientation=="down")	{
			bvertical = false;
			ilenx = dt;
			if( sorientation=="down")	{
				anupstd.setpos(0,600-anupstd.geth());
				anupact.setpos(0,600-anupact.geth());
				andownstd.setpos(800-andownstd.getw(),600-andownstd.geth());
				andownact.setpos(800-andownact.getw(),600-andownact.geth());
				dy = andownstd.getey();
			} else {
				anupstd.setpos(0,0);
				anupact.setpos(0,0);
				andownstd.setpos(800-andownstd.getw(),0);
				andownact.setpos(800-andownact.getw(),0);
				dy = 0;
			}
			ibx1 = anupstd.getex()+iodleg;
			ibx2 = andownstd.getpx()-iodleg;
			dx = ibx1;
		} else {
			bvertical = true;
			ileny = dt;
			if( sorientation=="right")	{
				anupstd.setpos(800-anupstd.getw(),0);
				anupact.setpos(800-anupact.getw(),0);
				andownstd.setpos(800-andownstd.getw(),600-andownstd.geth());
				andownact.setpos(800-andownact.getw(),600-andownact.geth());
				dx = anupstd.getex();
			} else {
				anupstd.setpos(0,0);
				anupact.setpos(0,0);
				andownstd.setpos(0,600-andownstd.geth());
				andownact.setpos(0,600-andownact.geth());
				dx = 0;
			}
			iby1 = anupstd.getey()+iodleg;
			iby2 = andownstd.getpy()-iodleg;
			dy = iby1;
		}
		butup._rewbuildbut(this.getname(),"up");
		butdown._rewbuildbut(this.getname(),"down");
		
		int ile = <sgrelem>.size();
		<sgrelem>._setpos(dx,dy);
		new int ilimx = dx;
		new int ilimy = dy;
		string s;
		for(int i=0; i<ile; i++)	{
			s = <sgr>.get(i);
			if( sorientation=="right")	{
				<s>.setpos( dx - <s>.getw() - <s>.lodx(), dy - <s>.lody() );
				dy += <s>.geth()+iodleg;
			} else if (sorientation=="left")	{
				<s>.setpos( dx - <s>.lodx(), dy - <s>.lody() );
				dy += <s>.geth()+iodleg;
			} else if (sorientation=="up")	{
				<s>.setpos( dx - <s>.lodx(), dy - <s>.lody() );
				dx += <s>.getw()+iodleg;
			} else if (sorientation=="down")	{
				<s>.setpos( dx - <s>.lodx(), dy - <s>.geth() - <s>.lody() );
				dx += <s>.getw()+iodleg;
			}
			<s>.clip(ibx1,iby1,ibx2,iby2);
		}
	}
	/*************************************/
	_rewbuildbut(string s, string s2)	{
		new string _sob = s;
		new string _sdir;
		if( s2=="up" )	{
			if(bvertical==false)	{	_sdir = "left";	}
			else {	_sdir = "up";	}
		} else if (s2=="down")	{
			if(bvertical==false)	{	_sdir = "right";	}
			else {	_sdir = "down";	}
		}
	}
	_rewbutmoveon()	{
		//this.mstrzalkaon(_sdir);
		this.<_sob+"_"+_sdir+"_MOVEON">();
	}
	_rewbutclick()	{
		this.mstrzalkaon(_sdir);
		this.<_sob+"_"+_sdir+"_CLICK">();
	}
	mstrzalkaon(string s)	{
		sarrowdir=s;
		timtick.play();
	}
	_rewbutrel	{
		sarrowdir=null;
		timtick.stop(false);
		fxrew.stop(false);
	}
	_rewstrzalkaoff()	{
		sarrowdir=null;
		timtick.stop(false);
		fxrew.stop(false);
		this.<_sob+"_"+_sdir+"_MOVEOFF">();
	}
	timfin()	{
		if( this.getlock() )	{	return;	}
		bool bok = false;
		if( sarrowdir!=null && !<sgr>.empty())	{
			if( sarrowdir=="up")	{
				if( <sgr>.getey() > andownstd.getpy() - ileny )	{
					<sgr>.move(0,-ileny);
					bok=true;
				}
			} else if (sarrowdir=="down") {
				if( <sgr>.getpy() < ilimy )	{
					<sgr>.move(0,ileny);
					bok=true;
				}
			} else if (sarrowdir=="left")	{
				if( <sgr>.getex() > andownstd.getpx() - ilenx )	{
					<sgr>.move(-ilenx,0);
					bok=true;
				}
			} else if (sarrowdir=="right") {
				if( <sgr>.getpx() < ilimx )	{
					<sgr>.move(ilenx,0);
					bok=true;
				}
			}
		}
		if( bok )	{
			if( !fxrew.isplaying() )	fxrew.play();
		} else {
			fxrew.stop(false);
		}
		this.play();
	}
}

class ConRewinder : Rewinder, ObjController {
	init()	{
		Rewinder::init();
		ObjController::init();
		new DelayTaker cldt; 
	}
	public getitem(string s, int x, int y)	{
		Rewinder::getitem(s,x,y);
		cldt.take();
	}
	_put()	{
		cldt.ret();
		this.<_sme + "_PUT">();
	}
	onmousemove()	{	this.moveitem();	}
	onmouselrel()	{
		if( this.getlock() )	return;
		if( cldt.isonrel() )	{	this._put();	}
	}
	onmouselclick()	{
		if( this.getlock() ) return;
		if( cldt.isonclick() )	{
			this._put();
		} else if ( !cldt.istaken() )	{
			this.<_sme+"_GET">();
		}
	}
}

class Button : LObjController	{
	init	{
		LObjController::init;
		.unlock;
		new gmimgvec grbuts;
		.var2("sobject", null);
	}
	addgroups	{	grbuts.addgroups;	grbuts.sortimgs;	}
	addgroup(string s)	{	grbuts.addgr(s);	grbuts.sortimgs;	}
	addlist		{	grbuts.addlist;		grbuts.sortimgs;	}
	add(string sob)	{	grbuts.add(sob);	grbuts.sortimgs;	}
	load(string sname, string sfile, string sfuninit) {
		<GAME>.varnew("gmimgvec", sname);
		sname .* sfile;
		<sname>.each( sfuninit );
		.addgroup(sname);
	}
	remove(string sname)	{
		if( <GAME>.hasvar(sname) )	{
			//for( int i=0; i < <sname>.size; i++ )	grbuts.remove( <sname>.get(i) );
			grbuts.removegr(sname);
		}
	}
	loadfrom(string sname, string spath, string sfile, string sfuninit) {
		@s = .getgraphpath;
		.setgraphpath(spath);
		.load(sname,sfile,sfuninit);
		.setgraphpath(s);
	}
	onmouselclick	{
		if( .getlock ) return;
		.<this + "_lclick">;
		if( sobject!=null )	{
			<sobject>.butclick;
		}
	}
	onmousemove	{
		if( .getlock ) return;
		|int x, int y| = mouse.getpos;
		if(grbuts.isinfunc(x,y,"isbutin") )	{
			@s = grbuts.getsfound;
			if( s!=sobject )	{
				.lastoff;
				sobject = s;
				.<this + "_moveon">;
				<s>.butmoveon;
			}
		} else {
			.lastoff;
		}
	}
	lastoff	{
		if( sobject!=null )	{
			.<this + "_moveoff">;
			<sobject>.butmoveoff;
			sobject = null;
		}
	}
	/*
	virtual bool isbutin(int x, int y)	{ 0; }
	virtual butclick	{}
	virtual butmoveon {}
	virtual butmoveoff {}*/
}
public Button_isin			{	.addmethod("isbutin", func { (@x,@y) .isin(x,y,1,0); } );	}
public Button_isinalpha	{	.addmethod("isbutin", func { (@x,@y) .isin(x,y,1,1); } );	}
public Button_moveon		{
	.addmethod("butmoveon", func {
		sndakskermovon.play;
		advmouse.setbut;
		if( .nofframes(-1)>1 ) .setframe(-1,1);
	} );
}
public Button_moveoff		{	.addmethod("butmoveoff", func { advmouse.setstd; .setframe(-1,0);} );	}
public Button_std			{ .Button_isin; .Button_moveon; .Button_moveoff;	}
public Button_stdalpha		{ .Button_isinalpha; .Button_moveon; .Button_moveoff;	}

class Buttons : LObjController	{
	init(string sfile)	{
		LObjController::init;
		.unlock;
		new gmimgvec grbuts;
		new int __id = 0;
		new string sanbut = "anbut";
		.newanima(sanbut, sfile, 10);
		_ = .newanactionsgr(sanbut, sanbut, "grbuts");
		anbut.hide;
		grbuts.setz(10);
		grbuts.removeif( func {
			if( .actionname=="bkg" ) { .setz( .getz-1); true; }
			else false; 
			});
		new string slastb = null;
		.vars2(A,"sobject", null, "bvisible", true, "balpha", true);
	}
	_release()	{
		<slastb>.setframe(-1,0);
		.copyobj;
		.<this + "_moveoff">();
		slastb = null;
		bsms.setstd;
	}
	getbut	{	grbuts.getsfound;	}
	onmousemove()	{
		if( .getlock ) return;
		grbuts.setframe(-1,0);
		def id =  grbuts.isin(mouse.getpos,bvisible,balpha);
		if( slastb!=null ) <slastb>.setframe(-1, 1);
		if( id ) {
			string s = grbuts.getsfound;
			if( s!=slastb )	{
				if( slastb!=null )	._release;
				slastb = s;
				<s>.setframe(-1,1);
				.copyobj;
				bsms.setact;
				.<this + "_moveon">();
			}
		} else if( slastb!=null )	{
			._release;
		}
		//slastb==null ? bsms.setstd : bsms.setact;
	}
	copyobj()	{	sobject = <slastb>.actionname;	}
	onmouselclick()	{
		if( .getlock ) return;
		if( slastb!=null )	{
			.copyobj;
			.<this + "_lclick">;
		}
	}
	disable	{
		.lock;
		grbuts.hide;
		if( slastb!=null )	{
			bsms.setstd;
			slastb=null;
		}
	}
	enable	{
		.unlock;
		grbuts.show;
	}
}

class TextDb : classlocker, ObjController, gfxObject {
	init(string sfont, int isize, string sdbfile, int r, int g, int b, int x, int y, int dy, int z, string sdir)	{
		classlocker::init;
		ObjController::init;
		new string sFont = sfont;
		sfont = .checkfont( sfont, isize );
		new int iFontSize = isize;
		if( sdbfile.contains(".db") )	{
			.newdb( "dbtxt", sdbfile );
		} else {
			new db dbtxt;
			if( sdbfile.getb(0,5)=="$var:" )	dbtxt.dbcopy( sdbfile.strsubb(5) );
			else dbtxt.dbaddlast( sdbfile );
		}
		string s;
		int w = 0, int ile = dbtxt.getrowsno;
		new gmimgvec grtxt;
		grtxt._setpos(x,y);
		for( int i=0; i< ile; i++)	{
			s = "txt" + i;
			new text <s>;
			<s>.setfont( sfont );
			<s>.set( dbtxt.get(i,0) );
			<s>.setpos(x,y);
			y+=isize+dy;
			<s>.setz(z);
			<s>.createtxt(r,g,b);
			if( <s>.getw>w ) w = <s>.getw;
			grtxt.add(s);
		}
		if( sdir == "right" || sdir =="center" )	{
			for( i=0; i<ile; i++)	{
				s = "txt" + i;
				if( sdir == "center" )	{
					<s>.move( (w-<s>.getw)/2, 0 );
				} else {
					<s>.move( w-<s>.getw, 0 );
				}
			}
		}
		gfxObject::init("grtxt");
	}
	stdshadow(int dt)	{	.setshadow(0,0,0,dt);	}
	setshadow(int r, int g, int b, int dt)	{
		string s[2];
		string sfont = ._checkfont(sFont, iFontSize, "_fntbrd");
		for( int i=0; i< dbtxt.getrowsno; i++)	{
			s0 = "txt" + i;
			s1 = "txts" + i;
			new text <s1>;
			<s1>.set( <s0>.get );
			<s1>.setfont( sfont );
			<s1>.setz( <s0>.getz-1 );
			<s1>.setpos( <s0>.getpx+dt, <s0>.getpy+dt );
			<s1>.createtxt(r,g,b);
			grtxt.add(s1);
		}
	}
	setz(int z)	{
		for( int i=0; i< dbtxt.getrowsno; i++)	{
			<"txt" + i>.setz(z);
			<"txts" + i>.setz(z-1);
		}
	}
	view	{
		@s = _;
		string s2;
		while(A!=s)	{
			s2 = grtxt.get(s);
			<s2>.show;
			s2 = "txts" + s2.strsubbs("txt");
			if( engine.varexist(s2) ) <s2>.show;
			@s=_;
		}
	}
}

class Lexer	{
	init	{}
	buildlex	{
		.vars(A,"id","found");
		new vector vconsts;
		vconsts.type("string");
		new vector vtmp1;
		vtmp1.type("string");
		new vector vtmp2;
		vtmp2.type("string");
		
		new int dot = "."->getbyte(0);
	}
	bool _isvar(int b1, int b2)	{
		int i = id;
		found = "";
		int ib;
		while(i<.length)	{
			ib = .getbyte(i);
			if( ib>=b1 && ib<=b2 )	{
				found += .getb(i,1);
				i++;
			} else i = .length;
		}
		found.length;
	}
	bool isreal	{
		int i = id;
		found = "";
		int ib;
		bool kropka=true;
		while(i<.length)	{
			ib = .getbyte(i);
			if( (ib>=BYTE0 && ib<=BYTE9) || (ib==dot&&kropka) )	{
				if( ib==dot ) kropka=false;
				found += .getb(i,1);
				i++;
			} else i = .length;
		}
		if( kropka || found.getb(0,1)=="." || found.gete(0,1)=="." ) found="";
		found.length;
	}
	bool isident	{
		int i = id;
		found = "";
		int ib;
		while(i<.length)	{
			ib = .getbyte(i);
			if( (ib>=BYTEa && ib<=BYTEz) || (ib>=BYTEA && ib<=BYTEZ) || ib==BYTE_ ||
				(i>id && ib>=BYTE0 && ib<=BYTE9) )	{
				found += .getb(i,1);
				i++;
			} else i = .length;
		}
		found.length;
	}
	bool isliteral	{
		if( .check!="\"" )	return false;
		int i = id+1;
		found = "";
		string s;
		while(i<.length)	{
			s = .getb(i,1);
			if( s=="\"" )	{
				//found += s;
				return true;
			} else {
				found += s;
				i++;
			}
		}
		false;
	}
	bool isconst	{
		string s0;
		bool b = .isident;
		for( int i=0; i< vconsts.size; i++)	{
			s0 = vconsts.get(i);
			if( b )	{
				if( s0 == found )	return true;
			} else {
				found = .getb(id, s0.length);
				if( s0 == found ) return true;
			}
		}
		false;
	}
	gettoken(string svec, bool bideal)	{
		<svec>.free;
		while( .notend )	{
			if (.check==" ")	id++;
			else if (.isconst)	{	<svec>.add(.read);	}
			else if (.isreal )		{<svec>.add( "$real" );	.next; if( bideal ) <svec>.add( found );}
			else if (.isint )		{<svec>.add( "$int" );	.next; if( bideal ) <svec>.add( found );}
			else if (.isident )	{<svec>.add( "$alpha" );	.next; if( bideal ) <svec>.add( found );}
			else if (.isliteral )	{<svec>.add( "$literal" );	.next; id+=2; if( bideal ) <svec>.add( found );}
			else	{<svec>.add("$error"); id++; }
		}
	}
	int expectdb(string sdb, bool bideal)	{	// identyczne lub parse
		int j, string s;
		for( int i=0; i< <sdb>.getrowsno; i++)	{
			//vtmp2.veccopydbrow(sdb,i);
			vtmp2.free;
			for( j=0; j< <sdb>.getcolsno(i); j++)	{
				s = <sdb>.get(i,j);
				s.clear;
				if( s!="" ) vtmp2.add(s);
			}
			if( .expectvec("vtmp2", bideal) )	return i;
		}
		-1;
	}
	bool expectvec(string svecsrc, bool bideal)	{
		id = 0;
		.gettoken("vtmp1", bideal);
		/*vtmp1.print;
		<svecsrc>.print;*/
		vtmp1.veceq(svecsrc);
		/*bool b = vtmp1.veceq(svecsrc);
		if( !b ) {
			("wrong expect "+.get)->print;
			vtmp1.print;
			<svecsrc>.print;
		}
		b;*/
	}
	bool expects(string s, string ssep, bool bideal)	{
		vtmp2.vecbuildfromstring(s,ssep);
		.expectvec("vtmp2", bideal);
	}
	consts=	{	vconsts.withlist("addbegin");	}
	setas(string sob)	{
		<sob>.addmethod("buildlex", "buildlex");
		<sob>.buildlex;
		<sob>.addmethod("start",	func { (string s) .set(s);	id=0; } );
		<sob>.addmethod("notend",	func {	id<.length;	} );
		<sob>.addmethod("getnext",	func { if( id==.length ) return null;
					id++;	.getb(id-1,1);	} );
		<sob>.addmethod("next",	func { id+=found.length;	} );
		<sob>.addmethod("check",	func { if( id==.length ) return null; found=.getb(id,1); found; });
		<sob>.addmethod("ischar",	func { (string s) s.contains( .getb(id,1) ); } );
		<sob>.addmethod("isint",	func{	._isvar(BYTE0, BYTE9);	} );
		<sob>.addmethod("isreal", "isreal");
		<sob>.addmethod("isbinary",	func{	._isvar(BYTE0, BYTE0+1);	} );
		<sob>.addmethod("isident",	"isident" );
		<sob>.addmethod("isconst",	"isconst" );
		<sob>.addmethod("_isvar", "_isvar");
		<sob>.addmethod("read",	func { .next;	found;	} );
		<sob>.addmethod("isliteral", "isliteral");
		<sob>.addmethod("gettoken", "gettoken");
		<sob>.addmethod("expects", "expects");
		<sob>.addmethod("expectvec", "expectvec");
		<sob>.addmethod("expectdb", "expectdb");
		<sob>.addmethod("consts=", "consts=");
	}
}


class AnimaFx	{
	init {}
	build(string san)	{
		<san>.addmethod("_buildanfx", func {
			new db dbsnd;
			dbsnd.dbbuild(3);
			for( int i=0; i<dbsnd.getrowsno; i++) dbsnd.set(i,0, dbsnd.get(i,0)+"_"+dbsnd.get(i,1));
			} );
		<san>._buildanfx;
		<san>.addmethod("onsetframe", func {
			@id = dbsnd.findbyrow(.actionname+"_"+.framenr);
			if( id>=0 ) {
				<"fx"+dbsnd.get(id,2)>.play;
			}
			} );
	}
}
game Tclassmenu	{
	init()	{
		new db _dbl;
		new gmobjvec gr1;
		gr1.add("bkg");
	}
	public tload(string spath, string sbuts, string sdbfile)	{
		this.setgraphpath(spath);
		if( sdbfile!=null )	{
			_dbl.loadscript(this.getgraphpath()+sdbfile);
			for(int i=0; i<_dbl.getrowsno();i++)	{
				this.newsnd("snd"+_dbl.get(i,0), _dbl.get(i,1)+".wav");
			}
		}
		new classbutton _clb;
		_clb.build2( this.getgraphpath() + sbuts, 10, "imglobcurs", "gr1" );
		_clb.clickfunc("_gmbutclick");
		_clb.movonfunc("_gmbutmove");
		if(engine.varexist("sndintro"))	this.cbplay("sndintro");
	}
	mouselclick()	{
		this.cactsndstop(true);
	}
	_gmbutmove(string s)	{
		sndakskermovon.play();
		if( engine.varexist("sndintro") && sndintro.isplaying() )	return;
		if( engine.varexist("snd"+s) )	this.crselfplay("snd"+s);
	}
	_gmbutclick(string s)	{
		this.<s+"_BUTCLICK">();
	}
}

class TMenu 	{
	init()	{}
	tinit(string sbuts)	{
		new Buttons but1(sbuts);
	}
	mousel_click()	{
		.cactsndstop(true);
	}
	but1_moveon	{
		string s = but1.sobject;
		sndakskermovon.play;
		if( !(engine.varexist("sndintro") && sndintro.isplaying) )
			if( engine.varexist("snd"+s) )	this.cbselfplay("snd"+s);
		.<s+"_MOVEON">;
	}
	but1_moveoff	{	.<but1.sobject + "_MOVEOFF">;	}
	but1_lclick()	{
		this.<but1.sobject+"_BUTCLICK">();
	}
}

/************ template game Painter **************/
class TPainter {
	init()	{}
	tinit(string sndbase, string spath, string sfilebg, string sfilebrush, string sfile, string sfarby, @dir)	{
		if( sndbase!=null )
			GameController::init(sndbase);
		this.unlock();
		this.setgraphpath(spath);
		
		if( sfilebg!=null )
			this.newanima("anbkg",sfilebg,0);
		this.newanima("anbrush1", sfilebrush, 3000);
		this.copyanima("anbrush1","anbrush2");
		anbrush2.setframe(0,1);
		anbrush2.setz(anbrush1.getz-1);
		anima_pack::resizemethods("anbrush1");		// galka
		anima_pack::resizemethods("anbrush2");		// pedzel
		int x, int y;
		match( dir )	{
			"ru" => { x = anbrush2.getex;
				y = anbrush2.getpy; }
			"rd" => { x = anbrush2.getex;
				y = anbrush2.getey; }
			"ld" => { x = anbrush2.getpx;
				y = anbrush2.getey; }
			? => { x = anbrush2.getpx;
				y = anbrush2.getpy; }
		}
		anbrush1.saverelpos(x, y);	// lewy dolny rog - kursor myszy
		anbrush2.saverelpos(x, y);	// lewy dolny rog - kursor myszy
		mouse.hide();
		
		this.newanima("anfg", sfile, 100);
		anfg.setframe("foreground",0);
		
		new gmimgvec grdraw;
		_ = this.newanframesgr("anfg", "andraw", anfg.actionnr("draw"), "grdraw");
		grdraw.setz(10);
		
		new gmimgvec grpaleta;
		//_ = this.newanframesgr("anfg", "anpaleta", anfg.actionnr("paleta"), "grpaleta");
		"grpaleta" ..< sfarby;
		grpaleta.setz(20);
		
		new int _ibrx = anbrush2.getpx();
		new int _ibry = anbrush2.getpy();
		while( !anbrush2.isin(_ibrx, _ibry, false, true) )	{
			_ibrx++;
			if( _ibrx==anbrush2.getex() ) {
				_ibrx = anbrush2.getpx();
				_ibry++;
			}
		}
		_ibrx-=anbrush2.getpx();
		_ibry-=anbrush2.getpy();
		TPainter::mouse_move;		// ustawienie pedzla w pozycji myszy
	}
	game_exit()	{
		mouse.show();
		GameController::game_exit();
	}
	mouse_move()	{
		anbrush1.mssetrelpos();
		anbrush2.mssetrelpos();
	}
	mouse_lclick()	{
		if( !this.getlock() )	{
			|int x, int y| = mouse.getpos();
			if( grdraw.isin(x,y,true,true) )	{
				<grdraw.getsfound()>.paint(
					anbrush2.getrgba(anbrush2.getpx()+_ibrx,anbrush2.getpy()+_ibry), 0 );
				.onpaint;
			} else if ( grpaleta.isin(x,y,false,true) )	{
				|@c[4]| = <grpaleta.getsfound()>.getrgba(x,y);
				c3 = 255;
				anbrush2.paint( c0, c1, c2, c3, 0 );
				.onsetbrush;
			}
		}
	}
}

class TPainterCon : TPainter, GameController	{
	init	{}
}
class TRoznice	{
	tinit(string spath, string sfilebg, string sfbgr1, string sfiler)	{
		.unlock;
		.setgraphpath(spath);
		if( sfilebg!=null )	.newanima("anbkg",sfilebg,0);
		.newanima("anbg1", sfbgr1, 10);
		.copyanima("anbg1", "anbg2");
		new gmimgvec gr1;
		"gr1" .* sfiler;
		new gmimgvec gr2;
		int id;
		string s[2];
		for( int i=0; i<gr1.size; i++)	{
			id = 2->rand;
			s0 = gr1.get(i);
			<s0>.setframe(i, id);
			s1 = "anel2_"+i;
			.copyanima(s0, s1);
			<s1>.setframe(i, (id+1)%2);
			gr2.add(s1);
		}
		new gmimgvec gral;
		_= "gral" .+ "gr1" .+ "gr2" .+ "anbg1" .+ "anbg2";
		gral.move(-anbg1.getpx, -anbg1.getpy);
		gral.move( (iResX/2-anbg1.getw)/2, 10 );
		.with(A,"anbg2", "gr2", func { .move(iResX/2, 0); });
		.with(A,"gr1", "gr2", func { .setz(20); } );
	}
	bool tremove(int id, int x, int y)	{
		string s = "gr"+id;
		if( <s>.isin(x,y,true,true) )	{
			< <s>.getsfound()> {
				.setframe( .actionnr(-1), (.framenr+1)%2);
			};
			int id2 = <s>.getfound;
			<s>.removeat(id2);
			<"gr" + ((id%2)+1)>.removeat(id2);
			gr1.empty ? .tfinish : .tpoint;
			true;
		} else
			false;
	}
	int remained	{	gr1.size;	}
	mouse_lclick()	{
		if( !.getlock )	{
			|int x[2]| = mouse.getpos;
			if( !.tremove(1,x0,x1) )	_ = .tremove(2,x0,x1);
		}
		.tclick;
	}
	/***************************/
	virtual tclick		{}
	virtual tpoint		{}
	virtual tfinish	{}
}


module advmouse	{
	init()	{
		new anima anmsc;
	}
	public load(string sname)	{
		anmsc.load(sname);
		anmsc.hide();
	}
	set(string saction)	{
		anmsc.show();
		anmsc.setframe( saction, 0 );
		mouse.setcursor("anmsc");
		anmsc.hide();
	}
	setstd()	{	this.set("std");	}
	setact()	{	this.set("act");	}
	setbut()	{	this.set("but");	}
	get()		{	return anmsc.actionname();	}
}


new int iMusic = 1;
new int iNutka = 1;
new string sAskerGame;
class Dzieje : classadv, GameController	{
	init(string s)	{
		igmstate = 0;
		classadv::init;
		GameController::init(s);
		.path = (s);
		.setwavpath(SNDPATH);
		.sfxs=(A,"pop 50", "pik1");
		bsms.setstd;		// ustawia standardowo 
		clmusic.play;
		clbuts.reset;
		advmouse.setstd;
		if( igmdemo )	{
			new anima anpieczatka {
				.load("scripts/common/pieczatka.pyz");
				.setz(200);
				.hide;
			};
		}
	}
	cshowbut(@dir)	{	clp.show(cbok.getimgfunc("getcx"), cbok.getimgfunc("getcy"), dir); }
	napisshow(int x, int y)	{
		.show;
		.move(x,y);
	}
	napispod(string s)	{	.napisshow(<s>.getcx-.getw/2, <s>.getey+5); }
	crect	{	new Rect rec(600,196,403,497);	}
	crect2	{	new Rect rec2(6,174,1012,530);	}
	inpiecz(int x, int y)	{
		if( igmdemo )	{
			anpieczatka.setpos(x,y);
			anpieczatka.show;
		}
	}
	askfor(@s)	{ if( igmstate!=111) {sAskerGame=s; claskexit.askexittomenu; }	}
	outpiecz	{	if(igmdemo)	anpieczatka.hide;	}
	/***********************************************************/
	exit	{
		bsms.setstd;
		.game_exit;
	}
	public askrestart	{	claskexit.askrestart;	}
	/***********************************************************/
	advclick()	{
		if( igmdebug && (igmstate==0 || igmstate==5) )	{
			this.cactsndstop(true);
		}
	}
	public keyrestart	{
		/*if( igmdebug && keyboard.iskeydown("lctrl") && keyboard.iskey("r") )
			gameapi.play(this);*/
	}
	/***********************************************************/
	keydown()	{
		if( igmdebug==false )	{	return;	}
		
		if( keyboard.iskey("p") )	{
			clpause.pause();
		} else if( keyboard.iskey("escape") )	{
			claskexit.askexittomenu();
		} else {
// 			clnextgm.checkkey();
		}
	}
	/***********************************************************/
	key_down	{
		if( igmdebug && keyboard.iskeydown("lctrl") && keyboard.iskey("r") )	.crestart;
	}
}

class Epoka : Dzieje	{
	init(string s)	{
		Dzieje::init(s);
		new bool bStartPlay;
		.list = (A, "prehistoria", "Prehistoria", "egipt", "EpokaEg", "daleki", "EpokaCh", "europa", "EpokaSr", "afryka", "EpokaAf", "ameryka", "EpokaAm", "grecja", "EpokaGr", "rzym", "EpokaRz", "grgry");
		.list=(A, "Prehistoria", "bgrlas", "Sredniowiecze", "bgrlas", "lmusic");
		.loadlekcja;
		.newbgrloop("sndmusic", lmusic.get( lmusic.find(GAME) + 1 ) + ".wav");
		if( iMusic ) sndmusic.play; else sndmusic.stop(false);
		if( !iNutka ) clmusic.reset;
	}
	blitwpodklad	{
		.setframe(-1,1);
		imgpodklad.blit(this);
		.setframe(-1,0);
	}
	loadlekcja	{
		|new int X1, new int Y1, new int X2, new int Y2| = 12, 185, 500, 690;
		
		@spath = .getgraphpath;
		.path = ("plansza");
		.imgs = (A, "podklad.png");
		new gmimgvec grramka;
		"grramka" ..< "ramka.pyz";
		grramka.setz(50);
		new gmimgvec grepoki;
		"grepoki" .* ("epoki" + LANG + ".pyz");
		grepoki.each( func {	(@id)
			.setz(5);
			if( .actionname->strsubb(1)!=GAME.strsubb(1) )
				.hide;
			.addmethod("_butmoveon", func {
				fxpop.play;
				if( igmstate!=3 ) {	.show; advmouse.setbut; }
				} );
			.addmethod("_butmoveoff", func {
				if( igmstate!=3) {
					if( .actionname->strsubb(1)!=GAME.strsubb(1) )
						.hide;
					advmouse.setstd; 
				}
				} );
			} );
		grepoki.eval("blitwpodklad");
		
		new gmimgvec grprzyc;
		"grprzyc" .* "przyciski.pyz";
		grprzyc.setz(100);
		grprzyc.each( func {	(@id)
			if( .actionname=="help") { .hide; return; }
			.addmethod("_butmoveon", func {
				fxpop.play;
				if( igmstate!=3 ) { 
					advmouse.setbut;
					.setframe(-1,1);
				}
				} );
			.addmethod("_butmoveoff", func {
				if( igmstate!=3 )	{
					advmouse.setstd;
					.setframe(-1,0);
				}
				} );
			} );
		grprzyc.remove("help");
		
		/*new anima anmapka	{
			.load(.getgraphpath+"mapka.pyz");
			.setz(1);
			.setframe(GAME,0);
			.addmethod("_butmoveon", func {
				if( igmstate!=3 ) advmouse.setbut;	
				.inpiecz( .getcx, .getcy );
				} );
			.addmethod("_butmoveoff", func { if( igmstate!=3 ) advmouse.setstd; .outpiecz;	} );
		};*/
		
		.setgraphpath(spath);
		
		.imgs = (A, "mapa.pyz 10");
		.newanima("antytul", "tytul" + LANG + ".pyz", 0);
		imgpodklad.blit("antytul");
		antytul.hide;
		anmapa.clip(X1, Y1, X2, Y2);
		
		new gmimgvec grludki;
		"grludki" .* "ludki.pyz";
		grludki.eval("blitwpodklad");
		grludki.setz(60);
		grludki.each( func {	(@id)
			.hide;
			.addmethod("_butmoveon", "_lekmoveonact" );
			.addmethod("_butmoveoff", "_lekmoveoffact" );
			} );
		
		new gmimgvec grobs;
		"grobs" .* "obiekty.pyz";
		
		new anima anmovon	{
			.load(.getgraphpath+"moveon.pyz");
			.hide;
			.setz(10);
			new vector vecac;
			vecac.type("string");
			for(int i=0; i<.nofactions; i++)	{
				vecac.add(.nameofaction(i));
			}
			.addmethod("contains", func { (string s) vecac.contains(s); } );
		};
		
		
		grobs.each( func {	(@id)
			.addmethod("_butmoveon", "_lekmoveonact" );
			.addmethod("_butmoveoff", "_lekmoveoffact" );
			.setz(20);
			.hide;
			.clip(X1, Y1, X2, Y2);	} );
		new gmimgvec grmap;
		grmap.addlist(A, "anmapa", "grobs" );
		grmap.move((X1+X2-anmapa.getw)/2,(Y1+Y2-anmapa.geth)/2);
		
		new anima anbutmusic	{
			.load("scripts/plansza/music.pyz");
			.setz(100);
			.setframe(0,iMusic);
			.addmethod("_butmoveon", func { fxpop.play; if( igmstate!=3 ) advmouse.setbut;	} );
			.addmethod("_butmoveoff", func { if( igmstate!=3 ) advmouse.setstd;	} );
		};
		new anima anbutnutka	{
			.load("scripts/plansza/nutka.pyz");
			.setz(100);
			.setframe(0,iNutka);
			.addmethod("_butmoveon", func { fxpop.play; if( igmstate!=3 ) advmouse.setbut;	} );
			.addmethod("_butmoveoff", func { if( igmstate!=3 ) advmouse.setstd;	} );
		};
		new bool bZoom = false;
		new anima anbutzoom	{
			.load("scripts/plansza/zoom.pyz");
			.setz(100);
			.addmethod("_butmoveon", func {
				if( igmstate==2 && bZoom )	{
					fxpop.play;
					advmouse.setbut;
					.setframe(-1,1);
				}
				} );
			.addmethod("_butmoveoff", func {
				if( igmstate==2 )	{
					if( bZoom )	.setframe(-1,0);
					advmouse.setstd;
				}
			 	} );
		};
		
		new anima anzoomer;
		anzoomer.hide;
		//new snd sfxbg;
		new int iilesfx=0;
		new gmobjvec sfxbg;
		sfxbg.buildarray("snd", "sfxbg", 10);
		sfxbg.each( func { (@id)
			.vars2(A,"iframe",-1,"vol",100);
			} );
		
		new db dbob;
		dbob.loadbeh(.getgraphpath+"obiekty" + LANG + ".beh");
		.adddzwieki("-say");
		.adddzwieki("-say2");
		.adddzwieki("-say3");
		.stdexportsnd;
		new int iFontSize = 25;
		new @sfntopis = .snewfont( "configs/fonts/normal.ttf", iFontSize);
		new @sfntopis2 = .snewfont( "configs/fonts/normal.ttf", iFontSize+4);
		new text txtobrazki;
		txtobrazki.setfont(sfntopis);
		.newimgarray("grtxtile", "text", "txtileo", 16);
		grtxtile.each( func {(@id)
				.setfont(sfntopis2);
				.txtset(id);
				.addmethod("withincut", func { (int x, int y) 1; } );
				.addmethod("actionname", func { "_number_"; } );
				.addmethod("_butmoveon", func {
					if( igmstate==2 && .isvisible && .get->to_i>0 )	{
						advmouse.setact;
					}
					});
				.addmethod("_butmoveoff", func {
					if( igmstate==2 && .isvisible)	advmouse.setstd;
					} );
			});
		
		new anima anobrazek	{
			.addmethod("onsetframe", func {
				string s;
				for( int i=0; i<sfxbg.size; i++)	{
					s = sfxbg.get(i);
					if( <s>.iframe==.framenr )	{
						<s>.setvol(<s>.vol);
						<s>.play;
					}
				}
				} );
		};
		new int iileobrazow;
		new string sactobraz = null;
		new gmimgvec grobrazki	{
			.addlist(A, "txtobrazki", "grtxtile", "anobrazek");
			.setz(50);
			.hide;
		};
		
		new gmimgvec _grbuts;
		_grbuts.addgroups(A, "grobs", "grludki", "grepoki", "grprzyc", "grtxtile");
		_grbuts.addlist(A,"anbutmusic", "anbutzoom"/*, "anmapka"*/, "anbutnutka");
		_grbuts.sortimgs;
		
		new @_slastlek = null;
		new @sclickedlek = null;
		new @_itoler = 50;
		new @_imover = 8;
		.cycle = ("timbgcyk", func {
			|int x, int y| = mouse.getpos;
			if( clsurf.isin(x,y,X1,Y1,X2,Y2) )	{
				if( igmstate==1 )	{
					int dt;
					if( x-X1 < _itoler )	{ 
						dt = X1 - anmapa.getpx;
						if( dt > 0 )	{
							if (dt > _imover) dt = _imover;
							grmap.move(dt,0);
						}
					} else if (X2-x<_itoler) {
						dt = anmapa.getex - X2;
						if( dt>0 )	{
							if( dt>_imover) dt=_imover;
							grmap.move( -dt, 0 );
						}
					} if( y-Y1 < _itoler )	{
						dt = Y1 - anmapa.getpy;
						if( dt > 0 )	{
							if (dt > _imover) dt = _imover;
							grmap.move(0,dt);
						}
					} else if (Y2-y<_itoler)	{
						dt = anmapa.getey - Y2;
						if( dt>0 )	{
							if( dt>_imover) dt=_imover;
							grmap.move( 0, -dt );
						}
					}
					<GAME>.lekcjamove;
				}
			}
			.play;
			} );
		timbgcyk.play;
		
		igmstate = 1;
	}
	_lekmoveonact	{
		if( igmstate==1)	{
			if( this->contains("ludki") )
				fxpop.play;
			.show;
			advmouse.setact;
			@s = .actionname;
			if( anmovon.contains(s) )	{
				anmovon.setframe(s,0);
				anmovon.show;
				if( igmdemo && vblok.contains(s) )
					.inpiecz( anmovon.getcx, anmovon.getey-60 );
			}
		}
	}
	adddzwieki(string spref)	{
		string s;
		for( int i=0; i<dbob.getrowsno; i++)	{
			for( int j=0; j<dbob.getcolsno(i); j++)	{
				if( dbob.get(i,j)==spref )	{
					j+=2;
					s = "";
					while( dbob.get(i,j)!=")" )	{
						s += dbob.get(i,j)+" ";
						j++;
					}
					j++;
					.addsnd( "snd"+i+"_"+j, s );
				}
			}
		}
	}
	_restoresfx	{
		iilesfx = 0;
		sfxbg.stop(false);
		sfxbg.each( func { (@id) iframe=-1; } );
	}
	_lekmoveoffact	{
		if( igmstate==1)	{
			.hide;
			advmouse.setstd;
			anmovon.hide;
			.outpiecz;
		}
	}
	lekcjamove	{
		|int x, int y| = mouse.getpos;
		if(_grbuts.isincut(x,y,false,true) )	{
			@s = _grbuts.getsfound;
			if( s!=_slastlek )	{
				.leklastoff;
				_slastlek = s;
				<s>._butmoveon;
			}
		} else {
			.leklastoff;
		}
	}
	leklastoff	{
		if( _slastlek!=null )	{
			<_slastlek>._butmoveoff;
			_slastlek = null;
		}
	}
	lekcjaclick	{
		if( igmstate==3 )	{
			igmstate = 2;
			anzoomer.hide;
			return;
		} else if (igmstate==2 && (clsurf.isin(mouse.getpos,X1,Y1,X2,Y2)||grludki.isin(mouse.getpos,0,0) )) {
			.lekcjaret;
			return;
		}
		if ( _slastlek!=null )	{
			@s = <_slastlek>.actionname;
			match(s)	{
				"music" => {
					iMusic = !iMusic;	anbutmusic.setframe(0,iMusic);
					if( iMusic ) sndmusic.play;
					else sndmusic.stop(false);
					fxpik1.play;
				}
				"nutka" => {
					iNutka = !iNutka;
					anbutnutka.setframe(0,iNutka);
					if( iNutka ) clmusic.play;
					else clmusic.reset;
					fxpik1.play;
				}
				"prehistoria", "egipt", "grecja", "daleki", "rzym", "europa", "afryka", "ameryka" => {
					//if( !igmdemo )	{
						gameapi.play( grgry.get( grgry.find(s) + 1 ) );
					//}
				}
				"Prehistoria" => ;	// mapka
				"help" => ;
				"exit" => gameapi.play("MenuPreh");
				"_number_" => if( igmstate==2) {
					fxpik1.play;
					.viewobraz(sactobraz, _slastlek.strsubbs("txtileo"));
					}
				"nonzoom" => ;
				"yeszoom" => {
					if( igmstate==2)	{
						fxpik1.play;
						igmstate=3;
						anzoomer.show;
						advmouse.setstd;
					}
				}
				? => {
					if( igmstate==1 )	{
						if( igmdemo && vblok.contains(s) ) return;
						sactobraz = s;
						@irow = dbob.findbyrow(s);
						iileobrazow=0;
						@icol = 0;
						while( icol<dbob.getcolsno(irow) )	{
							if( dbob.get(irow,icol)=="file:" ) iileobrazow++;
							icol++;
						}
						if( iileobrazow==0 ) return;
						advmouse.setstd;
						igmstate = 2;
						sclickedlek = _slastlek;
						fxpik1.play;
						.viewobraz(s, 1);
					}
				}
			}
		} else .cactsndstop(true);
	}
	lnapiscol		{	return 117,1,1;	}
	lnapiscolact	{	return 217,1,1;	}
	viewobraz(string srow, int id)	{
		.cactsndstop(false);
		@irow = dbob.findbyrow(srow);
		string s[2];
		@srx = 776;
		@sry = 194;
		@x = srx;
		@y = sry + iFontSize + 5;
		@dx = 8;
		txtileo0.txtsetcol("- ",.lnapiscol);
		txtileo0.setpos(x,y);
		txtileo0.show;
		x+=txtileo0.getw+dx;
		for( int i=1; i<=iileobrazow; i++)	{
			s0 = "txtileo"+i;
			if( i==id)	<s0>.txtsetcol(i,.lnapiscolact);
			else	<s0>.txtsetcol(i,.lnapiscol);
			<s0>.setpos(x,y);
			<s0>.show;
			x+=<s0>.getw+dx;
		}
		s1 = "txtileo"+(iileobrazow+1);
		<s1>.txtsetcol(" -",.lnapiscol);
		<s1>.setpos(x,y);
		<s1>.show;
		x+=<s1>.getw;
		grtxtile.move((srx-x)/2,0);
		._restoresfx;
		if( irow>=0 )	{
			@icol = 1;
			@ile = 0;
			while( icol<dbob.getcolsno(irow) )	{
				match( dbob.get(irow, icol) )	{
					"text:" => {
						s0 = dbob.get(irow, icol+1); icol+=2;
						s0.change("_"," ");
						txtobrazki.txtsetcol("- "+s0+" -",.lnapiscol);
						txtobrazki.setpos(srx-txtobrazki.getw/2,sry);
						txtobrazki.show;
					}
					"file:" => { ile++;
						icol++;
						if(ile==id)	{
							s0 = dbob.get(irow,icol);	icol++;
							anobrazek.load(.getgraphpath+s0+".pyz");
							anobrazek.setz(190);
							//anobrazek.show;
							anmovon.hide;
							bZoom = false;
							anbutzoom.setframe(0,0);
							while(icol<dbob.getcolsno(irow) && dbob.get(irow,icol)!="file:")	{
								match(dbob.get(irow,icol))	{
									"-zoom" => {
										bZoom = true;
										anbutzoom.setframe(1,0);
										icol++;
										anzoomer.load(.getgraphpath+dbob.get(irow,icol)+".pyz");
										anzoomer.setz(200);
										anzoomer.hide;
									}
									"-say", "-say2", "-say3" => {
										while( dbob.get(irow,icol)!=")" ) icol++;
										.cbplay("snd"+irow+"_"+(icol+1));
										bStartPlay = true;
									}
									"-sfx" => {
										icol++;
										s0 = sfxbg.get(iilesfx); iilesfx++;
										<s0>.load(SFXPATH+dbob.get(irow,icol)+".wav"); icol++;
										<s0>.iframe = (dbob.get(irow,icol)); icol++;
										<s0>.iframe = (dbob.get(irow,icol)); icol++;
										<s0>.vol = ( dbob.get(irow,icol) );
									}
									? => ;
								}
								icol++;
							}
							icol = dbob.getcolsno(irow);
							anobrazek.play(0);
						} else {
							while(icol<dbob.getcolsno(irow) && dbob.get(irow,icol)!="file:")	icol++;
						}
					}
					? => icol++;
				}
			}
		}
	}
	lekcjaret	{
		igmstate = 1;
		.cactsndstop(false);
		anobrazek.stop(false);
		._restoresfx;
		grobrazki.hide;
		anbutzoom.setframe(0,0);
		bZoom = false;
		.leklastoff;
		if( sclickedlek!=null )	{
			<sclickedlek>._butmoveoff;
			sclickedlek = null;
		}
		.lekcjamove;
	}
}

new classgamepause clpause;
new classgamemusic clmusic;
clmusic.sndbgrpath("sounds/bgr/");
clmusic.musicpath("sounds/music/");
clmusic.load("sounds/music.db");

new snd sndakskermovon;
sndakskermovon.load("sounds/sfx/butmovon.wav");

class classasker2 : classasker	{
	init()	{
		classasker::init();
		
		this.setwavpath(SNDPATH);
		this.newsnd("sndaskexit", "nar07.wav");
		this.newsnd("sndaskexitgame", "nar12.wav");
		this.newsnd("sndyes", "nar08.wav");
		this.newsnd("sndno", "nar09.wav");
		this.newsnd("sndaskrestart", "nar11.wav");
		this.newsnd("sndaskrestart2", "nar14.wav");
		this.load( "scripts/common/asker.pyz", 2000 );
		this.fxonmovon("sndakskermovon");
	}
	askexittomenu()	{
		this.ask( "sndaskexit", "sndyes", "sndno", "myestomenu", "mnotomenu");
	}
	askexitgame	{	.ask( "sndaskexitgame", "sndyes", "sndno", "myestomenu", "mnotomenu");	}
	askrestart()	{
		this.ask( "sndaskrestart", "sndyes", "sndno", "myesrestart", "mnorestart");
	}
	askrestart2()	{
		this.ask( "sndaskrestart2", "sndyes", "sndno", "myesrestart", "mnorestart");
	}
	mnotomenu()	{}
	myestomenu()	{
		match( gameapi.getgamename() )	{
			"gamemenu" => "gameoutro";
			"MenuPreh" => "Outro" + LANG;
			? => sAskerGame;
		}
		gameapi.play;
	}
	mnorestart()	{
		match(gameapi.getgamename)	{
			"Memo" => "gamemenu";
			? => "gamemenu";
		}
		gameapi.play;
	}
	myesrestart()	{	this.crestart();	}
}

new classasker2 claskexit;

module clbuts	{
	init()	{}
	load()	{
		new classbutton buts;
		buts.build("scripts/common/buttons.pyz", 4000, "imglobcurs");
		buts.transclickfunc( engine.actclassname(), "butclick");
		buts.transmovonfunc( engine.actclassname(), "butmovon");
		buts.transmovofffunc( engine.actclassname(), "butmovoff");
		buts.disableall();
		new db dbb;
		dbb.load("scripts/common/buts.db");
		new snd sndfxglobon;
		sndfxglobon.load("sounds/sfx/globbutmovon.wav");
		new @bvisible = true;
	}
	reset()	{
		buts.disableall();	
		@sgame = gameapi.getgamename;
		int pos = dbb.findbyrow( sgame );
		if( pos>=0 )	{
			int ile = dbb.getcolsno( pos );
			for( int i=1; i<ile; i++)	{
				buts.enable( dbb.get( pos, i ) );
			}
		}
	}
	enable(string sbu)	{
		buts.enable( sbu );
	}
	/*****************************************/
	butmovon(string sc)	{
		sndfxglobon.play();
		bvisible = mouse.isvisible;
		mouse.show;
	}
	butmovoff(string sc)	{
		if( !bvisible ) mouse.hide;
	}
	butclick(string sc)	{
		if( sc=="pause" )	{
			clpause.pause();
		} else if( sc=="exit" )	{
			claskexit.askexittomenu();
		} else if (sc=="restart")	{
			claskexit.askrestart();
		}
	}
}

class classplacepointer2 : classplacepointer    {
	init()  {
		classplacepointer::init();
		this.load("scripts/common/strzalka.pyz");
	}
}

/***************************************************/
// new classnextgame clnextgm;
igmstate = 0;
|igmdebug, igmeasy, igmdemo, igmbegin| = false, false, true, true;

bsms.setstd;

//clnextgm.load("scripts/common/games.db");
clbuts.load;
advmouse.load("scripts/plansza/kursory.pyz");
new classfullsave save("scripts/common/save.txt");
save.stdload;

gameapi.play("MainLoader");
game MainLoader : Dzieje	{
	init	{
		Dzieje::init("mainloader");
		.exportbank(A, "oooo tak", "wspaaniale", "ho ho ho", "doobrze", "braawo", "achaa", "uhummm",
			"myes");
		.exportbank(A, "ooj nie", "ymym", "nie tak", "aj", "co le", "uups", "ajajaj",
			"mno");
		
		gameapi.play("IntroPreh");
	}
}
/***************************************************/

new string sPrehArg1;
class MenuGry : Dzieje	{
	init	{
		Dzieje::init(sSubMenu);
		if( igmdemo ) anpieczatka.setframe(1,0);
		.imgs=(A,"bkg.pyz", "tytul"+LANG+".pyz 5", "glowa.pyz 100");
		.sfxs=(A,"getpuz","putpuz", "ok 60", "step");
		if( GAME=="PrehMenuGry" && sSubMenuGame==null )
			.img = ("initimg.pyz");
		anglowa	{
			.play("std");
			.addmethod("onfinish", func {
				match(.actionname)	{
					"std" => ;
					"talk" => .play(-1);
					? => .play("std");
				}
				} );
		};
		.sounds=(A,
			"sndmenukolo", "Kolorowanie", "cstop",
			"sndmenukons", "Konstruowanie", "cstop",
			"sndmenupuzz", "Puzzle wszelakie", "cstop",
			"sndmenurozn", "Ronicowanie", "cstop",
			"sndmenumoda", "Prehistoryczna moda", "cstop"
			);
		new Button but1;
		but1.loadfrom("grprzyc", "scripts/plansza/", "przyciski.pyz", "_but_func" );
		but1.load("grgry", sSubEpoka+".pyz", func {	(@id)
			.setz(10);
			.Button_isin;
			.addmethod("butmoveon", func {
				if( <GAME>.hasvar("cmov") && cmov.moving ) return;
				fxpop.play;
				@s = .actionname->getb(0,4);
				.cglowa2("sndmenu"+s);
				advmouse.setbut;
				if( s!=sSubMenuGame )
					if( .nofframes(-1)>1 ) .setframe(-1,1);
				} );
			.addmethod("butmoveoff", func {
				advmouse.setstd;
				if( .actionname->getb(0,4)!=sSubMenuGame )
					.setframe(-1,0);
				} );
			.addmethod("butclick", func {
				if( <GAME>.hasvar("cmov") && cmov.moving ) return;
				fxpik1.play;
				if( GAME!="PrehMenuGry" )	{
					sSubMenuGame = <but1.sobject>.actionname->getb(0,4);
					gameapi.play("PrehMenuGry");
					return;
				} else {
					but1 {
						grbuts.setframe(-1,0);
					};
					.setframe(-1,1);
					if( sSubMenuGame==null )
						aninitimg.hide;
				}
				sSubMenuGame = .actionname->getb(0,4);
				<GAME>.removesubmenu;
				but1.load("grgry2", "gm"+<but1.sobject>.actionname+".pyz", func { (@id)
					//.Button_std;
					.Button_isin;
					.addmethod("butmoveon", func {
						sndakskermovon.play;
						advmouse.setbut;
						if( .nofframes(-1)>1 ) .setframe(-1,1);
						@s = but1.sobject;
						if( <s>.actionname->contains("demo") )
							.inpiecz(<s>.getcx, <s>.getcy);
						} );
					.addmethod("butmoveoff", func {
						advmouse.setstd;
						.outpiecz;
						.setframe(-1,0);
						} );
					.addmethod("butclick", func {
						@id2 = <but1.sobject>.actionnr(-1);
						@s = but1.sobject->getb(4,4);
						if( <but1.sobject>.actionname->contains("demo") ) return;
						match( s )	{
							"kolo" => gameapi.play("MenuKol"+(id2+1));
							"rozn" => {
								sSubObraz = <but1.sobject>.actionname;
								gameapi.play("Roznice");
								}
							"kons" => gameapi.play("MenuKons"+(id2+1));
							"puzz" => { sPrehArg1=id2;
									if ( id2)	gameapi.play("MenuPuzzle");
									else		gameapi.play("MenuWstaw");
									}
							"moda" => {
								sSubObraz = <but1.sobject>.actionname;
								if( sSubObraz=="babka")	gameapi.play("Moda");
								else						gameapi.play("Moda2");
								}
							? => ;
						}
						} );
					} );
				} );
				if( .actionname->getb(0,4)==sSubMenuGame )	{
					.setframe(-1,1);
					if( GAME=="PrehMenuGry" )	{
						but1.sobject = (this);
						.butclick;
					}
				}
			} );
	}
	_but_func(@id)	{
		.setz(100);
		.Button_isin;
		.addmethod("butclick", func {
			match( <but1.sobject>.actionname )	{
				"exit" => 	.exit_click;
				"help" => .help_click;
				"restart" => .restart_click;
				? => ;
			}
			} );
		.addmethod("butmoveon", func {
			fxstep.play;
			advmouse.setbut;
			.< <but1.sobject>.actionname + "_moveon" >;
			} );
		.addmethod("butmoveoff", func {
			advmouse.setstd;
			.< <but1.sobject>.actionname + "_moveoff" >;
			} );
	}
	addbutrestart	{
		but1.loadfrom("grprzycrestart", "scripts/plansza/", "prestart.pyz", "_but_func");
	}
	cexit	 { .cstop; igmstate=111; }
	cquit(@s)	{	if( igmstate==111) gameapi.play(s);	}
	ohno	{	anglowa.play("nie");	}
	ohyeah	{	anglowa.play("tak");	}
	removehelp	{
		but1 {
			@id = grbuts.findsac("help");
			if( id>=0 )	<grbuts.get(id)>.hide;
		};
	}
	removesubmenu	{
		if(.hasvar("grgry2"))	{
			but1.remove("grgry2");
			delete < grgry2.get(0)->strsube(1) >;
			grgry2.deleteallgm;
			delete grgry2;
		}
	}
	cglowa(@s)	{	.cbplay2(s); anglowa.play("talk");	}
	cglowa2(@s)	{
		if(_csplay!=null && <_csplay>.isplaying() &&
			!_csplay.in(A,"sndmenukolo","sndmenukons", "sndmenupuzz", "sndmenurozn","sndmenumoda") )	return;
		if( _csplay==s ) return;
		.cactsndstop(false);
		anglowa.play("talk");
		.cbplay(s);
	}
	cglowa3(@s)	{
		if( !<_csplay>.isplaying() )	{
			anglowa.play("talk");
			.crplay(s);
		}
	}
	cstop	{	anglowa.play("std");	}
	cunstop	{	.gmunlockall; .cstop;	}
}

new string sSubMenu = "grypreh";
new string sSubMenuGame = null;
new string sSubEpoka = "prehistoria";
new string sSubObraz = "mamuty";
new bool bPrehMenuGry;
game PrehMenuGry : MenuGry	{
	init	{
		MenuGry::init;
		.setsndbase("prehmenugry");
		.sounds = (A,
			"sndintro", "Wybierz gr", "cstop"
			);
		if( bPrehMenuGry )	{
			bPrehMenuGry = false;
			.cglowa("sndintro");
		}
		.removehelp;
	}
	exit_click	{	gameapi.play("MenuPreh");	}
}

class SubMenuGame : MenuGry	{
	init {}
	tinit(string sfile, string sfunc)	{
		MenuGry::init;
		new string sFuncClick = sfunc;
		but1.load("grgry2", sfile+".pyz", func { (@id)
			/*if( GAME=="MenuKons1" )	{
				.Button_isin;
				.addmethod("butmoveon", func {
					advmouse.setbut;
					sndakskermovon.play;
					if( .actionnr(-1)>0 ) .inpiecz( .getcx, .getcy );
					.setframe(-1,1);
					} );
				.addmethod("butmoveoff", func {
					advmouse.setstd;
					.outpiecz;
					.setframe(-1,0);
					} );
			} else*/
			GAME.in(A, "MenuKons1") ? .Button_stdalpha : .Button_std;
			.addmethod("butmoveon", func {
				sndakskermovon.play;
				advmouse.setbut;
				if( .nofframes(-1)>1 ) .setframe(-1,1);
				@s = "sndmenu"+.actionnr(-1);
				if( <GAME>.hasvar(s) )	.cbplay(s);
				if( .actionname->contains("demo") )	{
					.inpiecz(.getcx, .getcy);
				}
			} );
			.addmethod("butmvoeoff", func { .outpiecz; } );
			.addmethod("butclick", func { if( !.actionname->contains("demo")) .<sFuncClick>; } );
			} );
	}
}

game MenuKol3 : SubMenuGame	{
	init	{
		.tinit("gmkol3", func {	gameapi.play(<but1.sobject>.actionnr(-1),"Kolorowanka2");	} );
		.removehelp;
	}
	exit_click	{	gameapi.play("PrehMenuGry");	}
}

game MenuKol1 : SubMenuGame	{
	init	{
		.tinit("gmkol1", func {
			sSubObraz = <but1.sobject>.actionname;
			gameapi.play(1,"Kolorowanka1");
			} );
		.removehelp;
	}
	exit_click	{	gameapi.play("PrehMenuGry");	}
}

game MenuKol2 : SubMenuGame	{
	init	{
		.tinit("gmkol2", func {
			sSubObraz = <but1.sobject>.actionname;
			gameapi.play(2,"Kolorowanka1");
			} );
		.removehelp;
	}
	exit_click	{	gameapi.play("PrehMenuGry");	}
}

game MenuSzkielety : SubMenuGame	{
	init	{
		if( save.bis("zaliczony40") )
			.tinit("gmszkielety", "mplay" );
		else .tinit("gmszkielety2", "mplay" );
		.setsndbase("menuskel");
		.sounds = (A,
			"sndmenu0", "mamut", null,
			"sndmenu3", "baw", null,
			"sndmenu4", "nosoroec",null,
			"sndmenu1", "pies", null,
			"sndmenu2", "ko", null,
			"sndbrak", "eby zoy szkielet nosoroca musisz najpierw zaliczy najtrudniejszy quiz", "cstop"
			);
		.removehelp;
	}
	mplay	{
		sSubObraz = <but1.sobject>.actionname;
		if( sSubObraz=="nosor" && !save.bis("zaliczony40") )	.cglowa("sndbrak");
		else gameapi.play("Szkielety");
	}
	exit_click	{	gameapi.play("MenuKons4");	}
}

game MenuKons4 : SubMenuGame	{
	init	{
		.tinit("gmkonekstra", func {
			match( <but1.sobject>.actionnr(-1) ) {
				0 => {gameapi.play("MenuSzkielety");}
				1 => {sSubObraz="rampa"; gameapi.play("Konstruktor3_1");}
				2 => {sSubObraz="stone"; gameapi.play("Konstruktor2_2");}
				? => ;
			}
			} );
		.setsndbase("menukons4");
		.sounds=(A,
			"sndmenu0", "Zosta archeologiem", null,
			"sndmenu1", "Zbuduj ramp w Stonehenge", null,
			"sndmenu2", "Zbuduj nasyp w Stonehenge", null
			);
		.removehelp;
	}
	exit_click	{	gameapi.play("PrehMenuGry");	}
}

game MenuKons3 : SubMenuGame	{
	init	{
		if( save.bis("zaliczony20") )
			.tinit("gmbiskupin", "mplay" );
		else .tinit("gmbiskupin2", "mplay" );
		.setsndbase("menubiskup");
		.sounds=(A,
			"sndbrak", "eby rozegra t gr musisz zaliczy redni poziom quizu", "cstop"
			);
		.removehelp;
	}
	mplay	{
		match( <but1.sobject>.actionnr(-1) ) {
			0 => {sSubObraz="bis1"; gameapi.play("Konstruktor3_1");}
			1 => if( save.bis("zaliczony20") ){
					sSubObraz="bis2";	gameapi.play("Konstruktor3_1");
				} else
					.cglowa("sndbrak");
			2 => {sSubObraz="bis3"; gameapi.play("Konstruktor3_1");}
			? => ;
		}
	}
	exit_click	{	gameapi.play("PrehMenuGry");	}
}

game MenuKons2 : SubMenuGame	{
	init	{
		.tinit("gmkons2", func {
			match( <but1.sobject>.actionnr(-1) ) {
				0 => {gameapi.play("Konstruktor2_1"); }
				1 => { sSubObraz="dom2"; gameapi.play("Konstruktor2_2");}
				2 => gameapi.play("Konstruktor2_3");
				? => ;
			}
			} );
		.removehelp;
	}
	exit_click	{	gameapi.play("PrehMenuGry");	}
}

game MenuKons1 : SubMenuGame	{
	init	{
		.tinit("gmkon1", func {
			match( <but1.sobject>.actionnr(-1) ) {
				0 => {sSubObraz = "lodka";
					gameapi.play("Konstruktor1"); }
				1 => {KolejneLevel=0;	gameapi.play("Konstruktor2");}
				2 => gameapi.play("MenuKons1_3");
				? => ;
			}
			} );
		.removehelp;
	}
	exit_click	{	gameapi.play("PrehMenuGry");	}
}

game MenuKons1_3 : SubMenuGame	{
	init	{
		.tinit("gmkon1_3", func {
			sSubObraz = "lod" + (<but1.sobject>.actionnr(-1) ? 16 : 8);
			gameapi.play("Konstruktor3");
			} );
		.removehelp;
	}
	exit_click	{	gameapi.play("MenuKons1");	}
}

game MenuPuzzle : SubMenuGame	{
	init	{
		if( !save.bis("zaliczony10") && sPrehArg1==2 )
			.tinit("gmpuz2_2", "mplay" );
		else .tinit("gmpuz"+sPrehArg1, "mplay" );
		.setsndbase("menupuzle");
		.sounds = (A,
			"sndblok", "Te puzzle bdziesz mg uoy jeli zaliczysz najprostszy quiz", "cstop"
			);
		.removehelp;
	}
	mplay	{
		int i[2];
		if( sPrehArg1==1 )
			match( <but1.sobject>.actionnr(-1) ) {
				0 => { i0=2; i1=2; sSubObraz = "stone"; }
				1 => { i0=3; i1=3; sSubObraz = "renifer"; }
				2 => { i0=4; i1=4; sSubObraz = "biskupin"; }
				? => ;
			}
		else
			match( <but1.sobject>.actionnr(-1) ) {
				0 => { i0=5; i1=5; sSubObraz = "mamuty"; }
				1 => { i0=6; i1=6; sSubObraz = "statki"; }
				2 => if( save.bis("zaliczony10") )	{
						i0=7; i1=7; sSubObraz = "osada";
					} else {
						.cglowa("sndblok");
						return;
					}
				? => ;
			}
		gameapi.play(i0, i1, "Puzzle");
	}
	exit_click	{	gameapi.play("PrehMenuGry");	}
}

game MenuWstaw : SubMenuGame	{
	init	{
		.tinit("gmpuz"+sPrehArg1, func {
			sSubObraz = <but1.sobject>.actionname;
			gameapi.play("Wstaw");
			} );
		.removehelp;
	}
	exit_click	{	gameapi.play("PrehMenuGry");	}
}

game Kolorowanka2 : MenuGry, TPainter	{
	init(int id)	{
		new int ikolololevel = id;
		MenuGry::init;
		TPainter::init;
		.tinit(null, "scripts/kolo2/", null, "pedzel.pyz", "draw"+id+".pyz", "farby.pyz", "ld");
		.addbutrestart;
		.setsndbase("ko2lo");
		.sounds = (A,
			"sndhelp", "Aby wyczyci obrazek kliknij przycisk restart", null
			);
		.sfxs=(A,"pedzel", "pedzel2");
		grpaleta.hide;
		new db dbkolory;
		@s = "scripts/kolo2/img"+ikolololevel+".db";
		if( engine.fileexist(s) )	{
			dbkolory.load(s);
			grdraw.each( func { (@id)
				.paint( dbkolory.get(id,0), dbkolory.get(id,1), dbkolory.get(id,2), 255, 0);
				} );
		} else {
			grdraw.each( func { (@id)
				.paint(.white,255,0);
				dbkolory.dbaddstringrow("255 255 255"," ");
				} );
			.savekols;
		}
		anbkg.load( .getgraphpath + "bgkol.pyz");
	}
	help_click	{	.crplay("sndhelp");	}
	savekols	{
		if( !<GAME>.hasvar("dbkolory") ) return;
		grdraw.each( func { (@id)
			int c[4];
			//|c0, c1| = .anfirstnontr;
			int ex = .getex , int ey = .getey;
			int x = .getpx, int y=.getpy;
			while( x!=ex && y!=ey )	{
				if( .isin(x,y,false,true) ) { c0=x; c1=y; x=ex; }
				else x++;
			}
			|c0,c1,c2,_| = .getrgba(c0,c1);
			dbkolory.set(id,0,c0);
			dbkolory.set(id,1,c1);
			dbkolory.set(id,2,c2);
			} );
		dbkolory.save( "scripts/kolo2/img"+ikolololevel+".db" );
	}
	onpaint	{	fxpedzel.play;	}
	onsetbrush	{	fxpedzel2.play;	}
	but1_lclick	{	if( sobject!=null ) .savekols;	}
	exit_click	{
		.savekols;
		.askfor("MenuKol3");
	}
	restart_click	{
		fxpedzel.play;
		grdraw.each( func { (@id)
			.paint(.white,255,0);
			dbkolory.set(id,0,255);
			dbkolory.set(id,1,255);
			dbkolory.set(id,2,255);
		} );
		.savekols;
	}
	claskexit_ask	{	mouse.show;	}
	claskexit_no	{	mouse.hide;	}
}

game Kolorowanka1 : MenuGry, TPainter	{
	init(int imod)	{
		new int imode = imod;
		MenuGry::init;
		TPainter::init;
		.tinit(null, "scripts/kolo1/", null, "pedzel.pyz", sSubObraz+".pyz", sSubObraz+"kredki.pyz", "ld");
		.sfxs=(A,"pedzel", "pedzel2");
		anbkg.load( .getgraphpath + sSubObraz+ "bgkol.pyz");
		.path=(sSubMenu);
		if( imode==1) grdraw.each( func { (@id) .paint(.white,255,0); } );
		else grdraw.each( func { (@id) .paint(.grey(232),255,0); } );
		anbrush2.paint( .white, 255, 0 );
		new string sbrush = null;
		
		grdraw.each( func { (@id)
			.var2("kolor", "white");
			} );
		.setsndbase("kolo1");
		
		grpaleta.hide;
		
		.importbank("sndtak", "myes", "ckolstop");
		.importbank("sndnie", "mno", "ckolstop");
		.sounds = (A,
			"sndgokol", "Dokocz kolorowanie obrazka", "cstop",
			"sndsuper", "Brawo! Wszystko idealnie pokolorowane", "cexit",
			"sndgomod2", "Pokoloruj wedug wskazwek obrazek", "cplaym2",
			"sndloski1", "Zamaluj rogi osia na pomaraczowo", "cmod2",
			"sndloski2", "Zamaluj sierc osia na brzowo", "cmod2",
			"sndloski3", "Zamaluj racice osia", "cmod2",
			"sndloski4", "Zamaluj maego osia na brzowo", "cmod2",
			"sndloski5", "Zamaluj ogon taty osia", "cmod2",
			"sndloski6", "Zamaluj brod taty osia", "cmod2",
			"sndloski7", "Zamaluj pozostae nogi osia", "cmod2",
			"sndloski8", "Wspaniale pomalowae oba osie", "cexit",
			"sndpanna1", "Pomaluj nos modelki", "cmod2",
			"sndpanna2", "Pomaluj usta modelki na czerwono", "cmod2",
			"sndpanna3", "Pomaluj zby modelki na biao", "cmod2",
			"sndpanna4", "Pomaluj ucho modelki", "cmod2",
			"sndpanna5", "Pomaluj makija na twarzy na czerwono", "cmod2",
			"sndpanna6", "Pomaluj kolczyk z muszli na niebiesko", "cmod2",
			"sndpanna7", "Pomaluj wosy modelki", "cmod2",
			"sndpanna8", "Pomaluj muszelki w opasce na gowie na niebiesko", "cmod2",
			"sndpanna9", "Pomaluj szyj modelki", "cmod2",
			"sndpanna10", "Pomaluj wisiorek z kw", "cmod2",
			"sndpanna11", "I nasza panna pomalowana!", "cexit",
			"snddom1", "Pomaluj dach na czerwono", "cmod2",
			"snddom2", "Pomaluj komin na biao", "cmod2",
			"snddom3", "Pomaluj szyb w okrgym oknie na jasny niebieski", "cmod2",
			"snddom4", "Pomaluj pot za domem na pomaraczowo", "cmod2",
			"snddom5", "Pomaluj niebo na ciemny niebieski", "cmod2",
			"snddom6", "Pomaluj pozostae okna", "cmod2",
			"snddom7", "Pomaluj psa na brzowo", "cmod2",
			"snddom8", "Pomaluj choinke na taki sam kolor jak krzew przed domem", "cmod2",
			"snddom9", "Pomaluj rynny na brzowo", "cmod2",
			"snddom10", "Pomaluj dym na szaro", "cmod2",
			"snddom11", "Pomaluj drzwi do garau na ten sam klor co rynny", "cmod2",
			"snddom12", "Pomaluj chmurk na ten sam kolor co snieg", "cmod2",
			"snddom13", "wietnie! domek pokolorowany!", "cexit",
			"sndbadel", "wybrae zy element", "cplaym2",
			"sndbadkol", "pomalowae prawidowy element ale zym kolorem", "cplaym2",
			"sndhelp2", "Pokoloruj wedug wskazwek obrazek", "cstop"
			);
		if( imode==2 ) {
			new int ilevel = 1;
			.cglowa("sndgomod2");
		} else .cglowa("sndgokol");
	}
	ckolstop	{
		if( imode==1 ) .cstop;
		else if (imode==2)	{
			.cplaym2;
		}
	}
	cmod2	{	.cunstop;	}
	cplaym2	{	.lock;	.cglowa("snd" + sSubObraz + ilevel);	}
	mouse_lclick	{
		.cquit("MenuKol"+imode);
		if( !.getlock )	{
			|int x, int y| = mouse.getpos;
			if( grdraw.isin(x,y,true,true) )	{
				.onpaint;
			} else if ( grpaleta.isin(x,y,false,true) )	{
				|@c[4]| = <grpaleta.getsfound()>.getrgba(x,y);
				c3 = 255;
				anbrush2.paint( c0, c1, c2, c3, 0 );
				.onsetbrush;
			}
		}
	}
	cdraw	{
		<grdraw.getsfound>.paint( anbrush2.getrgba(anbrush2.getpx+_ibrx,anbrush2.getpy+_ibry), 0 );
	}
	onpaint	{
		@s = grdraw.getsfound;
		if( imode==1 ) {
			.cdraw;
			<s>.kolor = (sbrush);
			if( grdraw.ineach( func { (@id) .framename->contains(kolor); } ) )	{
				.lock;
				.cglowa("sndsuper");
			} else {
				if( <s>.framename->contains( sbrush ) )	{
					.ohyeah;
					.cbplay2("sndtak");
				}	else	{
					.ohno;
					.cbplay2("sndnie");
				}
			}
			fxpedzel.play;
		} else if (imode==2)	{
			if( <s>.framenr==ilevel-1 )	{
				<s>.kolor = (sbrush);
				.cdraw;
				fxpedzel.play;
				if( <s>.framename->contains(sbrush) )	{
					ilevel++;
					.cplaym2;
				} else .cglowa("sndbadkol");
			} else { .cglowa("sndbadel");	}
		}
	}
	onsetbrush	{
		sbrush = <grpaleta.getsfound>.framename;
		fxpedzel2.play;
	}
	exit_click	{	.askfor("MenuKol"+imode);	}
	help_click	{
		.crplay( imode==1 ? "sndgokol" : "sndhelp2" );
	}
	claskexit_ask	{	mouse.show;	}
	claskexit_no	{	mouse.hide;	}
}

game Moda2 : MenuGry	{
	init	{
		MenuGry::init;
		.path = ("moda");
		.setsndbase("moda2");
		new gmimgvec grface	{
			this ..< (sSubObraz+"face.pyz");
			.setmodaz;
		};
		.newanima("anfc2", sSubObraz+"fcmask.pyz", 0);
		anfc2.hide;
		new gmimgvec grlezy	{
			this ..< (sSubObraz+".pyz");
			.setmodaz;
			.hide;
			.sortimgs;
		};
		new gmimgvec grszafa;
		"grszafa" ..< (sSubObraz+"szafa.pyz");
		new gmimgvec grmov;
		"grmov" ..< (sSubObraz+"mov.pyz");
		grmov.hide;
		new DelayMover cmov;
		new vector vecstroj;
		vecstroj.type("string");
		grszafa.each( func { (@id)
			vecstroj.add( .framename->strsube(1) );
			vecstroj.add(0);
			} );
		.sounds = (A,
			"sndgopanna", "Przed tob stoi przepikna jaskiniowa ksiniczka; Dzi wybiera si na bal jaskiniowcw; Pom dobra jej wieczorn kreacj" ,"modago",
			"sndgowoj", "Oto Ukki wojownik z gr; Wanie przygotowuje si do polowania; Ubierz go naleycie","modago",
			"snddzida", "pasuje do ubioru ta dzida", "cstop",
			"sndkaptur", "z kapturem nie zmoknie", "cstop",
			"sndkozaki", "wietne kozaki", "cstop"
			);
		.exportbank(A, "nieze sam bym si tak ubra", "he he he", "ciekawy strj", "no w czym takim to nawet na wesele mona i", "w tym to do obiadu raczej",
			"modaok");
		.importbank("sndtak", "modaok", "cstop");
		sndtak.startrand;
		.cglowa("sndgo"+sSubObraz);
	}
	modago	{	.cunstop; cmov.unlock;	}
	setmodaz	{	.each( func { (@id) .setz(10 + .framename->strgetfrom("_") ); } );	}
	cmov_GET	{
		|int x, int y| = mouse.getpos;
		@s, @s2, bool b = 0;
		if( grlezy.isin( x, y, 1, 1 ) )	{
			s = grlezy.getsfound;
			s2 = <s>.actionname;
			grlezy.eval1( func { (@sact)	if( .isvisible && .actionname==sact ) .hide; }, s2 );
			s2 = grmov.get(grmov.findsfr(s2));
			b=1;
		} else if ( grszafa.isin( x,y,1,1) )	{
			@id = grszafa.getfound;
			s = grszafa.getsfound;
			<s>.hide;
			s2 = grmov.get(id);
			b=1;
		}
		if( b) {
			<s2>.show;
			<s2>.ansetbpos( <s>.getpx-(<s2>.getw-<s>.getw)/2, <s>.getpy-(<s2>.geth-<s>.geth)/2 );
			<s2>.setz(900);
			.mssetobj(s2);
			fxgetpuz.play;
		}
	}
	cmov_PUT	{
		@s = .getfree;
		<s>.hide;
		|int x, int y| = mouse.getpos;
		@s2 = <s>.framename;
		anfc2.ansetsframe(0, s2.strsube(1));
		if( anfc2.isin(x,y,0,1) )	{
			grlezy.eval2( func { (@sset, @sact)
				@s = .actionname;
				if( .isvisible && s.strsube(1)==sset )	{
					.hide;
					<grszafa.get( .actionnr(-1) )>.show;
				} else if( s==sact )	{
					.show;
				}
				}, s2.strsube(1), s2 );
			if( !(5->rand) )	{
				bool b=0;
				if( 2->rand )	{
					if( sSubObraz=="woj" )	{
						if( !<grszafa.get( grszafa.findsfr("kurtka3") )>.isvisible )	.cglowa("sndkaptur");
						else if( !<grszafa.get( grszafa.findsfr("gunlewa1") )>.isvisible )	.cglowa("snddzida");
						else b=1;
					} else {
						if( !<grszafa.get( grszafa.findsfr("kurtka1") )>.isvisible )	.cglowa("sndkaptur");
						else if( !<grszafa.get( grszafa.findsfr("buty2") )>.isvisible )	.cglowa("sndkozaki");
						else b=1;
					}
				} else b=1;
				if (b) .cglowa("sndtak");
			}
		} else {
			<grszafa.get(<s>.framenr)>.show;
		}
		fxputpuz.play;
	}
	help_click	{	.cglowa("sndgo"+sSubObraz);	}
	exit_click	{	.askfor("PrehMenuGry");	}
}

game Moda : MenuGry	{
	init	{
		MenuGry::init;
		.path = ("moda");
		.setsndbase("moda");
		.newanima("anface", sSubObraz+"face.pyz", 0);
		.copyanima("anface", "anfc2");
		anfc2.hide;
		new gmimgvec grubrana;
		"grubrana" ..< (sSubObraz+".pyz");
		grubrana.hide;
		new gmimgvec grstroj;
		"grstroj" ..< (sSubObraz+"kol.pyz");
		new DelayMover cmov;
		@s = grstroj.get(0);
		new vector vecac;
		vecac.type("string");
		for( int i=0; i< <s>.nofactions; i++)	{
			vecac.add( <s>.nameofaction(i) );
			vecac.add(0);
			vecac.add(0);
		}
		new int idfound;
		.sounds = (A,
			"sndgomoda", "Oto pikna prehistoryczna modelka; Pom stworzy jej wiosenn kolekcj mody!",
				"cunstop"
			);
		//.addbank(A, "ho ho jaki adny efekt", "ciekawe", "no prosz", "dobre poczenie", "sndwow", "cstop");
		.importbank("sndtak", "myes", "cstop");
		sndtak.startrand;
		.cglowa("sndgomoda");
	}
	cmov_GET	{
		if( grstroj.isin(mouse.getpos,1,1) )	{
			@s = grstroj.getsfound;
			idfound = grstroj.getfound;
			<s>.setz(900);
			.mssetobj(s);
			fxgetpuz.play;
		} else if (grubrana.isin(mouse.getpos,1,1))	{
			idfound = grubrana.getfound;
			@s = grstroj.get(idfound);
			@s2 = grubrana.getsfound;
			<s>.ansetbpos( <s2>.getpx, <s2>.getpy );
			@id = .cpodnies( s );
			<s>.setz(900);
			.mssetobj(s);
			fxgetpuz.play;
		}
	}
	int cpodnies(string s)	{
		@id = vecac.find(<s>.actionname);
		if( vecac.get(id+1)=="1" )	{
			int id2 = vecac.get(id+2);
			<grstroj.get(id2)>.show;
			<grubrana.get(id2)>.hide;
		}
		id;
	}
	cmov_PUT	{
		@s = .getfree;
		<s>.setpos(0,0);
		<s>.setz(0);
		anfc2.ansetsframe(1,<s>.actionname);
		if( anfc2.isin(mouse.getpos,0,1) )	{
			@id = .cpodnies(s);
			vecac.set(id+1,"1");
			vecac.set(id+2,idfound);
			<s>.hide;
			<grubrana.get(idfound)>.show;
			if( !(5->rand) )	.cglowa("sndtak");
		}
		fxputpuz.play;
	}
	exit_click	{	.askfor("PrehMenuGry");	}
	help_click	{	.cglowa("sndgomoda");	}
}

game Roznice : MenuGry, TRoznice	{
	init	{
		MenuGry::init;
		.sfxs=(A,"pik");
		.tinit("scripts/roznice/", null, sSubObraz+".pyz", sSubObraz+"kol.pyz");
		gral.move(0,190);
		new string sfont = .stdfont(36);
		/*.newtext("txtzostalo", .remained, sfont, 100,100,255);
		txtzostalo.setz(20);
		txtzostalo.setpos((iResX-txtzostalo.getw)/2,280);
		txtzostalo.txtshadow(2,sfont);*/
		.img = ("cyferki.pyz 20");
		.copyanima("ancyferki", "ancyf2");
		.cputpoint;
		.setsndbase("roznice");
		.sounds = (A,
			"sndgoroz", "Cho obrazki wygldaj na pierwszy rzut oka tak samo s midzy nimi rnice; Znajd je wszystkie", "cunstop",
			"sndok", "Doskonale; Wszystkie rnice odnalezione", "cexit"
			);
		.importbank("sndtak", "myes", "cstop");
		.cglowa("sndgoroz");
	}
	cputpoint	{
		@ile = .remained;
		if( ile<10 )	{
			ancyferki.setpos(0,0);
			ancyferki.setframe(0,ile);
			ancyf2.hide;
		} else {
			ancyferki.setpos(-20,0);
			ancyf2.setpos(ancyferki.getw-15,0);
			ancyferki.setframe(0,ile/10);
			ancyf2.setframe(0,ile%10);
			ancyf2.show;
		}
	}
	tpoint	{
		fxpik.play;
		//txtzostalo.txtset(.remained);
		//txtzostalo.txtshadow(2,sfont);
		.cputpoint;
		if( 3->rand==0 ) .cglowa("sndtak");
	}
	tfinish	{	.tpoint; fxpik.stop(0); fxok.play;	.cglowa("sndok");	}
	tclick	{	.cquit("PrehMenuGry");	/*.cstopsnds(A,"sndgoroz", true);*/		}
	exit_click	{	.askfor("PrehMenuGry");	}
	help_click	{	.cglowa3("sndgoroz");	}
}

game Sredniowiecze : Epoka	{
	init	{
		Epoka::init("sredniowiecze");
	}
	mouse_move	{
		.lekcjamove;
	}
	mouse_lclick	{
		.lekcjaclick;
	}
}

game Prehistoria : Epoka	{
	init	{
		if( igmdemo )	{
			new vector vblok;
			vblok.type("string");
			vblok.beginadd("begin", "mamuty", "lbizon", "ltrzcina", "ozdoby", "stone",
				"mlotek", "jaskinia", "igla", "lmamut", "ogien", "siekiera", "maczuga", "domek", "ubrania", "mapa");
		}
		Epoka::init("prehistoria");
	}
	mouse_move	{
		.lekcjamove;
	}
	mouse_lclick	{
		.lekcjaclick;
	}
	keydown	{
// 		if( igmdebug && keyboard.iskey("space") )	gameapi.play("Opowiesc");
	}
}

game Opowiesc : Dzieje	{
	init	{
		Dzieje::init("opowiesc");
		new int Row = 0;
		.sfxs=(A,"step", "struga");
		.newdb("dbopo", "opowiesc.db");
		for( int i=0; i<dbopo.getrowsno; i++)	{
			.addsnd("snd_"+i, dbopo.get(i,2));
		}
		.stdexportsnd;
		new bool bLoop;
		new img imgbg;
		imgbg.load("scripts/plansza/opobg.png");
		new snd sndbgr;
		sndbgr.addmethod("onfinish", func {	if( bLoop ) .play;	} );
		new anima anview;
		anview.addmethod("onfinish", func {	if( .actionname->contains("L") ) .play(-1);	} );
		.path = ("plansza");
		new Buttons butopo("przyciskiopo.pyz");
		new Button butnut;
		butnut.load("grnutka", "nutkaopo.pyz", func { (@id)
				.Button_isin;
				.setframe(0,1);
				.addmethod("butclick", func {
					@s = grnutka.get(0);
					if( <s>.framenr )	{
						<s>.setframe(0,0);
						clmusic.reset;
					 } else {
						<s>.setframe(0,1);
						clmusic.play;
					}
					fxpik1.play;
					} );
				.addmethod("butmoveon", func { fxstep.play; advmouse.setbut; } );
				.addmethod("butmoveoff", func { advmouse.setstd; } );
			} );
		.path = ("opowiesc");
		
		.mnext(0);
	}
	butopo_moveon	{	fxstep.play;	}
	butopo_lclick	{
		match(sobject)	{
			"help" => ;
			"exit" => gameapi.play("MenuPreh");
			"next" => .mnext(1);
			"prev" => .mnext(-1);
			"restart" => gameapi.play("Opowiesc");
			? => ;
		}
	}
	mnext(int id)	{
		sndbgr.stop(false);
		.cactsndstop(false);
		bLoop = false;
		Row+=id;
		if( Row<0 )	{
			Row=0;
			.mnext(0);
			return;
		}
		if( Row>=dbopo.getrowsno )	{
			gameapi.play("MenuPreh");
			return;
		}
		anview.load( .getgraphpath + "sc" + dbopo.get(Row,0) + ".pyz" );
		anview.play(0);
		if( dbopo.getcolsno(Row)>3 )	{
			@s = dbopo.get(Row,3);
			@s2;
			if( s.contains("bgr") ) {	s2=BGRPATH;	bLoop=true;	}
			else s2 = SFXPATH;
			if( dbopo.getcolsno(Row)>4 )	bLoop = dbopo.get(Row,4);
			sndbgr.load( s2 + s + ".wav");
			sndbgr.setvol(40);
			sndbgr.play;
		}
		.cbplay("snd_"+Row);
	}
}
class TPuzzle	{
	init	{}
	tinit(string sbkg, string sels, int row, int col, int dx, int dy)	{
		new int iCols = col;
		new int iRows = row;
		.newimg("imgbkg", sbkg, 0);
		
		new gmimgvec grel;
		new gmimgvec grend;
		"grel" ..< sels;
		grel.hash;
		grel.each( func { (@id) .setz(10+id); } );
		
		new int ibadajl = 25;
		new string sactpuz;
		new int iblitopacity = 255;
		new int PuzzleState = 0;
		
		new DelayMover cmov;
		new SimpleCounter cnt(200);
		
		new int iX = dx;
		new int iY = dy;
		grel.move( iX, iY );
	}
	setpuzstate(int istate)	{
		PuzzleState=istate;
		if( PuzzleState==1)	{
			new gmimgvec grblit;
			@s = _;
			"grblit" ..< s;
			grblit.hide;
		}
	}
	cmov_GET	{
		if( grel.isin( mouse.getpos, true, true ) )	{
			string s = grel.getsfound;
			<s>.setz(900);
			.mssetobj( s );
			.tpuzzle_get;
		}
	}
	bool cwithin(string s)	{
		int i;
		if( .gettype!="anima" )	{
			for( i=0; i < .size; i++)	{if( <.get(i)>.cwithin( s ) )	return true;}
			return false;
		} else {
			if( <s>.gettype=="anima" )	{
				int id = .framenr;
				int im = id%iCols;
				A;
				if( im>0 )			id-1;
				if( im<iCols-1 )	id+1;
				im = id/iCols;
				if( im>0 )			id-iCols;
				if( im<iRows-1)	id+iCols;
				return <s>.framenr->in;
			} else {
				for( i=0; i< <s>.size; i++)		{if( .cwithin( <s>.get(i) ) )	return true;}
				return false;
			}
		}
	}
	cblit(string s)	{
		if( <s>.gettype=="anima" )	{
			if( PuzzleState==1 )	{
				<s>.setpos(iX, iY);
				<s>.hide;
				s = grblit.get(<s>.framenr);
			}
			<s> {
				.setz(1);
				.show;
				.setpos(iX,iY);
				int x = .getpx;
				int y = .getpy;
				.anaddfilter;
				.setopacity(iblitopacity);
				.setpos(x,y);
				imgbkg.blit( this );
				.unlink;
				.setpos(iX,iY);
				.hide;
			};
		} else	for( int i=0; i< <s>.size; i++ )		.cblit( <s>.get(i) );
	}
	cmov_PUT	{	<GAME>.cput;	}
	cput	{
		.tpuzzle_put;
		string s = cmov.getmover;
		<s>.setz(100+cnt.next);
		cmov.free;
		grel {
			.sortimgs;
			.each( func { (int i) .setz(10+i); } );
		};
		string s1 = s, string s2;
		sactpuz = s;
		while(<s>.gettype != "anima")	s=<s>.get(0);
		if( ibadajl.length( <s>.lodx+iX-<s>.getpx, <s>.lody+iY-<s>.getpy ) < ibadajl )	{
			.cblit(s1);
			grel.remove(s1);
			grend.add(s1);
			.tpuzzle_blit;
			if( grel.empty )	{
				grend.show;
				.tpuzzle_end;
			}
		} else {
			grel.remove(s1);
			for( int i=0; i<grel.size; i++)	{
				s = grel.get(i);
				if( cllen.iposlen(s,s1)<ibadajl && <s1>.cwithin(s) )	{
					|int x, int y| = <s>.getpos;
					if( <s>.gettype=="anima")	{
						if( <s1>.gettype=="anima" )	{
							s2 = "gr" + s;
							new gmimgvec <s2>;
							<s2>.add(s);
							<s2>.add(s1);
						} else {
							<s1>.add(s);
							s2 = s1;
						}
						grel.remove(s);
						grel.add(s2);
					} else {
						if( <s1>.gettype=="anima" )	{
							<s>.add(s1);
						} else {
							<s>.addgr(s1);
						}
						s2 = s;
					}
					<s2>.setpos(x,y);
					<s2>.setz( <s1>.getz );
					grel.sortimgs;
					sactpuz = s2;
					return;
				}
			}
			grel.add(s1);
		}
	}
	virtual tpuzzle_end {}
	virtual tpuzzle_get {}
	virtual tpuzzle_blit {}
	virtual tpuzzle_put {}
}

game Puzzle : MenuGry, TPuzzle	{
	init(int irow, int icol)	{
		MenuGry::init;
		delete anbkg;
		.path = ("puzzle");
		.tinit("bg"+sSubObraz+".png", sSubObraz+".pyz", irow, icol, 0, 0);
		.newanima("anpodpo", "podp"+sSubObraz+".pyz", 0);
		anpodpo.hide;
		.crect;
		.crect2;
		rec.fitgrouprand("grel");
		.setsndbase("puzzle");
		.sounds=(A,
			"sndintro", "Z puzlle; Najed na przycisk Pomocy eby zobaczy podpowied", func { .cunstop; .unlockall; igmstate=1;},
			"sndok", "Bardzo adnie; obejrzyj obrazek i kliknij by zoy kolejny", func { .cunstop; igmstate=111; }
			);
		.setpuzstate("we"+sSubObraz+".pyz", 1);
		.cglowa("sndintro");
		//.unlockall;
	}
	help_moveon	{
		if( igmstate!=111)
			anpodpo.show;
	}
	help_moveoff	{	anpodpo.hide;		}
	tpuzzle_get	{	fxgetpuz.play;	}
	tpuzzle_put	{	fxputpuz.play;	}
	tpuzzle_end	{
		fxok.play;
		grend.hide;
		.cglowa("sndok");
	}
	cmov_PUT	{
		<GAME>.cput;
		rec2.fit(sactpuz);
	}
	mouse_lclick	{
		if( igmstate==0)	.cactsndstop(true);
		else if (igmstate==111)	gameapi.play("MenuPuzzle");
	}
	exit_click	{	.askfor("MenuPuzzle");	}
}

class TWstaw	{
	init {}
	tinit(string sbkg, string sbgel, string sels)	{
		.newimg("imgbkg",sbkg,0);
		.newanima("anbgel", sbgel, 0);
		imgbkg.blit("anbgel");
		new DelayMover cmov;
		new gmimgvec grels;
		"grels" ..< sels;
		grels.setz(10);
	}
	cmov_GET	{
		if( grels.isin(mouse.getpos,1,1) )	{
			@s = grels.getsfound;
			<s>.setz(900);
			.mssetobj( s );
			.twstaw_get;
		}
	}
	cmov_PUT	{
		.twstaw_put;
		string s = .getmover;
		if( cllen.ilen( <s>.getpx, <s>.getpy, <s>.lodx, <s>.lody) < 40 )	{
			<s>.setz(11);
			<s>.setpos(0,0);
			.free;
			grels.remove(s);
			if( grels.empty )	{
				.twstaw_end;
			} else {
				.twstaw_ok;
			}
		} else {
			<s>.setz(10);
			.retobj;
		}
	}
	virtual twstaw_end	{}
	virtual twstaw_ok	{}
	virtual twstaw_put {}
	virtual twstaw_get {}
}

game Wstaw : MenuGry, TWstaw	{
	init	{
		MenuGry::init;
		delete anbkg;
		.path = ("wstaw");
		.tinit("bgwstaw.png", sSubObraz+".pyz", sSubObraz+"kol.pyz");
		//grels.each(func {(@id) .ansetbpos(600+100->rand, 200+300->rand); } );
		.crect;
		rec.fitgrouprand("grels");
		.lockall;
		.setsndbase("wstaw");
		.removehelp;
		.sounds = (A,
			"sndintro", "Wstaw brakujce elementy do obrazka", "cunstop",
			"sndend", "Doskonale! Obrazek uzupeniony", func { .cstop; igmstate=11; }
			);
		.importbank("sndtak", "myes", "cstop");
		.cglowa("sndintro");
	}
	twstaw_get	{	fxgetpuz.play;	}
	twstaw_put	{	fxputpuz.play;	}
	twstaw_ok	{	.cglowa("sndtak"); }
	twstaw_end	{	.cglowa("sndend"); fxok.play;	}
	mouse_lclick	{
		if( igmstate==11 )	gameapi.play("MenuWstaw");
	}
	exit_click	{	gameapi.play("MenuWstaw");	}
}

game IntroPreh : Dzieje	{
	init	{
		Dzieje::init("intropreh");
		.img=("intro" + LANG + ".pyz");
		.timer=("timtik",3000,func { .mend; } );
		timtik.play;
	}
	mend	{	gameapi.play("MenuPreh");	}
	mouse_lclick	{	.mend;	}
}

game MenuPreh : Dzieje, TMenu	{
	init	{
		Dzieje::init("menupreh");
		.tinit("menu" + LANG + ".pyz");
		.img = ("mamut.pyz 50");
		anmamut.addmethod("onfinish", func { .play(-1); } );
		but1.balpha=(0);
		bPrehMenuGry = true;
		.sounds=(A,
			"sndintro", "Witamy w programie Dzieje Ludzi Prehistoria; Wybierz rodzaj zabawy", func { .cstopm; .gmunlockall; },
			"sndgry", "Gry i zabawy", "cstopm",
			"sndopowiesc", "Opowie o przygodach prehistorycznego myliwego", "cstopm",
			"sndepoka", "Poznaj ycie naszych przodkw", "cstopm",
			"sndquiz", "Sprawd swoj wiedz", "cstopm"
			);
		if( igmbegin )	{
			igmbegin=false;
			.cbplay("sndintro");
		} .gmunlockall;
	}
	cstopm	{	anmamut.stop(false);	anmamut.setframe(0,0);	}
	cbplay(string s)	{
		classsound::cbplay2(s);
		anmamut.stop(false);
		anmamut.play(0);
	}
	gry_BUTCLICK	{	gameapi.play("PrehMenuGry");	}
	opowiesc_MOVEON	{
		if(igmdemo) {
			@s =  but1.getbut;
			.inpiecz( <s>.getcx, <s>.getcy-80 );
		}
	}
	quiz_MOVEON	{
		if(igmdemo) {
			@s =  but1.getbut;
			.inpiecz( <s>.getcx, <s>.getcy-80 );
		}
	}
	opowiesc_MOVEOFF	{	.outpiecz;	}	
	opowiesc_BUTCLICK	{	if( !igmdemo )	gameapi.play("Opowiesc");	}
	quiz_BUTCLICK	{	if( !igmdemo ) gameapi.play("MenuQuiz");	}
	epoka_BUTCLICK	{	gameapi.play("Prehistoria");	}
	exit_BUTCLICK	{	/*.askfor("Outro");*/claskexit.askexitgame;	}
}

game Outro : Dzieje	{
	init	{
		Dzieje::init("outro");
		.img = ("outro.pyz");
		.timer=("timtik",7000, func {
			anoutro.framenr ? gameapi.exit : anoutro.setframe(0,1);
			.delay(40000);
			.play;
			} );
		timtik.play;
	}
	mouse_lclick	{
		timtik.stop(true);
	}
}

class Outro_common : Dzieje	{
	init(string sfile)	{
		Dzieje::init("outro");
		.img=(sfile);
		.timer=("timtik",10000, func { gameapi.exit; } );
		timtik.play;
	}
	mouse_lclick	{	timtik.stop(true);	}
}

game Outrocze : Outro_common	{
	init	{	Outro_common::init("outrocze.png");	}
}
game Outroslo : Outro_common	{
	init	{	Outro_common::init("outroslo.png");	}
}

game Outroeng : Dzieje	{
	init	{
		Dzieje::init("outro");
		.img = ("outroeng.pyz");
	}
	mouse_lclick	{
		if( anoutroeng.framenr )	gameapi.exit;
		else anoutroeng.setframe(0,1);
	}
}

class Epoka2 : Dzieje	{
	init(string s)	{
		sEpoka2 = s;
		Dzieje::init("plansza");
		
		.list = (A, "prehistoria", "Prehistoria", "egipt", "EpokaEg", "daleki", "EpokaCh", "europa", "EpokaSr", "afryka", "EpokaAf", "ameryka", "EpokaAm", "grecja", "EpokaGr", "rzym", "EpokaRz", "grgry");
		
		new Button but1;
		but1.load("grepoki", "epoki"+LANG+".pyz", func {	(@id)
			.show;
			.setz(10);
			//.Button_isin;
			.addmethod("isbutin", func { (@x,@y) .isin(x,y,1,1); } );
			if( .actionname!=sEpoka2 )
				.setframe(-1,1);
			.addmethod("butmoveon", func {
				fxpop.play;
				advmouse.setbut;
				.setframe(-1,0);
				} );
			.addmethod("butmoveoff", func {
				advmouse.setstd;
				if( .actionname!=sEpoka2 )
					.setframe(-1,1);
				} );
			.addmethod("butclick", func {
				gameapi.play( grgry.get( grgry.find(.actionname) + 1 ) );
				} );
			} );
		.path=("epoki");
	}
}

new string sEpoka2;
game EpokaSr : Epoka2	{
	init	{
		Epoka2::init("europa");
		.img=("sr_bg"+LANG+".pyz");
		new gmimgvec gmobs;
		"gmobs" ..< "sr_obs.pyz";
		gmobs.hide;
		.timer=("timtik", 3000, "ipacgo" );
		.ipacgo;
	}
	ipacgo	{
		@s = gmobs.first;
		gmobs.removeat(0);
		<s>.show;
		if( gmobs.size )
			timtik.play;
	}
}

game EpokaRz : Epoka2	{
	init	{
		Epoka2::init("rzym");
		.img=("rz_bg"+LANG+".pyz");
		.newanima("annak", "rz_nak"+LANG+".pyz", 5);
		new gmimgvec gmobs;
		"gmobs" ..< "rz_obs.pyz";
		gmobs.each( func { (@id)
			if( id>0 )	{
				@s = gmobs.get(id-1);
				.ansetbpos( <s>.getpx, <s>.getey );
			}
			} );
		.timer=("timtik", 20, func {
			gmobs.move(0, -2);
			@s = gmobs.get(0);
			if( <s>.getey <= annak.getpy )	{
				gmobs.removeat(0);
				@s2 = gmobs.last;
				<s>.ansetbpos( <s2>.getpx, <s2>.getey );
				gmobs.add(s);
			}
			.play;
			} );
		timtik.play;
	}
}
game EpokaCh : Epoka2	{
	init	{
		Epoka2::init("daleki");
		.img=("ch_bg"+LANG+".png");
		new string simg1 = "img1";
		new string simg2 = "img2";
		new img img1;
		new img img2;
		new int iwidok = 1;		// aktualnie odgrywana scena
		new string sbaseimg = .getgraphpath + "ch";
		new int iilescen = 12;
		new int ibajkaz = 10;
		new int ileft = 525;
		new int iup = 256;
		img1.load( sbaseimg + 1 + ".png" );
		img1.setpos( ileft, iup );
		img1.setz( ibajkaz );
		.tmodeopacity( 1, -2 );
		.timer=("timtik",3000,"mnext");
		.mnext;
	}
	public tmodeopacity(int ic, int idop)	{
		new classfadeinout clfio;
		new int iopacityc = ic;
		new int iopacityd = idop;
	}
	mfinclfio	{
		<simg2>.hide();
		<simg2>.setz( ibajkaz );
		timtik.play;
	}
	mnext	{
		int id = iwidok + 1;
		if( id > 0 && id <= iilescen );
		else id=1;
		iwidok = id;
		<simg2>.load( sbaseimg+iwidok+".png" );
		<simg2>.setz( ibajkaz );
		<simg2>.setpos( ileft, iup );
		<simg2>.setz( ibajkaz-1 );
		<simg1>.setz( ibajkaz );
		clfio.imgtransparency( iopacityc, iopacityd, simg1, "mfinclfio");
		string s = simg1;
		simg1 = simg2;
		simg2 = s;
	}
	mfinpop()	{
		if( iwidok>iilescen ) iwidok=1;
		.mnext;
	}
}
game EpokaAf : Epoka2	{
	init	{
		Epoka2::init("afryka");
		.imgs=(A,"af_bg"+LANG+".pyz");
	}
}
game EpokaAm : Epoka2	{
	init	{
		Epoka2::init("ameryka");
		.imgs=(A,"am_bg"+LANG+".pyz");
	}
}

game EpokaGr : Epoka2	{
	init	{
		Epoka2::init("grecja");
		.imgs=(A,"gr_bg"+LANG+".pyz", "gr_obs.pyz 10");
		angr_obs.anloopplay(0);
	}
}

game EpokaEg : Epoka2	{
	init	{
		Epoka2::init("egipt");
		.imgs=(A,"eg_bg"+LANG+".pyz", "eg_obs.pyzH");
		new gmimgvec greps;
		new int iaction = 0;
		new int iframe = 0;
		.timer = ("timtik",1000, func {
			if( iframe < aneg_obs.nofframes(iaction) )	{
				<greps.get(iframe)>.show;
				iframe++;
				if( iframe == aneg_obs.nofframes(iaction) ) .delay(3000);
				.play;
			} else	{
				iaction++;
				if( iaction > aneg_obs.nofactions )	iaction = 0;
				<GAME>.loadacts;
			}
			} );
		.loadacts;
	}
	loadacts	{
		greps.deleteallgm;
		greps.free;
		_ = .newanframesgr("aneg_obs", "anegob", iaction, "greps");
		iframe=0;
		greps.hide;
		timtik.delay(1000);
		timtik.play;
	}
}

new int SzkieletyHard = 0;
game Szkielety : MenuGry	{
	init	{
		MenuGry::init;
		.path=("szkielety");
		.sfxs=(A, sSubObraz);
		.setsndbase("szkielety");
		new DelayMover cmov;
		.newanima("anend", sSubObraz+"end.pyz", 0);
		anend.hide;
		.copyanima("anend", "anend2");
		anend2.setz(10);
		anend2.anaddfilter;
		.newanima("anpom", sSubObraz+"podpo.pyz", 0);
		anpom.hide;
		new classsimplebutton cbx;
		cbx.build("scripts/szkielety/"+sSubObraz+"x.pyz", "imglobcurs", 0, 0, 0, 0);
		new classfadeinout clfio;
		
		new gmimgvec grels;
		"grels" ..< (sSubObraz+"skel.pyz");
		grels.setz(5);
		.crect2;
		match( sSubObraz )	{
			"mamut" => new Rect rec3(12,184, 445, 504);
			"pies" => new Rect rec3(7,184, 445, 504);
			"bawol" => new Rect rec3(583,198, 430, 484);
			"kon" => new Rect rec3(583,198, 430, 484);
			"nosor" => new Rect rec3(583,198, 430, 484);
			? => ;
		}
		rec3.fitgrouprand("grels");
		.sounds=(A,
			"sndgo", "Praca archeologa wymaga wiele wiedzy i cierpliwoci; Sprbuj odtworzy prehistoryczne zwierz ktrego koci le na planszy; Najed na przycisk pomoc jeli masz problemy",
				func { igmstate=1; .cunstop;	},
			"sndok", "C za precyzyjnie odtworzony szkielet! Widz zadatki na prawdziwego archeologa! Najed na przycisk X aby obejrze szkielet wewntrz zwierzcia",
				func { .cstop; igmstate=111; }
			);
		.cglowa("sndgo");
		//.unlockall;
	}
	cmov_GET	{
		if( grels.isin(mouse.getpos,1,1) )	{
			@s = grels.getsfound;
			<s>.setz(50);
			fxgetpuz.play;
			.mssetobj( s );
		}
	}
	cmov_PUT	{
		@s = .getfree;
		rec2.fit(s);
		if( <s>.aninlod(20) )	{
			fxok.play;
			<s>.setz(0);
			<s>.setpos(0,0);
			grels.remove(s);
			if( grels.empty )	{
				cmov.lock;
				anend.show;
				anend2.show;
				clfio.setopacity( 1, 10, "anend2", func {
					anend.hide;
					.cglowa("sndok");
					<"fx"+sSubObraz>.play;
					} );
			}
		} else {
			<s>.setz(5);
			fxputpuz.play;
		}
	}
	cbx_MOVEON		{	fxstep.play;	if( igmstate==111 ) anend2.setframe(0,1);	}
	cbx_MOVEOFF	{	if( igmstate==111 ) anend2.setframe(0,0);	}
	help_moveon	{
		if( !cmov.getlock )	{
			anpom.setframe( SzkieletyHard, ( anpom.framenr ? 0 : 1 ) );
			anpom.show;
		}
	}
	help_moveoff	{	anpom.hide;	}
	mouse_lclick	{
		if( igmstate==111 )	gameapi.play("MenuSzkielety");
		else if (igmstate==0)	.cactsndstop(true);
	}
	exit_click	{	.askfor("MenuSzkielety");	}
}

game Konstruktor3_1 : MenuGry	{
	init	{
		MenuGry::init;
		.path=("konstr3/"+sSubObraz);
		.setsndbase(sSubObraz);
		new DelayMover cmov;
		new gmimgvec grels;
		new int itoler = 20;
		"grels" ..< "els.pyz";
		grels.each( func { (@id)
			if( sSubObraz=="bis2" ) .setz(10+.framenr*10);
			else .setz(300+.framenr*10);
			new vector vp;
			} );
		//711,211
		new Rect rec2(10,150, 1004, 618);
		
		new Rect rec(650, 211, 350, 400);
		
		.importbank("sndtak", "myes", "cstop");
		match(sSubObraz)	{
			"bis1" => {.imgs = (A, "podklad.pyz", "maska.pyz 75");
				.require(9,7);
				.sounds = (A,
				"sndgo", "Zostae mianowany gwnym architektem Biskupina; Pom dokoczy budow",
					"cstart",
				"sndend", "wietnie! W takim grodzie moemy si czu bezpiecznie", "cexit"
				);
				.removehelp;
				}
			"bis2" => { .imgs = (A, "podklad.pyz", "start2.pyz 90", "start3.pyz 105");
				.require(5,4);	.require(12,11);	.require(13,12);	.require(9,5);
				.require(5,6);
				.sounds = (A,
				"sndgo", "Zbuduj bram i wie obronn Biskupina", "cunstop",
				"sndend", "Doskonale! Z wiey dostrzeemy niebezpieczestwo i obronimy grd", "cexit"
				);
				.removehelp;
				}
			"bis3" => { .imgs=(A,"podklad.pyz", "helpH.pyz 5", "podpoH.pyz 1000");
				.copyanima("anpodpo", "anpodpogo");
				itoler = 30;
				new classplacepointer2 clp;
				new classsimplebutton cbgo;
				cbgo.build("scripts/konstr3/bis3/podpobut.pyz", "imglobcurs", 0, 0, 100, 0);
				.require(3,0);	.require(4,1);	.require(5,2);
				.require(6,3);	.require(6,4);	.require(6,5);
				.require(7,3);	.require(7,4);	.require(7,5);
				.require(8,6);	.require(8,7);
				.require(9,6);	.require(9,7);
				.require(10,6);	.require(10,7);
				.require(11,6);	.require(11,7);
				.require(15,12);	.require(15,13);
				.require(16,13);	.require(16,14);
				.sounds = (A,
					"sndgo", "Budowniczy nie zdy zbudowa kadki ale zrobi jej projekt na piasku; Dokocz budow; W razie problemw kliknij przycisk pomoc", "cunstop",
					"sndend", "Dobrze; Zbudowae most e ho ho", "cexit"
				);
				}
			"rampa" => { .imgs=(A,"podklad.pyz", "glaz.Hpyz 10");
				rec.set(10, 150, 1004, 255);
				.removehelp;
				.sfxs=(A, "putbadpuz", "demolka", "ciagna", "glaz");
				anglaz.addmethod("onendframe", func {
					if( .framename=="check" && grels.size ) {
						fxdemolka.play;
						.play(1);
						grcopyel.hide;
						grspada.eval1("play",-1);
						grspada.each( func { (@id)
							if( grels.findfr(id)!=-1 ) .hide;
							} );
					} else if (.framename=="glaz")	{
						fxglaz.play;
					}
					} );
				anglaz.addmethod("onfinish", func {
					if( .actionnr(-1) )	.cglowa("sndups");
					else .cglowa("sndend");
					} );
				new gmobjvec grcopyel;
				grcopyel.copy("grels");
				new gmimgvec grspada;
				"grspada" .* "spada.pyz";
				grspada.hide;
				new classsimplebutton cbrampa;
				cbrampa.build("scripts/konstr3/rampa/butgo.pyz", "imglobcurs", 0, 0, 100, 0);
				.require(1, 0);
				.require(5, 2);	.require(5, 3);
				.require(6, 2);	.require(6, 3);
				.require(7, 3);	.require(7, 4);
				.require(8, 3);	.require(8, 4);
				.sounds = (A,
				"sndgo", "Budowniczy Stonehenge musz wtoczy na dwa bloki gaz; Zbuduj im ramp podjazdow", "cunstop",
				"sndups", "Ojoj wszystko trzeba zbudowa od pocztku", func { .cstop; igmstate=16; },
				"sndend", "Brawo konstruktorze! Rampa wytrzymaa ciar", "cexit"
				);
				}
			? => ;
		}
		
		rec.fitgrouprand("grels");
		.cglowa("sndgo");
	}
	cstart	{	.cunstop; }
	cbrampa_MOVEON	{	fxputbadpuz.play;	}
	cbrampa_CLICK	{
		if( igmstate!=111 && igmstate!=16 && grels.findfr(0)==-1 && grels.findfr(1)==-1)	{
			igmstate = 111;
			fxciagna.play;
			cmov.lock;
			anglaz.play(0);
		}
	}
	help_moveon	{
		if( sSubObraz=="bis3" )	{
			anhelp.setframe(0, anhelp.framenr ? 0 : 1 );
			anhelp.show;
		}
	}
	help_moveoff	{
		if( sSubObraz=="bis3" )	anhelp.hide;
	}
	cbgo_MOVEON	{	fxstep.play;	}
	cbgo_CLICK	{
		fxok.play;
		anpodpo.show;
		anpodpogo.play(1);
	}
	require(@i1, @i2)	{
		<grels.get(i1)> (i2) { (@id)
			vp.add(id);
		};
	}
	hasrequired	{
		for( int i=0; i< vp.size; i++ )
			if( grels.findfr(vp.get(i))!=-1 ) return false;
		true;
	}
	mouse_lclick	{
		if( sndgo.isplaying )	.cactsndstop(true);;
		if( igmstate==16 )	gameapi.play("Konstruktor3_1");
		.cquit(sSubObraz=="rampa" ? "MenuKons4" : "MenuKons3");
		if (anglowa.isin(mouse.getpos, 1, 1) && !.cisplaying )	{
			.cglowa("sndgo");
		}
	}
	cmov_GET	{
		if( sSubObraz=="bis3" && anpodpo.isvisible )	{
			anpodpogo.anhide;
			anpodpo.hide;
		} else if( grels.isin(mouse.getpos,1,1) )	{
			@s = grels.getsfound;
			if( sSubObraz!="bis2" )
				<s>.setz(600);
			fxgetpuz.play;
			.mssetobj( s );
		}
	}
	cmov_PUT	{
		@s = .getfree;
		rec2.fit(s);
		if( <s>.aninlod(itoler) && <s>.hasrequired )	{
			<s>.setpos(0,0);
			if( sSubObraz!="bis2" ) <s>.setz(10+<s>.framenr*10);
			grels.remove(s);
			fxok.play;
			if( grels.empty && sSubObraz.getb(0,3)=="bis")	{
				.cglowa("sndend");
			} else .cglowa("sndtak");
		} else {
			if( sSubObraz!="bis2" ) <s>.setz(300+<s>.framenr*10);
			fxputpuz.play;
		}
	}
	exit_click	{
		if( igmstate!=16 ) .askfor( sSubObraz=="rampa" ? "MenuKons4" : "MenuKons3" );
	}
}

game Konstruktor2_3 : MenuGry	{
	init	{
		MenuGry::init;
		.path=("konstr2/dom3");
		.sfxs=(A,"upadl2");
		.setsndbase("dom3");
		new DelayMover cmov;
		.imgs=(A, "podklad.pyz", "kolek.pyz 100", "zatyczka.pyz 110");
		.sfxs=(A,"getitem");
		anzatyczka.ansetbpos(701,509);
		ankolek.ansetbpos(663,160);
		new gmimgvec grdach;
		"grdach" .* "dach.pyz";
		grdach.setz(95);
		grdach.setdelay(3);
		new gmimgvec grsciana;
		.crect2;
		"grsciana" ..< "sciana.pyz";
		grsciana.setz(90);
		new gmimgvec grdrzwi;
		"grdrzwi" ..< "drzwi.pyz";
		new Rect recsciana(800, 260, 200, 200);
		recsciana.fitgrouprand("grsciana");
		new Rect recdach(800, 460, 200, 200);
		recdach.fitgrouprand("grdach");
		new string sdzwiek = "sndintro";
		new bool bdzwiek = false;
		.sounds = (A,
			"sndintro", "Teraz zbudujesz prehistorycznych kamienny domek; Zacznij od ciany", "gonext",
			"sndgo1", "Dobrze; Teraz zbuduj dach", "gonext",
			"sndgo2", "Dom prawie gotowy; Zatkaj dach bo zbiera si na deszcz", "gonext",
			"sndgo3", "Super mamy ju gotowy dom; teraz tylko wybierz kilka kamieni ze ciany ebymy mieli jak we do rodka", "gonext",
			"sndend", "Wspaniale zbudowae pikny kamienny dom; Sprbuj pobudowa inne", "cexit"
			);
		new int savx;
		new int savy;
		new int iileok = 0;
		.removehelp;
		.cglowa("sndintro");
	}
	gonext	{	.unlockall; .cunstop; if( bdzwiek) bdzwiek=false; else igmstate++;	}
	cmov_GET	{
		|int x, int y| = mouse.getpos;
		string s;
		match(igmstate)	{
			1 => if( grsciana.isin(x,y,1,1) && <grsciana.getsfound>.getz==90)	{
				s = grsciana.getsfound;
				savx = <s>.getpx;
				savy = <s>.getpy;
				.mssetobj( s );
				fxgetpuz.play;
				}
			2 => {
				if( grdach.isin(x,y,1,1) && <grdach.getsfound>.getz==95 ) {
					s = grdach.getsfound;
					savx = <s>.getpx;
					savy = <s>.getpy;
					.mssetobj(s);
					fxgetpuz.play;
				} else if (ankolek.isin(x,y,1,1) && ankolek.getz==100) {
					.mssetobj("ankolek");
					fxgetpuz.play;
				}
			}
			3 => if( anzatyczka.isin(x,y,1,1) ) { savx=anzatyczka.getpx; savy=anzatyczka.getpy;
				.mssetobj("anzatyczka"); fxgetpuz.play;}
			4 => if( grdrzwi.isin(x,y,1,1) )	{
				@id = grdrzwi.getfound;
				fxgetitem.play;
				match(id)	{
					0 => <grdrzwi.get(0)>.hide;
					1, 2 => if( !<grdrzwi.get(0)>.isvisible ) <grdrzwi.get(id)>.hide;
					3 => if( !(<grdrzwi.get(1)>.isvisible || <grdrzwi.get(2)>.isvisible) ) {
							<grdrzwi.get(3)>.hide;
							cmov.lock;
							.cglowa("sndend");
						}
					? => ;
				}
				}
			? => ;
		}
	}
	cmov_PUT	{
		@s = .getfree;
		rec2.fit(s);
		fxputpuz.play;
		match( igmstate )	{
			1 => {
				@id = <s>.framenr;
				if( <s>.aninlod(20) && (id<2 || <grsciana.get(id-2)>.aninlod(0)) )	{
					<s>.setpos(0,0);
					<s>.setz(80);
					iileok++;
					if( iileok==grsciana.size )	{
						iileok=0;
						cmov.lock;
						sdzwiek="sndgo1";
						.cglowa("sndgo1");
					}
				} else	<s>.ansetbpos(savx, savy);
			}
			2 => {
				if( s=="ankolek" )	{
					if( ankolek.aninlod(20) )	{
						ankolek.setz(98);
						ankolek.setpos(0,0);
					}
				} else {
					if( ankolek.getz==100 )	{
						if( <s>.aninlod(20) )	{
							cmov.lock;
							<s>.setpos(0,0);
							<s>.anplayfin(-1, func {
								@x = .getpx;
								@y = .getpy;
								.setframe(-1,0);
								.ansetbpos(x,y);
								.unlockall;
								fxupadl2.play;
								} );
						} else {
							<s>.ansetbpos(savx, savy);
						}
					} else {
						if( <s>.aninlod(20) )	{
							iileok++;
							<s>.setpos(0,0);
							<s>.setz(93);
							if( iileok==2 )	{
								cmov.lock;
								sdzwiek="sndgo2";
								.cglowa("sndgo2");
							}
						} else {
							<s>.ansetbpos(savx, savy);
						}
					}
				}
			}
			3 => if( anzatyczka.aninlod(20) )	{
					anzatyczka.setpos(0,0);
					cmov.lock;
					sdzwiek="sndgo3";
					.cglowa("sndgo3");
				}
			? =>;
		}
	}
	mouse_lclick	{
		if (anglowa.isin(mouse.getpos, 1, 1) && !.cisplaying )	{
			cmov.lock;
			bdzwiek=true;
			.cglowa(sdzwiek);
		}
		.cquit("MenuKons2");
	}
	exit_click	{	.askfor("MenuKons2");	}
}

game Konstruktor2_2 : MenuGry	{
	init	{
		MenuGry::init;
		.path=("konstr2/"+sSubObraz);
		.setsndbase(sSubObraz);
		new DelayMover cmov;
		new string sdzwiek = "sndintro";
		.crect2;
		.img=("podklad.pyz");
		new gmimgvec grels;
		"grels" ..< "kola.pyz";
		grels.setz(20);
		new gmimgvec grshow;
		"grshow" ..< "show.pyz";
		grshow.hide;
		new int ilevel = 0;
		new int ishowlev = 0;
		new classplacepointer2 clp;
		.timer=("timtik", 1000, "showlev");
		.showlev;
		if( sSubObraz=="dom2" )	new Rect rec(100, 300, 400, 300);
		else new Rect rec(130, 200, 700, 150);
		rec.fitgrouprand("grels");
		grels.each( func { (@id)
			new vector vpom;
			vpom.add(.framenr);
			.addmethod("contains", func { (int id) vpom.contains(id); } );
			.addmethod("getproper", func {
				@id = ilevel-1;
				if( .framenr==id ) this;
				else {
					@s = grels.get(id);
					.ansetbpos(<s>.getpx, <s>.getpy);
					s;
				}
				} );
			} );
		if( sSubObraz=="dom2" )	{
			<grels.get(3)> { vpom.add(7); };
			<grels.get(7)> { vpom.add(3); };
			.sounds = (A,
				"sndintro", "W tej grze zbudujesz popularn w czasach prehistorycznych ziemiank",
					func { .cglowa("sndgo1"); @s = grels.first;
					|int x, int y| = <s>.getpos;	<s>.setpos(0,0);
					clp.showob(s, "ld");	<s>.setpos(x,y); },
				"sndgo1", "W te koa bdziesz wstawia po kolei kafelki z czynnociami ktre trzeba wykona najpierw",
					func { .cglowa("sndgo2"); clp.showob( grshow.first, "rd"); },
				"sndgo2", "Jeli wstawisz poprawny kafelek na tym kawaku ziemi zobaczysz jak prehistoryczny myliwy buduje ziemiank",
					func { .cglowa("sndgo3"); clp.stoph; },
				"sndgo3", "Zaczynamy; najpierw wstaw pod kko numer 1 kafelek z elementem ktrym wykopiesz d", func { .cunstop; <GAME>.unlockall; },
				"sndok1", "Tak jest; za pomoc rogu osia myliwy wykopa d pod ziemiank; Nim pooymy dach musimy wzmocni d eby si nie zapad", "gonext",
				"sndok2", "wietnie pale powstrzymaj osypywanie si ziemi; Teraz zbuduj konstrukcj dachu", "gonext",
				"sndok3", "OK; Czas na nieprzemakalny sufit", "gonext",
				"sndok4", "Dobrze skry ochroni ziemiank przed wilogoci i nie przepuszcz piasku; Teraz wzmocnij dach", "gonext",
				"sndok5", "Ziemia dobrze chroni przed zimnem ale potrzebujemy jeszcze co na ni pooy eby wiatr jej nie rozrzuci lub nie zamienia si w boto", "gonext",
				"sndok6", "Super dach gotowy; Teraz wzmocnij podog", "gonext",
				"sndok7", "Kamienie s stabilne ale za twarde; Po dywan", "gonext",
				"sndok8", "Pozostao nam umieszczenie wojownika w ziemiance", "gonext",
				"sndok9", "Gratuluj zbudowae wojownikowi wspaniay dom", "cexit"
			);
		} else if (sSubObraz=="stone")	{
			<grshow.first>.hide;
			<grels.get(4)> { vpom.add(7); };
			<grels.get(7)> { vpom.add(4); };
			.imgs = (A, "poczatek.pyz", "ups.pyzH");
			.sfxs=(A, "glaz", "ciagna", "upadl", "padlglaz");
			anups.addmethod("onfinish", func {
				.unlockall;
				ilevel=5;
				sdzwiek="sndok"+4;
				grshow.hide;
				<grshow.get(4)>.show;
				rec.fitgrouprand("grels");
				<grels.get(4)>.setz(20);
				for( int i=0; i<4; i++ ) <grels.get(i)>.setpos(0,0);
				.hide;
				} );
			.sounds = (A,
				"sndintro", "W tej grze pokierujesz prehistorycznymi budowniczymi przy pracach w Stonehenge",
					func { .cglowa("sndgo1"); @s = grels.first;
					|int x, int y| = <s>.getpos;	<s>.setpos(0,0);
					clp.showob(s, "ld");	<s>.setpos(x,y); },
				"sndgo1", "W te kwadraty bdziesz wstawia po kolei kafelki z czynnociami ktre trzeba wykona najpierw",
					func { .cglowa("sndgo2"); <grshow.first>.show; anpoczatek.hide;
						/*clp.showob( grshow.first, "rd");*/
						clp.show(784,423,"ld");
						 },
				"sndgo2", "Twoi ludzie musz pooy gaz na dwch blokach kamiennych",
					func { .cglowa("sndgo3"); clp.stoph; },
				"sndgo3", "Zaczynamy; Najpierw usyp podjazd pod kamienne bloki",
					 func { .cunstop; <GAME>.unlockall; },
				"sndok1", "Mamy ju nasyp; Co dalej?", "gonext",
				"sndok2", "Ok Po tych belkach wtoczymy gaz", "gonext",
				"sndok3", "Gaz przygotowany Co teraz?", "gonext",
				"sndok4", "Do gazu przywizalimy liny; Co dalej?", "gonext",
				"sndok5", "Uff ale wysoko wcignlimy; Czas troch odpocz i posili si", "gonext",
				"sndok6", "Gaz zabezpieczony teraz moemy je", "gonext",
				"sndok7", "No to wcigamy dalej", "gonext",
				"sndok8", "Hip hip hurra nakrylimy bloki kamienne", "cexit",
				"sndups", "Ojojoj my tu jemy a gaz niezabezpieczony! Wciganie trzeba zaczyna od nowa", "cunstop"
				);
		}
		.removehelp;
		cmov.lock;
		.cglowa("sndintro");
	}
	gonext	{	.cunstop;	}
	showlev	{
		if( sSubObraz=="stone" ) {
			igmstate=10;
			if( ilevel>0 )	<grshow.get(ilevel-1)>.hide;
			<grshow.get(ilevel)>.anplayfin(ilevel, func { igmstate=1; } );
			ilevel++;
			return;
		}
		<grshow.get(ishowlev)>.show;
		ishowlev++;
		if( ishowlev < grshow.size && <grshow.get(ishowlev)>.actionnr(-1)==ilevel )
			timtik.play;
		else {
			ilevel++;
		}
	}
	cmov_GET	{
		if( igmstate==10 ) return;
		if( !timtik.isplaying && grels.isin(mouse.getpos, 1,1) && <grels.getsfound>.getz==20)	{
			@s = grels.getsfound;
			<s>.setz(40);
			fxgetpuz.play;
			.mssetobj( s );
		}
	}
	cmov_PUT	{
		@s = .getfree;
		fxputpuz.play;
		rec2.fit(s);
		@ilev = ilevel-1;
		@s2 = grels.get(ilev);
		<s>.setz(20);
		if( 0->length(<s>.getpx-<s2>.lodx, <s>.getpy-<s2>.lody)<15 )	{
			if( <s>.contains(ilev) )	{
				s = <s>.getproper;
				<grshow.first>.hide;
				igmstate=5;
				sdzwiek = "sndok"+ilevel;
				.cglowa(sdzwiek);
				.showlev;
				<s>.setpos(0,0);
				<s>.setz(10);
				cmov.lock;
			} else if (sSubObraz=="stone" && ilevel==6 && <s>.framenr==6 )	{
				grshow.hide;
				cmov.lock;
				.cglowa("sndups");
				anups.play(-1);
			}
		}
	}
	mouse_lclick	{
		if( igmstate==5 ) igmstate=1;
		else if (anglowa.isin(mouse.getpos, 1, 1) && !.cisplaying )	{
			cmov.lock;
			.cglowa(sdzwiek);
		} else if( igmstate!=10 && .cgetactsnd!="sndups") .cactsndstop(true);
		.cquit(sSubObraz=="stone" ? "MenuKons4" : "MenuKons2");
	}
	exit_click	{	.askfor(sSubObraz=="stone" ? "MenuKons4" : "MenuKons2");	}
}

game Konstruktor2_1 : MenuGry	{
	init	{
		MenuGry::init;
		.path=("konstr2/chata");
		.setsndbase("chata");
		.imgs=(A, "podklad.pyz", "ognisko.pyz 1");
		anognisko.play(0);
		new gmimgvec grmov;
		"grmov" ..< "mov.pyz";
		grmov.hide;
		grmov.setz(100);
		new gmimgvec grlezy;
		"grlezy" ..< "leza.pyz";
		grlezy.each( func { (@id) .setz(10+.framename); } );
		new gmimgvec grstos;
		"grstos" ..< "elementy.pyz";
		grstos.hide;
		grstos.setz(1);
		<grstos.get(0)>.setz(0);
		<grstos.get(1)>.setz(0);
		new DelayMover cmov;
		.newdbscript("dborder", "order.db");
		new int ordrow = 0;
		
		.sounds = (A,
			"sndgo", "Zbuduj lepiank; Zacznij od paleniska i postawienia cian", "cunstop",
			"sndend", "Super! Sam bym w takiej fajnej lepiance pomieszka", "cexit"
			);
		.removehelp;
		.cglowa("sndgo");
	}
	cmov_GET	{
		if( grlezy.isin(mouse.getpos,1,1) )	{
			@s = grlezy.getsfound;
			<s>.hide;
			@s2 = grmov.get(grlezy.getfound);
			<s2>.show;
			<s2>.ansetbpos( <s>.getpx-(<s2>.getw-<s>.getw)/2, <s>.getpy-(<s2>.geth-<s>.geth)/2 );
			fxgetpuz.play;
			.mssetobj( s2 );
		}
	}
	cmov_PUT	{
		@s = .getfree;
		@ifr = <s>.framenr;
		<s>.hide;
		fxputpuz.play;
		if( <s>.aninlod(30) && dborder.dbrowcontains(ordrow,ifr) )	{
			dborder.removeat( ordrow, dborder.dbfindinrow( ordrow, ifr ) );
			<grstos.get( ifr )>.show;
			fxok.play;
			if( dborder.getcolsno(ordrow)==0 )	{
				ordrow++;
				if( ordrow>= dborder.getrowsno )	{
					cmov.lock;
					.cglowa("sndend");
				}
			}
		} else {
			<grlezy.get( ifr )>.show;
		}
	}
	mouse_lclick	{
		.cquit("MenuKons2");
		if (anglowa.isin(mouse.getpos, 1, 1) && !.cisplaying )	{
			.cglowa("sndgo");
		} else if (sndgo.isplaying)	.cactsndstop(true);
	}
	exit_click	{	.askfor("MenuKons2");	}
}

game Konstruktor3 : MenuGry	{		// lodzie szkieletowe
	init	{
		MenuGry::init;
		.path=("konstr1");
		.setsndbase("szkielet");
		.newanima("anpodpo", sSubObraz+"podpo.pyz", 0);
		.copyanima("anpodpo", "anlod1");
		.copyanima("anpodpo", "anlod2");
		anlod1.setframe(0,1);	anlod1.hide;	anlod1.setz(13);	anlod1.anaddfilter;
		anlod2.setframe(0,2);	anlod2.hide;	anlod2.setz(15);	anlod2.anaddfilter;
		new gmimgvec grmov;
		"grmov" ..< (sSubObraz+"mov.pyz");
		grmov.setz(100);
		new gmimgvec grin;
		"grin" ..< (sSubObraz+"in.pyz");
		grin.setz(10);
		grin.hide;
		new DelayMover cmov;
		new classfadeinout clfio;
		new classfadeinout clfio2;
		
		.sounds = (A,
			"sndgo", "skonstruuj szkielet odzi", "cunstop",
			"sndok", "gratuluj wietny z ciebie konstruktor", func { .cstop; igmstate=111; }
			);
		.removehelp;
		.cglowa("sndgo");
	}
	cmov_GET	{
		if( grmov.isin(mouse.getpos, 1, 1) )	{
			fxgetpuz.play;
			.mssetobj(grmov.getsfound);
		}
	}
	cmov_PUT	{
		@s = .getfree;
		@s2 = grin.get(<s>.framenr);
		fxputpuz.play;
		if( 0->length(<s>.getpx-<s2>.getpx, <s>.getpy-<s2>.getpy) < 20 )	{
			grmov.remove(s);
			<s>.hide;
			<s2>.show;
			if( grmov.empty )	.mend;
		} else {
			<s>.setpos(0,0);
		}
	}
	mend	{
		cmov.lock;
		anpodpo.hide;
		anlod1.show;
		clfio.setopacity( 1, 10, "anlod1", func {
			anlod2.show;
			clfio2.setopacity( 1, 10, "anlod2", func { 
				.cglowa("sndok"); } );
			} );
	}
	mouse_lclick	{	if( igmstate==111 ) gameapi.play("MenuKons1_3");	}
	exit_click	{	.askfor("MenuKons1_3");	}
}

new int KolejneLevel = 0;
game Konstruktor2 : MenuGry	{		// ustawianie kolejnosci wytwarzania
	init	{
		MenuGry::init;
		.path=("kolejne");
		.setsndbase("porzadki");
		.imgs=(A, "spod.pyzH", "zestawy.pyzH 100");
		.sfxs=(A, "przechyladrzewo", "ogien", "rzezbiarz", "dowody", "drzewobum", "zamach 60");
		new gmimgvec grels;
		new gmimgvec grspod;
		new int ikolejny;
		new Rect rec(100, 300, 824, 300);
		
		new DelayMover cmov;
		.crect2;
		
		.sounds = (A,
			"sndgo0", "U schemat budowy dki z trzciny", "cunstop",
			"sndgo1", "U schemat powstawania skrzanej kamizelki", "cunstop",
			"sndgo2", "U schemat budowy siekierki z kamienia", "cunstop",
			"sndgo3", "U schemat budowy dki z mamuta", "cunstop",
			"sndgo4", "U schemat budowy dki dubanki", "cunstop",
			"sndend", "Doskonale! Wszystkie zestawy uoone!", "cexit"
			);
		new anima annagroda;
		annagroda.addmethod("onfinish", func { .hide; <GAME>.buildlev; } );
		.removehelp;
		.buildlev;
	}
	buildlev	{
		if( KolejneLevel>=anzestawy.nofactions )	{
			cmov.lock;
			.cglowa("sndend");
			return;
		}
		ikolejny = 1;
		grels.deleteallgm;
		grspod.deleteallgm;
		grels.free;
		grspod.free;
		anzestawy.setframe(KolejneLevel,0);
		int x = (iResX-anzestawy.nofframes(KolejneLevel)*anspod.getw)/2;
		int y = 300;
		string s;
		for( int i=0; i<anzestawy.nofframes(KolejneLevel); i++)	{
			s = "ansp"+i;
			.copyanima("anspod", s);
			grspod.add(s);
			<s>.setpos(x,y);
			<s>(i) { (@i)
				.show;
				.var2("idzes", -1);
				new vector vp;
				vp.add(i);
			};
			x+=anspod.getw;
			s = "anz"+i;
			.copyanima("anzestawy", s);
			grels.add(s);
			<s>	{
				.show;
				.var2("idspod",-1);
			};
			<s>.setframe(KolejneLevel,i);
		}
		rec.fitgrouprand("grels");
		if( KolejneLevel==2 )	{
			.cdodaj(0,1);	.cdodaj(0,2);
			.cdodaj(1,0);	.cdodaj(1,2);
			.cdodaj(2,0);	.cdodaj(2,1);
		} else if (KolejneLevel==3)	{
			.cdodaj(1,2);
			.cdodaj(2,1);
		}
		.cglowa("sndgo"+KolejneLevel);
	}
	cdodaj(@i1, @i2)	{
		<grspod.get(i1)>(i2) { (@i2) vp.add(i2); };
	}
	cmov_GET	{
		if( grels.isin(mouse.getpos, 1, 1) )	{
			fxgetpuz.play;
			@s = grels.getsfound;
			<s>.setz(100+ikolejny);
			ikolejny=(ikolejny+1)%200;
			grels.sortimgs;
			.mssetobj( s );
			if( <s>.idspod != -1 )	{
				<grspod.get(<s>.idspod)>.idzes = (-1);
				<s>.idspod = (-1);
			}
		}
	}
	cmov_PUT	{
		@s = .getfree;
		rec2.fit(s);
		fxputpuz.play;
		grspod.eval1( func { (@san)
			if( idzes==-1 && 0->length( .getposx-<san>.getposx, .getposy-<san>.getposy) < 20 )	{
				<san>.setpos( .getposx, .getposy );
				idzes = <san>.framenr;
				<san>.idspod=( this->strsubbs("ansp") );
			}
			}, s );
		if( grspod.ineach( func { (@id) vp.contains(idzes); } ) )	{
			fxok.play;
			annagroda.load( .getgraphpath + "nagroda"+ KolejneLevel + ".pyz" );
			annagroda.setpos(-250,0);
			grspod.hide;
			grels.hide;
			KolejneLevel++;
			annagroda.play(0);
		}
	}
	mouse_lclick	{	.cquit("MenuKons1");	}
	exit_click	{	.askfor("MenuKons1");	}
}

game Konstruktor1 : MenuGry	{		// lodz z bawola
	init	{
		MenuGry::init;
		new vector vecpos;
		vecpos.beginadd("begin", 364,195, 49,433, 27,217, 589,190 );
		.path = ("konstr1");
		.setsndbase("kons1");
		new int ileczesci = .loadanframes("anszkielet", sSubObraz+".pyz", 2, 10);
		_anszkielet.setz(20);
		_anszkielet.show;
		new gmimgvec grczesci;
		grczesci.additer("anszkielet", 0, ileczesci);
		grczesci.each( func { (@id) id*=2; .ansetbpos(vecpos.get(id), vecpos.get(id+1) ); } );
		new DelayMover cmov;
		.lockall;
		.sounds = (A,
			"sndgo", "Skonstruuj obiekt ktry widzisz przed sob", "cunstop",
			"sndfin", "Wspaniale! Idealna konstrukcja", "cexit"
			);
		.importbank("sndtak", "myes", "cstop");
		sndtak.startrand;
		.removehelp;
		.cglowa("sndgo");
	}
	cmov_GET	{
		if( grczesci.isin(mouse.getpos,1,1) && <grczesci.getsfound>.getz==10)	{
			@s = grczesci.getsfound;
			<s>.setz(900);
			.mssetobj(s);
			fxgetpuz.play;
		}
	}
	cmov_PUT	{
		string s = .getmover;
		if( cllen.ilen( <s>.getpx, <s>.getpy, <s>.lodx, <s>.lody) < 40 )	{
			<s>.setz(11);
			<s>.setpos(0,0);
			.free;
			ileczesci--;
			if( ileczesci==0 )	{
				.cglowa("sndfin");
				grczesci.hide;
				_anszkielet.setframe(1,0);
			} else {
				.ohyeah;
				.cbplay2("sndtak");
			}
		} else {
			<s>.setz(10);
			.retobj;
		}
		fxputpuz.play;
	}
	mouse_lclick	{	.cquit("MenuKons1");	}
	exit_click	{	.askfor("MenuKons1");	}
}

new int quizmode;

game MenuQuiz : Dzieje, TMenu	{
	init	{
		Dzieje::init("quiz");
		.tinit("menuquiz" + LANG + ".pyz");
		.setsndbase("menuquiz");
		.newanima("antyp", "typ" + LANG + ".pyz", 30);
		antyp.hide;
		.sounds=(A,
			"sndintro", "Wybierz stopie trudnoci", "gmunlockall",
			"sndsnd10", "kartkwka", null,
			"sndsnd20", "sprawdzian", null,
			"sndsnd40", "egzamin", null
			);
		.cbplay("sndintro");
	}
	cgo(@id)	{	quizmode=id;	gameapi.play("Quiz");	}
	cview(@id)	{	antyp.show; antyp.setframe(0,id);	}
	snd10_MOVEON	{	.cview(0);	}
	snd20_MOVEON	{	.cview(1);	}
	snd40_MOVEON	{	.cview(2);	}
	snd10_MOVEOFF	{	antyp.hide;	}
	snd20_MOVEOFF	{	antyp.hide;	}
	snd40_MOVEOFF	{	antyp.hide;	}
	snd10_BUTCLICK	{	.cgo(10);	}
	snd20_BUTCLICK	{	.cgo(20);	}
	snd40_BUTCLICK	{	.cgo(40);	}
	exit_BUTCLICK	{	gameapi.play("MenuPreh");	}
}

game Quiz : Dzieje	{
	init	{
		Dzieje::init("quiz");
		.newdb("dbpyt", "pytania.db");
		.sfxs=(A, "ok");
		string s;
		new vector vecpyt;
		new vector vecpos;
		vecpos.vecnewint(3);
		.importbank("sndtak", "myes", "mdalej");
		.importbank("sndnie", "mno", "mdalej");
		.sounds=(A,
			"sndend1", "Oj popenie stanowczo za duo bdw; Poucz si i sprbuj ponownie", "mend2",
			"sndend2", "Test zaliczony ale mogoby by lepiej; Postaraj si jeszcze troch", "mend2",
			"sndend3", "Cakiem niele cho zdarzyo si kilka bdw; Moe nastpnym razem pjdzie lepiej", "mend2",
			"sndend4", "Bardzo dobrze! Prawie wszystkie zadania rozwizane prawidowo", "mend2",
			"sndend5", "Doskonale! Bezbdnie rozwizany test", "mend2",
			"sndrekord", "Brawo! Dotychczasowy rekord zosta pobity!", "mcheck",
			"sndblok10", "W nagrod odblokowuj najtrudniejszy poziom puzli", "mend",
			"sndblok20", "W nagrod odblokowuj budow wiey w Biskupinie", "mend",
			"sndblok40", "W nagrod odblokowuj najtrudniejszy etap w ukadaniu szkieletw", "mend"
			);
		//.setsndbase("quizpyt");
		for( int i=0; i<dbpyt.getrowsno; i++)	{
			s = dbpyt.get(i,1);
			if( s!="ref")	.addsndf("snd_"+i, s, "mgo");
			vecpyt.add(i);
		}
		.stdexportsnd;
		vecpyt.hash;
		vecpyt.veclimes(quizmode);
		.imgs=(A,"mamut.pyz 10", "bkg" + LANG + ".pyz", "rekordH.pyz 100", "odblokujH.pyz 90", "nakladka.pyz 4");
		anmamut.play("std");
		new gmimgvec grel;
		_ = "grel" .+ "anodp1" .+ "anodp2" .+ "anodp3";
		if( LANG.in(A,"", "eng") )
			new @sfont22 = .stdfont(18);
		else new @sfont22 = .snewfont("configs/fonts/normal.ttf",22);
		.newtext("txtstatus", "", sfont22, .white);
		.newdb("dbstatus", "status.db");
		new int idlang = dbstatus.findbyrow(LANG=="" ? "pl" : LANG);
		
		txtstatus.setz(10);
		txtstatus.setpos( 20, 710 );
		//txtstatus.txtshadow(2, sfont22);
		new int ilepytan = vecpyt.size;
		new int ipoprawne=0;
		new int izle = 0;
		new int irekord;
		new classsimplebutton cbexit;
		cbexit.build("scripts/quiz/exit.pyz", "imglobcurs", 0, 0, 100, 0);
		if( save.get("rekordquiz"+quizmode)!=null )	irekord=save.get("rekordquiz"+quizmode);
		
		.copyanima("anrekord", "anbest");
		anbest.setframe(0,2);
		anbest.show;
		.newtext("txtdotyczas", dbstatus.get(idlang,4), sfont22, .white);
		txtdotyczas.setz( anrekord.getz+5 );
		txtdotyczas.setpos( anbest.getpx - txtdotyczas.getw, 710);
		.newtext("txtbest", irekord, sfont22, 192,0,0);
		txtbest.setz( anrekord.getz+5 );
		txtbest.setpos(anbest.getcx-txtbest.getw/2, anbest.getcy-txtbest.geth/2-4);
		
		.reload;
		.unlockall;
	}
	cbexit_MOVEON	{	sndakskermovon.play;	}
	cbexit_CLICK	{	gameapi.play("MenuQuiz");	}
	mprint	{
		@id = ilepytan-vecpyt.size+1;
		if( id>ilepytan ) id = ilepytan;
		txtstatus.txtset(dbstatus.get(idlang,1) + id + "/"+ ilepytan +
			dbstatus.get(idlang,2) + ipoprawne +
			dbstatus.get(idlang,3)+ izle);
	}
	mstatus	{
		grel.hide;
		anrekord.show;
		if( !(ipoprawne==quizmode && !save.bis("zaliczony"+quizmode)) )	{
			anrekord.setframe(0,3);
			.copyanima("anrekord", "anrekbg");
			anrekbg.setz( anrekord.getz-10);
			anrekbg.setframe(0,5);
		}
		
		annakladka.hide;
		if( engine.varexist("anprzyk") )	anprzyk.hide;
		.newtext("txtrekord", ipoprawne, sfont22, 192,0,0);
		txtrekord.setz( anrekord.getz+5 );
		txtrekord.setpos(anrekord.getcx-txtrekord.getw/2, anrekord.getcy-20);
		real r = ipoprawne;
		r/=ilepytan;
		int ocena = 5;
		if( r<0.5 )	ocena=1;
		else if (r<0.6) ocena=2;
		else if (r<0.8) ocena=3;
		else if (r<1) ocena=4;
		.cbplay("sndend"+ocena);
	}
	mend2	{
		if( ipoprawne>irekord )	{
			txtrekord.txtset(ipoprawne);
			.copyanima("anrekord", "anrek2");
			anrek2.setframe(0, anrekord.framenr+1);
			fxok.play;
			.cbplay("sndrekord");
		} else .mend;
	}
	mend	{	igmstate=11;	}
	mcheck	{
		save.set("rekordquiz"+quizmode, ipoprawne);
		if( ipoprawne==quizmode && !save.bis("zaliczony"+quizmode) )	{
			save.bset("zaliczony"+quizmode);
			if( quizmode==20 ) anodblokuj.setframe(0,1);
			else if (quizmode==40) anodblokuj.setframe(0,2);
			anodblokuj.show;
			.cbplay("sndblok"+quizmode);
		} else .mend;
	}
	mgo	{	igmstate = 1;	}
	mdalej	{
		_ = vecpyt.vecpop;
		if( vecpyt.size )	{
			<GAME>.reload;
		} else {
			.mprint;
			<GAME>.mstatus;
		}
	}
	reload	{
		.vardelif("anodp2");
		.vardelif("anodp3");
		.vardelif("anprzyk");
		.vardelif("anodp1");
		@id = vecpyt.veclast;
		.newanima("anodp1", "p"+(id+1)+".pyz", 20);
		.copyanima("anodp1", "anodp2");	anodp2.setframe(0,1);
		.copyanima("anodp1", "anodp3");	anodp3.setframe(0,2);
		if( anodp1.nofactions>1 )	{
			.copyanima("anodp1", "anprzyk");
			anprzyk.setframe(1,0);
		}
		vecpos.hash;
		for( int i=0; i<3; i++) <"anodp"+(i+1)>.setpos(vecpos.get(i)*336,0);
		.mprint;
		.ask;
	}
	ask	{
		igmstate = 0;
		@id = vecpyt.last;
		if( dbpyt.get(id,1)=="ref" ) id = dbpyt.get(id,2)->to_i - 1;
		.cbplay("snd_"+id);
	}
	mouse_lclick	{
		if( igmstate!=1 ) {
			if( igmstate==11 ) gameapi.play("MenuQuiz");
			return;
		}
		if( grel.isin( mouse.getpos, true, false ) )	{
			igmstate = 0;
			fxpop.play;
			if( <grel.getsfound>.framenr==0 ) {
				anmamut.play("yes");
				ipoprawne++;
				.cbplay("sndtak");
			} else {
				anmamut.play("no");
				izle++;
				.cbplay("sndnie");
			}
		} else if (anmamut.isin(mouse.getpos,true,false) )	.ask;
	}
	/*keydown	{
		if( keyboard.iskey("1") )	{
			ipoprawne=1;
			izle = 9;
			.mprint;
			.mstatus;
		} else if (keyboard.iskey("2") )	{
			ipoprawne=10;
			izle = 0;
			.mprint;
			.mstatus;
		} else if (keyboard.iskey("3") )	{
			ipoprawne=6;
			izle = 4;
			.mprint;
			.mstatus;
		}
	}*/
}

