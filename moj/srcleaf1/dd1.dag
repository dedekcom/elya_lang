/******** konstrukcje  ********************/
new string	A = "!!!";
new real		PI = 3.14159265358979323846;
new int		BYTE0 = "0"->getbyte(0);
new int		BYTE9 = "9"->getbyte(0);
new int		BYTEa = "a"->getbyte(0);
new int		BYTEz = "z"->getbyte(0);
new int		BYTEA = "A"->getbyte(0);
new int		BYTEZ = "Z"->getbyte(0);
new int		BYTE_ = "_"->getbyte(0);
new int		BYTESPACE = " "->getbyte(0);

// engine.setdebugstate(2);

public varget(string svar)				{	[svar];				}
public varset(string svar, def val)			{	<svar> = val;			}
public varnew(string styp, string svar)	{	new <styp> <svar>;	}
public varnewif(string styp, string svar)	{	if( !.hasvar(svar) )	.varnew(styp,svar);}
public vardelif(string svar)				{	if( .hasvar(svar) )	.vardel(svar);		}
public vardel(string svar)				{	delete <svar>;		}
public reader(string sname)	{
	.varnewif("def", sname);
	.addmethod( sname, func { [.methodname]; } );
}
public writer(string sname)	{
	.varnewif("def", sname);
	.addmethod( sname+"=", func { (def val) <.methodname->strsube(1)> = val; } );
}
public var(string sname)	{
	.reader(sname);
	.writer(sname);
}
public var2(string sname, def val)	{
	.var(sname);
	<sname> = val;
}
public withlist(string sfun)	{
	@s = _;
	while( A != s )	{
		.<sfun>(s);
		@s = _;
	}
}
public withlist2(string sfun)	{
	@s = _;
	while( A != s )	{
		@s1 = _;
		.<sfun>(s1,s);
		@s = _;
	}
}
public vars	{	.withlist("var");}
public vars2	{	.withlist2("var2");}
/*****************************************************/
public bool in	{
	bool b = false;
	@x = .get;
	@y = _;
	while( A != y )	{
		if( !b )	b = x==y;
		@y=_;
	}
	b;
}
public with(string sfun)	{
	string sob = _;
	while( sob!=A )	{
		<sob>.<sfun>();
		sob=_;
	}
}
public copycall(string sfun, string sob)	{
	string s = "__call" + sfun;
	new string <s>;
	<s> = sob;
	.addmethod( sfun, func {
		string sf = .methodname;
		< [ "__call" + sf ] >.<sf>();
		});
}
public copycalls(string sobj)	{
	string s = _;
	while( s!=A )	{
		.copycall( s, sobj ); 
		s=_;
	}
}
/***********************************/
public mresize()	{	< .gettype + "_pack">::resizemethods( this );	}
/******** petle ********************/
public times(string sfun)		{	this.for_plus(0, this.get()-1, sfun );		}
public upto(int ito, string sfun)	{	this.for_plus( this.get(), ito, sfun );	}
public downto(int ito, string sfun)	{	this.for_minus( this.get(), ito, sfun );	}
public for_plus(int ifrom, int ito, string sfun)	{
	if( ito-ifrom<=0 )	return;
	for( ; ifrom<=ito; ifrom++)	this.<sfun>(ifrom);
}
public for_minus(int ifrom, int ito, string sfun)	{
	if( ifrom-ito<=0 )	return;
	for( ; ifrom>=ito; ifrom--)	this.<sfun>(ifrom);
}
public double_for(int w, int h, string sfun)	{
	int j;
	for( int i=0; i<w; i++)	{
		for( j=0; j<h; j++)	{
			this.<sfun>(i,j);
		}
	}
}
/****************************************/

// klasa do np. dynamicznego tworzenia obiektow z prefixem+id
class classobjcounter	{
	init(string sprefix)	{
		new string _sprefix=sprefix;
		new int _iile=0;
		.var2("limit",0);
	}
	string get()	{
		if( limit>0 ) _iile=_iile%limit+1;
		else _iile++;
		return _sprefix + (_iile-1);
	}
	int size()	{_iile;}
	int getid(int id)	{	_sprefix + (_iile-1-id);	}
}

/*class classvsigobj	{
	init()	{
		new bool bplaying=false;
	}
	virtual play()	{	bplaying=true;	}
	virtual stop(bool bstop)	{ 
		bplaying=false;
		if( bstop )	{	this.onfinish();	}
	}
	virtual bool isplaying()	{	bplaying;	}
}*/

/***************************************************************************/

class classsignals	{
	init()	{}
	/********** std obj **********************/
	stdfinish(string sob) { <sob>.addmethod("onfinish",func { this.<this.getname()+"_FINISH">();}); }
	stdstart(string sob) { <sob>.addmethod("onstart",func { this.<this.getname()+"_START">(); }); }
	stdsigs(string sob)	{
		this.stdstart(sob);
		this.stdfinish(sob);
	}
	/********** anima **********************/
	buildanima(string san)	{
		this.stdsigs(san);
		<san>.addmethod("onendframe", func { this.<this.getname()+"_ENDFRAME">(); } );
	}
	/********** snd **********************/
	buildsnd(string ssnd)	{	this.stdsigs(ssnd);		}
	/********** timer **********************/
	buildtimer(string stimer)	{
		this.stdsigs(stimer);
		<stimer>.addmethod("ontick", func { this.<this.getname()+"_TICK">(); });
	}
	/********** button *******************/
	buildbut(string sbut)	{
		<sbut>.addmethod("onclick", func { this.<this.getname()+"_CLICK">(); });
		<sbut>.addmethod("onrel", func { this.<this.getname()+"_REL">(); });
		<sbut>.addmethod("onmoveon", func { this.<this.getname()+"_MOVEON">(); });
		<sbut>.addmethod("onmoveoff", func { this.<this.getname()+"_MOVEOFF">(); });
	}
}

/******************************************************************/

class classlocker	{
	init()	{
		new bool _block = true;
	}
	public lock()	{	_block=true;	}
	public unlock()	{	_block=false;	}
	public setlock(bool b)	{	_block=b;	}
	public bool getlock()	{	return _block;	}
	public bool unlocked	{	_block==false;	}
	public setaslocker(string sob)	{
		<sob>.addmethod("buildlocker", func { new bool _block=true; });
		<sob>.buildlocker;
		<sob>.addmethod("lock", "lock");
		<sob>.addmethod("unlock", "unlock");
		<sob>.addmethod("setlock", "setlock");
		<sob>.addmethod("getlock", "getlock");
		<sob>.addmethod("unlocked", "unlocked");
	}
}

/***************************************************************************/

module classdbreader	{
	init()	{
		new db dbl;
	}
	readdb( string sfunc )	{
		int id = 0;
		int ile = dbl.getrowsno();
		while( id < ile )	{
			this.<sfunc>( id );
			id++;
		}
	}
	readrow( string srow, string sfunc )	{
		int ipos = dbl.findbyrow( srow );
		if( ipos >= 0 )	{
			this.<sfunc>( ipos );
		}
	}
}

/***************************************************************************/


/***************************************************************************/
class collection	{
	init(string styp)	{	new string stype=styp;	}
	public string type()	{	return stype;		}
}

class array : collection {
	init(string styp, int idimens, int isiz)	{
		collection::init(styp);
		new int idim = idimens;
		new int isize = isiz;
		new vector vec;
		vec.type(styp);
		if( idimens<=0 || isiz<=0 )	return;
		//vec.resize( isiz.pow(isiz,idimens), 0 );
		vec.resize( isiz.pow(idimens), 0 );
	}
	int getid()	{
		int pos=0;
		int dim=idim-1;
		while(dim>0)	{
			pos+=_;
			pos*=isize;
			dim--;
		}
		return pos+_;
	}
	public def get()	{	return vec.get( this.getid() );	}
	public set(def svar)	{	vec.set( this.getid(), svar);	}
	public int getsize()	{	return isize;			}
	public int getdim()	{	return idim;			}
}

class stack : collection	{
	init(string styp)	{
		collection::init(styp);
		new vector vec;
		vec.type(styp);
		new <styp> var;
	}
	public push(string svar){	vec.add(svar);		}
	public def top()	{	return vec.last();	}
	public def pop()	{
		var = this.top();
		vec.removeat( vec.size()-1 );
		return var;
	}
	public free	{	vec.free;	}
}

class map : collection	{
	init(string styp)	{
		collection::init(styp);
		new int isize=0;
	}
	set(string svar, def val)	{
		if( !this.hasvar("v"+svar) )	this.add(svar);
		<"v"+svar>.set(val);
	}
	add(string svar)	{	new <stype> <"v"+svar>;		}
	def get(string svar)	{	return ["v"+svar];		}
	remove(string svar)	{	delete <"v"+svar>;		}
	bool contains(string svar){	return this.hasvar("v"+svar);	}
}
class map2 : collection	{
	init(string styp)	{
		collection::init(styp);
		new vector vn;
		vn.type("string");
		new vector vec;
		vec.type(styp);
	}
	add(string svar, def val)	{	vn.add(svar);	vec.add(val);	}
	set(string svar, def val)	{	vec.set( vn.find(svar), val );	}
	bool contains(string svar)	{	return vn.contains(svar);	}
	def get(string svar)		{	return vec.get( vn.find(svar) );}
	remove(string svar)	{
		int id = vn.find(svar);
		if( id>=0 )	{
			vec.removeat( id );
			vn.removeat(id);
		}
	}
	free()	{	vn.free();	vec.free();	}
}


/***************************************************************************/
class classgamemusic : classdbreader	{
	init()	{
		classdbreader::init();
		new string smuspath = "";
		new string sbgrpath = "";
		new snd _sndbgr;
		_sndbgr.addmethod("onfinish", "_stdsndloop");
	}
	reset()	{
		gameapi.stopmusic();
		this.stopbgr();
	}
	_stdsndloop()	{	this.play(); }
	load(string sfile)	{	dbl.loadscript( sfile );	}
	musicpath(string s)	{	smuspath = s;	}
	sndbgrpath(string s)	{	sbgrpath=s;	}
	_play(int ipos)	{
		int i[3], string s[2];
		i0 = 1;
		i1 = dbl.getcolsno( ipos );
		while( i0 < i1 )	{
			s0 = dbl.get( ipos, i0 );	i0++;
			if( s0 == "music" )	{
				s1 = smuspath + dbl.get( ipos, i0 );
				i0++;
				if( i0 < i1 )	{
					if( dbl.get( ipos, i0 )=="vol" )	{
						i0++;
						gameapi.setmusicvol( dbl.get( ipos, i0 ) );
						i0++;
					}
				} else {
					gameapi.setmusicvol( 100 );
				}
				gameapi.playmusic( s1 );
			} else if (s0 == "bgr")	{
				_sndbgr.load( sbgrpath + dbl.get( ipos, i0 ) );
				i0++;
				if( i0 < i1 )	{
					if( dbl.get( ipos, i0 )=="vol" )	{
						i0++;
						_sndbgr.setvol( dbl.get( ipos, i0 ) );
						i0++;
					}
				} else {
					_sndbgr.setvol( 100 );
				}
				this.playbgr();
			} else {	i0++;	}
		}
	}
	play()	{
		this.reset();
		this.readrow( gameapi.getgamename(), "_play" );
	}
	playbgr()		{	_sndbgr.play();	}
	stopbgr()	{	_sndbgr.stop(false);	}
}

class Music	{
	init	{
		new vector vmus;
		vmus.type("string");
		new int ilastid;
		//onmusicfin      {       mus.play;       }
	}
	playdb(string s, int row, int icol)	{
		vmus.free;
		while (icol < <s>.getcolsno(row) )	{
			vmus.add( <s>.get(row, icol) );
			icol++;
		}
		ilastid = 0;
		.play;
	}
	playvec(string s, int id)	{
		vmus.free;
		while( id< <s>.size )	{
			vmus.add( <s>.get(id) );
			id++;
		}
		ilastid = 0;
		.play;
	}
	playstr(string s)	{
		vmus.vecbuildfromstring(s, " ");
		ilastid = 0;
		.play;
	}
	play	{
		if( ilastid >= vmus.size ) return;
		@s = MUSICPATH + vmus.get(ilastid);
		ilastid++;
		bool bloop=false;
		int fin=0;
		int fout = 0;
		int vol = 100;
		for( int i=ilastid; i<vmus.size; i++)	{
			@s1 = vmus.get(i);
			match(s1)	{
				"-l" => bloop = true;
				"-v" => { i++; vol = vmus.get(i); }
				"-fin" => { i++; fin = vmus.get(i); }
				"-fout" => { i++; fout = vmus.get(i); }
				"-p" => ;
				? => { ilastid=i; i = vmus.size; }
			}
		}
		gameapi.setmusicvol(vol);
		if( bloop ) {
			gameapi.playmusic(s);
			ilastid = vmus.size;
			return;
		}
		gameapi.loadmusic(s);
		if (fin) gameapi.fadeinmusic(fin);
		else gameapi.startmusic;
		if (fout) gameapi.fadeoutmusic(fout);
	}
	fadeout(int ms)	{
		if( gameapi.ismusicplaying ) {
			gameapi.fadeoutmusic(ms);
			ilastid=vmus.size;
		}
	}
	isplaying	{	gameapi.ismusicplaying;	}
	stop	{
		gameapi.endmusic(false);
	}
}
/**************************************************************/
	// zmienne globalna - stany gry
new int igmstate;
new int igmdebug;
new int igmeasy;
new int igmdemo;
new int igmbegin;

new int igmwinlocal;		// special folder windows
new string sgmproject = "DagielLeaf1";

new string sgmfontfile = "configs/fonts/normal.ttf";
new string sgmfontmono = "configs/fonts/mono.ttf";
new string sgmfontmonobold = "configs/fonts/monobold.ttf";
new string sgmfontbold = "configs/fonts/monobold.ttf";
new string sgmfontitalic = "configs/fonts/timesit.ttf";

new string SFXPATH = "sounds/sfx/";
new string BGRPATH = "sounds/bgr/";
new string MUSICPATH = "sounds/music/";
new string LANG = "pl";	// pl, eng, cze, slo
new string SNDPATH = "sounds/";
if( LANG=="pl" ) LANG="";
if( LANG.length > 0 ) SNDPATH += LANG + "/";

new int iResX = 800;
new int iResY = 600;

/**************************************************************/
	// standardowa klasa do tworzenia zmiennych
class newvars		{
	init()	{
		new string _sclpath = "";
		new string _sclwavpath = "";
	}
	string _checkfont(string sfont, int isize, string sfnt)	{
		if( sfont==null )	sfont=sgmfontfile;
		if( sfont.contains(".ttf") )	{
			new font <sfnt>;
			<sfnt>.load( sfont, isize );
			sfont = sfnt;
		}
		sfont;
	}
	string checkfont(string sfont, int isize)	{
		._checkfont(sfont, isize, "_fnt");
	}
	bool begingame()	{
		igmbegin = !igmbegin;
		!igmbegin;
	}
	newarray(string styp, string sbase, int size)	{
		if( size<= 0 )	return;
		size--;
		while(size>=0)	{
			new <styp> <sbase+size>;
			size--;
		}
	}
	setgraphpath(string spath)	{	_sclpath = spath;	}
	setwavpath(string spath)	{ _sclwavpath = spath; }
	string getgraphpath()	{	return _sclpath; }
	string getsndpath()	{	return _sclwavpath; }
	getpath(string sfile)	{
		if( sfile.getb(0,1)=="$" ) sfile.strsubb(1);
		else .getgraphpath + sfile;
	}
	newanima(string sname, string sfile, int z)	{
		new anima <sname>;
		<sname>.load( .getpath(sfile) );
		<sname>.setz(z);
	}
	newstdanima(string sname, string sfile, int z)	{
		this.newanima(sname, sfile, z);
		this.stdanaction(sname);
	}
	copyanimaactz(string ssrc, string sdest, string saction, int z)	{
		this.copyanimaact(ssrc, sdest, saction);
		<sdest>.setz(z);
	}
	copyanimaact(string ssrc, string sdest, string saction)	{
		this.copyanima(ssrc, sdest);
		<sdest>.setframe( saction, 0 );
	}
	copyanima(string ssrc, string sdest)	{
		new anima <sdest>;
		<sdest>.copy( ssrc );
	}
	copyanimas(string san, string sname, int istart, int ilosc)	{
		if (ilosc<0)	return;
		for(int i=0; i<ilosc; i++)	this.copyanima( san, sname + (istart + i)  );
	}
	newanimas(string sname, string sfile, int z, int ilosc)	{
		if(ilosc<0) return; 
		this.newanima(sname+"0", sfile, z);		// pierwsza load z zerem
		this.copyanimas(sname+"0", sname, 1, ilosc-1);		// pozostale kopiowane z niej
	}
	int newanframesgr(string san, string sname, int iaction, string sgr)	{	// tworzy animacje z klatek
		int ile = <san>.nofframes( iaction );
		this.copyanimas( san, sname, 0, ile );
		for(int i=0; i<ile; i++)	{
			<sname+i>.setframe(iaction, i);
			if( sgr!=null )	{	<sgr>.add( sname+i );	}
		}
		return ile;		// zwraca ilosc stworzonych animacji
	}
	int newanframes(string san, string sname, int iaction)	{	// tworzy animacje z klatek
		return this.newanframesgr(san,sname,iaction,null);
	}
	newcanvas(string sname, int w, int h, int r, int g, int b, int a, int z)	{
		new img <sname>;
		<sname>.create(w,h,r,g,b,a);
		<sname>.setz(z);
	}
	newimg(string sname, string sfile, int z)	{
		new img <sname>;
		<sname>.load( .getpath( sfile ) );
		<sname>.setz(z);
	}
	copyimg(string ssrc, string sdest)	{
		new img <sdest>;
		<sdest>.copy(ssrc);
	}
	playmusic(string sfile)	{gameapi.playmusic( MUSICPATH + sfile );	}
	newsndfree(string sname, string sfile)	{
		new snd <sname>;
		<sname>.setstartstopflag(false, true);
		<sname>.load( this.getsndpath() + sfile);
	}
	snewsnd(string sname, string sfile)	{
		this.newsnd(sname,sfile);
		<sname>.addmethod("onfinish","__std_finish");
	}
	_newsnd(string sname, string sfile)	{
		new snd <sname>;
		if( !sfile.contains(".") ) sfile += ".wav";
		<sname>.load( sfile);
		if( igmsubtitle )	{
			subtitle.register(sname, sfile);
		}
	}
	newsfx(string sname, string sfile)	{	._newsnd(sname, SFXPATH + sfile);	}
	newbgr(string sname, string sfile)	{	._newsnd(sname, BGRPATH + sfile);	}
	newbgrloop(string s, string s2)	{	.newbgr(s,s2); .sndplayloop(s);	}
	newsnd(string sname, string sfile)	{	._newsnd(sname, .getsndpath+sfile);	}
	newsndloop(string sname, string sfile)	{
		this.newsnd(sname,sfile);
		this.looponfinish1( sname );
	}
	looponfinish1( string sob )	{<sob>.addmethod("onfinish","_stdsndloop");	}
	sndplayloop(string sob)	{
		this.looponfinish1( sob );
		<sob>.play();
	}
	newsnds(string sbase, int inamestart, string sfilebase, int ifilefrom, int ifileto)	{
		string s;
		int ile = ifileto-ifilefrom+1;
		for(int i=0; i<ile; i++)	{
			s = sbase + (inamestart + i);
			new snd <s>;
			<s>.load( this.getsndpath() + sfilebase + (ifilefrom+i) + ".wav" );
		}
	}
	newtimer(string sname, int idelay, int iticks)	{
		new timer <sname>;
		<sname>.settick(iticks);
		<sname>.delay(idelay);
	}
	newtimercycle(string sname, int icycle, int iticks)	{
		new timer <sname>;
		<sname>.settick(iticks);
		<sname>.setcycle(icycle);
	}
	stdanaction(string san)	{
		string s = <san>.actionname();
		if( s.contains("L")  )	this.looponfinish(san);
		else if( s.contains("H")  )	this.hideonfinish(san);
		if( s.contains("P")  )	<san>.play(-1);
	}
	int newanactionsgr(string san, string sname, string sgr)	{
		int ile = <san>.nofactions();
		this.copyanimas( san, sname, 0, ile );
		string s;
		for(int i=0; i<ile; i++)	{
			s = sname+i;
			<s>.setframe(i,0);
			this.stdanaction(s);
			if( sgr!=null )	{<sgr>.add( s );}
		}
		return ile;
	}
	int newanactions(string san, string sname)	{return this.newanactionsgr(san,sname,null);	}
	int newanfrbyactgr(string san, string sname, string sgr)	{
		int ile = <san>.nofactions();
		for( int i=0; i<ile; i++)	_ = this.newanframesgr(san, sname+i+"_", i, sgr);
		return ile;
	}
	int newanfrbyact(string san, string sname)	{return this.newanfrbyactgr(san,sname,null);	}
	int loadanfrbyact(string san, string sfile, int z)	{
		string s = "_"+san;
		this.newanima(s,sfile,z);
		int ile = this.newanfrbyact(s, san);
		<s>.hide();
		return ile;
	}
	int loadanactions(string san, string sfile, int z)	{
		string s = "_"+san;
		this.newanima(s, sfile, z);
		int ile = this.newanactions(s, san);
		<s>.hide();
		return ile;
	}
	int loadanframes(string san, string sfile, int iaction, int z)	{
		string s = "_"+san;
		this.newanima(s, sfile, z);
		int ile = this.newanframes(s, san, iaction);
		<s>.hide();
		return ile;
	}
	newbutimg(string sbut, string sstd, string smov, string sclick, string smouse)	{
		new button <sbut>;
		<sbut>.set(sstd, smov, sclick);
		<sbut>.setmouse(smouse);
	}
	newbutan(string sbut, string sanstd, string sanmov, string sanclick, string smouse)	{
		new button <sbut>;
		<sbut>.setan(sanstd, sanmov, sanclick);
		<sbut>.setmouse(smouse);
	}
	/*****************************************************/
	newdb(string sdb, string sfile)	{
		new db <sdb>;
		<sdb>.load( .getpath(sfile) );
	}
	newdbscript(string sdb, string sfile)	{
		new db <sdb>;
		//<sdb>.loadscript( this.getgraphpath() + sfile );
		<sdb>.loadscritp( .getpath(sfile) );
	}
	vargmset(string svar, def val)	{
		string sg = gameapi.getgamename();
		if( !<sg>.hasvar(svar) )	<sg>.varnew( val.gettype(), svar );
		<svar> = val;
	}
}

/**************************************************************/
new img imglobcurs;		// globalny kursor aktywnosci
bsms.load("configs/kursorstd.png","configs/kursoract.png" );
	// modul obslugi standardowych kursorow myszy
module bsms {
	init()	{
		new img imgstd;
		new img imgact;
		new int msid = 0;		// 0- brak kursora 1-std lapka 2- active lapka 3- wlasny (wczytany w jakiejs grze)
	}
	load(string spath1, string spath2)	{
		imgstd.load(spath1);
		imgact.load(spath2);
		imglobcurs.copy("imgact");
		imglobcurs.hide();
		imgstd.hide();
		imgact.hide();
		this.reset();
		engine.stdbutcursor("imgstd");
	}
	setinitial()	{	mouse.stdcursor();	msid = 0;	}
	setstd()	{
		if( msid!=1 )	{
			mouse.setcursor("imgstd");
			engine.stdbutcursor("imgstd");
			msid = 1;
		}
	}
	setact()	{
		if( msid!=2 )	{
			mouse.setcursor("imgact");
			msid = 2;
		}
	}
	setown()	{	msid=3;	}
	bool isinitial()	{	msid==0;	}
	bool isstd()	{	msid==1;	}
	bool isact()	{	msid==2;	}
	bool isown()	{	msid==3;	}
}

/***************************************************************************/

module clsurf	{
	init()	{}
	bool isin(int x, int y, int x1, int y1, int x2, int y2)	{	x >= x1 && x<=x2 && y>=y1 && y<=y2;	}
	bool isin2(int x, int y, int x1, int y1, int w, int h)	{	x >= x1 && x < x1+w && y>=y1 && y<y1+h;	}
	bool inscreen(int x, int y, int dx, int dy)	{	this.isin( x, y, 0-dx, 0-dy, 800+dx, 600+dy );	}
	bool insurf(int x, int y, string simg) { .isin(x,y,<simg>.getpx, <simg>.getpy, <simg>.getex-1, <simg>.getey-1);}
	bool issurfin(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)	{
		this.isin(x1,y1, x3,y3,x4,y4) || this.isin(x2,y1, x3,y3,x4,y4) ||
				this.isin(x1,y2, x3,y3,x4,y4) || this.isin(x2,y2, x3,y3,x4,y4);
	}
	bool commonsurface(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)	{
		this.issurfin(x1,y1,x2,y2, x3,y3,x4,y4) || 
				this.issurfin(x3,y3,x4,y4, x1,y1,x2,y2);
	}
	bool commonimgs(string simg1, string simg2)	{
		this.commonsurface(<simg1>.getpx(), <simg1>.getpy(), <simg1>.getex()-1, <simg1>.getey()-1,
				<simg2>.getpx(), <simg2>.getpy(), <simg2>.getex()-1, <simg2>.getey()-1 );
	}
	bool surfwithinsurf(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)	{
		this.isin(x1,y1, x3,y3,x4,y4) && this.isin(x2,y1, x3,y3,x4,y4) &&
				this.isin(x1,y2, x3,y3,x4,y4) && this.isin(x2,y2, x3,y3,x4,y4);
	}
	bool imgwithinimg(string simg1, string simg2)	{
		this.surfwithinsurf(<simg1>.getpx(), <simg1>.getpy(), <simg1>.getex()-1, <simg1>.getey()-1,
				<simg2>.getpx(), <simg2>.getpy(), <simg2>.getex()-1, <simg2>.getey()-1 );
	}
}

/* modul do obliczen odleglosci */

module cllen	{
	init()	{
		new int il1;
		new int ilx;
		new int ily;
	}
	int ilenx()	{ return ilx; }
	int ileny()	{ return ily; }
	int ilen4(int x1, int x2)	{	return (x1-x2)->abs();	}
	int ilen3(string simg1, string simg2)	{
		return this.ilen( <simg1>.getcx(), <simg1>.getcy(), <simg2>.getcx(), <simg2>.getcy() );
	}
	int ilen5(string simg1, string simg2)	{
		return this.ilen( <simg1>.getpx(), <simg1>.getpy(), <simg2>.getpx(), <simg2>.getpy() );
	}
	int ilen2(string simg1, int x, int y)	{return this.ilen( <simg1>.getcx(), <simg1>.getcy(), x,  y );	}
	int ilen(int x1, int y1, int x2, int y2)	{
		ilx = x1-x2;
		ily = y1-y2;
		return il1.length( ilx, ily );
	}
	int iclenx(string simg1, int x)	{	return <simg1>.getcx() - x;	}
	int iclenx2(string simg1, string simg2)	{	return <simg1>.getcx() - <simg2>.getcx();	}
	int icleny(string simg1, int y)	{	return <simg1>.getcy() - y;	}
	int icleny2(string simg1, string simg2)	{	return <simg1>.getcy() - <simg2>.getcy();	}
	int isbetween2(string simg1, string simg2, int x1, int y1, int x2, int y2)	{
		return this.isbetween(simg1, <simg2>.getcx(), <simg2>.getcy(), x1, y1, x2, y2);
	}
	int isbetween(string simg1, int xx, int yy, int x1, int y1, int x2, int y2)	{
		il1 = this.ilen( simg1, xx, yy );
		return ilx>=x1 && ilx<=x2 && ily>=y1 && ily<=y2;
	}
	int ilodlen(string s1, string s2)	{	.ilen(<s1>.lodx,<s1>.lody, <s2>.lodx, <s2>.lody);	}
	int iposlen(string simg1, string simg2)	{
		.ilen( <simg1>.getpos, <simg2>.getpos );
	}
}

/****************************************************/
class classansearcher	{
	init()	{}
	def _findnotr(string san, int x, int y, int dx, int dy)	{
		int ex = <san>.getex() , int ey = <san>.getey();
		while( x!=ex && y!=ey )	{
			if( <san>.isin(x,y,false,true) ) return x,y;
			x+=dx;	y+=dy;
		}
		return -1,-1;
	}
	def firstnotrx1y(string san)	{	return ._findnotr(san,<san>.getpx(), <san>.getpy(), 1, 0);	}
	def firstnotrexy1(string san)	{	return ._findnotr(san,<san>.getex()-1, <san>.getpy(), 0, 1);	}
	def firstnotrxy1(string san)	{	return ._findnotr(san,<san>.getpx(), <san>.getpy(), 0, 1);	}
	def firstnotrx1ey(string san)	{	return ._findnotr(san,<san>.getpx(), <san>.getey()-1, 1, 0);	}
}

class signal_pack	{
	init()	{}
	addsignals(string san)	{
		<san>.addmethod("operator<", func { (string sfun) this.addmethod("onfinish", sfun ); } );
	}
}
/***************************************************************************/
class ImagePos	{
	init	{}
	getex	{	.getpx + .getw;	}
	getey	{	.getpy + .geth;	}
	getcx	{	.getpx + .getw/2;	}
	getcy	{	.getpy + .geth/2;	}
	setpos(int x, int y)	{	.move(x-.getpx, y-.getpy);	}
}
class ImageVisible	{
	init	{
		new bool _isvisible=1;
	}
	isvisible	{	_isvisible;	}
	show		{	_isvisible=1;	}
	hide		{	_isvisible=0;	}
}
class Image	{
	init	{}
	public resizemethods(string sob)	{
		<sob>.vars2(A, "getz",0, "getpx",0, "getpy",0, "getw",0, "geth",0, "isvisible", 0);
		<sob>.addmethod("show", func { isvisible=1; }	);
		<sob>.addmethod("hide", func { isvisible=0; }	);
		<sob>.addmethod("setz", func { (int z) getz=z; } );
		<sob>.addmethod("setpos", func { (int x, int y) getpx=x; getpy=y; } );
		<sob>.addmethod("move", func { (int x, int y) getpx+=x; getpy+=y; } );
		<sob>.addmethod("getex", func { getpx+getw; } );
		<sob>.addmethod("getey", func { getpy+geth; } );
		<sob>.addmethod("getcx", func { getpx+getw/2; } );
		<sob>.addmethod("getcy", func { getpy+geth/2; } );
		<sob>.addmethod("isin", func { (int x, int y, int bv, int ba)
			if( !ba ) {
				if( !bv || (bv&&isvisible) )	{
					x>=getpx && x<.getex && y>=getpy && y<.getey;
				} else 0;
			} else 0;
			} );
	}
}
	// rozszerzenia dla animcaji
class anima_pack : signal_pack	{
	init()	{}
	public resizemethods(string san)	{
		<san>.addmethod("_clanbuildpomvars", func { new int _ixp; new int _iyp; } );
		<san>._clanbuildpomvars();
		<san>.addmethod("setbpos", func {(int x, int y) .setpos( x-.lodx, y-.lody ); });
		<san>.addmethod("saverelpos", func {(int x,int y)_ixp=x-.getpx;_iyp=y-.getpy;} );
		<san>.addmethod("setrelpos", func{(int x, int y) .setbpos( x - _ixp, y - _iyp );});
		<san>.addmethod("mssaverelpos", func {.saverelpos( mouse.getpos );} );
		<san>.addmethod("mssetrelpos", func {.setrelpos( mouse.getpos );});
		<san>.addmethod("rplay", func {(string sact)if( !.isplaying(sact) ) .play(sact);});
		<san>.addmethod("setcpos", func {(int x, int y).setbpos( x-.getw/2, y-.geth/2 );});
		<san>.addmethod("operator=", func { (string s) .copy(s); } );
		<san>.addmethod("operator==", func { (string s)
			.actionnr==<s>.actionnr && .framenr==<s>.framenr; } );
		this.addsignals(san);
	}
}

class timer_pack : signal_pack	{
	init()	{}
	resizemethods(string sob)	{
		this.addsignals(sob);
	}
}
/***************************************************************************/
class vector_pack	{
	init()	{}
	each(string sfun)	{	for( int i=0; i<.size; i++) this.<sfun>(.get(i));	}
	resizemethods(string svec)	{
		<svec>.addmethod("each", "each");
		<svec>.addmethod("operator-", func { (def x) this.remove(x); this; } );
		<svec>.addmethod("operator+", func { (def x) this.add(x); this; } );
	}
}

/***************************************************************************/

public new_object(string styp, string sob)	{
	new <styp> <sob>;
	<styp+"_pack">::resizemethods(sob);
}
public new_anima(string s)	{	.new_object("anima",s);	}
public new_vector(string s)	{	.new_object("vector",s);	}

/***************************************************************************/

class classanfilter	{
	init()	{}
	buildanfilter()	{
		new filter ft;
		ft.link( this.getname() );
		ft.setpivottype(1);
	}
	public build(string san)	{
		<san>.addmethod("buildanfilter","buildanfilter");
		<san>.buildanfilter();
		<san>.addmethod("setopacity",	func {	(int iop) ft.setopacity(iop); }		);
		<san>.addmethod("setzoom",		func {	(real r) ft.setzoom(r); }			);
		<san>.addmethod("setangle",		func {	(real r) ft.setangle(r); }			);
		<san>.addmethod("getangle",		func {	return ft.getangle; }			);
		<san>.addmethod("rotate",		func {	(real r)	ft.rotate(r); }			);
		<san>.addmethod("setpivottype",	func {	(int ityp) ft.setpivottype(ityp); }	);
		<san>.addmethod("unlink",		func {	ft.unlink(); }					);
		<san>.addmethod("link",			func {	ft.link(this); }					);
		<san>.addmethod("blend",		func {	(string s) ft.blend(s); }			);
		<san>.addmethod("mask",		func {	(string s) ft.mask(s); }			);
	}
}

/***************************************************************************/

class classancounter	{
	init()	{
		new int iile;
		new int id;
		new string _san;
		new vector _vs;
		new int _pos;
	}
	set(string sname, int ile)	{
		_san = sname;
		iile = ile;
		id = 0;
		_pos = sname.length();
		_vs.resize( ile, false );
	}
	string get()	{
		string s = _san+id;
		id = (id+1)%iile;
		return s;
	}
	string getf()	{
		for(int i=0; i<iile; i++)	{
			if( !_vs.get(i) )	{
				_vs.set(i, true);
				return _san+i;
			}
		}
		return null;	// brak wolnych
	}
	retf(string s)	{	_vs.set( s.getb( _pos, 10 ), false );	}
	isfree(int pos)	{	return _vs.get(pos);	}
	int getile()	{	return iile;	}
}

/**************************************************************/
	// operacje na obrazach, dzwiekach, timerach i animacjach
class gmobjvec {
	init()	{
		new vector lsim;
		lsim.type("string");
	}
	operator=(string sgr)	{
		if( engine.varexist(sgr) )	{
			match(<sgr>.gettype())	{
				"vector" => this.copy(sgr);
				"gmobjvec" => this.copy(sgr);
				"gmimgvec" => this.copy(sgr);
				? => {	this.free(); this.add(sgr); }
			}
		} else {
			this.free();
			this.add(sgr);
		}
	}
	save(string s)	{	lsim.save(s);	}
	load(string s)	{	lsim.load(s);	}
	operator+(string sob)	{	this.add(sob);		return this;	}
	operator-(string sob)	{	this.remove(sob);	return this;	}
	removegr(string sgr)	{	for( int i=0; i < <sgr>.size; i++)	.remove( <sgr>.get(i) );	}
	addtogr(string sgr)	{	for( int i=0; i<this.size(); i++)	<sgr>.add(this.get(i));	}
	addgr(string sgr)	{	for( int i=0; i< <sgr>.size(); i++)	this.add( <sgr>.get(i) );	}
	addgroups	{	.withlist("addgr");	}
	copy(string sgr)	{
		this.free();
		this.addgr(sgr);
	}
	free()	{ lsim.free();	}
	int size()	{ return lsim.size(); }
	bool empty()	{	return this.size()==0;	}
	hash()	{ lsim.hash(); }
	string first()	{ return lsim.get(0); }
	string last()	{ return lsim.get( lsim.size()-1 ); }
	print()	{	lsim.print();	}
	string get(int i)	{ return lsim.get(i); }
	set(int pos, string sval)	{	lsim.set(pos,sval);	}
	add(string simg)	{	lsim.add(simg);	}
	additer(string s, int ifrom, int iile)	{
		while( iile>0 )	{
			.add(s+ifrom);
			ifrom++;
			iile--;
		}
	}
	buildarray(string styp, string sname, int ilosc)	{
		<gameapi.getgamename>.newarray(styp,sname,ilosc);
		.additer(sname,0,ilosc);
	}
	deleteall	{	for( int i=0; i<.size; i++)	delete <.get(i)>;	}
	deleteallgm	{
		@s = gameapi.getgamename;
		for( int i=0; i<.size; i++)	<s>.vardel(.get(i));
	}
	deleteallgmobj	{
		@s = gameapi.getgamename;
		for( int i=0; i<.size; i++)	<s>.deletegmobj(.get(i));
	}
	lockall	{	.eval("lock");	.print;	}
	unlockall	{	.eval("unlock");	}
	addbegin(string simg)	{	lsim.addbegin(simg);	}
	swap(int i, int j)	{	lsim.swap(i,j);	}
	addonce(string simg)	{	if( !lsim.contains(simg) )	lsim.add(simg);	}
	sepadd(string separator)	{
		string s = _;
		while( s!=separator )	{
			this.addbegin(s);
			s = _;
		}
	}
	addlist	{	.sepadd(A);	}
	removelist	{ .withlist("remove");	}
	insertat(string sob, int pos)	{
		@ile = .size;
		if( pos<=0 )	.addbegin(sob);
		else if (pos>=ile)	.add(sob);
		else {
			.add(null);
			for( @i=ile; i>pos; i--)	.set( i, .get(i-1) );
			.set(pos, sob );
		}
	}
	remove(string simg)	{	lsim.remove(simg);	}
	removeat(int pos)		{	lsim.removeat(pos);	}
	removefirst			{	lsim.removeat(0);	}
	removelast			{	lsim.removeat(.size-1);	}
	removealloccurs(string simg)	{	while(this.contains(simg))	this.remove(simg);	}
	removeif(string sfun)	{
		for( int i=0; i<.size; i++)
			if( <.get(i)>.<sfun>() )  .removeat(i);
	}
	int find(string simg)	{ return lsim.find(simg); }
	int contains(string simg)	{ return lsim.contains(simg); }
	addgroup(string sob, int ile)	{	this.addgroup2( sob, 0, ile-1 );	}
	addgroup2(string sob, int ifrom, int ito)	{
		while( ifrom <= ito )	{
			this.add( sob+ifrom );
			ifrom++;
		}
	}
	string rand()	{
		int ile = .size;
		ile>0 ? .get(ile.rand) : null;
	}
	string randdiff(string s)	{
		int ile = .size;
		if( ile>0 )	{
			int id = ile.rand;
			int i = id;
			while( .get(id)==s )	{
				id = (id+1)%ile;
				if( id==i )	return null;
			}
			return .get(id);
		}
		null;
	}
	buildfullvars	{	.each( func { (@id) .buildfullname; } );	}
	buildvars		{	.each( func { (@id) .addtogamevars(this); } );	}
	/******************* metody na obiektach grupy *****************************/
	movefrom(string simg, int x, int y)	{
		int i = this.find(simg);
		if( i>=0 )	{
			while( i<lsim.size() )	{
				<lsim.get(i)>.move(x,y);
				i++;
			}
		}
	}
	move(int x, int y)	{	this.eval2("move",x,y);	}
	setpos(int x, int y)	{	this.eval2("setpos",x,y);	}
	show()	{	this.eval("show");	}
	hide()	{	this.eval("hide");	}
	stop(int fin)	{	this.eval1("stop",fin);	}
	play()	{	this.eval("play");	}
	setdelay(int d)	{	this.eval1("setdelay",d);	}
	graddmethod(string sdest, string ssrc)	{	this.eval2("addmethod",sdest,ssrc);	}
	string getimg(int x, int y, int bignorehidden, int bignorealpha)	{
		for( int i=lsim.size()-1; i>=0; i--)	{
			if( <lsim.get(i)>.isin( x,y,bignorehidden,bignorealpha ) )	return lsim.get(i);
		}
		return null;
	}
	int isin(int x, int y, bool bignorehidden, bool bignorealpha)	{
		for( int i=lsim.size()-1; i>=0; i--)	{
			if( <lsim.get(i)>.isin( x,y,bignorehidden,bignorealpha ) )	return i+1;
		}
		return false;
	}
	setframe(def ac, int ifr)	{	this.eval2("setframe",ac,ifr);	}
	setz(int z)	{	this.eval1("setz",z);	}
	/**************/
	eval(string sfunc)	{
		for(int i=0; i<lsim.size(); i++)	{<lsim.get(i)>.<sfunc>();	}
	}
	eval1(string sfunc, def darg)	{
		for(int i=0; i<lsim.size(); i++)	{<lsim.get(i)>.<sfunc>(darg);}
	}
	eval2(string sfunc, def darg1, def darg2)	{
		for(int i=0; i<lsim.size(); i++)	{<lsim.get(i)>.<sfunc>(darg1, darg2);}
	}
	eval3(string sfunc, def darg1, def darg2, def darg3)	{
		for(int i=0; i<lsim.size(); i++)	{<lsim.get(i)>.<sfunc>(darg1, darg2, darg3);}
	}
	int _find(string sfun, def id)	{
		for( int i=0; i<this.size; i++) if ( <this.get(i)>.<sfun>()==id ) return i;
		-1;
	}
	int _find1(string sfun, @id)	{
		for( int i=0; i<.size; i++) if ( <this.get(i)>.<sfun>(id) ) return i;
		-1;
	}
	each(string sfun)	{	for( int i=0; i<.size; i++) <.get(i)>.<sfun>(i);	}
	each1(string sfun, @d1)	{	for( int i=0; i<.size; i++) <.get(i)>.<sfun>(i, d1);	}
	each2(string sfun, @d1, @d2)	{	for( int i=0; i<.size; i++) <.get(i)>.<sfun>(i, d1, d2);	}
	bool ineach(string sfun)	{
		for( int i=0; i<.size; i++) if( !<.get(i)>.<sfun>(i) )	return false;
		true;
	}
	int find_closest(string sob, string sfun)	{
		if( .empty ) return;
		int id = 0, real il;
		real ilen = <.get(0)>.<sfun>(sob);
		for( int i=1; i<.size; i++)	{
			il = <.get(i)>.<sfun>(sob);
			if( il < ilen )	{
				id = i;
				il = ilen;
			}
		}
		id;
	}
	/**************/
	sortimgsfun(string sfun)	{	lsim.vecsort(sfun);	}
	sortimgs()	{	// sortowanie od najmniejszych
		lsim.vecsort("_scmpimg1");
	}
	bool _scmpimg1(string s0, string s1)	{
		return ( <s0>.getz() < <s1>.getz() || ( <s0>.getz()==<s1>.getz() && <s0>.getidobj() < <s1>.getidobj() ) );
	}
}

class gmimgvec : gmobjvec	{
	init()	{
		gmobjvec::init();
		new int _ix = 0;
		new int _iy = 0;
		new int _iz = 0;
		new int _ifound = -1;
		new string sanload = null;
	}
	_setpos(int x, int y)	{	|_ix, _iy| = x,y;	}
	int lodx()	{0;}
	int lody()	{0;}
	int getposx()	{	return _ix;	}
	int getposy()	{	return _iy;	}
	int getpos()	{	return _ix, _iy;	}
	int getpx() {	return _ix;	}
	int getpy() {	return _iy;	}
	int getw()	{	return this.getex()-this.getpx();	}
	int geth()	{	return this.getey()-this.getpy();	}
	int getcx() {	return this.getpx()+this.getw()/2;	}
	int getcy() {	return this.getpy()+this.geth()/2;	}
	int getz()	{	return _iz;	}
	int getex()	{
		int ile = this.size();
		if( ile<=0 )	{	return _ix;	}
		int x = <this.get(0)>.getex();
		int x2;
		for( int i=1; i<ile; i++)	{
			x2 = <this.get(i)>.getex();
			if( x2>x )	{	x=x2;	}
		}
		return x;
	}
	int getey()	{
		int ile = this.size();
		if( ile<=0 )	{	return _iy;	}
		int y = <this.get(0)>.getey();
		int y2;
		for( int i=1; i<ile; i++)	{
			y2 = <this.get(i)>.getey();
			if( y2>y )	{	y=y2;	}
		}
		return y;
	}
	int _getpx()	{
		int ile = this.size();
		if( ile<=0 )	{	return _ix;	}
		int x = <this.get(0)>.getpx();
		int x2;
		for( int i=1; i<ile; i++)	{
			x2 = <this.get(i)>.getpx();
			if( x2<x )	{	x=x2;	}
		}
		return x;
	}
	int _getpy()	{
		int ile = this.size();
		if( ile<=0 )	{	return _iy;	}
		int y = <this.get(0)>.getpy();
		int y2;
		for( int i=1; i<ile; i++)	{
			y2 = <this.get(i)>.getpy();
			if( y2<y )	{	y=y2;	}
		}
		return y;
	}
	int _getw	{	.getex-._getpx;	}
	int _geth	{	.getey-._getpy;	}
	/*minx	{	.find_closest(null, func {(@s) .getpx; } );	}
	miny	{	.find_closest(null, func {(@s) .getpy; } );	}
	countborders	{
		_ix = .minx;
		_iy = .miny;
	}*/
	setz(int z)	{
		_iz = z;
		this.eval1("setz",z);
	}
	move(int x, int y)	{
		_ix +=x;
		_iy +=y;
		this.eval2("move",x,y);
	}
	setpos(int x, int y)	{
		_ix = x;
		_iy = y;
		this.eval2("setpos",x,y);
	}
	setpos2(int x, int y)	{
		_ix = x;
		_iy = y;
		if( !.empty )	{
			x -= <.get(0)>.getpx;
			y -= <.get(0)>.getpy;
			.move(-x,-y);
		}
	}
	changeframe(int ifr) {
		string s;
		for( int i=0; i<.size; i++)	{
			s = .get(i);
			<s>.setframe( <s>.actionnr(-1), ifr );
		}
	}
	nplay(int n)	{	.eval1("play",n);	}
	txtreset	{	for( int i=0; i<.size; i++) <.get(i)>.txtset("");	}
	anputgr()	{	this.eval("anputgr");	}
	anputy(int ypos)	{	this.eval1("anputy", ipos);	}
	int isin(int x, int y, bool bignorehidden, bool bignorealpha)	{
		for( int i=lsim.size()-1; i>=0; i--)	{
			if( <lsim.get(i)>.isin( x,y,bignorehidden,bignorealpha ) )	{
				_ifound=i;
				return i+1;
			}
		}
		_ifound = -1;
		return false;
	}
	int isinfunc(int x, int y, string sfunc)	{
		for( int i=lsim.size()-1; i>=0; i--)	{
			if( <lsim.get(i)>.<sfunc>( x,y ) )	{
				_ifound=i;
				return i+1;
			}
		}
		_ifound = -1;
		return false;
	}
	int isincut(int x, int y, bool bignorehidden, bool bignorealpha)	{
		for( int i=lsim.size()-1; i>=0; i--)	{
			if( <lsim.get(i)>.withincut(x,y) && <lsim.get(i)>.isin( x,y,bignorehidden,bignorealpha ) )	{
				_ifound=i;
				return i+1;
			}
		}
		_ifound = -1;
		return false;
	}
	int findif(string sfunc)	{	._find( sfunc,true);	}
	int getfound()	{	return _ifound;	}
	string getsfound()	{	return this.get(_ifound);	}
	int findfr(int id)	{	._find("framenr", id);	}
	int findsfr(string s)	{	._find("framename", s);	}
	int findac(int id)	{	._find("actionnr", id);	}
	int findsac(string sac)	{	._find("actionname", sac);	}
	int nearest_to(string sob)	{
		//.find_closest(sob, func {(string s) 0->length( .getpx-<s>.getpx, .getpy-<s>.getpy ); } );
		.find_closest(sob, func {(string s) cllen.ilen5(this,s); } );
	}
	string getsac(string sac)	{	.get( .findsac(sac) );	}
	string getsacfr(string sac, int fr)	{	for(int i=0; i<.size; i++) if( <.get(i)>.actionname==sac && <.get(i)>.framenr==fr ) return .get(i); null; }
	/*def find_min(string s)	{
		if( .empty ) return;
		int x = <s>.getpx;
		int y = <s>.getpy;
		int id = 0, int il;
		int ilen = id.length( <.get(0)>.getpx-x, <.get(0)>.getpy-y );
		for( int i=1; i<.size; i++)	{
			il = id.length( <.get(i)>.getpx-x, <.get(i)>.getpy-y );
			if( il < ilen )	{
				id = i;
				il = ilen;
			}
		}
	}*/
	blitto(string simg)	{	for( int i=0; i<.size; i++)	<simg>.blit(.get(i));	}
	sortz(int z)	{	for( int i=0; i<.size; i++) <.get(i)>.setz(z+i);	}
	/****************************/
	loadallan(string sname, string sfile, int z)	{
		string s = gameapi.getgamename();
		<s>.newanima(sname,sfile,z);
		_ = <s>.newanfrbyactgr(sname, sname, this);
		<sname>.hide();
	}
	operator*(string s)	{
		string sg = gameapi.getgamename;
		string san;
		if ( s.contains(".pyz") ) {
			san = "an" + s.strsubes(".pyz");
			<sg>.newanima(san,s,0);
		} else san = s;
		sanload = san;
		_ = <sg>.newanactionsgr(san, san, this);
		<san>.hide();
	}
	operator<(string s)	{
		string sg = gameapi.getgamename;
		string san;
		if ( s.contains(".pyz") ) {
			san = "an" + s.strsubes(".pyz");
			<sg>.newanima(san,s,0);
		} else san = s;
		sanload = san;
		_ = <sg>.newanfrbyactgr(san, san, this);
		<san>.hide();
	}
	deleteloaded	{
		.deleteallgm;
		if( sanload!=null ) <gameapi.getgamename>.vardel(sanload);
	}
}

class gmadvvec : gmimgvec	{
	init	{	gmimgvec::init;	}
	int butisin(int x, int y, bool bignorehidden, bool bignorealpha)	{
		for( int i=lsim.size()-1; i>=0; i--)	{
			if( <lsim.get(i)>.butisin( x,y,bignorehidden,bignorealpha ) )	{
				_ifound=i;
				return i+1;
			}
		}
		_ifound = -1;
		return false;
	}
}

class gmmaskvec : gmadvvec	{
	init()	{	gmadvvec::init;	}
	int butisin(int x, int y, bool bigvis, bool bigalpha)	{	gmimgvec::butisin(x,y,false,bigalpha);	}
}




new int igmsubtitle = 0;
class Subtitle	{
	init(string sdbfile, string spath, string sfont, int ifont, int borx, int bory)	{
		real rwidth = 0.5;
		int col[3];	// kolor fonta
		col0 = 255;
		col1 = 255;
		col2 = 255;
	
		new int iborx = borx;
		new int ibory = bory;
		
		new font fnt;
		fnt.load(sfont, ifont);
		new int ifontsize = ifont;
		
		new db dbl;
		dbl.load("lang/"+sdbfile);
		string s;
		string s2;
		new vector v1;	v1.type("string");
		int cols = (iResX-2*borx)/(rwidth*ifont+1);
		int k, int j;
		int linie = 0;
		for( int i=0; i<dbl.getrowsno; i++)	{
			dbl.set( i, 0, spath + dbl.get(i,0)+".wav" );
			s = dbl.get(i,1);
			v1.vecbuildfromstring(s, " ");
			s2 = "";
			k = 1;
			for( j=0; j<v1.size; j++)	{
				if( s2.length + v1.get(j)->length + 1 <= cols )	s2 += " " + v1.get(j);
				else {
					if( k==1 )	dbl.set(i, k, s2);
					else dbl.add(i, s2);
					s2 = v1.get(j);
					k++;
				}
			}
			if( k==1 )	dbl.set(i, k, s2);
			else dbl.add(i, s2);
			if( k>linie ) linie = k;
		}
		
		new gmimgvec grtxt;
		for( int i=0; i<linie; i++)	{
			s = "txt"+i;
			s2 = "txts"+i;
			classgame::newtext(s2,"","fnt",.black);
			classgame::newtext(s,"","fnt",col0, col1, col2);
			grtxt.add(s);
			grtxt.add(s2);
		}
		
		new db dbsnd;
		new timer timtxt;
		timtxt.settick(1);
		timtxt.setcycle(1);
		timtxt.addmethod("onfinish", func {
			if( !.cisplaying )	.hidesubs;
			else .play;
			} );
		.setz(12000);
	}
	reset	{
		.stop;
		dbsnd.free;
	}
	hidesubs	{
		grtxt.hide;
	}
	setz(int z)	{
		grtxt.setz(z);
	}
	stop	{
		.hidesubs;
		timtxt.stop(false);
	}
	register(string ssnd, string sfile)	{
		@id = dbl.findbyrow(sfile);
		if( id>=0 )	{
			@r = dbsnd.findbyrow(ssnd);
			if( r>=0 )	dbsnd.set(r, 1, id);
			else {
				@r = dbsnd.addrow-1;
				dbsnd.add(r, ssnd);
				dbsnd.add(r, id);
			}
		}
		//("register "+ssnd+" "+sfile+" "+id)->print;
	}
	play(string s)	{
		.stop;
		@id = dbsnd.findbyrow(s);
		if( id>=0 )	{
			id = dbsnd.get(id, 1);
			@ile = dbl.getcolsno(id)-1;
			string s[2], int i2;
			grtxt.setpos(0,0);
			int dy = 2;
			for( int i=0; i<ile; i++)	{
				i2 = 2*i;
				s0 = grtxt.get(i2);
				<s0>.txtset(dbl.get(id, i+1));
				s1 = grtxt.get(i2+1);
				<s1>.txtset(<s0>.get);
				<s0>.setpos( (iResX-<s0>.getw)/2, i*ifontsize + dy );
				<s0>.show;
				<s1>.setpos(<s0>.getpx+1, <s0>.getpy+1);
				<s1>.show;
			}
			grtxt.move( 0, iResY - ile*(ifontsize+dy)-ibory );
			timtxt.play;
		}
	}
}

if( igmsubtitle )	{
	new Subtitle subtitle("eng_egipt.db", "sounds/", sgmfontbold, 24, 50, 15);
}

class classsound {
	init()	{
		new string _csplay = null;
		if( igmsubtitle )	{
			subtitle.reset;
		}
	}
	creset()	{ _csplay = null; }
	string cgetactsnd()	{ return _csplay; }
	crselfplay(string ssnd)	{
		if( !this.cisplaying() )	this.cbplay(ssnd);
		else if ( this.cgetactsnd()!=ssnd )	this.cbplay(ssnd);
	}
	cbselfplay(string ssnd)	{
		if( !.cisplaying || .cgetactsnd!=ssnd )	.cbplay(ssnd);
	}
	cbplay(string ssnd)	{
		if(this.cisplaying())	<_csplay>.stop(true);
		_csplay = ssnd;
		if( ssnd!=null )
			.csubplay(ssnd);
		//	<ssnd>.play();
	}
	cbsplay(string ssnd)	{
		_csplay = ssnd;
		if( ssnd!=null)	.csubplay(ssnd);
	}
	cbplayfin(string ssnd, string sfun)	{
		<ssnd>.addmethod("onfinish", sfun);
		.cbplay(ssnd);
	}
	cbplay2(string ssnd)	{
		if(this.cisplaying())	<_csplay>.stop(false);
		_csplay = ssnd;
		if( ssnd!=null )
			.csubplay(ssnd);
		//	<ssnd>.play();
	}
	crplay(string ssnd)	{
		if(_csplay!=null && <_csplay>.isplaying() )	return;
		_csplay = ssnd;
		if( ssnd!=null )
			.csubplay(ssnd);
		//	<ssnd>.play();
	}
	crbgplay(string ssnd)	{
		if( ssnd != null && !<ssnd>.isplaying() )
			.csubplay(ssnd);
			//<ssnd>.play();
	}
	crandplay(string ssnd, int irand, string styp)	{
		if( irand.rand()==0 )	this.<"c"+styp+"play">( ssnd );
	}
	cplayf(string styp, string ssnd, string sfun)	{
		this.<"c"+styp+"play">(ssnd);
		if( <ssnd>.isplaying() && sfun!=null)	<ssnd>.addmethod("onfinish",sfun);
	}
	//cactsndstop(bool bfin)	{	if(_csplay!=null)	<_csplay>.stop(bfin);	}
	cactsndstop(bool bfin)	{
		if(.cisplaying)	<_csplay>.stop(bfin);
	}
	cstopsnds(bool b)	{
		if( _csplay.in && .cisplaying )
			.cactsndstop(b);
	}
	bool cisplaying()	{	_csplay!=null ? <_csplay>.isplaying() : false;	}
	csubplay(string s)	{
		if( igmsubtitle )	{
			subtitle.play(s);
		}
		<s>.play;
	}
}

/***************************************************************************/
class classsndbank	{
	init()	{
		new int itype;
		new int ilicz = 0;
		new int iile;
		new string splay=null;
		new string ssnd = "snd";
	}
	/********************************/
	loadsingle(string sfile, int ile)	{
		if( ile<=0)	{	iile=0;	return;	}
		iile=ile;
		itype=0;
		for( int i=0; i<ile; i++)	newvars::newsnd( ssnd+i, sfile );
	}
	/********************************/
	load(string sfilebase, int ifilefrom, int ifileto, int ityp, int itypstart)	{
		iile = ifileto-ifilefrom+1;
		if(iile<=0)	{
			iile = 0;
			return;
		}
		newvars::newsnds( ssnd, 0, sfilebase, ifilefrom, ifileto);
		itype = ityp;			// 0 - po kolei, 1 - random
		if(itypstart==1)	{	// 0 - od pierwszego, 1 - randomowy
			ilicz = iile.rand( );
		}
	}
	addmethod(string ssig, string sfunc)	{
		for( int i=0; i<iile; i++)	<ssnd+i>.addmethod( ssig, sfunc );
	}
	stop(int ifin)	{	if(splay!=null)	<splay>.stop(ifin);	}
	int isplaying()	{	splay!=null ? <splay>.isplaying() : false;	}
	randplay( int irand )	{	if( irand.rand()==0 )	this.play();	}
	playid(int id)	{
		ilicz=id%iile;
		this.play();
	}
	play()	{
		this.stop(false);
		this.bgplay();
	}
	reset()	{	ilicz=0;	}
	/************************************************/
	rbgplay()	{	if( !this.isplaying() )	this.bgplay();	}
	rplay()	{	if( !this.isplaying() )	this.play();	}
	bgplay()	{
		splay = ssnd + ilicz;
		<splay>.play();
		if( itype==0)	ilicz = (ilicz+1)%iile;
		else if (itype==1)	ilicz = iile.rand();
	}
	setvol(int vol)	{	for( int i=0; i<iile; i++)	<ssnd+i>.setvol( vol );	}
}

class SoundSource	{
	init	{	}
	setvol(string ssnd, int srcvol, int outvol, real rad, real length)	{
		if( length.abs>=rad ) <ssnd>.setvol(outvol);
		else <ssnd>.setvol((1.0-length.abs/rad)*srcvol + outvol);
	}
}

/**************************************************************/
	// standardowe czynnosci przy grach, popakowane w metody
class classgame : newvars , classsound {
	init()	{
		newvars::init();
		classsound::init();
		new int _iconstid;
	}
	/**************************************************************/
	bkg=(@sfile)	{
		if( sfile.contains(".pyz") ) .newanima("anbkg", sfile, 0);
		else .newimg("imgbkg",sfile,0);
	}
	bgr=(@sfile)	{
		//this.csndplayloop("sndbgr",sfile);
		.csndbgr(sfile);
	}
	path=(@s)	{	.setgraphpath("scripts/"+s+"/");	}
	cycle=(@stimer, @sfun)	{	.cnewtimercyclefin(stimer,1,1,sfun);	}
	timer=(@stimer, @itime, @sfun) { .cnewtimerfin(stimer,itime,1,sfun);	}
	def _getflags(string s)	{
		@bloop = false;
		if( s.contains("L") )	{
			s.strremove("L");
			bloop=true;
		}
		@bplay = false;
		if( s.contains("P") )	{
			s.strremove("P");
			bplay=true;
		}
		@bhide = false;
		if( s.contains("H") )	{
			s.strremove("H");
			bhide=true;
		}
		return s,bloop,bplay,bhide;
	}
	img=(@sfile)	{
		|sfile,@bloop,@bplay,@bhide| = ._getflags(sfile);
		@iz = 0;
		if( sfile.contains(" ") )	{
			iz = sfile.strgetfrom(" ");
			sfile = sfile.strgetto(" ");
		}
		string sname;
		if( sfile.contains("/") ) {
			new vector _v_sfile;
			_v_sfile.type("string");
			_v_sfile.vecbuildfromstring(sfile,"/");
			sname = _v_sfile.last->strsube(4);
			delete _v_sfile;
		} else sname = sfile.strsube(4);
		string s;
		if( sfile.contains(".pyz") ) {
			s = "an" + sname;
			.newanima(s, sfile, iz);
		} else {
			s = "img" + sname;
			.newimg(s, sfile, iz);
		}
		if( bloop ) <s>.anloopfin;
		if( bplay ) <s>.play(-1);
		if( bhide ) <s>.hide;
	}
	imgs=	{	.withlist("img=");	}
	clone(string sob)	{
		<gameapi.getgamename> (this, .gettype, sob) { (@sthis, @styp, @sob)
			new <styp> <sob>;
			<sob>.copy(sthis);
		};
	}
	clones=	{	.withlist("clone");	}
	list=(@sname)	{
		@s=_;
		new gmobjvec <sname>;
		while(A!=s)	{
			<sname>.addbegin(s);
			s = _;
		}
	}
	list2={
		@s = .newconst("gmobjvec");
		.list=(s);
		s;
	}
	debug=(@b)	{	engine.setdebugstate(b);	}
	sfx=(string s)	{
		bool bloop2 = s.contains("N");
		if( bloop2 )	{
			s.strremove("N");
		}
		|s,@bloop,@bplay,_| = ._getflags(s);
		@ivol = 100;
		if( s.contains(" ") )	{
			ivol = s.strgetfrom(" ");
			s = s.strgetto(" ");
		}
		string sf = "fx"+s;
		//.newsnd(sf, "sfx/"+s+".wav");
		.newsfx( sf, s+".wav");
		<sf>.setvol( ivol );
		if( bloop ) <sf>.addmethod("onfinish","_stdsndloop");
		if( bplay ) <sf>.play;
		else if( bloop2 ) <sf>.playloop;
	}
	sfxs=	{	.withlist("sfx=");	}
	tickstart	{
		if( !.hasvar("__timspeed") )	new TicksCounter __timspeed;
		__timspeed.start;
	}
	tickstop	{	__timspeed.print("ticker: ");	}
	/**************************************************************/
	csndplayloop(string ssnd, string sfile)	{
		this.newsndloop(ssnd,sfile);
		<ssnd>.play();
	}
	csndbgr(string sfile)	{
		//this.csndplayloop("sndbgr",sfile);
		.newbgr("sndbgr", sfile );
		.sndplayloop("sndbgr");
	}
	cloadcursor(string sfile)	{
		if( sfile.contains(".") )	{
			.newimg("imgkursor", sfile,0);
			sfile = "imgkursor";
		}
		<sfile>.hide();
		mouse.setcursor(sfile);
		engine.stdbutcursor(sfile);
		bsms.setown();
	}
	/****************************************************************/
	newimgarray(string sname, string styp, string sn, int ile)	{
		new gmimgvec <sname>;
		<sname>.buildarray(styp,sn,ile);
	}
	newfont(string sfnt, string sfile, int isize)	{
		new font <sfnt>;
		<sfnt>.load( sfile, isize );
	}
	monofont(string sfnt, int isize)	{	.newfont(sfnt, sgmfontmono, isize);	}
	newfontbold(string sfnt, int isize)	{	.newfont(sfnt, sgmfontbold, isize);	}
	string snewfont(string sfontfile, int isize)	{
		string s = .newconst("font");
		<s>.load( sfontfile, isize );
		return s;
	}
	string stdfont(int isize)	{	.snewfont( sgmfontfile, isize	);	}
	string stdmono(int isize)	{	.snewfont( sgmfontmono, isize);	}
	string stdbold(int isize)	{	.snewfont( sgmfontbold, isize);	}
	int getconstid	{	_iconstid++;	_iconstid-1;	}
	string newconst(string styp)	{
		string s = "const"+styp+.getconstid;
		new <styp> <s>;
		return s;
	}
	string consttext(string stext, int x, int y, int isize, int r, int g, int b)	{
		string s = this.newconst("text");
		string sf = .stdfont(isize);
		<s>.setfont(sf);
		<s>.set(stext);
		<s>.createtxt(r,g,b);
		<s>.setpos(x,y);
		return s;
	}
	newtext(string stxt, string stext, string sfont, int r, int g, int b)	{
		new text <stxt>;
		<stxt>.set(stext);
		<stxt>.setfont(sfont);
		<stxt>.createtxt(r,g,b);
	}
	newtextposz(string stxt, string stext, string sfont, int r, int g, int b, int x, int y, int z)	{
		.newtext(stxt,stext,sfont,r,g,b);
		<stxt>.anposz(x,y,z);
	}
	/****************************************************************/
	cfinmethod(string sobj, string sfuncfin)	{	<sobj>.addmethod("onfinish", sfuncfin);	}
	cnewsndfin(string sname, string sfile, string sfunc)	{
		this.newsnd(sname,sfile);
		this.cfinmethod(sname,sfunc);
	}
	cnewsndsfin(string sbase, int inamestart, string sfilebase, int ifilefrom, int ifileto, string sfunc)	{
		this.newsnds(sbase, inamestart, sfilebase, ifilefrom, ifileto);
		this.caddobjsfunfin(sbase, inamestart, inamestart+( ifileto-ifilefrom), sfunc);
	}
	cnewsndfinbplay(string sname, string sfile, string sfunc)	{
		this.cnewsndfin(sname,sfile,sfunc);
		this.cbplay(sname);
	}
	cnewtimerfin(string sname, int idelay, int iticks, string sfunc)	{
		this.newtimer(sname,idelay,iticks);
		this.cfinmethod(sname,sfunc);
	}
	cnewtimercyclefin(string sname, int icycle, int iticks, string sfunc)	{
		this.newtimercycle(sname,icycle,iticks);
		this.cfinmethod(sname,sfunc);
	}
	/****************************************************************/
	caddobjsfun(string ssnd, int ifrom, int ito, string ssig, string sfunc)	{
		while( ifrom <= ito )	{
			<ssnd+ifrom>.addmethod( ssig, sfunc+ifrom );
			ifrom++;
		}
	}
	caddobjsfunfin(string ssnd, int ifrom, int ito, string sfunc)	{
		this.caddobjsfun( ssnd, ifrom, ito, "onfinish", sfunc );
	}
	/****************************************************************/
	newancounter(string scounter, string sname, string sfile, int z, int ile)	{
		this.newanimas( sname, sfile, z, ile);
		new classancounter <scounter>;
		<scounter>.set( sname, ile );
	}
	newancounterh(string scounter, string sname, string sfile, int z, int ile)	{
		this.newancounter( scounter, sname, sfile, z , ile );
		for( int i=0; i<ile; i++)	<sname+i>.hide();
	}
	newancounterf(string scounter, string sname, string sfile, int z, int ile, string sfun)	{
		this.newancounter( scounter, sname, sfile, z , ile );
		for( int i=0; i<ile; i++)	<sname+i>.addmethod("onfinish", sfun);
	}
	newancounterhf(string scounter, string sname, string sfile, int z, int ile, string sfun)	{
		this.newancounter( scounter, sname, sfile, z , ile );
		for( int i=0; i<ile; i++)	{
			<sname+i>.addmethod("onfinish", sfun);
			<sname+i>.hide();
		}
	}
	cnewanimafin(string sname, string sfile, int z, string sfunc)	{
		this.newanima(sname, sfile, z);
		<sname>.addmethod("onfinish", sfunc );
	}
	ccopyanimafin(string sname, string snew, string sfunc)	{
		this.copyanima(sname, snew);
		<snew>.addmethod("onfinish", sfunc );
	}
	/****************************************************************/
	cloadwavs(string sdb, string sfile)	{
		this.newdb( sdb, sfile );
		int id = 0;
		int ile = <sdb>.getrowsno();
		int i[6], string s[5];
		while( id < ile )	{
			i1 = <sdb>.getcolsno(id);
			i2 = 0;
			s1 = <sdb>.get( id, i2 );	i2++;
			if( s1.getb(0,1)!="#" )	{
				s3 = <sdb>.get( id, i2 );	i2++;
				if( s1=="wav" || s1=="sfx" )	{
					s2 = <sdb>.get( id, i2 );	i2++;
					if( s1=="sfx")	{
						this.newsfx( s3, s2 );
					} else { this.newsnd( s3, s2 ); }
					if( i2 < i1 )	{
						s1 = <sdb>.get( id, i2 );	i2++;
						s2 = <sdb>.get( id, i2 );	i2++;
						if( s1=="method" )	{
							<s3>.addmethod("onfinish", s2 );
						} else if (s1.gete(0,4)=="play")	{
							this.<"c"+s1.gete(4,10)+"playonfin">(s3, s2);
						} else if ( s1=="vol" )	{
							<s3>.setvol( s2 );
						}
					}
				} else if (s1=="group")	{
					s2 = <sdb>.get( id, i2 );	i2++;
					i3 = <sdb>.get( id, i2 );	i2++;
					i4 = <sdb>.get( id, i2 );	i2++;
					if( i2 < i1 )	{		// jest method
						s1 = <sdb>.get( id, i2 );	i2++;
						if( s1=="method" )	{
							s4 = <sdb>.get( id, i2 );	i2++;
							this.cnewsndsfin( s3, i3, s2, i3, i4, s4 );
						}
					} else {
						this.newsnds( s3, i3, s2, i3, i4 );
					}
				} else if (s1=="bank")	{
					s2 = <sdb>.get( id, i2 );	i2++;
					i0 = <sdb>.get( id, i2 );	i2++;
					i3 = <sdb>.get( id, i2 );	i2++;
					i4 = <sdb>.get( id, i2 );	i2++;
					i5 = <sdb>.get( id, i2 );	i2++;
					new classsndbank <s3>;
					<s3>.load( s2, i0, i3, i4, i5);
					if( i2<i1)	{
						s1 = <sdb>.get( id, i2 );	i2++;
						if( s1=="method")	{
							s4 = <sdb>.get( id, i2 );	i2++;
							<s3>.addmethod( "onfinish", s4 );
						} else if (s1=="vol")	{
							<s3>.setvol( <sdb>.get( id, i2 ) );
						}
					}
				} else if ( s1=="method" )	{
					s2 = <sdb>.get( id, i2 );	i2++;
					i3 = <sdb>.get( id, i2 );	i2++;
					i4 = <sdb>.get( id, i2 );	i2++;
					while( i3<=i4)	{
						<s2+i3>.addmethod("onfinish", s3);
						i3++;
					}
				} else if ( s1=="singlebank")	{
					s2 = <sdb>.get( id, i2 );	i2++;
					i3 = <sdb>.get( id, i2 );	i2++;
					new classsndbank <s3>;
					<s3>.loadsingle( s2, i3 );
				} else if ( s1=="bgr" )	{
					this.csndbgr( s3 );
					if( i2 < i1 )	{
						if( <sdb>.get( id, i2 )=="vol" )	{
							i2++;
							sndbgr.setvol( <sdb>.get( id, i2 ) );
							i2++;
						}
					}
				} else if ( s1=="music" )	{
					this.playmusic( s3 );
					if( i2 < i1 )	{
						if( <sdb>.get( id, i2 )=="vol" )	{
							i2++;
							sndbgr.setvol( <sdb>.get( id, i2 ) );
							i2++;
						}
					}
				}
			}
			id++;
		}
	}
	/****************************************************************/
	crestart()	{	gameapi.play( gameapi.getgamename() );	}
}


/***************************************************************************/

class clfindfunc	{
	init()	{}
	int _stdfindfunc(string sobj, int ifirst, int ilast, string sname, string sfunc)	{	
		while(ifirst<=ilast)	{
			if( <sobj + ifirst>.<sfunc>() ==sname )	return ifirst;
			ifirst++;
		}
		-1;
	}
	int _stdfindfunc2(string sobj, int iile, string sname, string sfunc)	{	
		._stdfindfunc(sobj, 0, iile-1, sname, sfunc);
	}
	/****************************************************************/
	cfindandeval2(string sobj, int iile, string sname, string sfunc, string seval)	{	
		.cfindandeval(sobj, 0, iile-1, sname, sfunc, seval);
	}
	cfindandeval(string sobj, int ifirst, int ilast, string sname, string sfunc, string seval)	{	
		int pos = ._stdfindfunc(sobj, ifirst, ilast, sname, sfunc);
		if(pos>=0)	<sobj+pos>.<seval>();
	}
}



/*****************************************************************/
class classbutton 	{
	init()	{
		new string san = "anbut";
		new string sbut = "but";
		new int iilebut = 0;
		new string sfxmon = null;
	}
	_cbuildbutname(string sname)	{	new string _sbutname=sname; }
	string cgetbutname()	{ return _sbutname; }
	build(string sfile, int z, string smouse)	{this.build2(sfile,z,smouse,null);	}
	build2(string sfile, int z, string smouse, string sgrp)	{	// wczytuje animacje i buduje z niej przyciski
		string smain = "_" + san;
		new anima <smain>;
		<smain>.load( sfile );
		<smain>.setz(z);
		int ile = <smain>.nofactions();
		int j;	int k;
		int iliczans = 0;
		string sn1, string sn2, string sn3;
		string spom;
		for(int i=0; i<ile; i++)	{
			sn1 = null;	sn2 = null;	sn3 = null;
			j = <smain>.nofframes(i);
			for(k=1; k<=j; k++)	{
				spom = san + iliczans;
				if(k==1)	{	sn1=spom; } 
				else if (k==2)	{ sn2 = spom; }
				else if (k==3)	{ sn3 = spom; }
				newvars::copyanima( smain, spom );
				<spom>.setframe( i, k-1 );
				iliczans++;
			}
			if( sgrp!=null && <sgrp>.contains( <smain>.nameofaction(i)) ) {
				<sn1>.setz(z-1);
			} else this.addbut(sn1, sn2, sn3, smouse);
		}
		<smain>.hide();
	}
	/***************************** \/ \/ \/ \/ \/ wewnetrzne \/ \/ \/ \/ \/ *************************************************/
	_buildfuncclick( string sname )	{	new string _sfunclick = sname; }
	_stdbutclick()	{	this.<_sfunclick>( this.getbutname() );		}
	_buildfuncrel( string sname )	{	new string _sfuncrel = sname; }
	_stdbutrel()	{	this.<_sfuncrel>( this.getbutname() );	}
	_buildfuncmovon( string sname )	{	new string _sfunmovon = sname; }
	_stdbutmovon()	{
		if( sfxmon!=null )	<sfxmon>.play();
		this.<_sfunmovon>( this.getbutname() );
	}
	_buildfuncmovoff( string sname )	{	new string _sfunmovoff = sname; }
	_stdbutmovoff()	{	this.<_sfunmovoff>( this.getbutname() );	}
	butsigfun(string sb, string sfunc, string ssig, string sfun1, string sfun2)	{
		if( sfunc==null )	return;
		<sb>.addmethod(sfun1, sfun1);
		<sb>.<sfun1>( sfunc );
		<sb>.addmethod(ssig, sfun2);
	}
	sigfunc(string sfunc, string ssig, string sfun1, string sfun2)	{
		for(int i=0; i<iilebut; i++)	this.butsigfun(sbut + i, sfunc, ssig, sfun1, sfun2);
	}
	print()	{for(int i=0; i<iilebut; i++)	engine.print( <sbut+i>.getbutname() );}
	setrect()	{
		string s;
		for( int i=0; i<iilebut; i++)	{
			s = <sbut+i>.getimg;
			<sbut+i>.setrect( <s>.getpx, <s>.getpy, <s>.getex, <s>.getey );
		}
	}
	setflags(bool bvis, bool balph)	{	for(int i=0; i<iilebut; i++)	<sbut+i>.setflags(bvis,balph);	}
	/***************************** /\ /\ /\ /\ /\ wewnetrzne /\ /\ /\ /\ /\ ************************************************/
	sfxonmovon(string ssnd)	{	sfxmon=ssnd;	}
	clickfunc(string sfunc)	{this.sigfunc(sfunc,"onclick", "_buildfuncclick", "_stdbutclick");	}
	relfunc(string sfunc)	{this.sigfunc(sfunc,"onrel", "_buildfuncrel", "_stdbutrel");	}
	movonfunc(string sfunc)	{this.sigfunc(sfunc,"onmoveon", "_buildfuncmovon", "_stdbutmovon");	}
	movofffunc( string sfunc)	{this.sigfunc( sfunc,"onmoveoff", "_buildfuncmovoff", "_stdbutmovoff");}
	/*****************************************************************/
	int ilebuts()	{	return iilebut;	}
	/*****************************************************************/
	int ifind(string sname)	{return clfindfunc::_stdfindfunc2(sbut, iilebut, sname, "getbutname");	}
	string sfind(string sname)	{
		int pos = clfindfunc::_stdfindfunc2(sbut, iilebut, sname, "getbutname");
		return pos>=0 ? sbut+pos : null;
	}
	/*****************************************************************/
	_cbutfun(string sname, string sfunc)	{
		clfindfunc::cfindandeval2(sbut, this.ilebuts(), sname, "getbutname", sfunc );
	}
	_callbutfunc(string sfunc)	{	for(int i=0; i<iilebut; i++)	<sbut+i>.<sfunc>();	}
	_cibutfunc(string sfunc, int ile)	{
		if( ile > iilebut )	ile = iilebut;
		for(int i=0; i<ile; i++)	<sbut+i>.<sfunc>();
	}
	ienable( int ile )	{	this._cibutfunc("enable", ile);	}
	benableall()	{	this.resumeall();	this.enableall();	}
	pauseall()	{	this._callbutfunc("pause");	}
	resumeall()	{	this._callbutfunc("resume");	}
	enableall()	{	this._callbutfunc("enable");	}
	disableall()	{	this._callbutfunc("disable");	}
	disabled	{	<sbut+0>.disabled;	}
	
	benable(string sname)	{	this.resume(sname);	this.enable(sname);	}
	disable(string sname)	{	this._cbutfun( sname, "disable");	}
	enable(string sname)	{	this._cbutfun( sname, "enable");	}
	pause(string sname)	{	this._cbutfun( sname, "pause");	}
	resume(string sname)	{	this._cbutfun( sname, "resume");	}
	
	resetall()	{	for(int i=0; i<iilebut; i++)	<sbut+i>.setcursorpos(0, 0);	}
	setcursorpos(int x, int y)	{	for(int i=0; i<iilebut; i++)	<sbut+i>.setcursorpos(x, y);	}
	/*****************************************************************/
	string getimg(string sname)	{
		string s= this.sfind(sname);
		return s!=null ? <s>.getimg() : null;	
	}
	callimgfun(string sname, string sfun)	{	<.getimg(sname)>.<sfun>;	}
	/*****************************************************************/
	newmouse(string sname, string snewmouse)	{
		string s = this.sfind(sname);
		if(s!=null)	<s>.setmouse( snewmouse );
	}
	addbut(string san1, string san2, string san3, string smouse)	{
		string spom = sbut + iilebut;
		newvars::newbutan( spom, san1, san2, san3, smouse);
		<spom>.addmethod("getbutname","cgetbutname");
		<spom>._cbuildbutname( <san1>.actionname() );	// nazwa buttonu to nazwa akcji
		iilebut++;
	}
	/*****************************************************************/
	_addfunc(string s, string sfclick, string sfrel, string sfmvon, string sfmvoff)	{
		if( s== null)	return;
		this.butsigfun( s, sfclick, "onclick", "_buildfuncclick", "_stdbutclick");
		this.butsigfun( s, sfrel, "onrel", "_buildfuncrel", "_stdbutrel");
		this.butsigfun( s, sfmvon, "onmoveon", "_buildfuncmovon", "_stdbutmovon");
		this.butsigfun( s, sfmvoff, "onmoveoff", "_buildfuncmovoff", "_stdbutmovoff");
	}
	addfuncto(string sname, string sfclick, string sfrel, string sfmvon, string sfmvoff)	{
		this._addfunc( this.sfind(sname), sfclick, sfrel, sfmvon, sfmvoff);
	}
	addfunctolast(string sfclick, string sfrel, string sfmvon, string sfmvoff)	{
		this._addfunc( sbut + (iilebut-1) , sfclick, sfrel, sfmvon, sfmvoff);
	}
	/*****************************************************************/
	_transmet(string sob, string sfunc, string smet, string s)	{
		new string <"_sob" + s> = sob;
		new string <"_sf" + s> = sfunc;
		this.<smet>( "_trf"+s );
	}
	transclickfunc(string sob, string sfunc)	{this._transmet( sob, sfunc, "clickfunc", "cl" );	}
	transrelfunc(string sob, string sfunc)	{this._transmet( sob, sfunc, "relfunc", "rl" );	}
	transmovonfunc(string sob, string sfunc){this._transmet( sob, sfunc, "movonfunc", "mn" );	}
	transmovofffunc(string sob, string sfunc){this._transmet( sob, sfunc, "movofffunc", "mf" );	}
	_trfcl(string s)	{	<_sobcl>.<_sfcl>(s);		}
	_trfrl(string s)	{	<_sobrl>.<_sfrl>(s);		}
	_trfmn(string s)	{
		if( sfxmon!=null )	<sfxmon>.play();
		<_sobmn>.<_sfmn>(s);
	}
	_trfmf(string s)	{	<_sobmf>.<_sfmf>(s);		}
}

class classsimplebutton {
	init()	{
		new string simgob=null;
		new gmimgvec grbut;
	}
	public stdbuild(string sfile, string smouse, int z)	{this.build(this.getgraphpath()+sfile, smouse, 0, 0, z, 0);	}
	public getimgfunc(string sfunc)	{	simgob==null ? 0 : <simgob>.<sfunc>();	}
	public setbutpos(int x, int y)	{	grbut.setpos(x,y);	}
	public build(string sfile, string smouse, int x, int y, int z, int iact)	{
		new button but1;
		but1 (this.getname()) {(string s) new string sbut = s; };
		but1.addmethod("onclick", func { this.<sbut+"_CLICK">(); });
		but1.addmethod("onrel", func { this.<sbut+"_REL">(); } );
		but1.addmethod("onmoveon", func { this.<sbut+"_MOVEON">(); });
		but1.addmethod("onmoveoff", func { this.<sbut+"_MOVEOFF">(); });
		
		if( sfile.contains(".pyz") )	{
			new anima anbut0;
			anbut0.load( sfile );
			anbut0.setpos(x,y);
			anbut0.setz(z);
			anbut0.setframe(iact,0);
			simgob="anbut0";
			grbut.add(simgob);
			string s0="anbut0";
			string s1=null;
			string s2=null;
			int ile = anbut0.nofframes(iact);
			if( ile>1 )	{
				new anima anbut1;
				anbut1.copy("anbut0");
				anbut1.setframe(iact,1);
				s1 = "anbut1";
				grbut.add(s1);
			}
			if (ile>2)	{
				new anima anbut2;
				anbut2.copy("anbut0");
				anbut2.setframe(iact,2);
				s1 = "anbut2";
				grbut.add(s1);
			}
			but1.setan(s0,s1,s2);
		} else {
			new img imgbut;
			simgob="imgbut";
			grbut.add(simgob);
			imgbut.load(sfile);
			imgbut.setpos(x,y);
			imgbut.setz(z);
			but1.set("imgbut",null,null);
		}
		but1.setmouse(smouse);
	}
}

/*****************************************************************/

class classmask : classbutton	{
	init()	{
		classbutton::init();
	}
	buildmask(string sfile, string smouse)	{
		this.build(sfile, 0, smouse);
		int ile = this.ilebuts();
		for(int i=0; i<ile; i++)	{
			<sbut+i>.setflags(false, false);
			<sbut+i>.hide();
		}
	}
	buildmaskfunc(string sfile, string smouse, string sfunc)	{
		this.buildmask(sfile, smouse);
		this.clickfunc(sfunc);
	}
	addmask(string sanim, string sname, string smouse, int bhide)	{		// dodanie np. ludka jako maski
		string spom = sbut + iilebut;
		newvars::newbutan( spom, sanim, null, null, smouse);
		<spom>.addmethod("getbutname","cgetbutname");
		sname==null ? <spom>._cbuildbutname(<sanim>.actionname()) : <spom>._cbuildbutname(sname);
		if(bhide)	{
			<spom>.setflags(false, false);
			<spom>.hide();
		}
		iilebut++;
	}
	addadvmask(string sanim, string sname, string smouse, string sfuncclick)	{
		this.addmask( sanim, sname, smouse, false );
		this.addfunctolast( sfuncclick, null, null, null);	
	}
}

/*****************************************************/
public callfun(string sob, string sfun)	{if( sfun!=null ) sob==null ? this.<sfun>() : <sob>.<sfun>();}
public _stdanloop()	{	this.play(-1); }
public _stdanhide()	{	this.hide();	}
public _stdsndloop()	{	this.play(); }
public __std_finish()	{	this.<this+"_FINISH">();	}
public looponfinish(string san)	{	<san>.addmethod("onfinish", "_stdanloop");	}
public hideonfinish(string san)	{	<san>.addmethod("onfinish", "_stdanhide");	}
/*****************************************************/
public string strsube(int ile)	{	return this.getb( 0, this.length()-ile );	}
public string strsubb(int ile)	{	return this.getb( ile, this.length() - ile );	}
public string strsubbs(string s)	{	return this.strsubb( s.length() );	}
public string strsubes(string s)	{	return this.strsube( s.length() );	 }
public string strgetto(string schar)	{
	@id = .find(schar);
	id<0 ? .get : .getb(0, id);
}
public string strgetfromto(int ipos, string schar)	{	return this.getb(ipos, this.find(schar));	}
public string strgetfrom(string schar)	{	return .getb(.find(schar)+schar.length, .length );	}
public strremove(string s)	{	.set( .strgetto(s) + .strgetfrom(s) ); }
public bool strisbetween(int b1, int b2)	{
	int ib;
	for(int i=0; i<.length; i++)	{
		ib = .getbyte(i);
		if( ib<b1 || ib>b2 )	return false;
	}
	true;
}
public bool strisint		{	.strisbetween(BYTE0, BYTE9);	}
public bool strisbin	{	.strisbetween(BYTE0, BYTE0+1);	}
public bool strisalpha	{	.strisbetween(BYTEa, BYTEz);	}
public streach(string sfun)	{
	string s;
	for( int i=0; i<.length; i++) {
		s = .getb(i,1);
		<s>.<sfun>(i);
	}
}
public string strdotpos(int pos)	{	.strgetto(".") + "." + .strgetfrom(".")->getb(0,pos);}
/*****************************************************/
public swap(string s1, string s2)	{
	[s1];
	<s1> = [s2];
	<s2> = _;
}
public bool stats(int ile)	{	(ile <= 0) ? false : ( 100->rand <= ile );}
public def between(def i1, def i, def i2)	{	( i < i1 ) ? i1 : (i>i2) ? i2 : i;}
public def max(def val1, def val2)	{	val1>val2 ? val1 : val2;	}
public def min(def val1, def val2)		{	val1<val2 ? val1 : val2;	}
/*************** do wykorzystania na obiektach!! ***********************************/
public imgborders(int w, int r, int g, int b, int a)	{	.imgborderss(w,r,g,b,a,"1111"); }
public imgborderss(int w, int r, int g, int b, int a, string sbor)	{
	new img _img_bor;
	_img_bor.create(.getw, w, r,g,b,a);
	_img_bor.setpos(.getpx, .getpy );
	if(sbor.getb(3,1)=="1")
		.blit("_img_bor");
	_img_bor.move(0, .geth-w);
	if(sbor.getb(1,1)=="1")
		.blit("_img_bor");
	_img_bor.create(w,.geth,r,g,b,a);
	_img_bor.setpos(.getpx, .getpy);
	if(sbor.getb(0,1)=="1")
		.blit("_img_bor");
	_img_bor.move(.getw-w, 0);
	if(sbor.getb(2,1)=="1")
		.blit("_img_bor");
	delete _img_bor;
}
public imgroundborder(int w, int r, int g, int b, int a)	{
	.imgborders(w,r,g,b,a);
	.imgerasecorners;
}
public imgerasecorners	{
	@x = .getpx;
	@y = .getpy;
	.putrgba(x,y,.transparent);
	.putrgba(.getex-1,y,.transparent);
	.putrgba(.getex-1,.getey-1,.transparent);
	.putrgba(x,.getey-1,.transparent);
}
public real imgdrawline(string sbrush, int xstart, int ystart, int xstop, int ystop, real istep, real rdy)	{
	.imgfuncline("blit",sbrush,xstart,ystart,xstop,ystop,istep,rdy);
}
public real imgeraseline(string sbrush, int xstart, int ystart, int xstop, int ystop, real istep, real rdy)	{
	.imgfuncline("erase",sbrush,xstart,ystart,xstop,ystop,istep,rdy);
}
public imgputoncenter(string simg)	{	.setpos( <simg>.getcx-.getw/2, <simg>.getcy-.geth/2);	}
public real imgfuncline(string sfun, string sbrush, int xstart, int ystart, int xstop, int ystop, real istep, real rdy)	{
	@dx = xstop-xstart;
	@dy = ystop-ystart;
	real r;
	if( dx==0 )	{
		if( dy<0 )	{
			r = rdy+ystart;
			while( r>=ystop )	{
				<sbrush>.setpos(xstart, r);
				.<sfun>(sbrush);
				r-=istep;
			}
			ystop-r;
		} else if (dy>0)	{
			r = rdy+ystart;
			while( r<=ystop )	{
				<sbrush>.setpos(xstart, r);
				.<sfun>(sbrush);
				r+=istep;
			}
			r-ystop;
		} else rdy;
	} else {
		r = rdy.length(dx, dy);
		real rd;
		while( rdy<=r )	{
			rd = 1.0 - (r-rdy)/r;
			<sbrush>.setpos( (rd*dx)+xstart, (rd*dy)+ystart );
			.<sfun>(sbrush);
			rdy+=istep;
		}
		rdy-r;
	}
}
public anresizemets()	{	anima_pack::resizemethods(this.getname());	}
//public def anfirstnontr	{	classansearcher::firstnotrx1y(this);	}
public def anfirstnontr	{	classansearcher::_findnotr(this,.getpx, .getpy, 1, 0);	}
public anloopfin()	{	this.addmethod("onfinish", "_stdanloop");	}
public anloopplay(int iact)	{	this.anloopfin();	this.play(iact);	}
public anloopsplay(string sact)	{	this.anloopfin();	this.play(sact);	}
public anhidefin()	{	this.addmethod("onfinish","_stdanhide");	}
public anputgr()	{	this.setz( this.getey() );	}
public anputy(int ypos)	{	this.move(0, ypos - this.geth() - this.getpy());	}
public anputx(int xpos)	{	this.move(0, xpos - this.geth() - this.getpy());	}
public ansetposgr(int x, int y)	{	this.setpos(x,y);	this.anputgr();	}
public anplayz(int id, int z)	{	this.setz(z);	this.play(id);	}
public anplaygr(int id)	{	this.play(id);	this.anputgr();	}
public anplayzpos(int id, int z, int x, int y)	{	this.setpos(x,y);	this.anplayz(id,z);	}
public anplaypos(int x, int y)	{	this.setpos(x,y);	this.play(-1);	}
public anplayposgr(int x, int y)	{	this.ansetposgr(x,y);	this.play(-1);	}
public anplaypos2(int x, int y, string sact)	{	this.setpos(x,y);	this.play(sact);	}
public anplaypos3(int x, int y, int iact)	{	this.setpos(x,y);	this.play(iact);	}
public anhide()	{	this.stop(false);	this.hide();	}
public andownpos(int x, int y)	{	this.setpos( x, y-this.geth() );	}
public ansetbpos(int x, int y)	{	this.setpos( x-this.lodx(), y-this.lody() );	}
public ansetcpos(int x, int y)	{	.ansetbpos( x - .getw/2, y - .geth/2 );	}
public ancenterscreen {       .ansetcpos( iResX/2, iResY/2 ); }
public ansetframe(int id)	{	this.setframe( this.actionnr(-1), id );	}
public ansetsframe(def d, string s)	{
	.setframe(d,0);
	int id = 0;
	while( id < .nofframes(-1) && .framename!=s )	{
		id++;
		.setframe(-1,id);
	}
}
public int anonscreen()	{	return clsurf.inscreen(this.getcx(), this.getcy(), this.getw()/2, this.geth()/2);	}
public objplayfin(string sfun)	{	this.addmethod("onfinish", sfun);	this.play();	}
public objloop()	{	this.addmethod("onfinish","_stdsndloop");	}
public objplayloop()	{	this.objloop;	this.play();	}
public anplayfin(int iact, string sfun)	{	this.addmethod("onfinish", sfun);	this.play(iact);	}
public anytoz()	{	this.setz(this.getposy());	}
public anposz(int x, int y, int z)	{	.setpos(x,y);	.setz(z);	}
public string annextaction(string sact)	{return this.nameofaction( (this.actionnr(sact)+1)%this.nofactions() );}
public ansetnextact	{	.setframe( (.actionnr(-1)+1)%.nofactions, 0 ); }
public ansetnextfr		{	.setframe( -1, (.framenr+1)%.nofframes(-1)); }
public anaddfilter()	{	classanfilter::build(this.getname());	}
public anaddfx	{	AnimaFx::build( this );	}
public anputc(int x1, int y1, int x2, int y2)	{
	.ansetbpos(x1,y1);
	.move( (x2-x1-.getw)/2, (y2-y1-.geth)/2 );
}
public aninlod(int itoler)	{	itoler.length( .getpx - .lodx, .getpy - .lody ) <= itoler; }
public angetcpos	{	return .getcx, .getcy;	}
public angetcrgba	{	.getrgba(.getcx, .getcy);	}
public anisin(int x, int y, bool bv, bool ba)	{
	for( int i=0; i<.nofactions; i++)	{
		.setframe(i, 0);
		if( .isin(x,y,bv,ba) ) return i;
	}
	-1;
}
public anreload(string sfile)	{
	int id = .actionnr(-1);
	int fr = .framenr;
	bool bplay = .isplaying(-1)!=false;
	|int x, int y| = .getpos;
	int z = .getz;
	.load( .getpath(sfile) );
	.setpos(x, y);
	.setz(z);
	if( id < .nofactions ) {
		if( bplay ) .play(id);
		.setframe(id ,fr );
	} else .setframe(0 ,0);
}
public anclipob(string sob)	{	.clip(<sob>.getpx, <sob>.getpy, <sob>.getex, <sob>.getey);	}
public ancopyan(string san)	{
	.setframe( <san>.actionnr(-1), <san>.framenr );
	<san>.isvisible ? .show : .hide;
	.setpos( <san>.getpos );
}
public anconstmove(int delay, int x, int y)	{
	.vars2(A, "mvx", x, "mvy", y);
	.setdelay(delay);
	.anplayfin(-1, func { .play(-1); .move(mvx, mvy); });
}
/***************** text ****************/
public txtset(string s)	{	.set(s);	.create;	}
public txtsetcol(string s, int r, int g, int b)	{	.set(s);	.createtxt(r,g,b);	}
public txtshadow(int w, string sfont)	{
	if( !.hasvar("txts") )	{
		new text txts;
		txts.setfont(sfont);
	}
	txts.set(.get);
	txts.setpos(.getpx+w, .getpy+w);
	txts.setz(.getz-1);
	txts.show;
	txts.createtxt(0,0,0);
}
public txthides	{	.hide; if(.hasvar("txts")) txts.hide; }
public txtisin(int x, int y)	{
	x>=.getpx && x<.getpx+.getw && y>=.getpy && y<=.getpy+.geth;
}
public txtcenter(string sob)	{	.setpos( <sob>.getcx - .getw/2, <sob>.getcy - .geth/2 );}
public txtright(string sob)	{	.setpos( <sob>.getex - .getw, <sob>.getcy - .geth/2 );}
/***************** vector ****************/
public vecinc(int pos)	{	this.set( pos, this.get(pos)+1 );	}
public vecdec(int pos)	{	this.set( pos, this.get(pos)-1 );		}
public vecnewint(int ile)	{
	this.free();
	if( ile>0 )	for( int i=0; i<ile; i++)	{	this.add(i);	}
}
public veccopy(string svec)	{
	this.free();
	for( int i=0; i< <svec>.size(); i++ )	this.add( <svec>.get(i) );
}
public int vecnextid(def val)	{
	int id = .find(val);
	if( id>=0 )	id = (id+1)%.size;
	id;
}
public int vecprevid(def val)	{
	int id = .find(val);
	if( id>0 )	id--;
	else if (id==0)	id = .size-1;
	id;
}
public def vecget(int id)	{
	( id>=0 && id<.size) ? .get(id) : null;
}
public def vecnext(def val)	{	.vecget( .vecnextid(val) );	}
public def vecprev(def val)	{	.vecget( .vecprevid(val) );	}
public def veclast()	{
	int ile = this.size();
	ile>0 ? this.get(ile-1) : null;
}
public def vecpop()	{
	@x = .last;
	.removeat( .size - 1 );
	x;
}
public veclimes(int ile)	{	while( .size > ile )	_ = .vecpop;	}
public def vecpopfront()	{
	def x = this.get(0);
	this.removeat( 0 );
	return x;
}
public vecreplace(def d1, def d2)	{
	@id = .find(d1);
	if( id>=0 )	.set(id,d2);
}
public insertsort(int ile, string sgetfun, string scomparefun, string sswapfun)	{
	if( ile<=1 )	{	return;	}
	def s[2], int id, int i, int j;
	for( i=0; i<ile; i++)	{
		s0 = this.<sgetfun>(i);
		id = i;
		for( j=i+1; j<ile; j++)	{
			s1 = this.<sgetfun>(j);
			if( this.<scomparefun>(s1,s0) )	{
				s0 = s1;
				id = j;
			}
		}
		this.<sswapfun>(i,id);
	}
}
public obbuildfromstring(string s, string separator, string sfunadd)	{
	int pos = s.find(separator);
	while( pos>-1 )	{
		this.<sfunadd>( s.getb(0,pos) );
		s = s.strsubb(pos+1);
		pos = s.find(separator);
	}
	if( s.length()>0 )	{	this.<sfunadd>(s);	}
}
public obbuildfromstring2(string s, string separator, string sfunadd)	{
	int pos = s.find(separator);
	while( pos>-1 )	{
		if( pos>0 )	this.<sfunadd>( s.getb(0,pos) );
		s = s.strsubb(pos+1);
		pos = s.find(separator);
	}
	if( s.length()>0 )	{	this.<sfunadd>(s);	}
}
public vecsort(string scomparefun)	{ .insertsort( .size, "get", scomparefun,"swap" ); }
public string vecbuildfromstring(string s, string separator)	{
	this.free();
	this.obbuildfromstring(s,separator,"add");
}
public string vecbuildfromstring2(string s, string separator)	{
	this.free();
	this.obbuildfromstring2(s,separator,"add");
}
public vecremoveto(int ito)		{	for( int i=0; i<ito; i++ ) this.removeat(0);		}
public vecremovefrom(int ifrom)	{	while( ifrom<this.size() ) this.removeat(ifrom);	}
public vecfindfrom(int ifrom, def d)	{
	while (ifrom<.size)	{
		if( .get(ifrom)==d ) return ifrom;
		else ifrom++;
	}
	return -1;
}
public vecposfromto(int i1, int i2)	{
	if( i1==i2 || .size==0 )	return;
	def x = .get(i1);
	if( i1>i2 )	for( int i=i1; i>i2; i--)	{	.set(i, .get(i-1));		}
	else if (i1<i2)	for( int i=i1; i<i2; i++)	{	.set(i, .get(i+1));	}
	.set(i2,x);
}
public vecposfirst( def x )	{
	int id = .find(x);
	if( id>=0 )	.vecposfromto(id, 0);
	else	.addbegin(x);
}
public vecposlast( def x )	{
	int id = .find(x);
	if( id>=0 )	.vecposfromto(id, .size-1);
	else	.addbegin(x);
}
public vecset(def x, def d2)	{
	int id = .find(x);
	if( id>=0 )	.set(id,d2);
}
public bool veceq(string svec)	{
	int id = .size;
	if( id != <svec>.size  )	return false;
	for( int i=0; i< id; i++)	if( .get(i)!=<svec>.get(i) ) return false;
	true;
}
public vecbuild	{	.withlist("addbegin");}
public bool veceq2	{
	new vector ___v;
	___v.type(.getvectype);
	___v.vecbuild;
	bool b = .veceq("___v");
	delete ___v;
	b;
}
public veccopydbrow(string sdb, int irow)	{	.free;	 .vecadddbrow(sdb,irow);	}
public vecadddbrow(string sdb, int irow)	{	for( int i=0; i< <sdb>.getcolsno(irow); i++)	.add( <sdb>.get(irow,i) );	}
public def vecchecknext(int id)	{
	id++;
	id < .size ? .get(id) : null;
}
public def vecsum	{
	if( .size )	{
		def sum = .get(0);
		for( int i=1; i<.size; i++)	{
			sum+=.get(i);
		}
		sum;
	} else 0;
}
/************** db ************************/
public dbbuild(int icol)	{
	if( icol<=0 )	return;
	icol--;
	.free;
	string s = _, int id;
	for( int i = 0; s!=A; )	{
		if( i==0 )	id = this.addbeginrow() - 1;
		this.addbegin(0,s);
		s = _;
		i = (i<icol)? i+1 : 0;
	}
}
public dbbuild2	{
	.free;
	string s = _;
	while( s!=A )	{
		if( s==null )	_ = .addbeginrow;
		else .addbegin(0,s);
		s = _;
	}
}
public dbaddvec(string svec)	{
	@id = .addrow-1;
	for( int i=0; i< <svec>.size; i++)	.add(id, <svec>.get(i));
}
public dbcopy(string sdb)	{	.dbcopyfromto(sdb, 0, <sdb>.getrowsno);}
public dbcopyrow(string sdb, int irow)	{	.dbcopyfromto(sdb,irow,irow+1);	}
public dbcopyfromto(string sdb, int i1, int i2)	{
	.free;
	int i, int j, int row;
	for( i =i1; i< i2; i++)	{
		row = .addrow-1;
		for( j=0; j< <sdb>.getcolsno(i); j++)	{
			.add( row, <sdb>.get(i,j) );
		}
	}
}
public dbadddbrowtorow(int myrow, string sdb, int row)	{
	for( int i=0; i< <sdb>.getcolsno(row); i++)	{
		.add( myrow, <sdb>.get(row,i) );
	}
}
public dbremovecol(int col)	{	for(int i=0; i<.getrowsno; i++) if( .getcolsno(i)>col ) .removeat(i,col);	}
public dbcopyfromtos(string sdb, string sfrom, string sto)	{
	.dbcopyfromto(sdb, <sdb>.findbyrow(sfrom)+1, <sdb>.findbyrow(sto));
}
public dbremovelast()	{
	.removerow( .getrowsno-1 );
}
public dbcuttosize(int isize)	{
	if( isize>0 ) while( .getrowsno > isize )	.dbremovelast;
	else	.free;
}
public dbaddlast(string svar)	{	this.add( this.getrowsno()-1, svar );	}
public dbaddstringrow(string s, string separator)	{
	_ = this.addrow();
	this.obbuildfromstring(s,separator,"dbaddlast");
}
public dbgetstringrow(int row)	{
	string s="";
	int ile = .getcolsno(row);
	for( int i = 0; i<ile; i++) s+= .get(row,i);
	s;
}
public dbaddrow	{
	@id = .addrow - 1;
	@s = _;
	while(A!=s)	{
		.addbegin(id, s);
		@s = _;
	}
}
public dbaddrowfrom(string sdb, int irow, int icol)	{
	if( <sdb>.rowinrange(irow) && icol>=0)	{
		int id = this.addrow()-1;
		int ile = <sdb>.getcolsno(irow);
		while( icol < ile )	{
			this.add( id, <sdb>.get( irow, icol ) );
			icol++;
		}
	}
}
public string dbchecknext(int irow, int icol)	{
	icol++;
	icol < this.getcolsno(irow) ? this.get(irow,icol) : null;
}
public string dbgets(string s, int icol)	{return this.get( this.findbyrow(s), icol );}
public int dbinsertless(int i1)	{
	int id = this.addrow()-1;
	this.add(id,i1);
	this.dbsort("cmpless");
	while( id>=0 )	{
		if( i1==this.get(id,0) )	return id;
		id--;
	}
	return -1;
}
public bool dbdelvar(int irow, string svar)	{return this.dbdelvarn(irow,svar,1);}
public bool dbdelvarn(int irow, string svar, int n)	{
	int id = this.dbfindinrow(irow,svar);
	if( id>=0 )	{
		this.removen(irow,id,n);
		return true;
	}
	return false;
}
public int dbfindinrow(int irow, string svar)	{
	if( this.rowinrange(irow) )	{
		for( int i=0; i<this.getcolsno(irow); i++)	if( this.get(irow,i)==svar )	return i;
	}
	return -1;
}
public int dbfindbycol(int icol, string svar)	{
	for( int i=0; i<this.getrowsno(); i++)	{if( this.get(i,icol)==svar ) return i;}
	return -1;
}
public bool dbrowcontains(int irow, string svar)	{	return this.dbfindinrow(irow,svar)!=-1;	}
public string dbfirst(int id)		{	return this.get(id,0);	}	
public bool cmpless(int i1, int i2)	{	return i1<i2;	}
public bool cmpabove(int i1, int i2)	{	i1>i2;	}
public bool dbfirstless(int i1, int i2)	{	.get(i1,0) < .get(i2,0);	}
public dbsort(string scomparefun)	{	.insertsort( .getrowsno, "dbfirst",scomparefun, "swap" ); }
public dbsetall(string svar)	{	for( @i=0; i<.getrowsno; i++)	for(@j=0; j<.getcolsno(i); j++)	.set(i,j,svar);	}
public dbeach_row(string sfun)	{	for( @i=0; i<.getrowsno; i++) .<sfun>(i);	}
public dbeq(string sdb)	{
	if( .getrowsno != <sdb>.getrowsno ) return false;
	int ile, int j;
	for( int i=0; i<.getrowsno; i++)	{
		ile = .getcolsno(i);
		if( ile!=<sdb>.getcolsno(i) ) return false;
		for( j=0; j<ile; j++)	{
			if( .get(i,j)!=<sdb>.get(i,j) ) return false;
		}
	}
	true;
}
/************** int ************************/
public int randdiff(int zakres, int odjakiej)	{
	if( zakres<=1 )		return -1;
	for( int i1 = zakres.rand; i1==odjakiej; i1= zakres.rand )	{}
	return i1;
}
public int bin_to_i	{
	string s = .get;
	int idwa = 1;
	int iout = 0;
	for( int i=s.length-1; i>=0; i--)	{
		if( s.getb(i,1)=="1") iout+=idwa;
		idwa*=2;
	}
	iout;
}

/***************************************************************************/
class classgamepause	{
	init()	{
		new button butpause;
		butpause.setrect( 0, 0, 800, 600 );
		butpause.addmethod("onclick", "resume");
		butpause.disable();
	}
	resume()	{
		butpause.disable();
		gameapi.resume();
	}
	pause()	{
		gameapi.pause();
		butpause.enable();
		butpause.resume();
	}
}

class TicksCounter	{
	init()	{
		new int istart;
	}
	start()	{	istart = engine.getticks();	}
	stop()	{	istart = engine.getticks() - istart;	}
	get()		{	return istart;	}
	int stopget()	{	this.stop();	return this.get();	}
	print(string s)	{	engine.print(s+" delay: "+this.stopget()+" ms");	}
	put()	{	.print("");	}
}

class ObjController	{
	init()	{
		new string _sme = this.getname();
		<GAME>.addgmobj(_sme);
	}
	removefromgame	{	<GAME>.removegmobj(_sme); }
}
class LObjController : ObjController, classlocker	{
	init()	{
		ObjController::init;
		classlocker::init;
	}
}

class gmbankvec : gmobjvec	{
	init	{
		gmobjvec::init;
		.var2("iid", -1);
	}
	startrand	{	if(.size>0) iid=.size->rand;	}
	play()	{
		this.stop(false);
		int ile = this.size();
		if( ile==0 ) return;
		iid = (iid+1)%ile;
		<this.get(iid)>.play();
	}
	onfinish()	{}
	stop(bool bfin)	{
		if( this.isplaying() )	{
			<this.getplay()>.stop(bfin);
			if( bfin ) this.onfinish();
		}
	}
	isplaying	{	( iid>=0 )	? <.getplay>.isplaying : false;	}
	getplay()	{	return this.get(iid);	}
}

class GameController : classlocker {
	init(string ssndbase)	{
		classlocker::init();
		new gmobjvec __grobj;
		
		new db _dbsnd;
		_dbsnd.setseparator("|");
		new string _sndbase = ssndbase;
		new string GAME = this;
		
		new timer __dblclick;
		__dblclick.delay(250);
		__dblclick.settick(1);
	}
	public game_exit()	{
		//this.stdexportsnd();
	}
	/*************************************************/
	public setsndbase(string sb)	{	_sndbase=sb;	}
	public say(string styp, string stxt)	{	this.sayf(styp,stxt,null);	}
	public sayf(string styp, string stxt, string sfun)	{
		string s = this.getsndtxt(stxt);
		<s>.setstartstopflag(false,true);
		this.cplayf(styp, s, sfun);
	}
	public string getsndtxt(string stxt)	{
		string ssnd = "snd" + _sndbase + _dbsnd.getrowsno();
		this.addsnd( ssnd, stxt );
		return ssnd;
	}
	_sndtimerstart()	{
		int id = _dbsnd.dbfindbycol(1,this.getname());
		if( id>=0 )	engine.print( _dbsnd.get( id,2) );
		else 		engine.print( this.getname() + " not in _dbsnd");
		engine.print("");
	}
	public addsndf(string ssnd, string stxt, string sfun)	{
		this.addsnd(ssnd,stxt);
		if( sfun!=null )	{
			if( ssnd.getb(0,1)==":" ) ssnd = ssnd.strsubb(1);
			<ssnd>.addmethod("onfinish", sfun );
		}
	}
	public asf(string ssnd, string stxt)	{	this.addsndff( "snd" + ssnd, stxt, "end" + ssnd);	}
	public addsndff(string ssnd, string stxt, string sfun)	{
		this.addsndf(ssnd,stxt,sfun);
		//<ssnd>.setstartstopflag(false,true);
	}
	gmconsnd(string ssnd, string swav)	{
		new snd <ssnd>;
		<ssnd>.setstartstopflag(false,true);
		<ssnd>.load( .getsndpath+swav );
		if( igmsubtitle )	{
			subtitle.register(ssnd, .getsndpath+swav);
		}
	}
	public addsnd(string ssnd, string stxt)	{
		int id = _dbsnd.addrow()-1;
		string swav;
		if( ssnd.getb(0,1)==":" )	{
			ssnd = ssnd.strsubb(1);
			swav = _sndbase + "_" + ssnd + id + ".wav";
		} else swav = _sndbase + id + ".wav";
		string sg = gameapi.getgamename();
		if( engine.fileexist( this.getsndpath() + swav ) )	{
			<sg>.gmconsnd( ssnd, swav );
		} else {
			<sg>.newtimer( ssnd, stxt.length()*40, 1);
			<ssnd>.addmethod("onstart", "_sndtimerstart");
			<ssnd>.addmethod("setstartstopflag", func { (bool b1, bool b2) ; });
		}
		_dbsnd.add(id, swav);
		_dbsnd.add(id, ssnd);
		_dbsnd.add(id, stxt);
	}
	public addbank(string sbank, string sfunc)	{
		new gmbankvec <sbank>;
		string s = _;
		string s2;
		while( s!=A )	{
			s2 = this.getsndtxt(s);
			<sbank>.addbegin( s2 );
			if( sfunc!=null ) <s2>.addmethod("onfinish", sfunc );
			s = _;
		}
	}
	public exportbank(string sbase)	{
		new db <"__db"+sbase> (sbase)	{ (@sbase)
			.dbbuild(1);
			.setseparator("|");
			.dbeach_row( func { (@id)
				@s = this->strsubbs("__db");
				.addbegin(id, "snd"+s+id);
				.addbegin(id, s+id+".wav");
				} );
			if( igmdebug )
				.save("exports/"+sbase+".dlg");
		};
		delete <"__db"+sbase>;
	}
	public importbank(string sbank, string sbase, string sfun)	{
		new gmbankvec <sbank>;
		.importgroupto(sbase, sfun, null, sbank);
	}
	public exportsnd(string sfile)	{	if( igmdebug) _dbsnd.save(sfile);	}
	public stdexportsnd()	{	this.exportsnd( "exports/" + _sndbase + ".dlg" );	}
	public sounds=()	{	.buildsnds;	}
	public sounds_from(string sbase)	{
		new db __tmpdb;
		@stmpbase = _sndbase;
		.setsndbase(sbase);
		__tmpdb.load("exports/"+sbase+".dlg");
		_dbsnd.free;
		@s = _;
		int id, string sf;
		while( A!=s )	{
			@s1 = _;
			id = __tmpdb.dbfindbycol(1, s1);
			if( id>=0 )	{
				sf = .getsndpath + __tmpdb.get(id,0);
				if( engine.fileexist( sf ) )	{
					<GAME>.gmconsnd( s1, __tmpdb.get(id,0) );
					<s1>.addmethod("onfinish", s );
				} else	.addsndf( s1, __tmpdb.get(id,1), s );
			}
			@s = _;
		}
		_dbsnd.free;
		delete __tmpdb;
		.setsndbase(stmpbase);
	}
	public buildsnds()	{
		_dbsnd.free;
		new db __dbsnd;
		__dbsnd.dbbuild(3);
		.buildfromdb("__dbsnd");
		delete __dbsnd; 
	}
	public buildfromdb(string sdb)	{
		for( int i=0; i< <sdb>.getrowsno; i++)	{
			.addsndf( <sdb>.get(i,0), <sdb>.get(i,1), <sdb>.get(i,2) );
		}
		.stdexportsnd;
	}
	public importsnd(string sbase, string sfun)	{	this.importgroup(sbase, sfun, null );	}
	public importgroup(string sbase, string sfun, string sgr)	{	.importgroupto(sbase,sfun,sgr,null);	}
	public importgroupto(string sbase, string sfun, string sgr, string sgrto)	{
		new db __tmpdb;
		@stmpbase = _sndbase;
		.setsndbase(sbase);
		__tmpdb.load("exports/"+sbase+".dlg");
		_dbsnd.free();
		string s;
		for( int i=0; i<__tmpdb.getrowsno(); i++)	{
			s = __tmpdb.get(i,1);
			if( sgr==null || <sgr>.contains(s) )	{
				.addsndf( s, __tmpdb.get(i,2), sfun );
				if( sgrto!=null ) <sgrto>.add(s);
			}
		}
		_dbsnd.free();
		__tmpdb.free();
		delete __tmpdb;
		.setsndbase(stmpbase);
	}
	public freesnd()	{	_dbsnd.free();	}
	/*************************************************/
	public addgmobj(string s)		{	__grobj.add(s);		}
	public removegmobj(string s)	{	__grobj.remove(s);	}
	public isgmobj(string s)	{	__grobj.contains(s);	}
	public deletegmobj(string s)	{
		if( .hasvar(s) )	{
			.removegmobj(s);
			delete <s>;
		}
	}
	public lockall()		{
		__grobj.eval("lock");
		this.lock();	
	}
	public unlockall()		{
		__grobj.eval("unlock");
		this.unlock();
	}
	public gmunlockall	{	<GAME>.unlockall;	}
	public gmlockall	{	<GAME>.lockall;	}
	public lock=(bool b)	{	b ? .gmlockall : .gmunlockall; }
	mousemove()	{
		__grobj.eval("onmousemove");
		this.mouse_move();
	}
	mouselclick()	{
		__grobj.eval("onmouselclick");
		this.mouse_lclick();
		if( __dblclick.isplaying )	.mouse_dblclick;
		else __dblclick.play;
	}
	mouserclick()	{
		__grobj.eval("onmouserclick");
		this.mouse_rclick();
	}
	mouselrel()	{
		__grobj.eval("onmouselrel");
		this.mouse_lrel();
	}
	mouserrel()	{
		__grobj.eval("onmouserrel");
		this.mouse_rrel();
	}
	keydown()	{
		__grobj.eval("onkeydown");
		this.key_down();
	}
}

/* classadv : klasa do przygodowek	*/

class classadv : classgame {
	init()	{
		classgame::init();
	}
	/**************************************************************************/
	newclpathf(string spt, string san, string sfile, int x, int y, real rstep, int ityp)	{
		new classpathf <spt>;
		<spt>.build(san, this.getgraphpath() + sfile, x, y, rstep, ityp);
	}
	newclpathfcopy(string spt, string san, string sptf, real rstep)	{
		new classpathf <spt>;
		<spt>.buildfrom( san, sptf, rstep );
	}
	newpathf(string spathf, string sfile, int x, int y)	{
		new path <spathf>;
		<spathf>.build( this.getgraphpath() +sfile, x, y, 2.0, 1 );
	}
	/**************************************************************************/
	newclbut(string sbut, string sfile, int z, string smouse)	{
		new classbutton <sbut>;
		<sbut>.build( this.getgraphpath() + sfile, z, smouse );
	}
	newclmask(string sm, string sfile, string smouse)	{
		new classmask <sm>;
		<sm>.buildmask( this.getgraphpath() + sfile, smouse );
	}
	newclmaskfunc(string sm, string sfile, string smouse, string sfunc)	{
		new classmask <sm>;
		<sm>.buildmaskfunc( this.getgraphpath() + sfile, smouse, sfunc );
	}
}

class classquest	{
	init()	{
		new vector vqst;
		vqst.type("string");
	}
	int isdone(string sqst)	{	return vqst.contains(sqst);	}
	int notdone( string sqst )	{	return !vqst.contains(sqst);	}
	done(string sqst)	{	if( !vqst.contains(sqst) )	vqst.add(sqst);		}
	reset()	{	vqst.free();	}
	save(string sfile)	{	vqst.save( sfile );	}
	load(string sfile)	{	vqst.load( sfile );	}
}

new classquest clqs;

/***************************************************************************/

public winsave(string sval)	{
	new db _db_win;
	_db_win.load("output.db");
	@id = _db_win.addrow-1;
	_db_win.add(id, sval);
	_db_win.save("output.db");
	delete _db_win;
}

public string getwinpath(string spath)	{
	string s = engine.getspecialpath("appdata");
	if( s!=null )	{
		s + "\/" + sgmproject + "/" + spath;
	} else spath;
}

public saveexist(string sfile)	{
	if( igmwinlocal ) engine.fileexist( .getwinpath(sfile) );
	else engine.fileexist(sfile);
}

public vecsave(string sfile)	{
	if( igmwinlocal )	{
		.save( .getwinpath(sfile) );
	} else
		.save(sfile);
}
public vecload(string sfile)	{
	if( igmwinlocal )	{
		.load( .getwinpath(sfile) );
	} else
		.load(sfile);
}


class classfullsave	{
	init(string sfile)	{
		new db dbsav;
		new string sstdfile;
		.setfile(sfile);
	}
	public save(string sfile)	{
		if( igmwinlocal )	{
			dbsav.save( .getwinpath(sfile) );
		} else {
			dbsav.save(sfile);
		}
	}
	_load(string sfile)	{
		if( engine.fileexist(sfile) )	{
			dbsav.free;
			dbsav.load(sfile);
		}
	}
	public load(string sfile)	{
		if( igmwinlocal )	{
			._load( .getwinpath(sfile) );
		} else {
			._load(sfile);
		}
	}
	public print()	{	dbsav.print();	}
	public setfile(string sf)	{	sstdfile = sf;	}
	public stdload()	{	this.load(sstdfile);	}
	public stdsave()	{	this.save(sstdfile); }
	public free()	{	dbsav.free();	}
	public set(string sname, string svar)	{
		int id = dbsav.findbyrow(sname);
		if( id>=0 )	{
			dbsav.set(id,1,svar);
		} else {
			id = dbsav.addrow()-1;
			dbsav.add( id, sname );
			dbsav.add( id, svar );
		}
		this.stdsave();
	}
	public bset(string sname)	{	this.set(sname,true);	}
	public string get(string sname)	{
		int id = dbsav.findbyrow(sname);
		return id>=0?dbsav.get(id,1):null;
	}
	public bool is(string sname, string svar)	{
		int i = dbsav.findbyrow(sname);
  		return i>=0?dbsav.get(i,1)==svar:false;
	}
	//public bool bis(string sname)	{	return this.is(sname,true);	}
	public bool bis(string sname)	{
		int i = dbsav.findbyrow(sname);
		return i>=0?dbsav.get(i,1)!=false:false;
	}
}



class StringChecker	{
	init()	{}
	/*bool isdigit(string s)	{	s.to_i == s;	}
	int getint(string s)	{	return s.to_i();	}
	real getreal(string s)	{	return s.to_r();	}	
	bool isreal(string s)	{	return this.isdigit(s)&&s.contains(".");	}
	bool isstring(string s) {	return s.getb(0,1)=="\"";	}
	string getstring(string s)	{	return s.strsubb(1);	}*/
	bool isdigit(string s)	{	return s.to_i()!=0||s.getb(0,1)=="0";	}
	int getint(string s)	{	return s.to_i();	}
	real getreal(string s)	{	return s.to_r();	}	
	bool isreal(string s)	{	return this.isdigit(s)&&s.contains(".");	}
	bool isstring(string s) {	return s.getb(0,1)=="\"";	}
	string getstring(string s)	{	return s.strsubb(1);	}
}

class Script	{
	init(string sfile)	{
		new db __dbcode;
		new string __sdb;
		new int __irow;
		new int __icol;
		new string __sreads;
		
		new vector __vec;
		__vec.type("string");
		
		new string __sarg;
		new int __iarg;
		new real __rarg;
		
		new StringChecker __csc;
		new map2 __mp("int");		// odnosniki do funkcji
		for( int i=0; i<10; i++)	new string <"ARG"+i>;
		
		this.load(sfile);
	}
	public ARG=(int id, string s)	{ <"ARG"+id> = s; }
	public ARG(int id)	{ ["ARG"+id]; }
	public load(string sfile)	{
		if( sfile==null )	return;
		if( sfile.contains(".") )	{		// znaczy sie plik jest
			__sdb = "__dbcode";
			__dbcode.loadbeh(sfile);
		} else {
			__sdb = sfile;		// odwolanie przez inna baze
		}
		__mp.free();
		for( int i=0; i < <__sdb>.getrowsno(); i++)	{
			if( <__sdb>.get(i,0)=="func" )
				__mp.add( <__sdb>.get(i,1), i );
		}
		this.call("init");
	}
	public def get(string svar)	{	return [svar];	}
	bool isvar(string s)	{	return s.contains("$");	}
	string getvar(string s)	{
		s = s.strsubb(1);
		if( !engine.varexist(s) )
			new def <s>;
		return s;
	}
	bool isfunc(string s)	{	return s.contains(".")&&!__csc.isreal(s);	}
	getfunc(string sfun)	{
		__vec.free();
		__vec.add( sfun.strgetto(".") );
		__vec.add( sfun.strgetfrom(".") );
	}
	string _get()	{
		__icol++;
		return <__sdb>.get(__irow,__icol-1);
	}
	bool isnext()	{
		if( __icol < <__sdb>.getcolsno(__irow) )	{
			__sreads=<__sdb>.get(__irow,__icol);
			return true;
		}
		return false;
	}
	perror(bool expr, string sout)	{
		if( expr )
			engine.print("error: " + sout);
	}
	interpcall(string scal)	{
		this.getfunc(scal);
		string sob = __vec.get(0);
		if( sob.getb(0,1)=="*" ) sob=[sob.strsubb(1)];
		string sfun = __vec.get(1);
		if( sfun.getb(0,1)=="*" ) sob=[sfun.strsubb(1)];
		__vec.free();
		__icol++;	// omin '('
		string s = this._get();
		while( s!=")" )	{
			this.getexpr(s);	// odloz na stos argumenty
			s = this._get();
		}
		if( sob=="this" ) sob=null;
		this.callfun(sob,sfun);
	}
	string getvname(string s)	{
		if( this.isvar(s) )	{
			s=this.getvar(s);
		} else if( __csc.isdigit(s) ) {
			__iarg = s;
			s = "__iarg";
		} else if( __csc.isstring(s) ) {
			__sarg = __csc.getstring(s);
			s = "__sarg";
		} else if(__csc.isreal(s))	{
			__rarg = s.to_r();
			s = "__rarg";
		}
		return s;
	}
	bool isscriptfun(string s)	{	return s.contains("->");	}
	string getscriptfun(string s)	{	return s.strsubb(2);	}
	getexpr(string sexpr)	{
		if( __csc.isstring(sexpr) )	{
			<this.getvname(sexpr)>.get();
		} else if( this.isfunc(sexpr) )	{
			this.interpcall(sexpr);
		} else if(this.isscriptfun(sexpr))	{
			int r = __irow;
			int c = __icol;
			this.call( this.getscriptfun(sexpr) );
			__irow = r;
			__icol = c;
		} else {
			<this.getvname(sexpr)>.get();
		}
	}
	bool cmp()	{
		bool bodp=false;
		def d0 = this.getexpr(this._get());
		string s2 = this._get();		// typ porownania
		def d1 = this.getexpr( this._get() );
		match(s2)	{
			"==" =>	{	bodp = d0 == d1;	}
			"!=" =>	{	bodp = d0 != d1;	}
			"<" =>	{	bodp = d0 < d1;	}
			">" =>	{	bodp = d0 > d1;	}
			"<=" =>	{	bodp = d0 <= d1;	}
			">=" =>	{	bodp = d0 >= d1;	}
			? => ;
		}
		s2 = this._get();
		if( s2=="||" )	return bodp || this.cmp();
		else if (s2=="&&")	return bodp && this.cmp();
		else return bodp;
	}
	public containsfun(string sfun)	{	__mp.contains(sfun);	}
	public call(string sfun)	{
		if( !__mp.contains(sfun) )	return;
		
		__irow = __mp.get( sfun );
		__irow++;
		__icol=0;
		
		bool bgo = true;
		bool bif = false, bool bifexp, bool bwhile=false;
		bool belif=false;
		int iwhilerow;
		string s[3], int i[3];
		while( bgo )	{
			__icol=0;
			s0 = this._get();
			match(s0)	{
				"new"=>{	s0 = this._get();
					s1 = this._get();
					s1 = s1.strsubb(1);	// pozbadz sie $
					if( this.isnext() )	{
						if( __sreads=="[" )	{
							__icol++;
							i0 = this._get();
							for(i1=0; i1<i0; i1++)	{
								new <s0> <s1+i1>;
							}
						} else {		// powinien byc "(" dla konstruktora
							__icol++;
							while( this.isnext() && __sreads!=")" )	this.getexpr( this._get() );
							new <s0> <s1>;
						}
					} else {
						new <s0> <s1>;
					}
					__irow++;
				}"delete" =>	{	delete <this.getvar(this._get())>;	__irow++;	}
				(s0=="if" || belif || bwhile)?s0:"" => {
	// 				belif ? this.perror(!bif,"else without if") : this.perror(bif,"if within if");
					__icol++;		// '('
					bifexp = this.cmp();
					if(s0=="if") bif=true;
					belif=false;
					bwhile = false;
					__irow++;
					if( !bifexp )	{
						i1=1;
						while(i1)	{
							s0 = <__sdb>.get(__irow,0);
							if( s0=="else"||s0=="elif"||s0=="fi"||s0=="done") i1=0;
							else	__irow++;
						}
					}
				}"else" => { 	this.perror(!bif,"else without if");
					__irow++;
					if( bifexp )	{
						while(<__sdb>.get(__irow,0)!="fi")
							__irow++;
					}
				} "fi" =>	{	this.perror(!bif,"fi without if");
					bif=false;
					bifexp = false;
					belif=false;
					__irow++;
				} "elif"=>	{
					if( bifexp )	{
						__irow++;
						while(<__sdb>.get(__irow,0)!="fi")
							__irow++;
					} else {
						belif = true;
					}
				} "end" =>	bgo=false;
				"while" =>	{
					iwhilerow = __irow;
					bwhile = true;
				}"done" =>	{
					if( bifexp )	{
						__irow = iwhilerow;
					} else {
						__irow++;
					}
				}"print" =>	{
					s0 = "";
					while( this.isnext() )
						s0 += this.getexpr( this._get() ); 
					engine.print( s0 );
					__irow++;
				}"return" => 	{
					if( this.isnext() )	{
						this.getexpr( __sreads );
					}
					return;
				} ? => { 
					if (s0.contains("$"))	{
						s0 = this.getvar( s0 );
						__icol++;		// olej <<
						<s0> = this.getexpr(this._get());
						while( this.isnext() )	{
							__icol++;		// omin znak dzialania
							def d2 = this.getexpr( this._get() );
							match(__sreads)	{
								"+"	=>	<s0> += d2;
								"-"	=> 	<s0> -= d2;
								"*"	=>	<s0> *= d2;
								"/"	=>	<s0> /= d2;
								"%"	=>	<s0> %= d2;
								?	=>	;
							}
						}
					} else
						this.getexpr( s0 );
					__irow++; 
				}
			}
			if( __irow >= <__sdb>.getrowsno() )	{
				this.perror(1,"function "+sfun+" not finished!");
				bgo=false;
			}
		}
	}
}

public transparent	{	return 0,0,0,0;	}
public red			{	return 255,0,0;	}
public green		{	return 0,255,0;	}
public blue			{	return 0,0,255;	}
public white		{	return 255,255,255; }
public black		{	return 0,0,0;		}
public grey(int c)	{	return c,c,c;		}
public yellow		{	return 255,255,0;	}

class Color	{
	init	{
		.vars(A,"r","g","b","a");
	}
	operator=(string scol)	{	this.set( <scol>.get() );	}
	img=(@simg)	{
		|r,g,b,a| = <simg>.getrgba( classansearcher::firstnotrx1y(simg) );
	}
	get			{	return r,g,b,a;	}
	set(int r2, int g2, int b2, int a2)	{	|r,g,b,a| = r2,g2,b2,a2;	}
	rgb=(int r2, int g2, int b2)	{	|r,g,b|=r2,g2,b2;	}
	rgb	{	return r,g,b;	}
	print	{	engine.print("Color::" + this + " (r,g,b,a) = ("+r+","+g+","+b+","+a+")");	}
}

/***************************************************************************/

class classasker : newvars	{
	init()	{
		newvars::init();
		new string sfuncyes = null;
		new string sfuncno = null;
		new string ssndask;
		new string ssndyes;
		new string ssndno;
		new classsound clsnd;
	}
	reset()	{
		sfuncyes=null;	sfuncno=null;
		buts.resetall();
	}
	setfuncs(string syes, string sno)	{
		sfuncyes = syes;
		sfuncno = sno;
	}
	fxonmovon(string ssnd)	{	buts.sfxonmovon(ssnd);	}
	setmouse(string smouse)	{
		buts.newmouse("yes", smouse);
		buts.newmouse("no", smouse);
	}
	load(string sfile, int z)	{
		new classbutton buts;
		buts.build(sfile, z, null);
		buts.transclickfunc( engine.actclassname(), "butclick");
		buts.transmovonfunc( engine.actclassname() , "butmovon");
		buts.disableall();
	}
	ask( string sask, string syes, string sno, string sf1, string sf2 )	{
		this.setfuncs(sf1,sf2);
		this.ask2( sask, syes, sno );
	}
	ask2( string sask, string syes, string sno )	{
		ssndask=sask;
		ssndyes = syes;
		ssndno = sno;
		gameapi.pause();
		buts.benableall();
		buts.pause("bkg");
		clsnd.creset();
		clsnd.cbplay( sask );
		.<this+"_ask">;
	}
	/**********************************************/
	butmovon(string sc)	{
		/*if( ssndask!=null )	{
			if( <ssndask>.isplaying()==true )	{
				return;
			}
		}*/
		if( sc=="yes" )	{
			<ssndask>.stop(false);
			clsnd.cbplay( ssndyes );
		} else if (sc=="no")	{
			<ssndask>.stop(false);
			clsnd.cbplay( ssndno );
		}
	}
	butclick(string sc)	{
		if( sc=="bkg" )	return;
		gameapi.resume();
		buts.disableall();
		clsnd.cactsndstop(false);
		if( sc=="yes" && sfuncyes!=null)	{
			this.<sfuncyes>();
			.<this+"_yes">;
		} else if( sc=="no" && sfuncno!=null)	{
			this.<sfuncno>();
			.<this+"_no">;
		}
	}
	disabled	{	buts.disabled;	}
	setcursorpos(int x, int y)	{	buts.setcursorpos(x,y);	}
}

/***************************************************************************/
class classplacepointer	{
	init()	{
		new anima anpointer;
		anpointer.addmethod("onfinish", func { this.play(-1); } );
		new int _iz = 1000;
	}
	public load(string sfile)	{
		anpointer.load(sfile);
		this.setz(_iz);
		anpointer.hide();
	}
	public setz(int iz)	{
		_iz = iz;
		anpointer.setz(iz);
	}
	public stop()	{	anpointer.stop(false);	}
	public stoph()	{	anpointer.stop(false);	anpointer.hide();	}
	public show(int x, int y, string sdir)	{
		anpointer.setpos(x,y);
		anpointer.play(sdir);
	}
	move(@x, @y)	{	anpointer.move(x,y);	}
	public showob(string sob, string sdir)	{	this.show(<sob>.getcx(), <sob>.getcy(), sdir);	}
	public showpob(string sob, string sdir)	{	this.show(<sob>.getpx(), <sob>.getpy(), sdir);	}
}

class SimpleCounter	{
	init(int ilength)	{
		.var2("length", ilength );
		new int iid = 0;
	}
	int next()	{	iid = (iid+1)%length;		iid;	}
	set(int i)	{	iid=i;	}
	reset()	{	iid=0;	}
	get()	{	iid;	}
}

/******************************************/

module clstrdigit	{
	init()	{}
	public string getdigit(int idigit, int ilepozycji)	{
		string s = idigit;
		while( s.length() < ilepozycji )	s = "0" + s;
		return s;
	}
	public string gettime(int itime, string smod)	{
		return this.getstime( this.geth(itime), this.getm(itime), this.gets(itime), 
			smod.contains("h"), smod.contains("m"), smod.contains("s") );
	}
	public string getstime(int ih, int im, int is, bool bh, bool bm, bool bs)	{
		string s = "";
		if( bh ) s+= ih;
		if( bm ) s+= (bh?":":"") + this.getdigit(im,2);
		if( bs ) s+= ((bh||bm)?":":"") + this.getdigit(is,2);
		return s;
	}
	public int geth(int itime)	{	return itime/3600;	}
	public int getm(int itime)	{	return (itime/60)%60;	}
	public int gets(int itime)	{	return itime%60;	}
	public string getns(int itime, int n)	{	return this.getdigit( this.gets(itime),n );	}
	public string getnm(int itime, int n)	{	return this.getdigit( this.getm(itime),n );	}
	string getbinary(int ival)	{
		string s = "";
		while(ival>0)	{
			s = "" + (ival%2) + s;
			ival/=2;
		}
		return s;
	}
	string bintohex(string sval)	{
		string s;
		match(sval.length%4)	{
			3=>"0"; 2=> "00"; 1=> "000";
			? => "";
		}
		s = _;
		sval = s + sval;
		s = "";
		for( int i=0; i<sval.length; i+=4)	{
			match(sval.getb(i,4))	{
				"0000" => "0";	"0001" => "1";	"0010" => "2";	"0011" => "3";
				"0100" => "4";	"0101" => "5";	"0110" => "6";	"0111" => "7";
				"1000" => "8";	"1001" => "9";	"1010" => "A";	"1011" => "B";
				"1100" => "C";	"1101" => "D";	"1110" => "E";	"1111" => "F";
				? => ;
			}
			s += _;
		}
		s;
	}
}

public string getbinary			{	clstrdigit::getbinary(.get);		}
public string getdigit(int ile)		{	clstrdigit::getdigit(.get,ile);		}
public string getbindigit(int ile)	{	clstrdigit::getdigit( .getbinary,ile);	}

class Text	{
	init(string sfont, int ifontsize, int ifr, int ifg, int ifb, int x, int y, int z)	{
		if( sfont==null )	sfont = sgmfontfile;
		if( sfont.contains(".ttf") )	{
			new font _fnt;
			_fnt.load( sfont, ifontsize );
			sfont = "_fnt";
		}
		new int iR = ifr;
		new int iG = ifg;
		new int iB = ifb;
		new int iFontSize = ifontsize;
		new text txt;
		txt.setfont(sfont);
		txt.setz(z);
		txt.setpos(x,y);
		txt.show;
		
		new text txtbg;
		txtbg.hide();
	}
	public hide()	{	txt.hide;	}
	public show()	{	txt.show;	}
	public setpos(int x, int y)	{	txt.setpos(x,y);	}
	public set(string s)	{
		txt.set( s );
		txt.createtxt( iR, iG, iB );
	}
	public string get()	{	return txt.get;	}
	public setbg(int ir, int ig, int ib, int ia)	{
		txtbg.setbkg(txt.getpx()-iFontSize/2, txt.getpy()-iFontSize/2,
			txt.getw()+iFontSize, iFontSize*2, ir, ig, ib, ia );
		txtbg.setborders(1,255,255,255,128);
		txtbg.show();
	}
	operator=(string val)	{	this.set(val);	}
}

class Cypher : Text	{
	init(string sfont, int ifontsize, int ifr, int ifg, int ifb, int x, int y, int z)	{
		Text::init(sfont, ifontsize, ifr, ifg, ifb, x, y, z );
		this.set(0);
	}
	add(int dt)	{	this.set( dt + this.get );	}
	iget()		{	this.get->to_i;		}
	operator+(int val)	{	this.add(val);	}
	operator++()	{	this.add(1);	}
	operator--()	{	this.add(-1);	}
	operator-(int val)	{	this.add(-val);	}
	operator=(int val)	{	this.set(val);	}
	operator==(int val)	{	.get==val;	}
	operator!=(int val)	{	.get!=val;	}
	operator>(int val)	{	.get>val;	}
	operator<(int val)	{	.get<val;	}
}

class SecCounter	{
	init(string sdigits)	{
		new string sdigit = sdigits;
		new int itime;
		this.reset();
		this.cnewtimerfin("timcyk",1000,1, func { .update(1); .play; } );
	}
	public play()	{	timcyk.play();	}
	public stop()	{	timcyk.stop(false);	}
	public string sgettime()	{	return clstrdigit.gettime(itime, sdigit);	}
	public int gettime()	{	return itime;	}
	public reset()	{	this.update(-itime);	}
	public update(int isec)	{	itime+=isec;	}
}

class TextTimeCounter : Text, SecCounter	{
	init(string sfont, int ifontsize, int ifr, int ifg, int ifb, int x, int y, int z, string sdigits)	{
		Text::init(sfont, ifontsize, ifr, ifg, ifb, x, y, z);
		SecCounter::init(sdigits);
		.reset;
	}
	public update(int isec)	{
		SecCounter::update(isec);
		this.set( this.sgettime() );
	}
}

class gfxObject	{
	init(string sob)	{	new string sgfxobj = sob; }
	setpos		{	<sgfxobj>.setpos;	}
	move		{	<sgfxobj>.move;	}
	getpos		{	<sgfxobj>.getpos;	}
	getposx		{	<sgfxobj>.getposx;	}
	getposy		{	<sgfxobj>.getposy;	}
	getpx		{	<sgfxobj>.getpx;	}
	getpy		{	<sgfxobj>.getpy;	}
	getw			{	<sgfxobj>.getw;	}
	geth			{	<sgfxobj>.geth;	}
	getcx		{	<sgfxobj>.getcx;	}
	getcy		{	<sgfxobj>.getcy;	}
	getex		{	<sgfxobj>.getex;	}
	getey		{	<sgfxobj>.getey;	}
	lodx			{	<sgfxobj>.lodx;	}
	lody			{	<sgfxobj>.lody;	}
	setz			{	<sgfxobj>.setz;		}
	getz			{	<sgfxobj>.getz;	}
	show		{	<sgfxobj>.show;	}
	hide			{	<sgfxobj>.hide;	}
	isvisible		{	<sgfxobj>.isvisible;	}
	bool isin		{	<sgfxobj>.isin;		}
}

class gfxSquare : Color, gfxObject	{
	init(int x1, int y1, int w1, int h1)	{
		Color::init;
		.vars(A, "w", "h");
		w=w1; h=h1;
		new img imggfx;
		imggfx.setpos(x1,y1);
		gfxObject::init("imggfx");
	}
	build	{	imggfx.create(w,h,r,g,b,a);	}
	shadow(int dx, int dy, int alpha)	{
		|@x,@y| = imggfx.getpos;
		imggfx.setpos(0,0);
		new img _img1;
		new img _img2;
		if( imggfx.getw>0 )	{
			_img1.create(w,h,.transparent);
			_img1.blit("imggfx");
		} else _img1.create(w,h,.get);
		_img2.create(w,h,.black,alpha);
		if( dx<0 )	{
			_img1.move(-dx, 0);
			x+=dx;
		} else	_img2.move( dx, 0 );
		if( dy<0 )	{
			_img1.move(0,-dy);
			y+=dy;
		} else	_img2.move( 0, dy );
		w += dx.abs;
		h += dy.abs;
		imggfx.create(w, h, .transparent);
		imggfx.blit("_img2");
		imggfx.blit("_img1");
		delete _img1;
		delete _img2;
		imggfx.move(x,y);
	}
	blackborder(int width, int a2)	{	.border(width,width, .black,a2);	}
	border(int width, int height, int r2, int g2, int b2, int a2)	{
		|@x,@y| = imggfx.getpos;
		imggfx.setpos(0,0);
		new img _img;
		if( imggfx.getw>0 )	{
			_img.create(w,h,.transparent);
			_img.blit("imggfx");
		} else _img.create(w,h,.get);
		_img.move(width,height);
		w += 2*width;
		h += 2*width;
		imggfx.create(w,h,r2,g2,b2,a2);
		imggfx.blit("_img");
		delete _img;
		imggfx.move(x,y);
	}
}

class Rect	{
	init(int _x, int _y, int _w, int _h)	{
		.vars(A, "x", "y", "w", "h");
		.set(_x, _y, _w, _h);
	}
	x2	{	x+w;	}
	y2	{	y+h;	}
	set(int _x, int _y, int _w, int _h)	{ x=_x; y=_y; w=_w; h=_h; }
	fit(string simg)	{
		if( <simg>.gettype=="gmimgvec") {
			@dx = x-<simg>._getpx;
			if( dx>0 ) <simg>.move(dx,0);
			@dy = y-<simg>._getpy;
			if( dy>0 ) <simg>.move(0,dy);
		} else {
			@dx = x-<simg>.getpx;
			if( dx>0 ) <simg>.move(dx,0);
			@dy = y-<simg>.getpy;
			if( dy>0 ) <simg>.move(0,dy);
		}
		dx = .x2-<simg>.getex;
		if( dx<0 ) <simg>.move(dx,0);
		dy = .y2-<simg>.getey;
		if( dy<0 ) <simg>.move(0,dy);
	}
	fitrand(string simg)	{	<simg>.ansetbpos( x+(w-<simg>.getw)->rand, y+(h-<simg>.geth)->rand);	}
	fitgrouprand(string sgr)	{	for( int i=0; i< <sgr>.size; i++) .fitrand( <sgr>.get(i) );	}
	fitgroup(string sgr)	{	for( int i=0; i< <sgr>.size; i++) .fit( <sgr>.get(i) );	}
}
/***************************************************************************/

class classfadeinout		{
	init()	{
		new timer timf;
		new string _sob;
		new int _istep;
		new int _ival;
		new int _ib1;
		new int _ib2;
		new string _sfun;
		new string _sfunfin;
		new string _sobfin;
		timf.addmethod("onfinish", "_ctimffin");
	}
	/***************\/\/\/\/\/ wewnetrzne \/\/\/\/\/\/************************************/
	_cfinito(int v)	{
		<_sob>.<_sfun>( v );
		if( _sfunfin!=null)	{
			if( _sobfin==null )
				this.<_sfunfin>();
			else <_sobfin>.<_sfunfin>;
		}
	}
	_ctimffin()	{
		_ival+=_istep;
		if( _ival >= _ib2 )	{
			this._cfinito( _ib2 );
		} else if( _ival<=_ib1 )	{
			this._cfinito( _ib1 );
		} else {
			<_sob>.<_sfun>( _ival );
			this.play();
		}
	}
	_play( int icycle, int istep, string sob, string sfun, int ib1, int ib2, string sob2, string sfun2 )	{
		_sobfin = sob2;
		_sfunfin = sfun2;
		_ib1 = ib1;
		_ib2 = ib2;
		int i = istep.abs();
		if( icycle <= 0 || i==ib1 || i>ib2 )	return;
		_sfun = sfun;
		timf.setcycle( icycle );
		_sob = sob;
		if( istep>0 )	_ival = _ib1;
		else if( istep<0 )	_ival=_ib2;
		else return;
		<sob>.<sfun>( _ival );
		_istep = istep;
		timf.play();
	}
	/******************* /\/\/\/\/\/\/\ wewnetrzne /\/\/\/\ ****************************/
	imgtransparency(int icycle, int istep, string simg, string sfun)	{
		this._play( icycle, istep, simg, "transparency", 0, 255, null, sfun );
	}
	setopacity(int icycle, int istep, string simg, string sfun)	{
		this._play( icycle, istep, simg, "setopacity", 0, 255, null, sfun );
	}
	sndvolume(int icycle, int istep, string ssnd, string sfun)	{
		this._play( icycle, istep, ssnd, "setvol", 0, 100, null, sfun );
	}
	/***************************************************/
	isplaying	{	timf.isplaying;	}
}

class CutScene : gfxObject	{
	init(int x1, int y1, int x2, int y2)	{
		new int X1;	new int Y1;
		new int X2;	new int Y2;
		new img _gsq;
		.build(x1, y1, x2, y2);
		gfxObject::init("_gsq");
		new string _sfunc1;
		new string _sob1;
		new string _sfunc2;
		new string _sob2;
		new int _idelay = 10;
		new classfadeinout _clfio;
	}
	build(int x1, int y1, int x2, int y2)	{
		|X1, Y1, X2, Y2| = x1, y1, x2, y2;
		_gsq.create(X2-X1,Y2-Y1,.black,255);
		_gsq.setpos(X1,Y1);
		_gsq.hide;
		_gsq.transparency(0);
	}
	delay(int n)	{	_idelay=n;	}
	transparency(int n)	{	_gsq.transparency(n);	}
	playfin(string sfunc1, string sfunc2)	{	.playobfin(null,sfunc1, null, sfunc2);	}
	playobfin(string sob1, string sfunc1, string sob2, string sfunc2)	{
		_sob1 = (sob1==null) ? gameapi.getgamename : sob1;
		_sfunc1 = sfunc1;
		_sob2 = (sob2==null) ? gameapi.getgamename : sob2;
		_sfunc2 = sfunc2;
		_gsq.show;
		_gsq.transparency(0);
		_clfio._play( 1, _idelay, this, "transparency", 0, 255, this, func {
			.callfun(_sob1, _sfunc1);
			_gsq.show;
			_clfio._play( 1, -_idelay, this, "transparency", 0, 255, this, "_callfun2" );
			} );
	}
	close(string sfunc1)	{	.obclose(gameapi.getgamename, sfunc1);	}
	obclose(string sob, string sfunc1)	{
		_sob1 = sob;
		_sfunc1 = sfunc1;
		_gsq.transparency(0);
		_gsq.show;
		_clfio._play( 1, _idelay, this, "transparency", 0, 255, this, func {
			_gsq.hide;
			.callfun(_sob1, _sfunc1);
			} );
	}
	enter(string sfunc2)	{	.obenter(gameapi.getgamename, sfunc2);	}
	obenter(string sob, string sfunc2)	{
		_sob2 = sob;
		_sfunc2 = sfunc2;
		_gsq.transparency(255);
		_gsq.show;
		_clfio._play( 1, -_idelay, this, "transparency", 0, 255, this, "_callfun2" );
	}
	_callfun2	{
		_gsq.hide;
		.callfun(_sob2, _sfunc2);
	}
	isplaying	{	_clfio.isplaying;	}
}


public string allchars	{	"a0 t_!@#$%^&*()_+-=[]\\|}{;':\",./<>?`~"; }

class TextTyper : classlocker, gfxObject {
	init(string sfont, int isize, int ir, int ig, int ib, string schars, int ilimit)	{
		classlocker::init();
		sfont = .checkfont(sfont, isize);
		new int iR = ir;
		new int iG = ig;
		new int iB = ib;
		new string sChars = schars;
		new int iLimit = ilimit;		// 0 - unlimited
		
		.vars2(A,"Sdir","left", "W", 0, "iFontSize", isize, "X", 0, "Y", 0);
		
		new text txt1;
		txt1.setfont(sfont);
		txt1.set("");
		new text txt2;
		txt2.setfont(sfont);
		txt2.set("_");
		txt2.createtxt(iR,iG,iB);
		txt2.hide();
		
		new text txtpass;
		txtpass.setfont(sfont);
		txtpass.hide;
		new bool bpass = false;
		
		new string _sob=null;
		new string _sfun=null;
		
		this.cnewtimerfin("timcyk",300,1,"fintimcyk");
		
		gfxObject::init("txt1");
	}
	setaspasswd	{
		bpass = true;
		txt1.hide;
		txtpass.setz( txt1.getz );
		txtpass.show;
		.copytopass;
	}
	copytopass	{
		@id = txt1.get->length;
		string s = "";
		for( int i=0; i<id; i++)	s += "*";
		txtpass.txtset(s);
		txtpass.setpos( txt1.getpx, txt1.getpy );
	}
	setastext	{
		bpass = false;
		txt1.show;
		txtpass.hide;
	}
	public isin(int x, int y, bool bv, bool ba)	{	txt1.isin(x,y,bv,ba);	}
	getcol	{	return iR,iG,iB;	}
	fintimcyk()	{
		if( this.getlock() )	return;
		this.updatecyk();
		this.play();
	}
	updatecyk()	{
		if( txt2.isvisible() )	{
			txt2.hide();
		} else {
			txt2.setpos( txt1.getex(), txt1.getpy() );
			txt2.show();
		}
	}
	public enable()	{
		this.unlock();
		this.updatecyk();
		timcyk.play();
	}
	public disable()	{
		txt2.hide();
		timcyk.stop(false);
		this.lock();
	}
	public onenter(string sob, string sfun)	{	_sob=sob;	_sfun=sfun;	}
	public setpos(int x, int y)	{
		X = x;
		Y = y;
		//txt1.setpos(x,y);
		.updatetxt(.get);
	}
	public move(int x, int y)	{	.setpos(X+x, Y+y); }
	public setz(int z)	{	txt1.setz(z);txt2.setz(z);	}
	public get()	{
		string s = txt1.get();
		( s.length()>0 ) ? s : "";
	}
	getpx	{	txt1.getpx;	}
	getpy	{	txt1.getpy;	}
	getcx	{	txt1.getcx;	}
	getcy	{	txt1.getcy;	}
	geth	{	txt1.geth;	}
	getey	{	txt1.getpy + iFontSize;	}
	clip(int x1, int y1, int x2, int y2)	{
		txt1.clip(x1,y1,x2,y2);
		txt2.clip(x1,y1,x2,y2);
	}
	public length	{	txt1.get->length;	}
	public set(string s)	{	txt1.set(s);	}
	public txtset(string s)	{	txt1.txtsetcol(s,.getcol);	}
	public limit=(int il)	{	iLimit=il;	}
	public onkeydown()	{
		if( this.getlock() )	return;
		.<this+"_ontype">;
		if( keyboard.iskeydown("enter") )	{
			this.disable();
			this.callfun(_sob,_sfun);
			.<this+"_onenter">;
			return;
		}
		string s;
		if( sChars.contains("t") && keyboard.iskey("tab") )	s = " ";
		else s = keyboard.getkey();
		string s2 = txt1.get();
		if( ( (keyboard.isalpha && sChars.contains("a") ) || ( keyboard.isdigit && sChars.contains("0") )
			|| sChars.contains(s) ) && (iLimit<=0 || iLimit>s2.length)  )	{
			//txt1.set( s2+s );
			//txt1.createtxt(iR,iG,iB);
			.updatetxt(s2+s);
			this.updatecyk();
		} else if (keyboard.iskey("backspace") && s2.length()>0)	{
			//txt1.set( s2.strsube(1) );
			//txt1.createtxt(iR,iG,iB);
			.updatetxt( s2.strsube(1) );
			this.updatecyk();
		}
	}
	updatetxt(string s)	{
		txt1.set(s);
		txt1.createtxt(iR, iG, iB);
		if( Sdir == "center" )	txt1.setpos( X+(W-txt1.getw)/2, Y );
		else if (Sdir=="right")	txt1.setpos( X+W-txt1.getw, Y );
		else txt1.setpos(X, Y);
		if( bpass )	.copytopass;
		.<this+"_onwrite">;
	}
}

class ConTextTyper : TextTyper, ObjController	{
	init()	{
		TextTyper::init();
		ObjController::init();
	}
}

new string sTextBoxTyperSys = null;
class TextBoxTyper : LObjController, ImagePos	{
	init(string sfont, int ish, int isw, int ir, int ig, int ib, string schars, int x, int y, int w, int h, int dy)	{
		LObjController::init;
		ImagePos::init;
		new @Font = .checkfont(sfont, ish);
		.vars2(A,"Cols", w/isw, "Rows", h/(ish+dy), "X", x, "Y", y, "Row", 0, "enablemove", true, "W", w,
			"insystem", false, "H", h, "isvisible", 1, "clipx1", x, "clipy1", y, "clipx2", 0, "clipy2", 0, "clipped", false );
		new @Size = ish;
		new @Dy = dy;
		new @Z = 0;
		string s;
		new gmimgvec grtt;
		new gmimgvec gren;
		for( int i=0; i<Rows; i++)	{
			s = "tt"+i;
			new TextTyper <s>(Font,ish,ir,ig,ib,schars,Cols);
			<s>.W = (w);
			<s>.Sdir = ("left");
			<s>.setpos( x, y+i*(ish+dy) );
			grtt.add(s);
		}
	}
	settyper(int id, string sfont, int ish, int isw, int ir, int ig, int ib, string schars, string sdir)	{
		int x;
		int y;
		string s;
		string stext = "";
		if( id<0 ) {
			x = <grtt.last>.X;
			y  = <grtt.last>.getey+Dy;
			id = grtt.size;
			grtt.add("tt"+id);
		} else {
			s = grtt.get(id);
			x = <s>.X;
			y = <s>.getpy;
			stext = <s>.get;
			grtt.movefrom( s, 0, ish - <s>.iFontSize );
			delete <s>;
		}
		s = "tt" + id;
		new TextTyper <s>(sfont,ish,ir,ig,ib,schars,W/isw);
		<s>.W = (W);
		<s>.Sdir = (sdir);
		<s>.updatetxt(stext);
		<s>.setz(Z);
		<s>.setpos( x, y );
	}
	move(int x, int y)	{	grtt.move(x,y); gren.move(x,y); X+=x; Y+=y;	}
	size	{	grtt.size;	}
	setz(int z)	{	Z = z; grtt.setz(z);	gren.setz(z); }
	getz	{	Z;	}
	show	{	isvisible=1; grtt.show;	}
	hide		{	isvisible=0;	grtt.hide;		}
	clip(int x1, int y1, int x2, int y2)	{
		clipped = true;
		clipx1=x1;	clipy1=y1;	clipx2=x2;	clipy2=y2;
		for( int i=0; i<grtt.size; i++) <grtt.get(i)>.clip(x1,y1,x2,y2);
	}
	getw	{	W;	}
	geth	{	H;	}
	enumerate(int dx)	{
		string s[2];
		for( int i=0; i<grtt.size; i++)	{
			s0 = "txte"+i;
			new text <s0>;
			gren.add(s0);
			<s0>.setz(Z);
			<s0>.setfont(Font);
			<s0>.txtsetcol(""+(i+1)+".", tt0.getcol);
			<s0>.setpos(X-<s0>.getw-dx,Y+i*(Size+Dy));
		}
	}
	cut(int id)	{	Rows=id;	}
	enable	{	.unlock;	.activateact;	}
	disable	{	.lock; grtt.eval("disable");	}
	actual	{	"tt"+Row;	}
	activate(int id)	{
		.unlock;
		if( id>=0 && id<Rows )	{
			if( insystem )	{
				if( <GAME>.isgmobj(sTextBoxTyperSys) && sTextBoxTyperSys!=this )	<sTextBoxTyperSys>.deactivate;
				sTextBoxTyperSys = this;
			}
			.deactivate;
			Row = id;
			<"tt"+ Row>.enable;
			.<this+"_activate">;
		}
	}
	activateact	{	.activate(Row);	}
	deactivate	{	<"tt"+Row>.disable;	}
	onkeydown	{
		if(.getlock)	return;
		.<this+"_boxontype">;
		if( keyboard.iskeydown("enter") )		{
			@s = .getid(Rows-1);
			s.clear;
			if( s.length==0 && enablemove )	{
				for( @i=Rows-1; i>Row+1; i--)	.setid( .getid(i-1), i);
				if( Row+1<Rows) .setid("", Row+1);
			}
			.activate(Row+1);
		} else if (keyboard.iskey("up") && Row>0) .activate(Row-1);
		else if (keyboard.iskey("down") && Row<Rows-1) .activate(Row+1);
		else if (keyboard.iskey("pgdown"))	{
			if(Row<Rows-10) .activate(Row+10);
			else .activate(Rows-1);
		} else if (keyboard.iskey("pgup"))	{
			if(Row>9) .activate(Row-10);
			else .activate(0);
		} else if ((keyboard.iskey("backspace") || keyboard.iskey("delete")) && <.actual>.length==0 ) {
			if( enablemove )	{
				for( @i=Row; i<Rows-1; i++)	.setid( .getid(i+1), i);
				.setid("",Rows-1);
			}
			if( keyboard.iskey("backspace") )
				.activate(Row-1);
		} else grtt.eval("onkeydown");
	}
	onmouselclick	{
		if(.getlock)	return;
		|int x, int y| = mouse.getpos;
		//if(  )	{
		if( (clipped && clsurf.isin(x,y,clipx1,clipy1,clipx2,clipy2)) || (!clipped && clsurf.isin2(x,y,X,Y,W,H)) )	{
			.deactivate;
			//.activate( ((y-Y)*Rows)/H );
			for( int i=0; i<.size; i++)	{
				if( <"tt"+i>.getey > y ) {
					.activate(i);
					return;
				}
			}
		} else {
			.<this+"_OUTSIDE">;
		}
	}
	int isin(int x, int y, bool bv, bool ba)	{
		if( bv && !isvisible ) return 0;
		clsurf.isin2(x,y,X,Y,W,H);
	}
	string getid(int id)	{	<"tt"+id>.get;	}
	string getact		{	<"tt"+Row>.get;	}
	int idpx(int id)	{	<"tt"+id>.getpx;	}
	int idpy(int id)	{	<"tt"+id>.getpy;	}
	//int getpy	{	.idpy(0);	}
	//int getpx	{	.idpx(0);	}
	int getpx	{	X;	}
	int getpy	{	Y;	}
	string get	{	.getfrom(0);	}
	string getfrom(int id)	{	.getlinesfrom(id,"");	}
	string getlinesfrom(int id, string send)	{
		string s = "";
		for( int i=id; i<grtt.size; i++) s += <"tt"+i>.get + send;
		s;
	}
	string getlines	{	.getlinesfrom(0," ");	}
	int nonempty(int id)	{
		string s;
		for( ; id<grtt.size; id++)	{
			s = <"tt"+id>.get;
			s.clear;
			if( s.length > 0 ) return id;
		}
		-1;
	}
	clear	{	grtt.txtreset;	}
	setid(string s, int id)	{	if( grtt.size>=id )	<"tt"+id>.txtset(s);	}
	settext(int ile)	{
		while(ile>0)	{
			ile--;
			.setid(_,ile);
		}
	}
	copytodb(string sdb)	{
		<sdb>.free;
		for( int i=0;i<grtt.size; i++)	{
			<sdb>.add( <sdb>.addrow-1, <grtt.get(i)>.get);
		}
	}
	copyfromdb(string sdb)	{	.copyfromdbii(sdb, 0, <sdb>.getrowsno);	}
	copyfromdbss(string sdb, string s1, string s2)	{	.copyfromdbii(sdb, <sdb>.findbyrow(s1)+1, <sdb>.findbyrow(s2) );	}
	copyfromdbii(string sdb, int row1, int row2)	{
		if( row1==-1 || row2==-1 ) return;
		.clear;
		if( row2-row1 > .size ) row2 = row1+.size;
		for( int i=row1; i<row2; i++)	{
			if( <sdb>.getcolsno(i) )
				.setid( <sdb>.get(i,0), i-row1 );
		}
	}
	copyfromdbrow(string sdb, int row, int startcol)	{
		int size = <sdb>.getcolsno(row);
		if( size>.size ) size = .size;
		for( int i=startcol; i<size; i++)
			.setid( <sdb>.get(row,i), i-startcol );
	}
	save(string sfile)	{
		new db __tmpdb;
		.copytodb("__tmpdb");
		__tmpdb.setseparator("|");
		__tmpdb.save(sfile);
		delete __tmpdb;
	}
	load(string sfile)	{
		new db __tmpdb;
		__tmpdb.load(sfile);
		.copyfromdb("__tmpdb");
		delete __tmpdb;
	}
	/*H	{
		if( grtt.size )	<grtt.last>.getey-<grtt.first>.getpy;
		else 0;
	}*/
}

class GUITextBoxTyper : TextBoxTyper	{
	init(string sfont, int ish, int isw, int ir, int ig, int ib, string schars, int x, int y, int w, int h, int dy)	{
		TextBoxTyper::init(sfont,ish,isw,ir,ig,ib,schars,x,y,w,h,dy);
		.vars2(A,"rewinder", null, "rewinderbg", null);
	}
	setrewinder(string s)	{
		rewinder = s;
		rewinderbg = s + "bg";
	}
	activate(int id)	{
		TextBoxTyper::activate(id);
		.updaterewactual;
	}
	updaterewactual	{	.updaterewpos(Row);	}
	updaterewpos(int id)	{
		if( rewinder!=null )	{
			@s = "tt"+id;
			if( <s>.getpy < <rewinderbg>.getpy )		<rewinder>.rewind( 0, <rewinderbg>.getpy - <s>.getpy );
			else if (<s>.getey > <rewinderbg>.getey)		<rewinder>.rewind( 0, <rewinderbg>.getey - <s>.getey );
		}
	}
}

/****************************************************************/
class DelayTaker	{
	init()	{
		new bool bonrel = false;
		new bool bstart = false;
		new bool bclickrel = true;
		this.cnewtimerfin("timwez",300,1, func { bonrel=true; } );
	}
	public setclickrel(bool b)	{	bclickrel=b;	}
	public setdelay(int idelay)	{	timwez.delay(idelay);	}
	public take()	{
		if( bclickrel )	{
			timwez.play();
			bonrel=false;
		} else bonrel=true;
		bstart=true;
		
	}
	public ret()	{
		bonrel=false;
		bstart=false;
		timwez.stop(false);
	}
	public bool isonclick()	{
		this.stoptimer();
		( bstart && !bonrel );
	}
	public bool isonrel()	{
		this.stoptimer();
		( bstart && bonrel );
	}
	public bool istaken()	{	bstart;	}
	public stoptimer()	{	timwez.stop(false);	}
}


class ImgMover	{
	init()	{
		new string smoved=null;
		new int ilastx;
		new int ilasty;
		new int irelx;
		new int irely;
	}
	public mssetobj(string s)	{	this.setobj(s,mouse.getpos);	}
	public setobj(string s, int x, int y)	{	this.set(s,x,y,0,0);	}
	public setcobj(string s)	{	.setobj(s, <s>.getcx, <s>.getcy);	}
	public setpobj(string s)	{	.setobj(s, <s>.getpx, <s>.getpy);	}
	public set(string s, int x, int y, int dx, int dy)	{
		ilastx = <s>.getposx()-dx;
		ilasty = <s>.getposy()-dy;
		irelx = x-<s>.getpx();
		irely = y-<s>.getpy();
		smoved = s;
	}
	public msmove()	{	this.move(mouse.getpos);	}
	public msftmove()	{	this.ftmove(mouse.getpos);	}
	public move(int x, int y)	{
		if( smoved!=null )	<smoved>.setpos( x-<smoved>.lodx()-irelx, y-<smoved>.lody()-irely );
	}
	public ftmove( int x, int y)	{	if( smoved!=null )	<smoved>.setpos( x, y );	}
	public retobj()	{	this.ret(0,0);	}
	public ret(int dx, int dy)	{
		<smoved>.setpos(ilastx+dx, ilasty+dy);
		this.free();
	}
	public put(int x, int y)	{
		<smoved>.setpos(x,y);
		this.free();
	}
	public free()	{	smoved=null;	}
	public string getmover()	{	return smoved;	}
	public string getfree	{	@s = smoved; .free; s; }
	public bool moving()	{	return smoved!=null;	}
}

class ConImgMover : ImgMover, ObjController	{
	init()	{
		ImgMover::init();
		ObjController::init();
	}
	onmousemove()	{	this.msmove();	}
	onmouselclick	{	.<_sme+"_GET">;	}
	onmouselrel	{	if( smoved!=null ) .<_sme+"_PUT">;	}
}

class DelayMover : ImgMover, LObjController	{
	init()	{
		ImgMover::init();
		LObjController::init();
		new DelayTaker cldt; 
	}
	public setclickrel(bool b)	{	cldt.setclickrel(b);	}
	public reset	{	cldt.ret;	}
	_put()	{
		cldt.ret();
		this.<_sme+"_PUT">();
	}
	set(string s, int x, int y, int dx, int dy)	{
		ImgMover::set(s,x,y,dx,dy);
		cldt.take;
	}
	onmousemove()	{	this.msmove();	}
	onmouselclick()	{
		if( this.getlock() ) return;
		if( cldt.isonclick() )	this._put();
		else if (!cldt.istaken())
			this.<_sme+"_GET">();
	}
	onmouselrel()	{
		if( this.getlock() ) return;
		if( cldt.isonrel() )
			this._put();
	}
}

class Rewinder : classlocker	{
	init(int x1, int y1, int x2, int y2)	{
		classlocker::init();
		new string sarrowdir;
		new int ilenx;
		new int ileny;
		new string sgr;
		new string sorientation;
		new bool bvertical;
		new bool bfilteritem = false;
		
		// clip obiektow
		new int ibx1=0;
		new int ibx2=iResX;
		new int iby1=0;
		new int iby2=iResY;
		
		new int iodleg = 2;	// odleglosc pomiedzy przedmiotami
		
		new ImgMover clmv;
		
		this.cnewtimercyclefin("timtick", 1, 1, "timfin");
		
		// granice
		.vars2(A, "borx1", x1, "bory1", y1, "borx2", x2, "bory2", y2);
		
		new snd fxrew;
// 		fxrew.addmethod("onfinish", func { this.play(); } );
	}
	public movefilter()		{	bfilteritem=true;	}
	public movenormal()	{	bfilteritem=false;	}
	public setfxrew(string sfile)	{
		fxrew.load(this.getsndpath()+sfile);
	}
	public getitem(string s, int x, int y)	{
		/*clmv.set(s,x,y,<sgr>.getpx(),<sgr>.getpy());
		<s>.clip(0,0,800,600);
		<sgr>.movefrom(s, 0, -<s>.geth);
		<sgr>.remove(s);*/
		<s>.setz( <s>.getz+1 );
		clmv.set(s,x,y,<sgr>.getpx(),<sgr>.getpy());
		<s>.clip(0,0,iResX,iResY);
		if( sorientation=="up" || sorientation=="down")	{
			<sgr>.movefrom(s, -(<s>.getw+iodleg), 0 );
			<s>.move( <s>.getw,0 );
		} else {
			<sgr>.movefrom(s, 0, -(<s>.geth+iodleg));
			<s>.move(0, <s>.geth );
		}
		<sgr>.remove(s);
	}
	public bool pickup(int x, int y)	{
		if( <sgr>.isin(x,y,true,true) )	{
			this.getitem( <sgr>.getsfound(), x, y );
			return true;
		}
		return false;
	}
	public bool mspickup()	{	return this.pickup(mouse.getpos );	}
	public freeitem()	{	clmv.free();	}
	public moveitem()	{
		if( bfilteritem )		clmv.msftmove();
		else		clmv.msmove();
	}
	public retitem()	{
		string s = clmv.getmover();
		clmv.ret(<sgr>.getpx(),<sgr>.getpy());
		this.putitem(s);
	}
	public putitem(string s)	{
		if( sorientation=="up" || sorientation=="down")	{
			<s>.move( <sgr>.getex-<s>.getpx+iodleg, 0);
		} else {
// 			@dx = anupstd.getex - <s>.getw;
// 			<s>.setpos( dx - <s>.lodx, <sgr>.getey-<s>.lody);
			<s>.move( 0, <sgr>.getey-<s>.getpy+iodleg);
		}
		<sgr>.add(s);
		<s>.setz( <s>.getz-1 );
		<s>.clip(ibx1,iby1,ibx2,iby2);
	}
	public string getmoved()	{	return clmv.getmover();	}
	public int getbutw()	{	return anupstd.getw();	}
	public int getbuth()	{	return anupstd.geth();	}
	public movearrows(int x, int y)	{	grarrows.move(x,y);	}
	public build(string sfile, int z, string scursor, string sorient, int dt, string sgrelem)	{
		sgr = sgrelem;
// 		this.newanima("anupstd",sfile,z);
		new anima anupstd;
		anupstd.load(sfile);
		anupstd.setz(z);
		
		anupstd.setframe("up",0);
		this.copyanima("anupstd","anupact");
		anupact.setframe("up",1);
		this.copyanima("anupstd","andownact");
		andownact.setframe("down",1);
		this.copyanima("anupstd","andownstd");
		andownstd.setframe("down",0);
		this.newbutan("butup","anupstd","anupact",null,scursor);
		this.newbutan("butdown","andownstd","andownact",null,scursor);
		butup.addmethod("onmoveon","_rewbutmoveon");
		butdown.addmethod("onmoveon","_rewbutmoveon");
		butup.addmethod("onmoveoff","_rewstrzalkaoff");
		butdown.addmethod("onmoveoff","_rewstrzalkaoff");
		butup.addmethod("onclick","_rewbutclick");
		butdown.addmethod("onclick","_rewbutclick");
		butup.addmethod("onrel","_rewbutrel");
		butdown.addmethod("onrel","_rewbutrel");
		sorientation=sorient;
		new gmimgvec grarrows;
		_ = "grarrows" .+ "anupstd" .+ "anupact" .+ "andownact" .+ "andownstd";
		
		int dy, int dx, int ix, int iy;
		if( sorientation=="up" || sorientation=="down")	{
			bvertical = false;
			ilenx = dt;
			if( sorientation=="down")	{
				anupstd.setpos(borx1,bory2-anupstd.geth());
				anupact.setpos(borx1,bory2-anupact.geth());
				andownstd.setpos(borx2-andownstd.getw(),bory2-andownstd.geth());
				andownact.setpos(borx2-andownact.getw(),bory2-andownact.geth());
				dy = andownstd.getey();
			} else {
				anupstd.setpos(borx1,bory1);
				anupact.setpos(borx1,bory1);
				andownstd.setpos(borx2-andownstd.getw(),bory1);
				andownact.setpos(borx2-andownact.getw(),bory1);
				dy = bory1;
			}
			ibx1 = anupstd.getex()+iodleg;
			ibx2 = andownstd.getpx()-iodleg;
			dx = ibx1;
		} else {
			bvertical = true;
			ileny = dt;
			if( sorientation=="right")	{
				anupstd.setpos(borx2-anupstd.getw(),bory1);
				anupact.setpos(borx2-anupact.getw(),bory1);
				andownstd.setpos(borx2-andownstd.getw(),bory2-andownstd.geth());
				andownact.setpos(borx2-andownact.getw(),bory2-andownact.geth());
				dx = anupstd.getex();
			} else {
				anupstd.setpos(borx1,bory1);
				anupact.setpos(borx1,bory1);
				andownstd.setpos(borx1,bory2-andownstd.geth());
				andownact.setpos(borx1,bory2-andownact.geth());
				dx = borx1;
			}
			iby1 = anupstd.getey()+iodleg;
			iby2 = andownstd.getpy()-iodleg;
			dy = iby1;
		}
		butup._rewbuildbut(this.getname(),"up");
		butdown._rewbuildbut(this.getname(),"down");
		
		int ile = <sgrelem>.size();
		<sgrelem>._setpos(dx,dy);
		new int ilimx = dx;
		new int ilimy = dy;
		string s;
		for(int i=0; i<ile; i++)	{
			s = <sgr>.get(i);
			if( sorientation=="right")	{
				<s>.setpos( dx - <s>.getw() - <s>.lodx(), dy - <s>.lody() );
				dy += <s>.geth()+iodleg;
			} else if (sorientation=="left")	{
				<s>.setpos( dx - <s>.lodx(), dy - <s>.lody() );
				dy += <s>.geth()+iodleg;
			} else if (sorientation=="up")	{
				<s>.setpos( dx - <s>.lodx(), dy - <s>.lody() );
				dx += <s>.getw()+iodleg;
			} else if (sorientation=="down")	{
				<s>.setpos( dx - <s>.lodx(), dy - <s>.geth() - <s>.lody() );
				dx += <s>.getw()+iodleg;
			}
			<s>.clip(ibx1,iby1,ibx2,iby2);
		}
	}
	/*************************************/
	_rewbuildbut(string s, string s2)	{
		new string _sob = s;
		new string _sdir;
		if( s2=="up" )	{
			if(bvertical==false)	{	_sdir = "left";	}
			else {	_sdir = "up";	}
		} else if (s2=="down")	{
			if(bvertical==false)	{	_sdir = "right";	}
			else {	_sdir = "down";	}
		}
	}
	_rewbutmoveon()	{
		//this.mstrzalkaon(_sdir);
		this.<_sob+"_"+_sdir+"_MOVEON">();
	}
	_rewbutclick()	{
		this.mstrzalkaon(_sdir);
		this.<_sob+"_"+_sdir+"_CLICK">();
	}
	mstrzalkaon(string s)	{
		sarrowdir=s;
		timtick.play();
	}
	_rewbutrel	{
		sarrowdir=null;
		timtick.stop(false);
		fxrew.stop(false);
	}
	_rewstrzalkaoff()	{
		sarrowdir=null;
		timtick.stop(false);
		fxrew.stop(false);
		this.<_sob+"_"+_sdir+"_MOVEOFF">();
	}
	timfin()	{
		if( this.getlock() )	{	return;	}
		bool bok = false;
		if( sarrowdir!=null && !<sgr>.empty())	{
			if( sarrowdir=="up")	{
				if( <sgr>.getey() > andownstd.getpy() - ileny )	{
					<sgr>.move(0,-ileny);
					bok=true;
				}
			} else if (sarrowdir=="down") {
				if( <sgr>.getpy() < ilimy )	{
					<sgr>.move(0,ileny);
					bok=true;
				}
			} else if (sarrowdir=="left")	{
				if( <sgr>.getex() > andownstd.getpx() - ilenx )	{
					<sgr>.move(-ilenx,0);
					bok=true;
				}
			} else if (sarrowdir=="right") {
				if( <sgr>.getpx() < ilimx )	{
					<sgr>.move(ilenx,0);
					bok=true;
				}
			}
		}
		if( bok )	{
			if( !fxrew.isplaying() )	fxrew.play();
		} else {
			fxrew.stop(false);
		}
		this.play();
	}
}

class ConRewinder : Rewinder, ObjController {
	init()	{
		Rewinder::init();
		ObjController::init();
		new DelayTaker cldt; 
	}
	public getitem(string s, int x, int y)	{
		Rewinder::getitem(s,x,y);
		cldt.take();
	}
	_put()	{
		cldt.ret();
		this.<_sme + "_PUT">();
	}
	onmousemove()	{	this.moveitem();	}
	onmouselrel()	{
		if( this.getlock() )	return;
		if( cldt.isonrel() )	{	this._put();	}
	}
	onmouselclick()	{
		if( this.getlock() ) return;
		if( cldt.isonclick() )	{
			this._put();
		} else if ( !cldt.istaken() )	{
			this.<_sme+"_GET">();
		}
	}
}

class Button : LObjController	{
	init	{
		LObjController::init;
		.unlock;
		new gmimgvec grbuts;
		.vars2(A,"sobject", null, "sclicked",null);
	}
	sort	{ grbuts.sortimgs; }
	addgroups	{	grbuts.addgroups;	grbuts.sortimgs;	}
	addgroup(string s)	{	grbuts.addgr(s);	grbuts.sortimgs;	}
	addlist		{	grbuts.addlist;		grbuts.sortimgs;	}
	add(string sob)	{	grbuts.add(sob);	grbuts.sortimgs;	}
	addlocker(string sob)	{
		.add(sob);
		classlocker::setaslocker(sob);
	}
	removebutlist	{	.withlist("removebut"); }
	removebut(string sbut)	{
		grbuts.remove(sbut);
		if( sbut==sobject ) sobject=null;
		if( sbut==sclicked ) sclicked = null;
	}
	load(string sname, string sfile, string sfuninit) {
		<GAME>.varnew("gmimgvec", sname);
		sname .* sfile;
		<sname>.each( sfuninit );
		.addgroup(sname);
	}
	remove(string sname)	{
		if( <GAME>.hasvar(sname) )	{
			//for( int i=0; i < <sname>.size; i++ )	grbuts.remove( <sname>.get(i) );
			grbuts.removegr(sname);
		}
	}
	loadfrom(string sname, string spath, string sfile, string sfuninit) {
		@s = .getgraphpath;
		.setgraphpath(spath);
		.load(sname,sfile,sfuninit);
		.setgraphpath(s);
	}
	onmouselclick	{
		if( .getlock ) return;
		.<this + "_lclick">;
		if( sobject!=null)	{
			sclicked = sobject;
			if (<sobject>.hasaddedmet("butclick") )
				<sobject>.butclick;
		}
	}
	onmouselrel	{
		if( .getlock ) return;
		.<this + "_lrel">;
		if( sclicked!=null && <sclicked>.hasaddedmet("butlrel") )	{
			<sclicked>.butlrel;
		} else sclicked=null;
	}
	onmousemove	{
		if( .getlock ) return;
		if( sclicked!=null )	{
			if( <sclicked>.hasaddedmet("butmoving") )	<sclicked>.butmoving;
		}
		|int x, int y| = mouse.getpos;
		if(grbuts.isinfunc(x,y,"isbutin") )	{
			@s = grbuts.getsfound;
			if( s!=sobject )	{
				.lastoff;
				sobject = s;
				.<this + "_moveon">;
 				if( <s>.hasaddedmet("butmoveon") )
					<s>.butmoveon;
			}
		} else {
			.lastoff;
		}
	}
	lastoff	{
		if( sobject!=null )	{
			.<this + "_moveoff">;
			if( <sobject>.hasaddedmet("butmoveoff") )
				<sobject>.butmoveoff;
			sobject = null;
		}
	}
	/*
	virtual bool isbutin(int x, int y)	{ 0; }
	virtual butclick	{}
	virtual butmoveon {}
	virtual butmoveoff {}*/
}
public Button_isin			{	.addmethod("isbutin", func { (@x,@y) .isin(x,y,1,0); } );	}
public Button_isinvis			{	.addmethod("isbutin", func { (@x,@y) .isin(x,y,0,0); } );	}
public Button_isinalpha	{	.addmethod("isbutin", func { (@x,@y) .isin(x,y,1,1); } );	}
public Button_moveon		{
	.addmethod("butmoveon", func {
		sndakskermovon.play;
		advmouse.setbut;
		if( .nofframes(-1)>1 ) .setframe(-1,1);
	} );
}
public Button_moveoff		{	.addmethod("butmoveoff", func { advmouse.setstd; .setframe(-1,0);} );	}
public Button_moveonms	{	.addmethod("butmoveon", func { advmouse.setbut; } );	}
public Button_moveoffms	{	.addmethod("butmoveoff", func { advmouse.setstd; } );	}
public Button_std			{ .Button_isin; .Button_moveon; .Button_moveoff;	}
public Button_stdalpha		{ .Button_isinalpha; .Button_moveon; .Button_moveoff;	}

class Buttons : LObjController	{
	init(string sfile)	{
		LObjController::init;
		.unlock;
		new gmimgvec grbuts;
		new int __id = 0;
		new string sanbut = "anbut";
		.newanima(sanbut, sfile, 10);
		_ = .newanactionsgr(sanbut, sanbut, "grbuts");
		anbut.hide;
		grbuts.setz(10);
		grbuts.removeif( func {
			if( .actionname=="bkg" ) { .setz( .getz-1); true; }
			else false; 
			});
		new string slastb = null;
		.vars2(A,"sobject", null, "bvisible", true, "balpha", true);
	}
	_release()	{
		<slastb>.setframe(-1,0);
		.copyobj;
		.<this + "_moveoff">();
		slastb = null;
		bsms.setstd;
	}
	getbut	{	grbuts.getsfound;	}
	onmousemove()	{
		if( .getlock ) return;
		grbuts.setframe(-1,0);
		def id =  grbuts.isin(mouse.getpos,bvisible,balpha);
		if( slastb!=null ) <slastb>.setframe(-1, 1);
		if( id ) {
			string s = grbuts.getsfound;
			if( s!=slastb )	{
				if( slastb!=null )	._release;
				slastb = s;
				<s>.setframe(-1,1);
				.copyobj;
				bsms.setact;
				.<this + "_moveon">();
			}
		} else if( slastb!=null )	{
			._release;
		}
		//slastb==null ? bsms.setstd : bsms.setact;
	}
	copyobj()	{	sobject = <slastb>.actionname;	}
	onmouselclick()	{
		if( .getlock ) return;
		if( slastb!=null )	{
			.copyobj;
			.<this + "_lclick">;
		}
	}
	onmouselrel	{
		if( .getlock ) return;
		if( slastb!=null )	{
			.copyobj;
			.<this + "_lrel">;
		}
	}
	disable	{
		.lock;
		grbuts.hide;
		if( slastb!=null )	{
			bsms.setstd;
			slastb=null;
		}
	}
	enable	{
		.unlock;
		grbuts.show;
	}
}

class TextDb : classlocker, ObjController, gfxObject {
	init(string sfont, int isize, string sdbfile, int r, int g, int b, int x, int y, int dy, int z, string sdir)	{
		classlocker::init;
		ObjController::init;
		new string sFont = sfont;
		sfont = .checkfont( sfont, isize );
		new int iFontSize = isize;
		string s;
		int id, int i;
		.var2("Z",z);
		if( sdbfile.contains(".db") )	{
			if( sdbfile.getb(0,6)=="$path:" )	{
				new db dbtxt;
				dbtxt.load( sdbfile.strsubb(6) );
			} else .newdb( "dbtxt", sdbfile );
		} else {
			new db dbtxt;
			match(sdbfile.getb(0,5))	{
				"$var:" => dbtxt.dbcopy( sdbfile.strsubb(5) );
				"$row:" => {
					s = sdbfile.strsubb(5)->strgetto(",");
					id = sdbfile.strgetfrom(",");
					for( i=0; i< <s>.getcolsno(id); i++)	{
						_ = dbtxt.addrow;
						dbtxt.add(i, <s>.get(id,i) );
					}
				}
				? => dbtxt.dbaddlast( sdbfile );
			}
		}
		int w = 0, int ile = dbtxt.getrowsno;
		new gmimgvec grtxt;
		grtxt._setpos(x,y);
		for( i=0; i< ile; i++)	{
			s = "txt" + i;
			new text <s>;
			<s>.setfont( sfont );
			<s>.set( dbtxt.get(i,0) );
			<s>.setpos(x,y);
			y+=isize+dy;
			<s>.setz(z);
			<s>.createtxt(r,g,b);
			if( <s>.getw>w ) w = <s>.getw;
			grtxt.add(s);
		}
		.var2("Rows", ile);
		if( sdir == "right" || sdir =="center" )	{
			for( i=0; i<ile; i++)	{
				s = "txt" + i;
				if( sdir == "center" )	{
					<s>.move( (w-<s>.getw)/2, 0 );
				} else {
					<s>.move( w-<s>.getw, 0 );
				}
			}
		}
		.var2("W", w);
		gfxObject::init("grtxt");
	}
	stdshadow(int dt)	{	.setshadow(0,0,0,dt);	}
	setshadow(int r, int g, int b, int dt)	{
		string s[2];
		string sfont = ._checkfont(sFont, iFontSize, "_fntbrd");
		for( int i=0; i< dbtxt.getrowsno; i++)	{
			s0 = "txt" + i;
			s1 = "txts" + i;
			new text <s1>;
			<s1>.set( <s0>.get );
			<s1>.setfont( sfont );
			<s1>.setz( <s0>.getz-1 );
			<s1>.setpos( <s0>.getpx+dt, <s0>.getpy+dt );
			<s1>.createtxt(r,g,b);
			grtxt.add(s1);
		}
	}
	setz(int z)	{
		/*for( int i=0; i< dbtxt.getrowsno; i++)	{
			<"txt" + i>.setz(z);
			<"txts" + i>.setz(z-1);
		}*/
		Z = z;
		grtxt.setz(z);
	}
	getz	{ Z;	}
	isin(int x, int y, bool bv, bool ba)	{	grtxt.isin(x,y,bv,ba);	}
	view	{
		@s = _;
		string s2;
		while(A!=s)	{
			s2 = grtxt.get(s);
			<s2>.show;
			s2 = "txts" + s2.strsubbs("txt");
			if( engine.varexist(s2) ) <s2>.show;
			@s=_;
		}
	}
	blitto(string simg)	{
		string s;
		for( int i=0; i<grtxt.size; i++)	{
			s = grtxt.get(i);
			<s>.buildfullname;
			<simg>.blit(<s>.getfullname);
			<GAME>.vardel(<s>.getfullname);
		}
	}
	setcol(int r, int g, int b)	{
		for( int i=0; i<grtxt.size; i++) <grtxt.get(i)>.createtxt(r,g,b);
	}
}

class Lexer	{
	init	{}
	buildlex	{
		.vars(A,"id","found");
		new vector vconsts;
		vconsts.type("string");
		new vector vtmp1;
		vtmp1.type("string");
		new vector vtmp2;
		vtmp2.type("string");
		
		new int dot = "."->getbyte(0);
		new string _literal_char = "\"";
	}
	setliteralchar(string s)	{	_literal_char=s;	}
	getliteralchar	{	_literal_char;	}
	bool _isvar(int b1, int b2)	{
		int i = id;
		found = "";
		int ib;
		while(i<.length)	{
			ib = .getbyte(i);
			if( ib>=b1 && ib<=b2 )	{
				found += .getb(i,1);
				i++;
			} else {
				if( (ib>=BYTEa && ib<=BYTEz) || (ib>=BYTEA && ib<=BYTEZ) || ib==BYTE_ )	found="";
				i = .length;
			}
		}
		found.length;
	}
	bool isreal	{
		int i = id;
		found = "";
		int ib;
		bool kropka=true;
		while(i<.length)	{
			ib = .getbyte(i);
			if( (ib>=BYTE0 && ib<=BYTE9) || (ib==dot&&kropka) )	{
				if( ib==dot ) kropka=false;
				found += .getb(i,1);
				i++;
			} else i = .length;
		}
		if( kropka || found.getb(0,1)=="." || found.gete(0,1)=="." ) found="";
		found.length;
	}
	bool isident	{
		int i = id;
		found = "";
		int ib;
		while(i<.length)	{
			ib = .getbyte(i);
			if( (ib>=BYTEa && ib<=BYTEz) || (ib>=BYTEA && ib<=BYTEZ) || ib==BYTE_ ||
				(i>id && ib>=BYTE0 && ib<=BYTE9) )	{
				found += .getb(i,1);
				i++;
			} else i = .length;
		}
		found.length;
	}
	bool isliteral	{
		if( .check!=.getliteralchar )	return false;
		int i = id+1;
		found = "";
		string s;
		while(i<.length)	{
			s = .getb(i,1);
			if( s==.getliteralchar )	{
				//found += s;
				return true;
			} else {
				found += s;
				i++;
			}
		}
		false;
	}
	bool isconst	{
		string s0;
		bool b = .isident;
		for( int i=0; i< vconsts.size; i++)	{
			s0 = vconsts.get(i);
			if( b )	{
				if( s0 == found )	return true;
			} else {
				found = .getb(id, s0.length);
				if( s0 == found ) return true;
			}
		}
		false;
	}
	gettoken(string svec, bool bideal)	{
		<svec>.free;
		while( .notend )	{
			if (.check==" ")	id++;
			else if (.isconst)	{	<svec>.add("$const"); <svec>.add(.read);	}
			else if (.isreal )		{<svec>.add( "$real" );	.next; if( bideal ) <svec>.add( found );}
			else if (.isint )		{<svec>.add( "$int" );	.next; if( bideal ) <svec>.add( found );}
			else if (.isident )	{<svec>.add( "$alpha" );	.next; if( bideal ) <svec>.add( found );}
			else if (.isliteral )	{<svec>.add( "$literal" );	.next; id+=2; if( bideal ) <svec>.add( found );}
			else	{<svec>.add("$error"); id++; }
		}
	}
	int expectdb(string sdb, bool bideal)	{	// identyczne lub parse
		int j, string s;
		for( int i=0; i< <sdb>.getrowsno; i++)	{
			//vtmp2.veccopydbrow(sdb,i);
			vtmp2.free;
			for( j=0; j< <sdb>.getcolsno(i); j++)	{
				s = <sdb>.get(i,j);
				s.clear;
				if( s!="" ) vtmp2.add(s);
			}
			if( .expectvec("vtmp2", bideal) )	return i;
		}
		-1;
	}
	bool expectvec(string svecsrc, bool bideal)	{
		id = 0;
		.gettoken("vtmp1", bideal);
		/*vtmp1.print;
		<svecsrc>.print;*/
		vtmp1.veceq(svecsrc);
		/*bool b = vtmp1.veceq(svecsrc);
		if( !b ) {
			("wrong expect "+.get)->print;
			vtmp1.print;
			<svecsrc>.print;
		}
		b;*/
	}
	bool expects(string s, string ssep, bool bideal)	{
		vtmp2.vecbuildfromstring(s,ssep);
		.expectvec("vtmp2", bideal);
	}
	consts=	{	vconsts.withlist("addbegin");	}
	setas(string sob)	{
		<sob>.addmethod("buildlex", "buildlex");
		<sob>.buildlex;
		<sob>.addmethod("start",	func { (string s) .set(s);	id=0; } );
		<sob>.addmethod("notend",	func {	id<.length;	} );
		<sob>.addmethod("getnext",	func { if( id==.length ) return null;
					id++;	.getb(id-1,1);	} );
		<sob>.addmethod("next",	func { id+=found.length;	} );
		<sob>.addmethod("check",	func { if( id==.length ) return null; found=.getb(id,1); found; });
		<sob>.addmethod("ischar",	func { (string s) s.contains( .getb(id,1) ); } );
		<sob>.addmethod("isint",	func{	._isvar(BYTE0, BYTE9);	} );
		<sob>.addmethod("isreal", "isreal");
		<sob>.addmethod("isbinary",	func{	._isvar(BYTE0, BYTE0+1);	} );
		<sob>.addmethod("isident",	"isident" );
		<sob>.addmethod("isconst",	"isconst" );
		<sob>.addmethod("_isvar", "_isvar");
		<sob>.addmethod("read",	func { .next;	found;	} );
		<sob>.addmethod("isliteral", "isliteral");
		<sob>.addmethod("gettoken", "gettoken");
		<sob>.addmethod("expects", "expects");
		<sob>.addmethod("expectvec", "expectvec");
		<sob>.addmethod("expectdb", "expectdb");
		<sob>.addmethod("consts=", "consts=");
		<sob>.addmethod("setliteralchar", "setliteralchar");
		<sob>.addmethod("getliteralchar", "getliteralchar");
	}
}


class AnimaFx	{
	init {}
	build(string san)	{
		<san>.addmethod("_buildanfx", func {
			new db dbsnd;
			dbsnd.dbbuild(3);
			for( int i=0; i<dbsnd.getrowsno; i++) dbsnd.set(i,0, dbsnd.get(i,0)+"_"+dbsnd.get(i,1));
			} );
		<san>._buildanfx;
		<san>.addmethod("onsetframe", func {
			@id = dbsnd.findbyrow(.actionname+"_"+.framenr);
			if( id>=0 ) {
				<"fx"+dbsnd.get(id,2)>.play;
			}
			} );
	}
}

class Localize	{
	init	{}
	_lang_db(string sname, string sfile, string sfunload)	{
		new db <sname>;
		<sname>.<"load"+sfunload>( .lang_path(sfile) + ".db");
	}
	lang_db(string sname, string sfile)	{ ._lang_db(sname,sfile,"");	}
	lang_dbscript(string sname, string sfile)	{ ._lang_db(sname,sfile,"script");	}
	lang_dbbeh(string sname, string sfile)	{ ._lang_db(sname,sfile,"beh");	}
	lang_path(string sfile)	{ "lang/" + gameapi.getgamename + "_" + sfile + LANG; }
}


module advmouse	{
	init()	{
		new anima anmsc;
	}
	public load(string sname)	{
		anmsc.load(sname);
		anmsc.hide();
	}
	set(string saction)	{
		anmsc.show();
		anmsc.setframe( saction, 0 );
		mouse.setcursor("anmsc");
		anmsc.hide();
	}
	setstd()	{	this.set("normal");	}
	setactive()	{	this.set("active");	}
	setbut	{	this.set("active");	}
	setexit()	{	this.set("exit");	}
	setwait()	{	this.set("wait");	}
	get()		{	return anmsc.actionname();	}
}

class classadvobject	{
	init()	{
		this.addasadvobject();
	}
	addasadvobject()	{
		if( !AdventureGame ) return;
		string s = this.getname();
		grmsmove.add(s);
		grmslrel.add(s);
		grmslclick.add(s);
		grmsrclick.add(s);
	}
	removefromadvobjs()	{
		if( !AdventureGame ) return;
		string s = this.getname();
		grmsmove.remove(s);
		grmslrel.remove(s);
		grmslclick.remove(s);
		grmsrclick.remove(s);
	}
	virtual onmousemove(int x, int y)	{}
	virtual onmouselclick(int x, int y)		{}
	virtual onmouselrel(int x, int y)		{}
	virtual onmouserclick(int x, int y)		{}
}

/*
	klasa bazowa, zawiera podstawowe metody i zmienne bohatera przygodowki
	Dominik Dagiel 3 III 2006
*/

class classadvanhero	{
	init()	{}
	public setashero(string sanima, string sfunonfinish)	{
		<sanima>.addmethod("buildhero", "buildhero");
		<sanima>.addmethod("onendframe", "heroendframe1");
		<sanima>.buildhero();
		<sanima>.addmethod("buildheroframe", "buildheroframe");
		<sanima>.addmethod("onfinish", "herofinish");
		<sanima>.addmethod("getdir", "getdir");
		<sanima>.addmethod("setdir", "setdir");
		<sanima>.addmethod("thisfinish", "thisfinish");
		<sanima>.addmethod("playspec", "playspec");
		<sanima>.addmethod("playspec2", "playspec2");
		<sanima>.addmethod("herostop", "herostop");
		<sanima>.addmethod("herostart", "herostart");
		<sanima>.addmethod("herostand", "herostand");
		<sanima>.addmethod("setstdfin", "setstdfin");
		<sanima>.addmethod("getpocket", "getpocket");
		<sanima>.addmethod("haspocket", "haspocket");
		<sanima>.addmethod("setstandbase", "setstandbase");
		<sanima>.setstdfin( sfunonfinish );
	}
	buildheroframe(string san)	{	<san>.addmethod("onendframe", "heroendframe");	}
	setstdfin(string s)	{	this.addmethod("onstdfinish", s);	}
	setstandbase(string s)	{	_sstandbase = s;	}
	buildhero()	{
		new string _sbase;	// baza akcji
		new int _istate = 0;	// 0 - neutral, 1 - start, 2 - body, 3 - stop
		new string _sfinfun;	// metoda do wywolania na finish akcji bohatera
		new string _sobfin;	// obiekt na ktorym wywolac metode na finish (jak null to this)
		new bool _bplaystop;	// czy odegrac stop
		new int _iiloscsek;	// ilosc sekwencji
		new int _itypsort;		// 0 - po kolei, 1 - random
		new int idsort;		// kolejny nr kawalka
		new string _sobstart;	// obiekt na finish start
		new string _sfunfinstart;	// metoda na finish start
		new bool bthisfin = false;	// czy finish jest w animacji a nie z zewnatrz
		new string _sstandbase = "stand";
	}
	getpocket()	{	return _spocketpref + this.getname(); }
	bool haspocket()	{	return engine.varexist(_spocketpref+this.getname());	}
	thisfinish(bool bfin)	{	bthisfin=bfin;	}
	string getdir()	{	return this.actionname()->gete(0,2);	}
	setdir(string sdir)	{	.setframe( .actionname->strsube(2) + sdir, .framenr );	}
	playspec(string sbase, int iloscsek, int itypsort, bool bstart, string sobstart, string sfunfinstart,
		bool bstop, string sobfin, string sfinfun, string sdir)	{
		_sbase = sbase;
		_iiloscsek = iloscsek;
		_itypsort = itypsort;
		_bplaystop = bstop;
		_sobfin = sobfin;
		_sfinfun = sfinfun;
		_sobstart = sobstart;
		_sfunfinstart = sfunfinstart;
		if( iloscsek > 0 )	{
			if( itypsort==0 )	{	idsort = 1;	}
			else if (itypsort==1)	{	idsort = iloscsek.rand + 1; }
		}
		if( bstart )	{
			_istate = 1;
			this.play( sbase + "start" + sdir );
		} else {
			this.setframe( sbase + (iloscsek>0?"1"+sdir:sdir), 0 );
			this.herostart();
		}
	}
	playspec2(string sact, string sobfin, string sfinfun)	{
		string s = ( sact.length()<2 ) ? "" : sact.strsube(2);
		this.playspec( s, 0, 0, false, null, null, false, sobfin, sfinfun, sact.gete(0,2));
	}
	herostop()	{
		_istate = 3;
		if( _bplaystop )	{
			_bplaystop = false;
			this.thisfinish(true);
			this.play( _sbase + "stop" + this.getdir() );
		} else {
			this.stop(true);
		}
	}
	herostart()	{
		_istate = 2;
		this.play( _sbase + (_iiloscsek>0 ? idsort : "") + this.getdir() );
	}
	herofinish()	{
		if( _istate==2 && bthisfin )	_istate=3;
		if (_istate==0 )	{		// standardowy finish
			this.herostand();	// 28.V.2006
			this.onstdfinish();
// 			this.< this.getname() + "_FINISH">();
			string sanimo = this.getname();
			string sevent = <sanimo>.actionname();
			this.<sanimo+"_FINISH">();
			this.<sanimo+"_ACTION_"+sevent+"_FINISH">();
		} else if( _istate==1)	{
			this.herostart();
			this.callfun(_sobstart,_sfunfinstart);
		} else if( _istate==2 )	{
			string s;
			if( _iiloscsek > 0 )	{
				if( _itypsort==0)	{	idsort = (idsort%_iiloscsek)+1;	}
				else if (_itypsort==1)	{	idsort = _iiloscsek.rand + 1; }
				s = _sbase + idsort + this.getdir();
			} else s = this.actionname();
			this.play( s );
		} else if ( _istate==3 )	{		// koniec stop
			_istate = 0;
			this.herostand();	// 28.V.2006
			this.thisfinish(true);
			this.callfun(_sobfin,_sfinfun);
		}
	}
	herostand()	{
		string s = _sstndpref + this.getname();
		if( engine.varexist(s) )	{
			this.play( _sstandbase + this.actionname()->gete(0,2) );
			<s>.play();
		}
	}
	heroendframe1()	{	this.< this.getname() + "_ENDFRAME" >();	}
	heroendframe()	{
		this.setz( this.getposy()-clcamera.getposy );
		if( this.haspocket() )	{
			<this.getpocket()>.pocketpos( this.getposx(), this.getposy() - this.geth()/2);
		}
		this.< this.getname() + "_ENDFRAME" >();
	}
}

/******************************************************/

class classadvhero 	{
	init()	{
		new string _sanim;		// podlinkowana animacja
		new bool _bisvecile = false;	// czy operacja sklada sie z kawalkow
		
		new string _sbase = null;		// bazowa nazwa akcji
		new string _sbase2 = null;
		new int izakres = 0;		// length of string _sbase
		
		new string _sbs2;
		new string _sbutoper;
		new string _smetpart;
		
		new string _simgbut;	// button z ktorego czyta dane
		new string _sptfname = this.getname();
	}
	string getptfname()	{	return _sptfname;	}
	public link(string sanim)	{	_sanim = sanim;	}
	public link2(string sanima, string sbase)	{
		this.link(sanima);
		this.checkamounts( sbase );
	}
	public anstand()	{	<_sanim>.play("stand"+this.getdir());	}
	public ansay()		{	<_sanim>.play("talk"+this.getdir());	}
	public string getdir()	{	<_sanim>.actionname()->gete(0, 2);	}
	public int nofpieces()	{	return this.nofpiecesdir( this.getdir() ); }
	public int nofpiecesdir(string sdir)	{return _bisvecile ? vecile.get( vecdirs.find(sdir) ) : 0;	}
	public setbase2(string sbase, string sbase2)	{
		this.setbase(sbase);
		_sbase2 = sbase2;
	}
	public setbase(string sbase)	{
		_sbase = sbase;
		izakres = sbase.length();
	}
	public getpropdir(string sdir)	{	return sdir=="auto" ? this.getdir() : sdir;	}
	/*****************************/
	_buildamounts()	{
		if( !_bisvecile )	{
			_bisvecile = true;
			new vector vecdirs;
			vecdirs.type("string");
			vecdirs.beginadd("begin", "uu", "ru", "rr", "rd", "dd", "ld", "ll", "lu" );
			new vector vecile;
		}
	}
	_clearvecile()	{
		vecile.free();
		vecile.resize( 8, 0 );
	}
	public checkamounts(string sbase)	{
		this.setbase(sbase);
		this._buildamounts();
		this._clearvecile();
		if( _sanim == null )	return;
		int ile = <_sanim>.nofactions();
		string s1, int i1;
		
		for(int  i=0; i < ile; i++)	{
			s1 = <_sanim>.nameofaction(i);
			if( s1.getb(0,izakres) == sbase )	{
				i1 = s1.getb( izakres, 10 );
				if( i1>0 )	{	// jest kolejna animacja gadania
					vecile.vecinc( vecdirs.find( s1.gete(0,2) ) );
				}
			}
		}
	}
	public getanim	{	_sanim;	}
	/********************************/
	virtual calllastfun()	{
		this.< this.getcallfin() >();
		<_simgbut>.checkonce;
	}
	_calllastfunfin()	{
		this.calllastfunfin();
		this.advmsunlock();
	}
	virtual calllastfunfin()	{	this.< this.getcallfin() + "_FINISH" >();	}
	virtual string getcallfin()	{	return _sanim+_smetpart+_sbutoper;	}
	_cplay(string sbase, string sfun, string sdir)	{
		this.advmslock();		// blokuj mysz
		<_sanim>.thisfinish(true);
		if( sbase==null )	{
			<_sanim>.setdir( .getpropdir(sdir) );
			if( sfun!=null )	this.<sfun>();
		} else {
			<_sanim>.playspec( sbase, 0, 0, false, null, null, false, 
				this.getname(), sfun, this.getpropdir(sdir) );
		}
	}
	_cplay1(string sbase, string sdir)	{	this._cplay(sbase,"_cplay1_2", sdir);	}
	_cplay1_2()	{
		this.calllastfun();
		this._callbehs();
	}
	_callbehs()	{
		this.advmsunlock();
		this.callbehs();
	}
	virtual callbehs()	{
		string s = this.getcallfin();
		this.behexist("beh_"+s) ? this.playbehobfin( "beh_" + s, this.getname(), "_calllastfunfin" ) : this._calllastfunfin();
	}
	_cplay2_2()	{
		this.calllastfun();
		this._cplay(_sbs2, "_callbehs", this.getdir() );
	}
	_cplay2(string sbase1, string sbase2, string sdir)	{
		_sbs2 = sbase2;
		this._cplay(sbase1, "_cplay2_2", sdir);
	}
	bool no_turn(string sfun)	{
		string sptf = _spathpref + _sanim;
		string sdir = .getpropdir( <_simgbut>.getbutdir );
		if( engine.varexist(sptf) && .getdir != sdir )	{
			<sptf>.heroturn(sdir, this, sfun);
			false;
		} else true;
	}
	_heroplay1	{	.heroplay1(_simgbut);	}
	_heroplay2	{	.heroplay2(_simgbut);	}
	public heroplay1(string simg)	{
		_simgbut=simg;
		if( .no_turn("_heroplay1") )	{
			_sbutoper = <simg>.getbutname();
			this._cplay1( <simg>.getbase1(), this.getpropdir( <simg>.getbutdir() ) );
		}
	}
	public heroplay2(string simg)	{
		_simgbut=simg;
		if( .no_turn("_heroplay2") )	{
			_sbutoper = <simg>.getbutname();
			this._cplay2( <simg>.getbase1(), <simg>.getbase2(), this.getpropdir( <simg>.getbutdir() ) );
		}
	}
	_setbase2(string styp)	{	this.setbase2( modadv.get(styp,1), modadv.get(styp,2) );	}
	_setbase(string styp)	{	this.setbase( modadv.get( styp, 1 ) );	}
	public heroplay3(string simg, string sb)	{
		<simg>.setbutbase1(modadv.get(sb,1));
		<simg>.setbutbase2(modadv.get(sb,2));
		this.heroplay2(simg);
	}
	/********************************/
}

/******************************************************/
new snd _fxtakeitem;
class classherotaker : classadvhero	{
	init() {
		classadvhero::init();
		_smetpart = "_PICKUP_";
	}
	public herotake(string simg)	{	this.heroplay2(simg);	}
	virtual calllastfun()	{
		if( <_sanim>.haspocket() )	{
			_fxtakeitem.play;
			if( <_simgbut>.hideontake )
				<_simgbut>.hide();		// zabranie przedmiotu
			else <_simgbut>.setbuttyp("but");
			< <_sanim>.getpocket() >.additem( _sbutoper, <_simgbut>.getpocket );
		}
		classadvhero::calllastfun();
	}
}

/******************************************************/

class classherolooker : classadvhero	{
	init()	{
		classadvhero::init();
		_smetpart = "_OPERATE_";
	}
	public herolook(string simg)	{	this.heroplay2(simg);	}
	public herooperate(string simg)	{	this.heroplay2(simg);	}
	public heroopendoor(string simg)	{	this.heroplay3(simg,"open:");	}
	public heroclosedoor(string simg)	{	this.heroplay3(simg,"close:");	}
}

/******************************************************/

class classherouser : classadvhero	{
	init()	{
		classadvhero::init();
		new string _stool;
	}
	public herouse(string stool, string simg)	{
		//_stool = this.getusetool();
		_stool = stool;
		_smetpart = "_USE_"+_stool+"_ON_";
		< <_sanim>.getpocket() >.itemhide();
		//this.heroplay2(simg);
		_simgbut=simg;
		_sbutoper = <simg>.getbutname();
		this._cplay2( <simg>.baseuse1, <simg>.baseuse2, this.getpropdir( <simg>.getbutdir() ) );
	}
	virtual calllastfun()	{
		this.< _sanim + "_USE_" + _stool>();
		this.< _sanim + "_USE_ON_" + _sbutoper>();
		this.< this.getcallfin() >();
	}
	virtual calllastfunfin()	{
		this.< _sanim + "_USE_" + _stool + "_FINISH">();
		this.< _sanim + "_USE_ON_" + _sbutoper + "_FINISH">();
		this.< this.getcallfin() + "_FINISH" >();
	}
	virtual callbehs()	{
		string s = this.getname();
		if( this.behexist( "beh_" + this.getcallfin() ) )	{
			this.playbehobfin( "beh_" + this.getcallfin(), s, "_calllastfunfin" );
		} else  if( this.behexist( "beh_" + _sanim + "_USE_ON_" + _sbutoper ) )	{
			this.playbehobfin( "beh_" + _sanim + "_USE_ON_" + _sbutoper, s, "_calllastfunfin" );
		} else  if( this.behexist( "beh_" + _sanim + "_USE_" + _stool ) )	{
			this.playbehobfin( "beh_" + _sanim + "_USE_" + _stool, s, "_calllastfunfin" );
		} else if ( this.behexist( "beh_"+_sanim+"_USE" ) )	{
			this.playbehobfin( "beh_" + _sanim + "_USE", s,"_calllastfunfin" );
		} else {
			this._calllastfunfin();
		}
	}
}

/******************************************************/
/**	metody rozpoczynajace sie na "c" sa metodami klasy, natomiast na "ob" dotycza obiektu "pathf" **/

class classpathf : classadvhero	{
	init()	{ 
		classadvhero::init();
		new path ptf;
		new string swalkto = null;
		new string _sfunnopath = null;
		new string _sfunvisit = null;
		new int destx;	// dla startgo
		new int desty;	// jezeli jest startgo
		new bool bzmien = false;
		new bool bzatrzym = false;
		new string _sitem=null;
		new string _sobzmien = null;
		new string _sfunzmien = null;
		new int _istep;
		new int _itmpspeed;
		.vars2(A, "ispathto", 1);
		ptf.addmethod("onfinish", "_cptffin");
		ptf.addmethod("onvisit","_cptvisit");
		this.addsigs("_cptfstdreach", "_cptfstdarrive");
		this._setbase( "go:" );
	}
	_buildan(string san)	{
		ptf.linkanima(san);
		this.link(san);
	}
	public build(string san, string sfile, int x, int y, int istep, int ityp)	{
		_istep = istep;
		ptf.build(sfile, x, y, istep, ityp);
		this._buildan(san);
	}
	public buildfrom(string san, string spathf, int istep)	{
		_istep = istep;
		ptf.copy(spathf, istep );
		this._buildan(san);
	}
	public addsigs(string sreach, string sarrive)	{
		if(sreach!=null)	{
			ptf.addmethod("onreach", sreach);
		}
		if(sarrive!=null)	{
			ptf.addmethod("onarrive", sarrive);
		}
	}
	public sigonnopath(string snopath)	{	_sfunnopath = snopath;	}
	public sigonvisit(string svisit)	{	_sfunvisit = svisit;	}
	_cptfstdreach(string s)	{}
	_cptfstdarrive()	{}
	/************************** funkcje dla pathf ***************************************/
	public move(int x, int y)	{	ptf.move( x, y );	}
	public setpos(int x, int y)	{	ptf.setpos(x,y);	}
	public show()	{	ptf.show();	}
	public hide()	{	ptf.hide();	}
	public enable(int id)	{	ptf.enable(id);	}
	public disable(int id)	{	ptf.disable(id);	}
	public setanstep(int istep)	{	_istep=istep; ptf.setanstep(istep);	}
	public mulspeed(int speed)	{	_itmpspeed=speed*_istep; ptf.setanstep(_itmpspeed);	}
	public retstep	{	.setanstep(_istep);	}
	public int getanstep()	{	return _istep;	}
	public int getposx()	{	return ptf.getposx(); }
	public int getposy()	{	return ptf.getposy(); }
	public int getpx()	{	return ptf.getpx(); }
	public int getpy()	{	return ptf.getpy(); }
	public int getidan()	{	return ptf.getidan(); }
	public int getidan2()	{	return ptf.getidan2(); }
	public int getidgo()	{	return ptf.getidgo(); }
	public int getidanpath()	{	return ptf.getidanpath(); }
	public int getidan2path()	{	return ptf.getidan2path(); }
	public int getidgopath()	{	return ptf.getidgopath(); }
	public excludev(int id)	{	ptf.excludev(id);	}
	public linkfilter()	{	ptf.linkfilter();	}
	public unlinkfilter()	{	ptf.unlinkfilter();	}
	public unlinkanima()	{	ptf.unlinkanima();	}
	public linkanima(string san)	{ ptf.linkanima(san);	}
	public setscalepower(real rs)	{	ptf.setscalepower(rs);	}
	public setzsize(real rs)	{	ptf.setzsize(rs);	}
	public bool iswayto(int x, int y)	{	return ptf.iswayto(x,y);	}
	public scalean()	{	ptf.scalean();	}
	public int getfromver(int ifrom, int ile, int ito)	{	return ptf.getfromver(ifrom,ile,ito);	}
	public int getgover(int ile)	{	return ptf.getgover(ile);	}
	public int getanver(int ile)	{	return ptf.getanver(ile);	}
	public int getxver(int id)	{	return ptf.getxver(id);	}
	public int getyver(int id)	{	return ptf.getyver(id);	}
	public int getbyname(int idpath)	{	return ptf.getbyname(idpath);	}
	public walkbase(string sb)	{	ptf.setbase(sb);	}
	public letturn(int id)	{ ptf.letturn(id);	}
	public bool canturn	{	ptf.canturn;	}
	public string vecdir(int x, int y)	{	ptf.vecdir(x,y);	}
	public int ptfgoto(int x, int y)	{	ptf.goto( x, y );	}
	public setmovetype(int id)	{	ptf.setmovetype(id);	}
	/*****************************************************************/
	public walkto2(string simg, int x, int y)	{
		swalkto = simg;
		if( this.cangoto(x,y) )	{
			x = ptf.goto( x, y );
		} else if ( _sfunnopath!=null )	{
			this.<_sfunnopath>();
		}
	}
	public int walkto(string simg, int x, int y)	{
		swalkto = simg;
		.letturn( simg == null );
		if( this.iswalking() )	{
			if( ptf.iswayto(x,y) )	{
				bzmien = true;
				destx = x;
				desty = y;
				return 0;
			} else {
				bzatrzym = true;
				return -1;
			}
		} else {
			return ptf.goto( x, y );
		}
	}
	public int iswaytover(int idver)	{
		idver = <slastpathf>.getbyname(idver);
		ptf.iswayto( .getxver(idver) - .getposx, .getyver(idver) - .getposy );
	}
	public real length(int x, int y)	{	ptf.length(x,y);	}
	public real lengthver(int idver)	{
		idver = <slastpathf>.getbyname(idver);
		.length( .getxver(idver) - .getposx, .getyver(idver) - .getposy );
	}
	public int goto(int x, int y)	{
		return this.walkto( null, x, y );
	}
	public int gotorel(int x, int y)	{
		return this.goto( <_sanim>.getpx() + x, <_sanim>.getey() + y );
	}
	public turn(string sdir)	{	ptf.turn(sdir);	}
	public int iswalking()	{	return ptf.iswalking();	}
	public stand()	{	ptf.stand(); 	}
	public stop(bool bstop)	{	ptf.stop(bstop);	}
	public int getidpath(int x, int y)	{	return ptf.getidpath( x, y);	}
	public bool cangoto(int x, int y)	{
		int id = ptf.getidpath(x,y);
		return id == -1 ? false : ptf.isenabled(id);
	}
	/************** wyjscia do zaawansowanego chodzenia ***********************/
	_cptfreachpocket()	{
		<this.getptfname()+"look">.herolook(swalkto);
	}
	_cptfreachbut()	{
		<this.getptfname()+"look">.herolook(swalkto);
	}
	_cptfreachdoors()	{
		<this.getptfname()+"look">.herooperate(swalkto);
	}
	_cptfreachitem()	{
		<this.getptfname()+"take">.herotake(swalkto);
	}
	_cptfherofin()	{
		this.herostand();
		if( swalkto!=null )	{
			this.<_sanim + "_REACH_" + <swalkto>.getbutname() >();	
			if( this.ismainhero( _sanim ) )	{
				string s = null;
				if( <_sanim>.haspocket() )
					s = < <_sanim>.getpocket()>.getitem();
				if( s!=null )	{
					<this.getptfname()+"use">.herouse(s,swalkto);
				} else {
					this.< "_cptfreach" + <swalkto>.gettyp() >();
				}
			}
			swalkto=null;
		} else {
			this.<_sanim+"_ARRIVE">();
			this._cptheroendpath();
		}
	}
	sigonzmien(string sob, string sfun)	{	_sobzmien=sob;	_sfunzmien=sfun;	}
	_cptheroendpath()	{
		this.callfun(_sfinob, _sfinfun );
		if( _bylfin )	_bylfin=false;
		else {
			_sfinfun = null;
			_sfinob = null;
		}
	}
	_cptfnopath()	{	this.< _sanim+"_NOPATH">();	}
	_cptfvisit()	{	this.<_sanim+"_VISIT">();	}
	public prepareforhero()	{
		ptf.addmethod("onfinish", "_cptfherofin");
		new string _sfinob;
		new string _sfinfun;
		new bool _bylfin;
		this.sigonnopath("_cptfnopath");
		this.sigonvisit("_cptfvisit");
	}
	public herowalkto2(int x, int y, string sob, string sfinfun)	{
		this.herowalkto(null,x,y,sob,sfinfun);
	}
	public herowalkto(string simg, int x, int y, string sob, string sfinfun)	{
		<_sstndpref + _sanim>.stop();		// wylaczenie standera
		_sfinob = sob;
		_sfinfun = sfinfun;
		if( sfinfun!=null )	_bylfin = true;
		if( this.walkto(simg, x,y)==-1 )	{
			//this.callfun(sob,sfinfun);
			//engine.print(this.getname() + " nie ma przejscia do " + simg + " call:"+sob+"."+sfinfun);
			ispathto = 0;
		} else ispathto = 1;
	}
	public heroturn(string sdir, string sob, string sfinfun)	{
		_sfinob = sob;
		_sfinfun = sfinfun;
		if( sfinfun!=null )	_bylfin = true;
		.turn(sdir);
	}
	public advgoto(int x, int y)	{
		this.herowalkto2(x,y,null,null);
	}
	public advwalkto(string simg, int x, int y)	{
		this.herowalkto(simg,x,y,null,null);
	}
	public advvisit(string simg)	{
		if( <simg>.reachable() )
			this.advwalkto( simg, <simg>.getgox(), <simg>.getgoy() );
	}
	public herostand()	{
		.retstep;
		this.stand();
		<_sanim>.herostand();
	}
	public stophero	{
		.herostand;
		bzatrzym = true;
	}
	/*****************************************************************/
	_cptvisit()	{
		this.<_sfunvisit>();	// zmienione 27 vi 2008
		if( bzmien )	{
			bzmien = false;
			if( this.goto(destx, desty)==-1 )	{
				this.<_sfunnopath>();
			} else {
				.callfun(_sobzmien, _sfunzmien);
			}
		} else if (bzatrzym)	{
			bzatrzym=false;
			this.stop(true);
		} /*else {
			this.<_sfunvisit>();
		}*/
	}
	_cptffin()	{
		if( swalkto!=null )	{
			ptf.onreach(swalkto);		// dotarcie do zadanego obiektu
			swalkto=null;
		} else {
			ptf.onarrive();		// dotarcie do punktu
		}
	}
	/**********************/
	anposx	{	<_sanim>.getposx;	}
	anposy	{	<_sanim>.getposy;	}
	bzmien	{	bzmien;	}
	bzmien=(bool b)	{	bzmien = b;	}
	checkreach(string simg)	{
		if( !ispathto && simg!=null && !.behplaying)	{
			_b_rewind = !.playbehif("beh_"+_sanim+"_NOPATH_"+<simg>.getbutname);
		}
	}
}

class classwalkerqueue	{
	init()	{
		new timer timwq;
		timwq.settick(1);
		timwq.setcycle(1);
		timwq.addmethod("onfinish","_timwqfin");
		new vector vecpt;
		vecpt.type("string");
		new int iverlen = 1;
		new int igox;
		new int igoy;
		new string _simg;
		new bool bniezmien = true;
	}
	_timwqfin()	{
		this.checkqueue();
		this.play();
	}
	public start()	{
		//timwq.play();
	}
	int ptpos(string spt)	{	vecpt.find(spt);	}
	public remove(string spt)	{
		int id = .ptpos(spt);
		if( id>=0 )	{
			if( id==0 )	{
				<vecpt.first>.sigonzmien(null, null);
				vecpt.removeat(0);
				if( vecpt.size )
					<vecpt.first>.sigonzmien(this, "ptzmien");
			} else vecpt.removeat(id);
		}
	}
	public stop()	{	timwq.stop(false);	}
	public add(string spt)	{
		_ = <spt>.iswayto( <spt>.anposx, <spt>.anposy );
		vecpt.add(spt);
		if( vecpt.size==1 )
			<vecpt.first>.sigonzmien(this, "ptzmien");
	}
	ptzmien	{
		// zapisz stan: bzmien
		bniezmien = false;
		.walkto(_simg, igox+clcamera.getposx, igoy+clcamera.getposy);
		<vecpt.first>.bzmien = (false);
		bniezmien = true;
	}
	public goto(int x, int y)	{
		this.walkto(null,x,y);
	}
	public visit(string simg)	{
		if( <simg>.reachable() )	{
			.<vecpt.first + "_WALKTO_"+simg>;
			this.walkto(simg, <simg>.getgox(), <simg>.getgoy() );
		}
	}
	public setverlen(int ilen)	{	iverlen = ilen;	}
	public stand	{
		for( int i=0; i<vecpt.size; i++)	{
			<vecpt.get(i)>.stop(false);
			<vecpt.get(i)>.herostand;
		}
	}
	public mulspeed(int ile)	{
		for( int i=0; i<vecpt.size; i++)	<vecpt.get(i)>.mulspeed(ile);
	}
	public walkto(string simg, int x, int y)	{
		igox = x - clcamera.getposx;
		igoy = y - clcamera.getposy;
		_simg = simg;
		iverlen = 1;
		
		int ile = vecpt.size();
		if( ile<=0 )	{	return;	}
		string sfirst = vecpt.first;
		<sfirst>.advwalkto( simg, x, y );
		int i[2], string s;
		//i1 = <sfirst>.getidgo;
		for( int i=1; i<ile; i++ )	{
			s = vecpt.get(i);
			i1 = <sfirst>.getidgo;
			if( bniezmien )	{
				i0 = <sfirst>.getgover(iverlen);
			} else {
				<s>.advwalkto( simg, x, y );
				i0 = <s>.getgover(i*iverlen);
			}
			
			if( i0<0 ) {
				i0 = <sfirst>.getgover(iverlen);
				if( i0<0 ) i0 = <sfirst>.getidan;
			}
			if( i0==i1 && bniezmien ) i0=-1;
			sfirst = s;
			if( i0 >= 0 )	{
				<s>.advwalkto( null, <s>.getxver(i0), <s>.getyver(i0) );
			} else {
				<s>.stop(false);
				<s>.herostand();
			}
		}
		<sfirst>.checkreach(simg);
		/*for( i=0; i<ile; i++)	{
			for(i0=i+1; i0<ile; i0++)	{
				s = vecpt.get(i);
				s2 = vecpt.get(i0);
				if( <s>.iswalking && !<s2>.iswalking && <s>.getidgopath==<s2>.getidgopath)	{
					<s>.stop(false);
					<s>.herostand;
					//i1 = <s>.getidanpath;;
					//<s>.advwalkto( simg, <s>.getxver(i1), <s>.getyver(i1) );
				}
			}
		}*/
		/*int j, string s;
		for( int i=0; i<ile; i++)	{
			s = vecpt.get(i);
			<s>.advwalkto(simg,x,y);
			for( j=i+1; j<ile; j++)	{
				<vecpt.get(j)>.excludev( <s>.getidgo() );
			}
		}*/
	}
	public checkqueue()	{
		int ile = vecpt.size();
		if( ile<=1 )	{	return;	}
		int j, string s[2], int ian, int ian2;
		for( int i=0; i<ile; i++)	{
			s0 = vecpt.get(i);
			if( <s0>.iswalking() )	{
				ian = <s0>.getidan();
				ian2 = <s0>.getidan2();
				for( j=i+1; j<ile; j++)	{
					s1 = vecpt.get(j);
					if( <s1>.iswalking() )	{
						<s1>.excludev( ian );
						<s1>.excludev( ian2 );
					}
				}
			}
		}
	}
}



class classstndgroup	{
	init()	{
		new gmobjvec grstnd;
	}
	public pause()	{
		grstnd.eval("lock");
		this.stop();
	}
	public resume()	{
		if( igmstate==0 )	{
			grstnd.eval("unlock");
			this.play();
		}
	}
	public add(string sstander)	{	grstnd.add(sstander);	}
	public remove(string sst)	{	grstnd.remove(sst);	}
	public stop()	{	grstnd.eval("stop");	}
	public play()	{	grstnd.eval("play");	}
	public reset()	{	grstnd.eval("reset");}
}

class classadvstander : classlocker 	{
	init()	{
		classlocker::init();
		new timer timstand;
		timstand.settick(1);
		timstand.delay(20000);
		timstand.addmethod("onfinish", "_timstandfin");
		
		new string sanim = this.getname();
		sanim = sanim.strsubbs( _sstndpref );
		
		new string _sbeh = "beh_" + sanim + "_IDLE";
		
		modstnd.add( this.getname() );
	}
	_timstandfin()	{
		string s = gameapi.getgamename();
		if( <s>.behexist( _sbeh )  && !this.getlock() )	<s>.playbeh( _sbeh );
	}
	public play()	{	if( !this.getlock() && !timstand.isplaying() )	timstand.play();	}
	public stop()	{	timstand.stop(false);	}
	public setdelay(int idelay)	{	timstand.setdelay(idelay);	}
	public reset()	{	this.stop();	this.play();	}
}


/*
	klasa obslugujaca "rozmawianie" postaci
	Dominik Dagiel	3 III 2006
*/

class classtalker : classadvhero	{
	init()	{
		classadvhero::init();
		this._setbase( "talk:" );
		
		new snd sndtalk;
		sndtalk.buildfullname;
		sndtalk.setstartstopflag(false, true);
		sndtalk.addmethod("onfinish", "_ctalkfin");
		
		new timer timtalk;
		timtalk.settick(1);
		new real rdelay = 1.0;
		timtalk.addmethod("onfinish","_ctalkfin");
		
		new gmimgvec txttalk;
		new int _iletxt=10;
		string s;
		for( int i=0; i<_iletxt; i++ )	{
			s = "txttalk"+i;
			new text <s>;
			txttalk.add(s);
		}
		new font fonttalk;
		txttalk.hide();
		new vector vecpom;
		vecpom.type("string");
		new int iTxtLim = 30;
		new int irtxt;
		new int igtxt;
		new int ibtxt;
		new string stextdb;		// baza z tekstem do mowienia
		new string _swav;
		
		this.buildfullname();
		
		new string stalktype;
		this.settalktype("snd");	// typ: (snd, txt, film) -> kombinacje
	}
	public set(string san)	{
		this.link(san);
	}
	public settextdb(string s)	{	stextdb=s;	}
	public setfont(string sfile, int size)	{
		fonttalk.load(sfile,size);
		txttalk.eval1("setfont","fonttalk");
	}
	public setsnd(string sfile)	{
		if( !sfile.contains(".wav") )	{
			_swav = sfile;
			sfile+=".wav";
		} else {
			_swav = sfile.strsubes(".wav");
		}
		//sndtalk.load( this.getsndpath() + sfile );
		sndtalk.advloadsnd(sfile);
	}
	public herosay1(string sfinfun)	{
		this.herosay(1, true, true, null, sfinfun );
	}
	public herosay(int itypsort, bool bstart, bool bstop, string sobfin, string sfinfun)	{
		this.herosaydir( itypsort, bstart, bstop, sobfin, sfinfun, this.getdir() );
	}
	public herosaydir(int itypsort, bool bstart, bool bstop, string sobfin, string sfinfun, string sdir)	{
		<_sanim>.thisfinish(false);
		if( !bstart )	{
			<_sanim>.playspec(_sbase, this.nofpiecesdir(sdir), itypsort, bstart, null, null,
					bstop, sobfin, sfinfun, sdir);
			this.<stalktype>();
		} else {
			<_sanim>.playspec(_sbase, this.nofpiecesdir(sdir), itypsort, bstart, this.getfullname(), "_ctalkstart",
					bstop, sobfin, sfinfun, sdir);
		}
	}
	public thisfinish(bool bthisfin)	{	<_sanim>.thisfinish(bthisfin);	}
	public stop(bool b)	{
		if( stalktype.contains("snd") )	{
			sndtalk.stop(b);
			timtalk.stop(false);
		} else {
			timtalk.stop(b);
		}
	}
	public settalktype(string stype)	{
		stalktype = "_cplay";
		if( stype.contains("snd") )	stalktype += "snd";
		if( stype.contains("txt") )		stalktype += "txt";
		if( stype.contains("film") )	stalktype += "film";
	}
	_csay()	{
		if( stextdb!=null )	{
			int id = <stextdb>.findbyrow(_swav);
			if( id<0 )	{	return;	}
			
			vecpom.vecbuildfromstring( <stextdb>.get(id,2), " " );
			string s="", int itlk=0, int x, int y;
			if( stalktype.contains("txt") )	{
				x = <_sanim>.getcx();
				y = <_sanim>.getpy();
			} else {
				x = 400;
				y = 590;
			}
			int x1=0, int x2=iResX, int y1=0, int y2=iResY;
			string s1;
			for( int i=0; i<vecpom.size(); i++)	{
				s+=vecpom.get(i)+" ";
				if( s.length()>iTxtLim )	{
					s1 = "txttalk"+itlk;
					<s1>._cprinttxt(s,x,y,itlk);
					if( <s1>.getpx() < x1 )	{	x1=<s1>.getpx();	}
					if( <s1>.getex() > x2 )	{	x2=<s1>.getex();	}
					if( <s1>.getpy() < y1 )	{	y1=<s1>.getpy();	}
					if( <s1>.getey() > y2 )	{	y2=<s1>.getey();	}
					s="";
					itlk++;
				}
			}
			if( s.length()>0 )	{
				s1 = "txttalk"+itlk;
				<s1>._cprinttxt(s,x,y,itlk);
				if( <s1>.getpx() < x1 )	{	x1=<s1>.getpx();	}
				if( <s1>.getex() > x2 )	{	x2=<s1>.getex();	}
				if( <s1>.getpy() < y1 )	{	y1=<s1>.getpy();	}
				if( <s1>.getey() > y2 )	{	y2=<s1>.getey();	}
				itlk++;
			}
			x2-=iResX;
			y2-=iResY;
			if( x1>0 )	{	x1=0;	}
			if( y1>0 )	{	x1=0;	}
			txttalk.move(0-x1+x2, -itlk*txttalk0.geth()-y1+y2 );
			if( txttalk0.getpy()<0 )	{
				txttalk.move(0,-txttalk0.getpy());
			}
			timtalk.delay( rdelay*500*vecpom.size() );
		}
	}
	_cprinttxt(string s, int x, int y,int id)	{
		this.set(s);
		this.createtxt(irtxt,igtxt,ibtxt);
		this.setpos( x-this.getw()/2, y+id*this.geth() );
		this.setz(2000);
		this.show();
	}
	public _cplaysnd()	{
		.cbsplay(sndtalk.getfullname);
		//sndtalk.play();
	}
	public _cplaysndtxt()	{
		._cplaysnd;
		this._csay();
	}
	public _cplaysndtxtfilm()	{
		._cplaysnd;
		this._csay();
	}
	public _cplaysndfilm()	{
		this._csay();
	}
	public _cplaytxt()	{
		this._csay();
		timtalk.play();
	}
	public _cplaytxtfilm()	{
		this._csay();
		timtalk.play();
	}
	public _cplayfilm()	{
		this._csay();
		timtalk.play();
	}
	/******  do tekstu pisanego ****************************/
	public setdelay(real r)	{	rdelay=r;	}
	public settxtcolor(int r, int g, int b)	{
		irtxt=r;	igtxt=g;	ibtxt=b;
	}
	/**********************************/
	_ctalkstart()	{
		this.<stalktype>();
	}
	_ctalkfin()	{
		txttalk.hide();
		<_sanim>.herostop();
	}
	/**********************************/
}

class classtxttalker : classadvhero	{
	init()	{
		classadvhero::init();
		this._setbase( "talk:" );
		
		new int iR;
		new int iG;
		new int iB;
		new int ibR;
		new int ibG;
		new int ibB;
		new int ibA;
		new int ibrr;
		new int ibrg;
		new int ibrb;
		new int ibra;
		new int ibw;
		new db dbtxt;
		new int iSize;
		new gmimgvec grtxt;
		new gmimgvec grtxt2;
		string s;
		for( int i=0; i<25; i++ )	{
			s = "txt"+i;
			new text <s>;
			grtxt.add(s);
			<s>.hide();
		}
		new text imgtxt;
		imgtxt.hide();
		
		new bool bplaying = false;
		
		new string slang;
		this.setlang("pol");
	}
	public setlang(string s)	{	slang = s;	}
	public bool isplaying()	{	return bplaying;	}
	public setfont(string sfont)	{
		grtxt.eval1("setfont",sfont);
		iSize = <sfont>.getsize();
	}
	public setfontcolor(int ir, int ig, int ib)	{
		iR=ir; iG=ig; iB=ib;
	}
	public setfontbg(int ibr, int ibg, int ibb, int iba)	{
		ibR=ibr; ibG=ibg; ibB=ibb; ibA=iba;
	}
	public setbgframe(int iw, int ir2, int ig2, int ib2)	{
		ibrr = ir2; ibrg = ig2; ibrb = ib2; ibra=255; ibw=iw;
	}
	public set(string san, int iz)	{
		this.link(san);
		grtxt.setz(iz);
		imgtxt.setz(iz-1);
	}
	public herosay(string sfile, int x, int y)	{
		this.herosaydir(sfile,x,y,this.getdir());
	}
	public herosaydir(string sfile, int x, int y, string sdir)	{
		if( sdir=="auto")	{	sdir=this.getdir();	}
		bplaying = true;
		dbtxt.load( this.getgraphpath() + sfile + "." + slang);
		string s;
		grtxt2.free();
		int iw=0;
		int ile = dbtxt.getrowsno();
		for( int i=0; i<ile; i++)	{
			s = "txt"+i;
			<s>.set( dbtxt.get(i,0) );
			<s>.createtxt(iR, iG, iB);
			<s>.setpos(x,y);
			y+=iSize;
			<s>.show();
			if( <s>.getw()>iw)	{	iw=<s>.getw();	}
			grtxt2.add(s);
		}
		imgtxt.setbkg(txt0.getpx()-iSize/2, txt0.getpy()-iSize/2, iw+iSize, iSize*(ile+1), ibR, ibG, ibB, ibA );
		imgtxt.setborders(ibw,ibrr,ibrg,ibrb,ibra);
		imgtxt.show();
		if( _sanim!=null )	{
			<_sanim>.thisfinish(false);
			<_sanim>.playspec(_sbase, 0, 0, false, null, null,
					false, null, null, sdir);
		}
	}
	public stop()	{
// 		if( bplaying==false )	{	return;	}
		bplaying = false;
		grtxt2.hide();
		imgtxt.hide();
		if( _sanim!=null )	{
			<_sanim>.thisfinish(true);
			<_sanim>.play("stand" + this.getdir());
		}
	}
}



/*
	klasy obslugujace plany tla oraz kamere 
*/

class classbgplan : gmobjvec {
	init() {
		gmobjvec::init;
		new real rpx;
		new real rpy;
		new real scalex;
		new real scaley;
		new int _ix;
		new int _iy;
	}
	public setscale(real rsx, real rsy)	{	|scalex, scaley| = rsx, rsy;	}
	public move(real x, real y)	{
		rpx+=x;	rpy+=y;
		int ix = rpx, int iy = rpy;
		rpx-=ix;	rpy-=iy;
		if( ix || iy )	{
			_ix += ix;
			_iy += iy;
			gmobjvec::move(ix,iy);
		}
	}
	public movebgr(real x, real y)	{	.move( scalex*x, scaley*y );	}
	int getpx	{	_ix;	}
	int getpy	{	_iy;	}
}

class classgrplans : gmobjvec	{
	init()	{
		gmobjvec::init();
		new real _rxp;
		new real _ryp;
	}
	public move(real x, real y)	{
		_rxp += x;	_ryp += y;
		this.eval2("movebgr",x,y);
	}
	public real getposx()	{	return _rxp;	}
	public real getposy()	{	return _ryp;	}
	public shift(int x, int y)	{
		_rxp+=x;	_ryp+=y;
		this.eval2("move",x,y);
	}
}

class CameraPos	{
	init(int x, int y)	{
		new int _x;
		new int _y;
		.setpos(x,y);
	}
	setpos(int x, int y)	{ _x=x; _y=y;	}
	getposx	{	_x;	}
	getposy	{	_y;	}
}

class classadvcamera	{
	init()	{
		new classgrplans grbgrs;
		new string sancamera=null;
		new string smsmvfun = null;
		|new real _rxmod, new real _rymod| = 0.05, 0.05;
		|new real rleft, new real rtop, new real rright, new real rbottom| = 0.0, 0.0, iResX-1, iResY-1;
		|new int icamx, new int icamy| = 400, 300;
		|new real rborx, new real rbory| = iResX-1, iResY-1;
		new real _lastx = 0;
		new real _lasty = 0;
		new string _sfunxedge = null;
		new string _sfunyedge = null;
		new CameraPos _campos(0,0);
		
		new timer timcamera;
		timcamera.settick(1);
		timcamera.setcycle(1);
		timcamera.addmethod("onfinish","_camerafin");
	}
	_camerafin()	{
		this.checkcamera();
		this.play();
	}
	public setscreen(int x1, int y1, int x2, int y2)	{
		rleft=x1;	rtop=y1;
		rright=x2;	rbottom = y2;
		rborx = x2;
		rbory = y2;
		_lastx = x1;
		_lasty = y1;
		icamx = (x1+x2)/2;
		icamy = (y1+y2)/2;
		//grbgrs.startpos(x1,y1);
	}
	public remove(string sob)	{	for( int i=0; i< grbgrs.size; i++)	<grbgrs.get(i)>.remove(sob);	}
	public funxedge(string sfun)	{	_sfunxedge=sfun;	}
	public funyedge(string sfun)	{	_sfunyedge=sfun;	}
	public setcenter(int x, int y)	{	| icamx, icamy | = x, y;	}
	public setborders(int x, int y){	|rright, rbottom| = x, y;	}
	public countcenter	{	.setcenter( rleft+(rright-rleft)/2, rtop+(rbottom-rtop)/2 );	}
	public real getposx()	{	return grbgrs.getposx();	}
	public real getposy()	{	return grbgrs.getposy();	}
	public setmetonmsmove(string s)	{	smsmvfun=s;	}
	public start()	{	timcamera.play();	}
	public stop()	{	timcamera.stop(false);	}
	public setactor(string sactor)	{	sancamera=sactor;	}
	public setcampos(int x, int y)	{
		_campos.setpos(x,y);
		.setactor("_campos");
	}
	public bool isactor(string sob)	{	return sob==sancamera;	}
	public string getactor()	{	return sancamera;	}
	public scalemodifiers(real rx, real ry)	{	| _rxmod, _rymod | = rx, ry;	}
	public newbgr(string sbgr, real rscalex, real rscaley)	{
		new classbgplan <sbgr>;
		this.addbgr(sbgr,rscalex,rscaley);
	}
	public addbgr(string sbgr, real rscalex, real rscaley)	{
		<sbgr>.setscale(rscalex,rscaley);
		grbgrs.add(sbgr);
	}
	public addtobgr(string sbgr, string sob)	{	<sbgr>.add(sob);	}
	public setscene()	{	this._setscene(1.0,1.0);	}
	_setscene(real _rx, real _ry)	{
		if( sancamera==null ) return;
		real x = icamx - <sancamera>.getposx();
		x*=_rx;
		real y = icamy - <sancamera>.getposy();
		y*=_ry;
		real ix = this.getposx()+x;
		real iy = this.getposy()+y;
		if( ix >= rleft )	x = -this.getposx();
		else if (ix+rright<rborx)	x = rborx - (this.getposx()+rright);
		
		if( iy >= rtop )	y = -this.getposy();
		else if (iy+rbottom<rbory)	y = rbory - (this.getposy()+rbottom);
		
		if( x||y )	{
			grbgrs.move(x,y);
			if( smsmvfun!=null )	this.<smsmvfun>();
		}
		if( x==0 && _lastx!=0 && _sfunxedge!=null )	.<_sfunxedge>;
		if( y==0 && _lasty!=0 && _sfunyedge!=null )	.<_sfunyedge>;
		_lastx = x;
		_lasty = y;
	}
	public checkcamera()	{
		if( sancamera==null )	return;
		this._setscene( _rxmod, _rymod );
	}
	public moveplans(int x, int y)	{
		rleft+=x;	rright+=x;
		rtop+=y;	rbottom+=y;
		rborx+=x;
		rbory+=y;
		icamx+=x;	icamy+=y;
		grbgrs.shift(x,y);
	}
}

/*
	tworzy z button z obiektu graficznego
*/

class classadvbut	{
	init(string sname)	{
		this.setadvbutmets(sname, "but");
	}
	setasbutton(string san, string sname)	{
		classadvbut::setasbutton2(san,sname,"but");
	}
	setasbutton2(string san, string sname, string styp)	{	// rozszerzanie obiektu o button
		<san>.addmethod("setadvbutmets","setadvbutmets");
		<san>.addmethod("setbuttyp","setbuttyp");
		<san>.addmethod("setadvbutpos","setadvbutpos");
		<san>.addmethod("setbutdir","setbutdir");
		<san>.addmethod("setbutbase1","setbutbase1");
		<san>.addmethod("setbutbase2","setbutbase2");
		<san>.addmethod("setbutbase","setbutbase");
		<san>.addmethod("getbase1","getbase1");
		<san>.addmethod("getbase2","getbase2");
		<san>.addmethod("getbutdir","getbutdir");
		<san>.addmethod("getbutname","getbutname");
		<san>.addmethod("gettyp","gettyp");
		<san>.addmethod("reachable", "reachable");
		<san>.addmethod("setreach", "setreach");
		<san>.addmethod("getgox","getgox");
		<san>.addmethod("getgoy","getgoy");
		
		<san>.addmethod("enable","enable");
		<san>.addmethod("disable","disable");
		<san>.addmethod("enabled","enabled");
		<san>.addmethod("setonce", "setonce" );
		<san>.addmethod("checkonce", "checkonce" );
		
		<san>.addmethod("setpocket", func { (string s) _spocket = s; } );
		<san>.addmethod("getpocket", func { _spocket; } );
		
		<san>.addmethod("moveon","moveon");
		<san>.addmethod("moveoff","moveoff");
		<san>.addmethod("clickon","clickon");
		<san>.addmethod("lrel","lrel");
		
		<san>.addmethod("becomebut", func { classadvbut::setasbut(this); });
		<san>.addmethod("becomeitem", func { classadvbut::setasitem(this); });
		<san>.addmethod("becomedoors", func { classadvbut::setasdoors(this); });
		
		<san>.addmethod("copyposfrompt", func { (string spt, int id)
			int i0 = <spt>.getbyname(id);
			.setadvbutpos(<spt>.getxver(i0) - <spt>.getposx, <spt>.getyver(i0) - <spt>.getposy );
			} );
		
		<san>.addmethod("butisin", func { .isin; } );
		
		<san>.setadvbutmets(sname, styp);
		<san>.setreach(true);
	}
	setonce(string s)	{ _sonce = s; }
	checkonce	{
		if(_sonce!=null && !clsave.bis(_sonce))	{
			clsave.bset(_sonce);
			.disable;
		}
	}
	setadvbutmets(string sname, string styp)	{
		new string _styp = styp;
		new string _sname = sname;
		new int igox = this.getposx();		// jak dojsc do tego..
		new int igoy = this.getposy();
		new string sgox = null;
		new string sgoy = null;
		new string _sbutdir = "auto";
		new string _sbase1 = modadv.get("look:",1);
		new string _sbase2 = modadv.get("look:",2);
		new bool breachable = false;
		new string _spocket = sname;
		new string _sonce = null;
		
		.vars2(A, "baseuse1", _sbase1, "baseuse2", _sbase2, "hideontake", true);
		
		this.enable();
	}
	setasmask(string san)	{
		<san>.addmethod("butisin", func { (int x, int y, bool bv, bool ba) .isin(x, y, false, ba);	} );
	}
	/*********************************/
	enable()	{
		if( !AdventureGame ) return;
		grbuts.addonce( this.getname() );
	}
	disable()	{
		if( !AdventureGame ) return;
		grbuts.remove(this.getname());
	}
	enabled()	{
		if( !AdventureGame ) return;
		return grbuts.contains(this.getname());
	}
	/*********************************/
	setbutbase(string s1, string s2)	{
		.setbutbase1(s1);
		.setbutbase2(s2);
	}
	setreach(bool b)	{	breachable=b;	}
	reachable()	{	return breachable;	}
	setbuttyp(string s)	{	_styp = s;	}
	/*************************/
	lrel()	{}		// mouselrel
	clickon()	{	if( this.reachable() )	{	clwalkq.visit( this.getname() );	}	}
	moveon()	{	advmouse.setactive();	}
	moveoff()	{	advmouse.setstd();	}
	/*************************/
	setadvbutpos(string x, string y)	{	sgox=x; sgoy=y; igox = x; igoy=y;		}
	setbutdir(string sdir)	{	_sbutdir=sdir;	}
	setbutbase1(string sb1)	{	_sbase1=sb1; baseuse1 = sb1;	}
	setbutbase2(string sb2)	{	_sbase2=sb2; baseuse2 = sb2;	}
	string getbase1()	{	return _sbase1;	}
	string getbase2()	{	return _sbase2;	}
	string getbutdir()	{	return _sbutdir;	}
	string getbutname()	{	return _sname;	}
	string gettyp()	{	return _styp;	}
	int getgox()	{
		if( sgox=="-hero" )	{
			sgoy=="-main" ? <smainhero>.getposx() : <sgoy>.getposx();
		} else if (sgox=="-but")	{
			<sgoy>.getcx;
		} else igox + clcamera.getposx();
	}
	int getgoy()	{
		if( sgox=="-hero" )	{
			sgoy=="-main" ? <smainhero>.getposy() : <sgoy>.getposy();
		} else if (sgox=="-but")	{
			<sgoy>.getey;
		} else igoy + clcamera.getposy();
	}
	/*******  virtuale  ****/
	virtual int getposx()	{	return 0;	}
	virtual int getposy()	{	return 0;	}
	virtual int getz()		{	return 0;	}
	virtual int butisin(int x, int y, bool bigv, bool biga)	{	return 0;	}
	/***************************/
	public setasbut(string san)	{
		//<san>.setbutbase( modadv.get("take:",1), modadv.get("take:",2) );
		<san>.addmethod("moveon", "moveon");
	}
	public setasitem(string san)	{
		<san>.setbutbase( modadv.get("take:",1), modadv.get("take:",2) );
		<san>.addmethod("moveon", "moveon");
	}
	public setasdoors(string san)	{
		<san>.addmethod("moveon", func { advmouse.setexit; } );
		<san>.setbutbase( modadv.get("doors:",1), modadv.get("doors:",2) );
	}
}

class classadvitem : classadvbut	{
	init(string sname)	{
		classadvbut::init(sname, "item");
		this.setbutbase( modadv.get("take:",1), modadv.get("take:",2) );
	}
	setasbutton(string san, string sname)	{
		classadvbut::setasbutton2(san, sname, "item");
		<san>.setbutbase( modadv.get("take:",1), modadv.get("take:",2) );
	}
}

class classadvdoors : classadvbut	{
	init(string sname)	{
		classadvbut::init(sname, "doors");
		this.setbutbase( modadv.get("doors:",1), modadv.get("doors:",2) );
	}
	setasbutton(string san, string sname)	{
		classadvbut::setasbutton2(san, sname, "doors");
		<san>.addmethod("moveon","moveon");
		<san>.setbutbase( modadv.get("doors:",1), modadv.get("doors:",2) );
	}
	moveon()	{	advmouse.setexit();		}
}

/* 
	behavioury : skladowe cut-scen w przygodzie
*/

class classbehhero 	{
	init()	{
		new string _snextbeh = null;
		new string _stdfinfun = null;	// std funkcja przekazana do odegrania na finish
		new string _stdfinobj = null;
		new string _stype = null;	// typ behavioura
		new string _scaller;	// kto go wywoluje (tego behavioura)
		new bool bblock = true;	// blokuj przed dzialaniami gracza
		//new string bonce = null;	// jednorazowego uzytku
		new bool bparal = false;
	}
	public gonext(string scaller)	{
		bool bfin = false;
		if( bparal )	{
			bfin = <_sstarter>.behret( this.getname() );
		} else if ( <_sstarter>.isenumer() && _sstarter!=this.getname())	{
			bfin = true;
		} else {
			if( _snextbeh!=null )	{
				<_snextbeh>.eval( scaller );
			} else {
				bfin = true;
			}
		}
		if( bfin )	{
			this.finishbeh(scaller);
		}
	}
	public finishbeh(string scaller)	{
		if( scaller!=null )	{
			<scaller>.reteval();
		} else {
			modstnd.resume();
			string s = this.getactbeh();
			<_sstarter>.callbehfin();
			if( this.getactbeh()==s )	{
				this.setactbeh(null);
			}
		}
	}
	public playfin(string sob, string sfun)	{
		this.setfinfun(sob,sfun);
		_bmslock = this.advgetlock();
		this.advmssetlock( bblock );	// zapamietuje mysz
		modstnd.pause();	// stop standery
		this.eval(null);
	}
	public eval(string scaller)	{
		this.setactbeh( this.getname() );		// zapamietanie kto teraz "gra"
		_scaller = scaller;
		this._eval();	
	}
	public rewind()	{
		//if( bblock==false && .hasaddedmet("_rew")/* || igmdebug*/)	{
		if( .hasaddedmet("_rew") )	{
			this._rew();
		}
	}
	public reteval()	{
		this.gonext(_scaller);
	}
	callbehfin()	{
		this.advmssetlock( _bmslock );	// przywrocenie blocka myszy
		
		this.callfun(_stdfinobj,_stdfinfun);
		_stdfinobj = null;
		_stdfinfun = null;
		
		this.< this.getname()->strsubbs( _sbeh )+"_FINISH">();
	}
// 	_rewenter	{}
// 	_rewclose	{}
	_evalenter	{
		ccs.obenter(this, "reteval");
	}
	_evalclose	{
		ccs.obclose(this, "reteval");
	}
	_evalmusic	{
		_music.playvec(vmus.getfullname, 0);
		.reteval;
	}
	_evalscript()	{
		if( _id>=0 )	{
			int id = _id;
			@s = <_sdb>.get(_row,id);
			while( s!=")" )	{
				<_sscr>.ARG=(id-_id, s);
				id++;
				s = <_sdb>.get(_row,id);
			}
		}
		<_sscr>.call( _sfun2 );
		this.reteval();
	}
// 	_rewscript()	{}
	_evalmet()	{
		this.callfun(_sob2,_sfun2);
		this.reteval();
	}
// 	_rewmet()	{}
	_evalsave()	{
		clsave.set( ssavvar, ssavval );
		this.reteval();
	}
// 	_rewsave()	{}
	_evalgame()	{
		string s = gameapi.getgamename;
		match( _styp )	{
			"-def" => <s>.playfromscript(_spath, _sgame);
			"-adv" => <s>.playnewgamepath(_sgame, _spath);
			? => <s>.playnewgame(_sgame);
		}
		this.reteval();
	}
// 	_rewgame()	{}
	_evalread()	{	clhilarytxt.herosaydir( _sread, _ix, _iy, _sdir );	}
	_rewread()	{
		clhilarytxt.stop();
		this.reteval();
	}
	_evalwait()	{	timwait.play();	}
	//_rewwait()	{	timwait.stop(true);	}
	_evaltalk()	{
		string sptf = _spathpref + _san;
		string s = _stalkpref + _san;
		if( engine.varexist(sptf) && <s>.getdir != <s>.getpropdir(_sdir) )	{
			<sptf>.heroturn(_sdir, this, "_evaltalk");
			return;
		}
		this.advanstand(_san);
		<s>.settalktype( modadv.gettalktype() );
		<s>.setsnd( __swav );
		<s>.checkamounts( __sbase );
		<s>.herosaydir(isort, bstt, bstp, this.getname(), "reteval", <s>.getpropdir(_sdir) );
	}
	_rewtalk()	{	<_stalkpref+_san>.stop(true);	}
	_evalsetpos()	{
		int x, int y;
		string _sptf = _spathpref + _san;
		if( _idestx=="-id" )	{
			y=<_sptf>.getbyname(_idesty);
			x = <_sptf>.getxver(y);
			y = <_sptf>.getyver(y);
			<_san>.setpos(x ,y  );
		} else {
			x=_idestx;
			y=_idesty;
			<_san>.setpos(x + clcamera.getposx() ,y + clcamera.getposy() );
		}
		if( _bssc ) clcamera.setscene;
		if( engine.varexist(_sptf) ) <_sptf>.scalean();
		<_san>.setz( <_san>.getposy );
		if( _sdir!="auto" )	<_san>.setdir(_sdir);
		this.reteval();
	}
// 	_rewsetpos()	{}
	_evalwalk()	{
		int x, int y;
		if( _idestx=="-id" )	{
			y=<_sptf>.getbyname(_idesty);
			x = <_sptf>.getxver(y) - <_sptf>.getposx;
			y = <_sptf>.getyver(y) - <_sptf>.getposy;
		} else if (_idestx == "-hero")	{
			x = <_idesty>.getposx;
			y = <_idesty>.getposy;
			bool b = true;
			if( <_sptf>.ptfgoto(x,y)>=0 )	{
				y = <_sptf>.getgover(1);
				if( y>=0 )	{
					x = <_sptf>.getxver(y);
					y = <_sptf>.getyver(y);
					b = false;
				}
			}
			<_sptf>.stop(false);
			if(b)	{
				@s = _sptf.strsubbs( _spathpref );
				x = <s>.getposx;
				y = <s>.getposy;
			}
		} else {
			x=_idestx;
			y=_idesty;
		}
		<_sptf>.herowalkto2( x + clcamera.getposx(), 
			y + clcamera.getposy(), this.getname(), "reteval" );
	}
	_evalturn	{
		string s = _sdir;
		if( !s.in(A, "uu", "ru", "rr", "rd", "dd", "ld", "ll", "lu") )	{
			string s2 = <_sptf>.getanim;
			s = <_sptf>.vecdir( <s>.getposx-<s2>.getposx, <s>.getposy-<s2>.getposy );
		}
		<_sptf>.heroturn(s, this, "reteval");
	}
// 	_rewwalk()	{}
	_evalanorder()	{
		this.advanstand(_san);
		_ = this.analizeaninstr(_sdb, _irow, _icol, _san);
		this.reteval();
	}
// 	_rewanorder()	{}
	_evalanplay()	{
		if( !<_san>.hasvar("bthisfin") )	{
			<_san>.setasadvanima;
		}
		this.advanstand(_san);
		<_san>.thisfinish(true);
		if( StringChecker::isdigit(_sact) ) _sact = <_san>.nameofaction(_sact);
		<_san>.playspec2( _sact, this.getname(), "reteval");
	}
	_rewanplay()	{	/*<_san>.stop(true);*/	}
	_evalsndbg()	{
		//_sndbg.play();
		.cbsplay(_sndbg.getfullname);
		this.reteval();
	}
// 	_rewsndbg()	{}
	_evalsndplay()	{
		//sndp.play();
		.cbsplay(sndp.getfullname);
	}
	_rewsndplay()	{	sndp.stop(true);	}
	_evalcall()	{
		string s = scallobj;
		if( s.contains("$") )	{
			s = s.strsubb(1);
			s = engine.varexist(s) ? [s] : <sscript>.get(s);
			if( s==null )	{
				this.reteval();
				return;
			}
		}
		s = this.getbeh(s);
		<s>.eval( this.getname() );
	}
// 	_rewcall()		{}
	_evalnull()	{	this.reteval();	}		// obiekt niezdefiniowany
// 	_rewnull()	{}
	_evalstart()	{
		int i, string s;
		vbif.free;
		if( bonce!=null )	{
			//s = this.getname()->strsubbs( _sbeh );
			if( !clsave.bis( bonce ) )	{
				clsave.bset( bonce ); 
			} else {
				this.finishbeh(_scaller);
				return;
			}
		}
		if( (iisifsave==0&&clsave.is(sisifsave,sisifvar)) || (iisifsave==1&&!clsave.is(sisifsave,sisifvar)) )	{
			this.finishbeh(_scaller);
			return;
		}
		if( brand)	{
			i = vecbehs.size();
			i>0 ? < vecbehs.get( i.rand ) >.eval( _scaller ) : this.reteval();
		} else if( bparal)	{
			vecbehs2.veccopy("vecbehs");
			for( i=0; i<vecbehs.size(); i++)	{
				<vecbehs.get(i)>.eval( _scaller );
			}
		} else if (ienumer>0)	{
			<vecbehs.get( this.nextenum()-1 )>.eval( _scaller );
		} else	{
			this.reteval();
		}
	}
// 	_rewstart()	{}
	_ifst(bool b, bool b2)	{
		match(ifst)	{
			1 => b && b2;
			2 => b || b2;
			? => b;
		}
	}
	bool _oper_check(string s)	{
		//s=="|" ? 2 : s=="&";
		match(s)	{
			"|" => 2;
			"&" => 1;
			? => 0;
		}
	}
	_ifcheck	{
		bool b[2];
		string s[2];
		int i1 = istart;
		ifst = 0;	// initial state
		while(i1<istop)	{
			s0 = <_db>.get(irow, i1);
			s1 = <_db>.dbchecknext(irow, i1);
			match( s1 )	{
				"=" => {
					i1+=2;
					b1 = clsave.is(s0, <_db>.get(irow, i1) );
					b0 = ._ifst(b1, b0);
					ifst = ._oper_check( <_db>.dbchecknext(irow, i1) );
					if( ifst ) i1++;
				}
				"!=" => {
					i1+=2;
					b1 = !clsave.is(s0, <_db>.get(irow, i1) );
					b0 = ._ifst(b1, b0);
					ifst = ._oper_check( <_db>.dbchecknext(irow, i1) );
					if( ifst ) i1++;
				}
				"&" => { i1++;
					b1 = ( (s0.getb(0,1)=="!") ? (!clsave.bis(s0.strsubb(1))) : clsave.bis(s0) );
					b0 = ._ifst(b1, b0);
					ifst=1;
				}
				"|" => { i1++;
					b1 = ( (s0.getb(0,1)=="!") ? (!clsave.bis(s0.strsubb(1))) : clsave.bis(s0) );
					b0 = ._ifst(b1, b0);
					ifst=2;
				}
				? => {
					b1 = ( (s0.getb(0,1)=="!") ? (!clsave.bis(s0.strsubb(1))) : clsave.bis(s0) );
					b0 = ._ifst(b1, b0);
				}
			}
			i1++;
		}
		<_sstarter>.bif=(b0);
		b0;
	}
	_checkif	{
		if( ._ifcheck )	{
			.reteval;
		} else {
			<_sstarter> (this) { (string s)
				int poz = 0;
				int end = vecbehs.size;
				int found = 0;
				for(int i =vecbehs.find(s)+1; i<end; i++ )	{
					match( <vecbehs.get(i)>.gettyp )	{
						"IF" => poz++;
						"FI" => {
							if( poz==0 )	{
								found = i;
								i = end;
							} else poz--;
						}
						"ELSE", "ELIF" => {
							if( poz==0 )	{
								found = i;
								i = end;
							}
						}
						? => ;
					}
					//!<vecbehs.get(i)>.gettyp->in(A,"FI","ELSE","ELIF")
				}
				<vecbehs.get(found)>.eval(_scaller);
			};
		}
	}
	_evalIF	{
		<_sstarter>.ifpush;
		._checkif;
	}
	_gotofi(string s)	{
		int poz = 0;
		for( int i = vecbehs.find(s)+1; i<vecbehs.size; i++) {
			match(<vecbehs.get(i)>.gettyp)	{
				"IF" => poz++;
				"FI" => {
					if( poz==0 )	{
						<vecbehs.get(i)>.eval(_scaller);
						return;
					} else poz--;
				}
				? => ;
			}
		}
	}
	_evalELIF	{
		if( <_sstarter>.bif )	{
			<_sstarter>._gotofi(this);
		} else ._checkif;
	}
	_evalELSE	{
		if( <_sstarter>.bif ) <_sstarter>._gotofi(this);
		else .reteval;
	}
	_evalFI	{
		<_sstarter>.ifpop;
		.reteval;
	}
// 	_rewIF	{}
// 	_rewELSE	{}
// 	_rewFI	{}
// 	_rewELIF	{}
	/***********************/
	gettyp	{	_stype;	}
	settype(string stype)	{
		_stype = stype;
		this.addmethod("_eval", "_eval" + stype );
		if( .hasmet("_rew"+stype) )	{
			this.addmethod("_rew", "_rew" + stype );
		}
	}
	setflags(string snextob)	{
		 _snextbeh = snextob;	
	}
	setfinfun(string stdfinobj, string stdfinfun)	{
		_stdfinobj = stdfinobj;
		_stdfinfun = stdfinfun;
	}
	setasstarter(string bone, bool brandom, bool bpar, bool block, int ienum, int iifsave, string sifsave, string sifvar)	{
		this.settype("start");
		new string _sstarter=this.getname();
		new bool brand = brandom;
		new bool _bmslock;		// tmp do przechowania locka myszy
		new vector vecbehs;
		bblock = block;
		vecbehs.type("string");
		new string bonce = bone;
		bparal = bpar;
		new int ienumer = ienum;
		if( ienum>0 )	{
			new int _iencnt = 1;
		} else if( bpar )	{
			new vector vecbehs2;
			vecbehs2.type("string");
		}
		new int iisifsave=iifsave;
		if( iifsave>=0 )	{
			new string sisifsave = sifsave;
			if( sifvar!=null )
				new string sisifvar = sifvar;
		}
		new vector vbif;
	}
	bif	{	vbif.last;	}
	bif=(bool b)	{	vbif.set( vbif.size-1, b);	}
	ifpush	{	vbif.add(1);	}
	ifpop	{	_ = vbif.pop;	}
	int isenumer()	{
		return ienumer;	
	}
	int nextenum()	{
		if( _iencnt > vecbehs.size() )	{
			_iencnt = ienumer+1;
		} else {
			_iencnt++;
		}
		return _iencnt-1;
	}
	addtostarter(string sob)	{	vecbehs.add( sob );	}
	bool getblock()	{	return bblock;	}
	addflags(string sst,  bool block, bool bpar)	{
		new string _sstarter=sst;
		bblock = _stype=="read" ? false : block;
		bparal = bpar;	// czy nalezy wykonac rownolegle
	}
	bool behret(string sob)	{
		vecbehs2.remove(sob);
		return vecbehs2.size()==0;
	}
	_setasif(string sdb, int row, int i1, int i2)	{
		new int istart = i1;
		new int istop = i2;
		new string _db = sdb;
		new int irow = row;
		new int ifst = 0;
	}
	setasIF(string sdb, int row, int i1, int i2)	{
		.settype("IF");
		._setasif(sdb, row, i1, i2);
	}
	setasELIF(string sdb, int row, int i1, int i2)	{
		.settype("ELIF");
		._setasif(sdb, row, i1, i2);
	}
	setas(string s)	{	.settype(s);	}
	setasscript(string sscr, string sfun, string sdb, int row, int id)	{
		this.settype("script");
		new string _sscr = sscr;
		new string _sfun2 = sfun;
		new int _id = id;
		new string _sdb = sdb;
		new int _row = row;
	}
	setasuse(string sitem)	{
		.settype("use");
		new string _sitem = sitem;
	}
	_evaluse	{
		<_spocketpref+.getmainhero>.pckremove( _sitem );
		.reteval;
	}
// 	_rewuse	{ }
	_evaltopck	{
		<_spocketpref+.getmainhero>.additem( _sitem, _sfile );
		.reteval;
	}
// 	_rewtopck	{}
	setastopck(string sitem, string sfile)	{
		.settype("topck");
		new string _sitem = sitem;
		new string _sfile = sfile;
	}
	setasmet(string sob, string sfun)	{
		this.settype("met");
		new string _sob2 = sob;
		new string _sfun2 = sfun;
	}
	setassaver(string svar, string sval)	{
		this.settype("save");
		new string ssavvar = svar;
		new string ssavval = sval;
	}
	setasnewgamer(string styp, string spath, string sgame)	{
		this.settype("game");
		new string _sgame=sgame;
		new string _styp = styp;
		new string _spath = spath;
	}
	setasreader(string sfile, int x, int y, string sdir)	{
		this.settype("read");
		new string _sread = sfile;
		new int _ix = x;
		new int _iy = y;
		new string _sdir = sdir;
	}
	setaswaiter(int delay)	{
		this.settype("wait");
		new timer timwait;
		timwait.settick(1);
		timwait.delay(delay);
		timwait._csplbuild( this.getname(), "reteval" );
		timwait.addmethod("onfinish", "_csplfinish");
	}
	setassndbg(string ssnd, int vol)	{
		this.settype("sndbg");
		new snd _sndbg;
		_sndbg.buildfullname;
		_sndbg.setstartstopflag(false, true);
		//_sndbg.load( this.getsndpath() + ssnd + ".wav" );
		_sndbg.advloadsnd(ssnd + ".wav");
		_sndbg.setvol(vol);
	}
	_loadsnd	{
		
	}
	setasanorder(string sdb,int irow,  int icol, string san)	{
		this.settype("anorder");
		new string _sdb = sdb;
		new int _irow = irow;
		new int _icol = icol;
		new string _san = san;
	}
	setascaller(string sbeh, string sscr)	{
		this.settype("call");
		new string scallobj = sbeh;
		new string sscript = sscr;
	}
	_csplbuild(string sob, string sfin)	{
		new string _sobj = sob;
		new string _sfinfun = sfin;
	}
	_csplfinish()	{
		this.callfun(_sobj, _sfinfun);
	}
	setassndplayer(string sfile, int vol)	{
		this.settype("sndplay");
		new snd sndp;
		sndp.buildfullname;
		sndp.setstartstopflag( false, true );
		//sndp.load( this.getsndpath()+sfile+".wav" );
		sndp.advloadsnd(sfile+".wav");
		sndp._csplbuild( this.getname(), "reteval" );
		sndp.addmethod("onfinish", "_csplfinish");
		sndp.setvol(vol);
	}
	setasposer(string san, string  idestx, int idesty, int bssc, string sdir )	{
		this.settype("setpos");
		new string _san = san;
		new string _idestx = idestx;
		new int _idesty = idesty;
		new bool _bssc = bssc;
		new string _sdir = sdir;
	}
	setasturn(string sptf, string sdir)	{
		this.settype("turn");
		new string _sptf = sptf;
		new string _sdir = sdir;
	}
	setaswalker(string sptf, string idestx, string idesty )	{
		this.settype("walk");
		new string _sptf = sptf;
		new string _idestx = idestx;
		new string _idesty = idesty;
	}
	setasanplayer(string san, string sact)	{	
		this.settype("anplay");
		new string _san = san;
		new string _sact = sact;
	}
	setastalker(string san, string swav, string sbase, int itypsort,
			bool bstart, bool bstop, string sdir )	{
		this.settype("talk");
		new string _san = san;
		
		new string __swav = swav;
		new string __sbase = sbase;
		
 		new int isort = itypsort;
 		new bool bstt = bstart;
 		new bool bstp = bstop;
 		new string _sdir = sdir;
	}
	setasenter	{	.settype("enter");	}
	setasclose	{	.settype("close");	}
	setasmusic(string sdb, int row, int colstart, int colend)	{
		.settype("music");
		new vector vmus;	vmus.type("string");
		vmus.buildfullname;
		while ( colstart>=0 && colstart<colend )	{
			vmus.add( <sdb>.get(row, colstart) );
			colstart++;
		}
	}
}

new snd _fx_pocket;
_fx_pocket.load("sounds/sfx/harfa.wav");

class classadvpocket : classadvobject, classadvbut, gmimgvec	{
	init(string sname)	{
		classadvobject::init();
		classadvbut::init(sname);
		gmimgvec::init();
		this.setbuttyp("pocket");
		.setreach(true);
		.setadvbutpos("-hero","-main");
		new int iX;
		new int iY;
		new int iNumItems = 0;
		new int iMaxItems = 14;
		new int iScale;
		new string sState = "closed";
		new string _sanim = this.getname();
		_sanim = _sanim.strsubbs( _spocketpref );
		new string sItem = null;
		new string sFocusItem = null;
		
		new string _sbase = "anpocket";
		new int _ibase = _sbase.length();
		
		this.setz(1000);
		
		new string sitempath;
		new vector arPocket;
		arPocket.type("string");
		new vector arPocketFile;
		arPocketFile.type("string");
		this.cnewtimercyclefin("tim", 1, 1, "evalpocket");
		
		sitempath = modadv.get("itempath:",1);
		
		int z = this.getz();
		new anima imitem;
		imitem.anloopfin();
		imitem.setz(z+1);
		new img immarker;
		immarker.load( sitempath + "itemmarker.png" );
		immarker.setz(z-1);
		immarker.hide();
		
		this.hide();
		
		new bool bskip=false;
	}
	/*******************************/
	addtoadv()	{		// jezeli jest globalna kieszen
		this.addtogamevars(this.getname());
		this.enable();
		this.addasadvobject();
	}
	removefromadv()	{
		this.disable();
		this.removefromadvobjs();
	}
	hidepocket()	{
		if( sState!="closed")	{
			if( sState!="close" )	{
				this.pockettoggle();
				tim.stop(false);
			}
			while(sState!="closed")	{
				tim.evalpocket();
				tim.stop(false);
			}
		}
	}
	exitpocket	{
		sState = "closed";
		tim.stop(false);
		.hide;
	}
	/*******************************/
	skip()	{	bskip=true;	}
	skipitem()	{	if( sItem!=null )	{	bskip=true;	}	}
	additem(string sname, string sfile)	{
		if( arPocket.contains(sname) ) return;
		arPocket.add(sname);
		arPocketFile.add(sfile);
// 		string s = _sbase+iNumItems;
		string s = _sbase + sname;
		new anima <s>;
		this.add(s);
		<s>.load( sitempath + sfile + ".pyz" );
		//<s>.setframe("in",0);
		<s>.play(0);
		<s>.setz( this.getz() );
		<s>.hide();
		iNumItems++;
	}
	savestate(string sfilepref)	{
		arPocket.vecsave( "saves/" + this+sfilepref + "_name.txt" );
		arPocketFile.vecsave( "saves/" + this+sfilepref + "_file.txt" );
	}
	loadstate(string sfilepref)	{
		new vector vpcp;	vpcp.type("string");
		new vector vpcf;		vpcf.type("string");
		vpcp.vecload( "saves/" + this+sfilepref + "_name.txt" );
		vpcf.vecload( "saves/" + this+sfilepref + "_file.txt" );
		for( int i=0; i< vpcp.size; i++)	.additem( vpcp.get(i), vpcf.get(i) );
		delete vpcp;
		delete vpcf;
	}
	removeitem(string sname)	{
		@id = arPocket.find(sname.strsubbs(_sbase));
		if( id<0 ) return;
		arPocket.removeat(id);
		arPocketFile.removeat(id);
		this.remove( sname );
		delete <sname>;
		iNumItems--;
		if ( sState == "opened" ){	this.hide();	}
	}
	useitem()	{
		if( sItem!=null )	{
			this.removeitem( sItem );
			this.itemhide();
		}
	}
	pckremove(string sname)	{	.removeitem( _sbase + sname );	}
	evalpocket(){
		this.play();
		if ( sState == "open" ){
			iScale+=16;
		} else if ( sState == "close" ){
			iScale-=16;
		}
		if ( iScale > 116 ){
			this.stop(false);
			iScale = 116;
			sState = "opened";
		} else if ( iScale < 0 ){
			this.stop(false);
			iScale = 0;
			sState = "closed";
		}
		real dRadius = (iScale * iScale )/550;
		//real dRadius = iScale.sqrt(iScale)*2;
		real dAngle;
		string s;
		for (int i=0; i< iNumItems; i++){
			dAngle = dRadius*i-(dRadius*iNumItems/2.0) -90.0 + dRadius/2;
			s = this.get(i);
			<s>.setpos( dAngle.cos() * iScale + iX - 76/2, dAngle.sin() * iScale + iY - 75/2 );
			//<s>.show();
			if( <s>.isvisible )
				<s>.play(0);
		}
		if ( sState == "closed" ){
			this.hide();
		}
	}
	pocketpos(int x, int y)	{
		int ix = x-iX;
		int iy = y-iY;
		this.move(ix,iy);
		iX=x;
		iY=y;
	}
	pockettoggle(){
		if ( sState == "opened" ){
			sState = "close";
			immarker.hide();
			tim.play();
		} else if ( sState == "closed" ){
			sState = "open";
			_fx_pocket.play;
			iX = <_sanim>.getposx();
			iY = <_sanim>.getposy()-<_sanim>.geth()/2;
			this.itemhide();
			this.show();
			tim.evalpocket();
			tim.play();
		} else if ( sState == "open" ){
			sState = "close";
		} else if ( sState == "close" ){
			sState = "open";
		}
	}
	string getitem()	{	return sItem!=null ? sItem.strsubbs(_sbase) : null;	}
	itemhide(){
		sFocusItem = null;
		sItem = null;
		imitem.stop(false);
		imitem.hide();
	}
	itemclick()	{
		this.skip();
		
		if ( sState == "closed" ){
			this.pockettoggle();
		} else if ( sState == "opened" ){
			if ( sFocusItem != null ){
				if( sItem!=null )	{
					.pockettoggle;
					_b_rewind = !.playbehif( "beh_"+_sanim+"_USE_"+sItem.strsubbs(_sbase)+"_ON_"+sFocusItem.strsubbs(_sbase) );
					.itemhide;
				} else {
					sItem = sFocusItem;
					imitem.copy(sItem);
					<sFocusItem>.hide();
					//imitem.play("out");
					imitem.play(1);
					imitem.setz( this.getz() + 1 );
					this.setitempos();
					//this.pockettoggle();
				}
			} else {
				this.pockettoggle();
			}
		} else if ( sState == "open" ){
			this.pockettoggle();
		} else if ( sState == "close" ){
			this.pockettoggle();
		}
	}
	int butisin(int x, int y, bool bignorehidden, bool bignorealpha)	{
		int id = gmimgvec::isin(x,y,bignorehidden,bignorealpha);
		if( id )	{
			sFocusItem = this.get( id-1 );
		} else {
			sFocusItem = null;
			id = <_sanim>.isin(x,y,bignorehidden,bignorealpha);
		}
		return id;
	}
	hide	{
		.eval1("stop",false);
		.eval("hide");
		immarker.hide;
	}
	setitempos()	{
		imitem.setpos( mouse.getpx()-76/2, mouse.getpy()-75/2 );
	}
	itemmoveoff()	{
		if ( sState == "opened" ){
			immarker.hide();
		}
	}
	itemmoveon()	{
		if ( sState == "opened" ){
			if (sFocusItem != null){
				immarker.show();
				immarker.setpos( <sFocusItem>.getcx-immarker.getw/2, <sFocusItem>.getcy-immarker.geth/2 );
			} 
		}
	}
	onmouselclick(int x, int y)	{
		if(bskip)	{
			bskip=false;
			if( sItem!=null && sState=="opened" && sFocusItem==null) .pockettoggle;
		} else {
			if( .getmainhero==_sanim )
				sState=="opened" || sState=="open"  ? this.pockettoggle() : this.itemhide();
		}
	}
	onmouserclick(int x, int y)	{
		if( .butisin(x,y,true,true) )	{
			if( sState=="opened" && sFocusItem!=null )	{
				_ = .playbehif( "beh_"+_sanim+"_ITEM_"+sFocusItem.strsubbs(_sbase) );
				//.pockettoggle;
			} else {
				_ = .playbehif( "beh_RCLICK_"+_sanim );
			}
		}
	}
	onmousemove(int x, int y)	{
		if ( sItem != null ){	this.setitempos();	}
		if ( sState == "opened" && this.butisin(x,y,true,true) )	{
			this.itemmoveon();
		}
	}
	/**************** button **********/
	moveoff()	{
		advmouse.setstd();
		this.itemmoveoff();	
	}
	clickon()	{
		if( .getmainhero == _sanim )	{
			//.skipitem;
			clwalkq.stand;
			.itemclick;
		} else {
			clwalkq.visit( this );
		}
	}
}

/* 
	klasa oblugujaca postac z gry
	Dominik Dagiel 3 III 2006
*/

new string sgmlastscene = null;
new string sgmglobpath = null;	// dla gier, ktore sa w innym katalogu niz ich nazwa
new string sgmgame = null;		// jezeli .adv inaczej sie nazywa niz game
new db gdbsound;			// baza dialogow
new classfullsave clsave("saves/save.txt");

new string _slhpref = "cllh";	// prefix do obiektu classloadedhero
new string _spathpref = "pt";	// prefix do obiektu classpathf
new string _spocketpref = "pc";	// prefix do pocket
new string _sstndpref = "stnd";	// prefix do standera
new string _stalkpref = "ctlk";

new bool AdventureGame;

new CutScene ccs(0, 0, iResX, iResY);
ccs.setz(2000);

module modadv	{
	init()	{
		new db dbload;
		new string stalktype;
		this.settalktype("snd");
		new Script scrl(null);
		new string _stalk;
	}
	/********************************/
	public execute(string sfunc)		{	scrl.call(sfunc);		}
	public loadscript(string sfile)		{	scrl.load(sfile);			}
	/********************************/
	public loadsounds(string sfile)	{
		gdbsound.load(sfile);
		if( igmdebug )	{
			gdbsound.save( "exports/adv.dlg" );
		}
	}
	public string gettalktype()	{	return stalktype;	}
	public settalktype(string s)	{	stalktype=s;	}
	/********************************/
	public load(string sfile)			{
		dbload.loadscript(sfile);
		_stalk = this.get("talk:",1);
	}
	public string get(string styp, int ipos)	{
		int id = dbload.findbyrow(styp);
		if( id<0 )	{
			engine.print("modadv.dbload: can't find "+styp);
			return null;
		} else
			return  dbload.get( id, ipos );
	}
}

module modadvglob	{
	init()	{
		new gmobjvec grhero;
		new gmobjvec grfiles;
		new gmobjvec grpck;
	}
	bool addhero(string sname, string sfile, bool bpocket)	{
		clsave.set("hero_"+sname+"_active",1);
		int id = grhero.find(sname);
		if( id>=0 ) {
			if( grfiles.get(id)!=sfile )	{
				grfiles.set(id, sfile);
				<sname>.load( .getpath(sfile) );
			}
			<sname>.addtogamevars(sname);
			if( bpocket )
				<_spocketpref+sname>.addtoadv();
			return false;
		} else {
			this.newanima(sname,sfile,0);
			<sname>.addtogamevars(sname);
			grhero.add(sname);
			grfiles.add(sfile);
			if( bpocket )	{
				string s = _spocketpref+sname;
				if( !.hasvar(s) )	{
					new classadvpocket <s>(sname);
					//<s>.addtogamevars(s);
					grpck.add(s);
					<s>.addtoadv;
					//<s>.enable;
				} else	{
					<s>.addtoadv;
				}
			}
			return true;
		}
	}
	reloadhero(string sname)	{
		int id = grhero.find(sname);
		if( id>=0 )	{
			string s = grfiles.get(id);
			._delhero(sname, false);
			_ = .addhero(sname, s, false);
		}
	}
	delhero(string sname)	{	._delhero(sname, true);	}
	delheros	{	while( grhero.size )	.delhero(grhero.first);	}
	_delhero(string sname, bool bdelpck)	{
		clsave.set("hero_"+sname+"_active",0);
		int id = grhero.find(sname);
		if(id>=0)	{
			delete <sname>;
			grhero.removeat(id);
			grfiles.removeat(id);
			/*if( <gameapi.getgamename>.hasvar("clcamera") )	{
				clcamera.remove(sname);
			}*/
			sname = _spocketpref + sname;
			if( this.hasvar(sname) && bdelpck)	{
				delete <sname>;
				grpck.remove(sname);
			}
		}
	}
	savepck(string s)	{
		grpck.vecsave("saves/grpck_"+s+".txt");
		for( int i=0; i<grpck.size; i++)	{	<grpck.get(i)>.savestate(s);	}
	}
	loadpck(string sfile)	{
		@s2, @s;
// 		engine.setdebugstate(1);
		for( int i=0; i< grpck.size; i++)	{
			s2 = grpck.get(i);
			<s2>.removefromadv;
			delete <s2>;
		}
		grpck.vecload("saves/grpck_"+sfile+".txt");
		for( i=0; i<grpck.size; i++)	{
			s2 = grpck.get(i);
			new classadvpocket <s2>( s2.strsubbs(_spocketpref) );
			<s2>.loadstate(sfile);
			<s2>.removefromadv;
		}
	}
	onexit()	{
		string s;
		for( int i=0; i<grhero.size(); i++)	{
			s = grhero.get(i);
			<s>.stop(false);
			<s>.hide();
			if( .hasvar(_spocketpref+s) )	<_spocketpref+s>.exitpocket;
			s = _spathpref + s;
			<s>.unlinkanima();
		}
	}
}

class classloadedhero	{
	init()	{
		new string sanhero;
		new bool bplaystart = false;
		new bool bplaystop = false;
	}
	public setplaystart(bool b)	{	bplaystart = b;	}
	public setplaystop(bool b)	{	bplaystop = b;	}
	public getstartstop()	{	return bplaystart, bplaystop;	}
}

class classadvcontroller : classadv	{
	init()	{
// 		new TicksCounter ctc;
		AdventureGame = true;
		
		classadv::init();
		
// 		engine.setdebugstate(1);
		
		this.setwavpath( modadv.get("sndpath:", 1) );
		
		new snd __sndplay	{
			.vars2(A,"sfun", null,"sob",null);
			.setstartstopflag(false, true);
			.addmethod("onfinish", func {	.callfun(sob, sfun);	} );
		};
		
		igmstate = 0;
		
// 		new string _slhpref = "cllh";	// prefix do obiektu classloadedhero
// 		new string _spathpref = "pt";	// prefix do obiektu classpathf
// 		new string _spocketpref = "pc";	// prefix do pocket
// 		new string _sstndpref = "stnd";	// prefix do standera
// 		new string _stalkpref = "ctlk";
		
		new classstndgroup modstnd;
		new Music _music;
		
		new timer _tim_dbclk;
		_tim_dbclk.setdelay(200);
		
		new int _if_pos = -1;
		
		new classobjcounter clcbeh("_dbbh");		// prefix do bazy danych bahaviourow
		
		new string _sbeh = "clbeh";	// prefix obiektu behaviour
		new int iidbeh;		// id behavioura niedeklarowanego poprzez nazwe
		
		new classobjcounter clcadv("dbadv");	// bazy danych z przygoda
		
		new db dbmacros;
		new vector _vecarg;	// argumenty wolania makr
		_vecarg.type("string");
		
		new classadvcamera clcamera;	// kamera
		clcamera.setmetonmsmove("advmsmove");
		
		new classwalkerqueue clwalkq;	// kolejnosc chodzenia
		
		new gmadvvec grbuts;		// obiekty do analizowania (buttons)
		new gmimgvec grmsmove;		// kieszenie bohaterow i inne do move
		new gmimgvec grmslclick;
		new gmimgvec grmsrclick;
		new gmimgvec grmslrel;
		
		new string _susetool = null;
		new string _slastms = null;
		new bool bmslock = false;
		new bool _b_rewind = true;
		
		new string sactbeh = null;		// aktualny beh
		new string slastpathf;		// ostatni pathfinder to podawania pozycji buttonow
		
		new int licznik=0;
		
		new string smainhero = null;
		
		.advsaveonstart;
		
		string s, string s2;
		if( sgmgame==null )	{
			sgmgame = this.getname();
		}
		new string sprivgame = sgmgame;
		sgmgame = null;
		
		s2 = sprivgame.strsubbs("game");
		if( sgmglobpath!=null )	{
			s = sgmglobpath;
			sgmglobpath = null;
		} else {
			s = s2;
		}
		this.setgraphpath("scripts/" + s + "/" );
		this.loadadventure( s2 + ".adv");
		grbuts.sortimgs();
		
		if( smainhero==null )	{	smainhero = clcamera.getactor();	}
		
		clcamera.start();
		clcamera.setscene();
		clwalkq.start();
		clwalkq.setverlen(1);
		
		advmouse.setstd();
		
		if( .behexist("preinit") )	{
			.playbehobfin("preinit", this, "playbehinit");
		} else .playbehinit;
		
		grbuts.sortimgs();
	}
	public playbehinit	{
		if ( clsave.bis(sprivgame+"visited") ){
			if ( this.playpostinit( "behinit_FROM_" + sgmlastscene ) )	{
			} else if ( this.playpostinit( "behinit" ) )	{
			}
//			else <gameapi.getgamename()>.postinit();
		} else {
			clsave.bset(sprivgame+"visited");
			if( this.playpostinit( "behinit0_FROM_" + sgmlastscene ) )	{}
			else if ( this.playpostinit( "behinit0" ) )	{}
			else if ( this.playpostinit( "behinit_FROM_" + sgmlastscene ) )	{}
			else if ( this.playpostinit( "behinit" ) )	{}
//			else <gameapi.getgamename()>.postinit();
		}
	}
	public getmainhero()	{
		return smainhero;
	}
	public setmainhero(string s)	{
		smainhero=s;
	}
	public bool ismainhero(string s)	{	return smainhero==s;	}
	public setactbeh(string s)	{	sactbeh = s;	}
	public string getactbeh()	{	return sactbeh;	}
	public bool advgetlock()	{	return bmslock;	}
	public advmslock()	{
		bmslock=true;
		advmouse.setwait();
	}
	public advmsunlock()	{
		bmslock=false;
		advmouse.setstd();
	}
	public advmssetlock(bool block)	{
		block ? this.advmslock() : this.advmsunlock();
	}
	public setusetool(string s)	{	_susetool=s;	}
	public getusetool()	{	return _susetool;	}
	/********************************/
	bool playpostinit( string sbeh ){ 
		return this.playbehobfinif( sbeh, gameapi.getgamename(), "postinit");
	}
	public playbeh(string sname)	{
		this.playbehfin(sname,null);
	}
	public bool playbehif(string sname)	{
		if ( this.behexist( sname ) ){
			this.playbehfin(sname,null);
			return true;
		}
		return false;
	}
	public playbehfin(string sname, string sfunfin)	{
		this.playbehobfin(sname,null,sfunfin);
	}
	public bool playbehfinif(string sname, string sfunfin)	{
		if ( this.behexist( sname ) ){
			this.playbehfin(sname,sfunfin);
			return true;
		}
		return false;
	}
	public playbehobfin(string sname, string sobfin, string sfunfin)	{
		<this.getbeh(sname)>.playfin(sobfin, sfunfin);
	}
	public bool playbehobfinif(string sname, string sobfin, string sfunfin)	{
		if ( this.behexist( sname ) ){
			this.playbehobfin(sname,sobfin,sfunfin);
			return true;
		}
		return false;
	}
	public playnewgamepath(string sgame, string spath)	{
		sgmglobpath = spath;
		sgmlastscene = sprivgame;
		clsave.set("lastscene", sgmlastscene);
		gameapi.play(sgame);
	}
	public playnewgame(string sgame)	{
		this.playnewgamepath(sgame, null);
	}
	public playfromscript(string spath, string sgame)	{
		sgmgame = sgame;
		this.playnewgamepath( modadv.get("defaultadv:",1), spath );
	}
	/********************************/
	string getheroloader(string swavbase)	{
		swavbase = _slhpref + swavbase;
		engine.varexist(swavbase) ? swavbase : null;
	}
	/*********************************/
	public advanstand(string san)	{
		string s =  _spathpref + san;
		if( engine.varexist( s ) && <s>.iswalking() )	{
			<s>.stop(false);
			<s>.stand();
		}
	}
	public reloadhero(string sfile)	{
		.anreload(._getheropath(sfile));
		string sptf = _spathpref + this;
		<sptf>.linkanima(this);
		<sptf>.linkfilter;
		<sptf>.scalean;
	}
	analizeanopts(string sdb, int irow, int icol, int ilecol, string san, string sgrp, string styp)	{
		real r[2], string s1, string s2;
		bool b0 = false, bool b1 = false, int i[3], bool bfont=false;
		while( icol < ilecol )	{
			icol++;
			match(<sdb>.get(irow,icol-1))	{
				"-stt" => {	b0 = <sdb>.get(irow,icol);	icol++;	}
				"-stp"=> {	b1 = <sdb>.get(irow,icol);	icol++;	}
				"-wav"=> { s1 = _slhpref + <sdb>.get(irow,icol);	icol++;
					new classloadedhero <s1>;
					<s1>.varset( "sanhero", san );
					<sgrp>.add( s1 );
				}
				"-path" => {
					classadvanhero::buildheroframe(san);	// on end frame anputgr
					s1 = <sdb>.get(irow,icol);	icol++;	// pathfinder
					r0 = <sdb>.get(irow,icol);	icol++;	// step
					s2 = _spathpref+san;
					this.newclpathfcopy( s2, san, s1, r0);
					<s2>.prepareforhero();
					s1 = s2 + "look";	new classherolooker <s1>;	<s1>.link( san );
					s1 = s2 + "use";	new classherouser <s1>;		<s1>.link( san );
					s1 = s2 + "take";	new classherotaker <s1>;	<s1>.link( san );
				}
				"-ft"=> {	s2 = _spathpref+san;
					r0 = <sdb>.get(irow,icol);	icol++;	// z depth
					r1 = <sdb>.get(irow,icol);	icol++;	// scale power
					<s2>.linkfilter();
					<s2>.setzsize(r0);
					<s2>.setscalepower(r1);
				}
				"-stnd"=> { <_sstndpref+san>.setdelay(<sdb>.get(irow,icol)); icol++; }
				"-txt" => { i0 = <sdb>.get(irow,icol);	icol++;
					i1 = <sdb>.get(irow,icol);	icol++;
					i2 = <sdb>.get(irow,icol);	icol++;
					<_stalkpref+san>.settxtcolor(i0,i1,i2);
				}
				"-font" => {	bfont=true;
					s1 = <sdb>.get(irow,icol);	icol++;
					s2 = <sdb>.get(irow,icol);	icol++;
					if( styp=="hero:" )	{
						<_stalkpref+san>.setfont( s1, s2 );
					}
				}
				? => icol = this.analizeaninstr( sdb ,irow, icol-1, san);
			}
		}
		if( !bfont && styp=="hero:")	{
			<_stalkpref+san>.setfont( modadv.get("font:",1), modadv.get("font:",2) );
		}
		<sgrp>.eval1("setplaystart", b0 );
		<sgrp>.eval1("setplaystop", b1 );
		<sgrp>.free();
	}
	setasadvanima()	{
		classadvanhero::setashero( this.getname(), "cadvherofinish");
	}
	analizebut(string styp, string sdb, int irow, int icol)	{
		string s[3], int i[2];
		s0 = <sdb>.get(irow,icol);	icol++;	// nazwa
		s1 = <sdb>.get(irow,icol);	icol++;	// nazwa annki
		if( s1.contains(".pyz") )	{
			s2 = s1;
			s1 = "an" + s1.strsube(4);
			.newanima( s1, s2, 0);
		}
		styp = styp.strsube(1);
		//<"classadv"+styp.strsube(1)>::setasbutton(s1,s0);
		classadvbut::setasbutton2(s1, s0, styp);
		classadvbut::<"setas"+styp>(s1);
		<s1>.setadvbutpos( <s1>.getcx(), <s1>.getcy() );
		while( icol < <sdb>.getcolsno(irow) )	{
			icol++;
			match( <sdb>.get(irow,icol-1) )	{
				"-pos"=> {	s0 = <sdb>.get(irow,icol);	icol++;	// x
					s2 = <sdb>.get(irow,icol);	icol++;	// y
					if(s0=="-id" && slastpathf!=null)	{
						i0 = <slastpathf>.getbyname(s2);
						s0 = <slastpathf>.getxver(i0) - <slastpathf>.getposx();
						s2 = <slastpathf>.getyver(i0) - <slastpathf>.getposy();
					}
					<s1>.setadvbutpos(s0,s2);
				}
				"-bs1"	=> {	<s1>.setbutbase1( <sdb>.get(irow,icol) ); icol++;}
				"-bs2"	=> {	<s1>.setbutbase2( <sdb>.get(irow,icol) ); icol++;}
				"-us1" => {	<s1>.baseuse1=( <sdb>.get(irow,icol) ); icol++;}
				"-us2" => {	<s1>.baseuse2=( <sdb>.get(irow,icol) ); icol++;}
				"-useon"	=> {	<s1>.setbutbase1( modadv.get("use:",1) );
					<s1>.setbutbase2( modadv.get("use:",2) );
				}
				"-dir"	=> {	<s1>.setbutdir( <sdb>.get(irow,icol) ); icol++;}
				"-noreach"=> 	<s1>.setreach(false);
				"-nh" => <s1>.hideontake = (false);
				"-pck" =>  {	<s1>.setpocket( <sdb>.get(irow,icol) ); icol++;}
				"-mask" => { classadvbut::setasmask(s1); <s1>.hide;	}
				"-inpck" => {
					if( <s1>.hideontake )	{
						<s1>.hide();		// zabranie przedmiotu
					} else <s1>.setbuttyp("but");
					s0 = .getmainhero;
					if( s0==null ) s0 = clcamera.getactor;
					< <s0>.getpocket >.additem( <s1>.getbutname, <s1>.getpocket );
				}
				"-disable" => <s1>.disable;
				"-once" => {
					s0 = <sdb>.get(irow,icol);	icol++;
					<s1>.setonce( s0 );
					if( clsave.bis(s0) ) <s1>.disable;
				}
				? => ;
			}
		}
	}
	_getheropath(string s)	{
		string sp = .getpath(s);
		if( engine.fileexist(sp) )
			"$" + sp;
		else "$" + modadv.get("heropath:",1) + s;
	}
	public loadadventure(string sfile)	{
		string sdb = clcadv.get();
		string sgrp = "grpers"+clcadv.size();
		new db <sdb>;
		//<sdb>.loadbeh(this.getgraphpath()+sfile);
		<sdb>.loadbeh( .getpath(sfile) );
		int ile = <sdb>.getrowsno();
		int i[4], string s[3], bool b[2], bool bhero;
		real r[2];
		
		s0 = sdb + "script";
		new Script <s0>(sdb);
		
		string spath = "";
		new gmobjvec <sgrp>;
		for( int i=0; i<ile; i++)	{
			i0 =0 ;
			i1 = <sdb>.getcolsno(i);
			s0 = <sdb>.get(i,i0);	i0++;
			match(s0)	{
				"setpath:" => {
					spath = <sdb>.get(i,i0);	i0++;
					this.setgraphpath(spath);
				} "nopath:" => {
					spath = "";
					this.setgraphpath(spath);
				} "func"	=> {		// funkcja skryptu
					while( <sdb>.get(i,0)!="end" )	i++;
				} "sndpath:"	=> {
					s0 = <sdb>.get(i,i0);	i0++;
					this.setwavpath(s0);
				} "hero:", "an:"	=> {
					i2 = <sdb>.dbdelvar(i,"-global");
					i3 = <sdb>.dbdelvar(i,"-pck");
					s2 = <sdb>.get(i,i0);	i0++;	// anima
					if( s2.contains(".pyz") )	{
						s1 = s2;
						s2 = "an"+s2.strsubes(".pyz");
					} else {
						s1 = <sdb>.get(i,i0);	i0++;	// file
					}
					if( s0=="hero:" )	{
						/*if( s1.contains(".pyz") && !engine.fileexist(.getpath(s1)) )
							s1 = "$" + modadv.get("heropath:",1) + s1;*/
						if( s1.contains(".pyz") )	{
							s1 = ._getheropath(s1);
							//s1.print;
						}
					}
					if( s1.contains(".pyz") )	{
						if( i2 )	{
							if(modadvglob.addhero(s2,s1,i3))
								<s2>.setasadvanima();
							i1--;
						} else {
							this.newanima(s2, s1, 0);
							<s2>.setasadvanima();
							if( s0=="hero:" && i3)	new classadvpocket <_spocketpref + s2>(s2);
						}
					} else {
						this.copyanima(s1, s2);
						<s2>.setasadvanima();
						if( s0=="hero:" && i3)	new classadvpocket <_spocketpref + s2>(s2);
					}
					if(i3)	i1--;
					if( s0=="hero:" )	{
						new classadvstander <_sstndpref+s2>;
						//classadvanhero::buildheroframe(s2);
						
						//new classadvpocket <_spocketpref + s2>(s2);
						
						s1 = _stalkpref+s2;
						new classtalker <s1>;
						<s1>.set(s2);
						<s1>.settextdb("gdbsound");
					}
					this.analizeanopts(sdb, i, i0, i1, s2, sgrp, s0);
				} "anaac:"	=>	{
					i2 = <sdb>.dbdelvar(i,"-mask");
					i3 = 0;
					s0 = <sdb>.get(i,i0);	i0++;	// anima
					if( s0.contains(".pyz") )	{
						s1 = s0;
						s0 = "an" + s0.strsubes(".pyz");
					} else {
						s1 = <sdb>.get(i,i0);	i0++;	// z ktorej..
					}
					if( i2 )	{
						i1--;
						new gmmaskvec <s0>;
					} else {
						new gmadvvec <s0>;
					}
					if( s1.contains(".pyz") )	{
						.newanima("_" + s0, s1, 0);
						s1 = "_" + s0;
						i3 = 1;
					}
					i2 = this.newanactionsgr(s1, s0, s0);
					i0 = this.analizeaninstr( sdb ,i, i0, s0);
					if( i3 ) <s1>.hide;
				} "anaf:"	=> {
					s0 = <sdb>.get(i,i0);	i0++;	// anima
					//s1 = <sdb>.get(i,i0);	i0++;	// z ktorej..
					if( s0.contains(".pyz") )	{
						s1 = s0;
						s0 = "an" + s0.strsubes(".pyz");
					} else {
						s1 = <sdb>.get(i,i0);	i0++;	// z ktorej..
					}
					new gmimgvec <s0>;
					if( s1.contains(".pyz") )	{
						.newanima("_" + s0, s1, 0);
						s1 = "_" + s0;
					}
					i2 = this.newanfrbyactgr(s1, s0, s0);
					i0 = this.analizeaninstr( sdb ,i, i0, s0);
				} "anfac:"	=> {
					i2 = <sdb>.dbdelvar(i,"-mask");
					s0 = <sdb>.get(i,i0);	i0++;	// anima
					if( i2 )	{
						i1--;
						new gmmaskvec <s0>;
					} else {
						new gmadvvec <s0>;
					}
					s1 = <sdb>.get(i,i0);	i0++;	// z ktorej..
					s2 = <sdb>.get(i,i0);	i0++;	// akcja
					i2 = this.newanframesgr(s1, s0, <s1>.actionnr(s2), s0);
					i0 = this.analizeaninstr( sdb ,i, i0, s0);
				} "anac:"	=> {
					i2 = <sdb>.dbdelvar(i,"-adv");
					s0 = <sdb>.get(i,i0);	i0++;	// anima
					s1 = <sdb>.get(i,i0);	i0++;	// z ktorej..
					s2 = <sdb>.get(i,i0);	i0++;	// akcja
					if( StringChecker::isdigit(s2) )	s2 = <s1>.nameofaction(s2);
					this.copyanimaact(s1, s0, s2);
					if( i2 )	{
						i1--;
						<s0>.setasadvanima();
					}
					i0 = this.analizeaninstr( sdb ,i, i0, s0);
				} "anf:" => {
					i2 = <sdb>.dbdelvar(i,"-mask");
					s0 = <sdb>.get(i,i0);	i0++;	// anima
					s1 = <sdb>.get(i,i0);	i0++;	// z ktorej..
					s2 = <sdb>.get(i,i0);	i0++;	// akcja
					i3 = <sdb>.get(i,i0);	i0++;	// klatka
					this.copyanima( s1, s0 );
					<s0>.setframe(s2,i3);
					if( i2 )	{
						i1--;
						<s0>.setasadvanima();
					}
					i0 = this.analizeaninstr( sdb ,i, i0, s0);
				} "anorder:" => {
					s0 = <sdb>.get(i,i0);	i0++;	// anima
					i0 = this.analizeaninstr( sdb ,i, i0, s0);
				} "behfile:" => {
					this.loadbehaviours( <sdb>.get(i,i0) );
					i0++;
				} "include:" =>	{	// another adv specification
					this.loadadventure( <sdb>.get(i,i0) );
					i0++;
				} "walkqueue:" => {
					while( i0<i1 )	{
						clwalkq.add( _spathpref + <sdb>.get(i,i0) );
						i0++;
					}
				} "font:" => {
					s0 = <sdb>.get(i,i0);	i0++;	// nazwa
					s1 = <sdb>.get(i,i0);	i0++;	// plik
					i2 = <sdb>.get(i,i0);	i0++;	// size
					new font <s0>;
					<s0>.load( s1, i2 );
				} "bkg:" => {
					s0 = <sdb>.get(i,i0);	i0++;	// plik
					//this.csetbkg(s0);
					if( s0.contains(".pyz") )	.newanima("imgbkg", s0, 0);
					else .newimg("imgbkg",s0,0);
				
					i0 = this.analizeaninstr( sdb ,i, i0, "imgbkg");
				} "img:" => {
					s0 = <sdb>.get(i,i0);	i0++;	// nazwa
					if( s0.gete(0,4)->in(A, ".jpg", ".png") )	{
						s1 = s0;
						s0 = "img" + s0.strsube(4);
					} else {
						s1 = <sdb>.get(i,i0);	i0++;	// plik
					}
					this.newimg(s0,s1,0);
					i0 = this.analizeaninstr( sdb ,i, i0, s0);
				} "but:", "doors:", "item:" => {
					this.analizebut(s0, sdb, i, i0);
				} "camera:" => {
					r0 = <sdb>.get(i,i0);	i0++;	// xmodfifier
					r1 = <sdb>.get(i,i0);	i0++;	// ymodifier
					clcamera.scalemodifiers(r0,r1);
					while(i0<i1)	{
						s0 = <sdb>.get(i,i0);	i0++;
						if( s0=="-size")	{
							i2 = <sdb>.get(i,i0);	i0++;
							i3 = <sdb>.get(i,i0);	i0++;
							clcamera.setborders( i2, i3 );
						} else if (s0=="-center")	{
							i2 = <sdb>.get(i,i0);	i0++;
							i3 = <sdb>.get(i,i0);	i0++;
							clcamera.setcenter( i2, i3 );
						} else if (s0=="-sizebg")	{
							clcamera.setborders(imgbkg.getw(), imgbkg.geth());
						}
					}
				} "actor:" => {	clcamera.setactor(<sdb>.get(i,i0)); i0++;
				} "bgr:" => {
					s0 = <sdb>.get(i,i0);	i0++;	// plan
					r0 = <sdb>.get(i,i0);	i0++;	// scalex
					r1 = <sdb>.get(i,i0);	i0++;	// scaley
					new classbgplan <s0>;
					clcamera.addbgr(s0, r0, r1);
				} "pathfinder:" => {
					slastpathf = <sdb>.get(i,i0);	i0++;	// nazwa
					s1 = <sdb>.get(i,i0);	i0++;	// file
					if( s1.contains(".ptf") )	{	
						i2 = 20;
						i3 = 20;
					} else {// znaczy, ze wgrywany z grafiki
						i2 = <sdb>.get(i,i0);	i0++;	// dx
						i3 = <sdb>.get(i,i0);	i0++;	// dy
					}
					this.newpathf(slastpathf, s1, i2, i3);
				} "script:" =>	{
					s0 = <sdb>.get(i,i0);	i0++;	// nazwa
					s1 = <sdb>.get(i,i0);	i0++;	// file
					new Script <s0>(s1);
				} "func:" => {		// wywolanie wewnetrznej funkcji
					s1 = <sdb>.get(i,i0); i0++;
					i1--;		// usuwamy nawiasy
					for(i2=clcadv.size-1; i2 >=0; i2--)	{
						s0 = clcadv.getid(i2) + "script";
						if( <s0>.containsfun(s1) )	{
							for(i2=3; i2< i1; i2++)
								<s0>.ARG = ( i2-3, <sdb>.get(i, i2) );
							i2 = -1;
							<s0>.call(s1);
						}
					}
				}
				"IF" => {
					_if_pos++;
					i = ._found_if(sdb, i, i0, i1);
				}
				"ELSE" => i = ._goto_fi(sdb, i+1);
				"FI" => {
					_if_pos--;
					if( _if_pos<-1 )	("FI error! "+this+"."+ .methodname)->print;
				}
				"bsave:" =>{ 	clsave.bset(<sdb>.get(i,i0)); i0++;}
				"save:" => {
					s0 = <sdb>.get(i,i0); i0++;
					s1 = <sdb>.get(i,i0); i0++;
					clsave.set(s0,s1);
				}
				"stdptf:" => {	slastpathf = <sdb>.get(i,i0); i0++;	}
				"sfxs:" => {
					while(i0<i1)	{
						s0 = <sdb>.get(i,i0); i0++;
						s2 = s0 + ".wav";
						i2=1;
						i3 = 100;
						b0 = false;
						b1 = false;
						r0 = 0.0;
						while(i2 && i0<i1)	{
							s1 = <sdb>.get(i, i0);
							match(s1)	{
								"-f" => {
									i0++;
									s2 = <sdb>.get(i,i0) + ".wav";
								}
								"-v" => {
									i0++;
									i3 = <sdb>.get(i,i0);
								}
								"-l" => b0 = true;
								"-p" => b1 = true;
								"-pl" => r0 = 1.0;
								? => {
									i0--;
									i2 = 0;
								}
							}
							i0++;
						}
						.newsfx(s0, s2);
						<s0>.setvol(i3);
						if( b0 ) <s0>.addmethod("onfinish","_stdsndloop");
						//if( b0 ) <s0>.loop;
						if( b1 ) <s0>.play;
						else if (r0) <s0>.playloop;
					}
				}
				? => ;
			}
		}
		<sdb>.readonly();
	}
	int _found_if(string sdb, int row, int col, int cols)	{
		col++;		// opusc nawias
		int i2 = 0;
		bool odp = 0;
		cols--;
		string s[2];
		while( col<cols )	{
			s0 = <sdb>.get(row, col);
			s1 = <sdb>.dbchecknext(row, col);
			match(s1)	{
				")","|", "&" => {
					odp = ._check_if(i2, odp, s0.getb(0,1)=="!" ? (!clsave.bis(s0.strsubb(1))) : clsave.bis(s0) );
					if( s1=="|" ) i2 = 1;
					else if (s1=="&") i2 = 2;
				}
				"=" => {
					col+=2;
					odp = ._check_if(i2, odp, clsave.is(s0, <sdb>.get(row, col)) );
					i2 = ._check_if2( <sdb>.dbchecknext(row, col) );
				}
				"!=" => {
					col+=2;
					odp = ._check_if(i2, odp, !clsave.is(s0, <sdb>.get(row, col)) );
					i2 = ._check_if2( <sdb>.dbchecknext(row, col) );
				}
				? => ;
			}
			col+=2;
		}
		if( !odp )	{
			._goto_fi(sdb, row+1);
		} else row;
	}
	_goto_fi(string sdb, int row)	{
		int poz = _if_pos;
		while( 1 )	{
			match( <sdb>.get(row,0) )	{
				"IF" => poz++;
				"ELSE" => if( poz==_if_pos ) return row;	// for robi potem i++
					//else poz--;
				"FI" => if( poz==_if_pos ) {
						_if_pos--;
						return row;	// for robi potem i++
					} else poz--;
				? => ;
			}
			row++;
		}
	}
	int _check_if2(string s)	{
		match(s)	{
			"|" => 1;
			"&" => 2;
			? => 0;
		}
	}
	bool _check_if(int opt, bool b, bool bnew)	{
		match( opt )	{
			1 => b || bnew;
			2 => b && bnew;
			? => bnew;
		}
	}
	behrewind()	{	if( sactbeh!=null )	<sactbeh>.rewind();	}
	bool behplaying()	{	return sactbeh!=null;	}
	bool behexist(string sname)	{	return engine.varexist( this.getbeh(sname) );	}
	string getbeh(string sname)	{	return _sbeh+sname;	}
	string newbehname()	{
		string s = _sbeh + "_" + iidbeh;
		iidbeh++;
		return s;
	}
	string newbeh()	{
		string s = this.newbehname();
		new classbehhero <s>;
		return s;
	}
	def _checkvol(string sdb,int irow, int id)	{
		if( <sdb>.dbchecknext(irow, id)=="-v" )	{
			id+=2;
			return <sdb>.get(irow, id), id+1;
		} else return 100, id+1;
	}
	loadbeh(string sdb, int irow, int icol, int id, string sstarter, string sprevobj, bool brand, bool bpar)	{
		string s[4], bool bblock = <sstarter>.getblock(), bool bread;
		s0 = <sdb>.get(irow,id);	id++;
		s1 = this.newbeh();
		int i[2];
		match(s0)	{
			"IF", "ELIF" => {
				i0 = id+1;
				while( <sdb>.get(irow, id)!=")" ) id++;
				<s1>.<"setas"+s0>(sdb, irow, i0, id);
				id++;
			}
			"FI", "ELSE" => <s1>.setas(s0);
			"call:" => {	s0 = <sdb>.get(irow,id);	id++;
				<s1>.setascaller( s0, sdb+"script" );
			}
			"walk:" => {	s0 = <sdb>.get(irow,id);	id++;	// kto
				s2 = <sdb>.get(irow,id);	id++;	// destx lub "id"
				s3 = <sdb>.get(irow,id);	id++;	// desty lub idpath
				<s1>.setaswalker( _spathpref + s0, s2, s3 );
			}
			"turn:" => {	s0 = <sdb>.get(irow,id);	id++;	// kto
				s2 = <sdb>.get(irow,id);	id++;	// dir
				<s1>.setasturn( _spathpref + s0, s2 );
			}
			"setpos:" => {	s0 = <sdb>.get(irow,id);	id++;	// kto
				s2 = <sdb>.get(irow,id);	id++;	// id lub x
				i1 = <sdb>.get(irow,id);
				i0 = 0;
				s3 = <sdb>.dbchecknext(irow,id);
				if( s3=="-ssc" )	{
					i0 = 1;
					id++;
					s3 = <sdb>.dbchecknext(irow,id);
				}
				if( s3=="-dir" )	{
					id+=2;
					s3 = <sdb>.get(irow, id);
				} else {
					s3 = "auto";
				}
				id++;
				<s1>.setasposer( s0, s2, i1, i0, s3 );
			}
			"game:" => {	s0 = <sdb>.get(irow,id);	id++;	// nazwa gry
				match( s0 )	{
					"-def", "-adv" => {
						<s1>.setasnewgamer(s0, <sdb>.get(irow, id), <sdb>.get(irow, id+1) );
						id+=2;
					}
					? => <s1>.setasnewgamer(null, null, s0);
				}
			}
			"ref:" => {		id = this.buildbeh( "_" + iidbeh, sdb, irow, id );
				s0 = this.newbehname();
				<s1>.setascaller( s0.strsubbs(_sbeh), sdb+"script" );
			}
			"anplay:" => {	s0 = <sdb>.get(irow,id);	id++;
				s2 = <sdb>.get(irow,id);	id++;
				<s1>.setasanplayer(s0, s2);
			}
			"anorder:" =>	{	s2 = <sdb>.get(irow,id);	id++;
				<s1>.setasanorder(sdb, irow, id, s2);
				id = this.analizeaninstr(sdb,irow,id,null);
			}
			"sndbg:" =>	{	s0 = <sdb>.get(irow,id);
				|i0, id| = ._checkvol(sdb,irow,id);
				<s1>.setassndbg(s0, i0);
			}
			"sndplay:" =>	{	s0 = <sdb>.get(irow,id);
				|i0, id| = ._checkvol(sdb,irow,id);
				<s1>.setassndplayer(s0, i0);
			}
			"fxplay:" => 	{	s0 = <sdb>.get(irow,id);
				|i0, id| = ._checkvol(sdb,irow,id);
				<s1>.setassndplayer("sfx/"+s0, i0);
			}
			"fxbg:" => 	{	s2 = <sdb>.get(irow,id);
				|i0, id| = ._checkvol(sdb,irow,id);
				<s1>.setassndbg("sfx/"+s2, i0);
			}
			"wait:" =>	{	i0 = <sdb>.get(irow,id);	id++;
				<s1>.setaswaiter(i0);
			}
			"read:" =>	{	s0 = <sdb>.get(irow,id);	id++;	// plik
				i0 = <sdb>.get(irow,id);	id++;	// x
				i1 = <sdb>.get(irow,id);	id++;	// y
				s2 = "auto";
				if( <sdb>.getcolsno(irow)>id )	{
					s2 = <sdb>.get(irow,id);
					if( s2=="-dir" )	{
						id++;
						s2 = <sdb>.get(irow,id); id++;
					}
				}
				<s1>.setasreader(s0,i0,i1,s2);
			}
			"met:" =>	{	s0 = <sdb>.get(irow,id);	id++;
				s3 = gameapi.getgamename;
				if( s0.contains(".") )	{
					s2 = s0.strgetto(".");
					s0 = s0.strgetfrom(".");
					if( s2=="" || s2=="this" ) s2 = s3;
				} else
					s2 = s3;
				<s1>.setasmet(s2, s0);
			}
			"bsave:" =>	{	s0 = <sdb>.get(irow,id);	id++;
				<s1>.setassaver(s0,"1");
			}
			"save:" =>	{	s0 = <sdb>.get(irow,id);	id++;
				s2 = <sdb>.get(irow,id);	id++;
				<s1>.setassaver(s0,s2);
			}
			"script:" =>	{	s0 = <sdb>.get(irow,id);	id++;
				s2 = <sdb>.get(irow,id);	id++;
				<s1>.setasscript(s0,s2);
			}
			"func:" =>	{
				s2 = <sdb>.get(irow,id);
				
				for(i1=clcbeh.size-1; i1 >= 0; i1--)	{
					s0 = clcbeh.getid(i1) + "script";
					if( <s0>.containsfun(s2) )	{
						i1 = -1;
					}
				}
				//s0 = sdb + "script";
				
				if( <sdb>.dbchecknext(irow,id)=="(" )	{
					i1 = id+2;
					while( <sdb>.get(irow,id)!=")" ) id++;
				} else {
					i1 = -1;
				}
				id++;
				<s1>.setasscript(s0,s2, sdb, irow, i1);
			}
			"use:" => {	s0 = <sdb>.get(irow,id);	id++;
				<s1>.setasuse(s0);
			}
			"topck:" => {
				s2 = <sdb>.get(irow,id);	// przedmiot
				if( <sdb>.dbchecknext(irow,id)=="-pck" )	{
					id+=2;
					s3 = <sdb>.get(irow,id);
				} else s3 = s2;
				id++;
				<s1>.setastopck(s2, s3);
			}
			"enter:"	=> <s1>.setasenter;
			"close:"	=> <s1>.setasclose;
			"music:"	=> {
				i1 = id+1;
				while( <sdb>.get(irow,id)!=")" ) id++;
				<s1>.setasmusic(sdb, irow, i1, id);
				id++;
			}
			? => {		// talker
				s3 = s0.strgetto("_");
				s2 = this.getheroloader( s3 );
				if( s2==null )	{
					if( igmdebug ) engine.print(s1+": "+s0+" loadbeh error: no hero linked to "+s3);
					return s1, icol;
					//<s1>.setassndplayer(s0);
				} else {
					|bool bstart, bool bstop| = <s2>.getstartstop();
					string sdir="auto", string sbase=modadv.varget("_stalk"), int itypsort=1;
					bread = id<icol;
					while(bread)	{
						s3 = <sdb>.get(irow,id);	id++;
						match(s3)	{
							"-stt" =>	{	bstart = <sdb>.get(irow,id);	id++;}
							"-stp"=>	{	bstop = <sdb>.get(irow,id);	id++;}
							"-base"=>	{	sbase = <sdb>.get(irow,id);	id++;}
							"-r" =>	itypsort=1; 
							"-nr" =>	itypsort = 0;
							"-dir" =>	{	sdir = <sdb>.get(irow,id);	id++;}
							? => {	bread = false;	id--;	}
						}
						if( bread && id>=icol )	{
							bread = false;
						}
					}
					<s1>.setastalker( <s2>.varget("sanhero"), s0, sbase,
						itypsort, bstart, bstop, sdir );
					
				}
			}
		}
		<sstarter>.addtostarter( s1 );
		
		if( brand==false)	{
			<sprevobj>.setflags(s1);
			<s1>.addflags( sstarter, bblock, bpar );
		} else {
			<sprevobj>.setflags(null);
			<s1>.addflags( sstarter, bblock, false );
		}
		/*if( id < icol )	{
			this.loadbeh(sdb,irow,icol,id,sstarter,s1,brand, bpar);
		}*/
		return s1, id;
	}
	int buildbeh(string sname, string sdb, int irow, int icol)	{
		int id = dbmacros.findbyrow( <sdb>.get(irow, icol) );
		if( id<0 )	{
			engine.print("no such macro: "+ <sdb>.get(irow, icol) );
			return -1;	
		}	// nie ma takiego makra
		while( <sdb>.get(irow, icol) != "(" )	{	icol++;	}
		icol++;
		int id2 = <sdb>.addrow() -1;
		string s = <sdb>.get( irow, icol ); icol++;
		_vecarg.free();
		while( s!=")" )	{		// sczytanie argumentow
			_vecarg.add( s );
			s = <sdb>.get( irow, icol ); icol++;
		}
		int ile = dbmacros.getcolsno( id );
		int i1;
		<sdb>.add( id2, sname );
		for( int i=1; i<ile; i++)	{
			s = dbmacros.get( id, i );
			if( s.getb(0,1)=="$" )	{
				i1 = s.getb(1,10);
				<sdb>.add( id2, _vecarg.get( i1-1 ) );
			} else {
				<sdb>.add( id2, s );
			}
		}
		return icol;
	}
	loadbehaviours(string sfile)	{
		string sdb = clcbeh.get();
		new db <sdb>;
		//<sdb>.loadbeh(this.getgraphpath()+sfile);
		<sdb>.loadbeh( .getpath(sfile) );
		string s = sdb + "script";
		new Script <s>(sdb);
		int i[2], string s[4], bool brand, bool bread, string bonce, bool bpar, bool bblock, int ienumer;
		int iifsave, string sifsave, string sifvar;
		for( int i=0; i< <sdb>.getrowsno(); i++)	{
			i1 = 0;
			s0 = <sdb>.get(i,i1);	i1++;
			match(s0)	{
				"macro:" => { dbmacros.dbaddrowfrom( sdb, i, 1 );
				} "include:" => {	this.loadbehaviours(<sdb>.get(i,i1));
					i1++;
				} "build:" => { i1 = this.buildbeh( <sdb>.get(i,i1), sdb, i, i1+1 );
				} "func" => 	{ while( <sdb>.get(i,0)!="end" )	i++;
				} "IF" => { _if_pos++;	i = ._found_if( sdb, i, i1, <sdb>.getcolsno(i) );
				} "ELSE" => { i = ._goto_fi(sdb, i+1);
				} "FI" => {
					_if_pos--;
					if( _if_pos< -1 )	("FI error! "+this+"."+ .methodname)->print;
				}
				? => {
					i0 = <sdb>.getcolsno(i);
					s0 = this.getbeh(s0);
					new classbehhero <s0>;
					brand = false;
					bread = true;
					bonce = null;
					bpar = false;
					bblock = true;
					//bblock = false;
					sifvar = null;
					iifsave = -1;
					ienumer=0;
					while(bread)	{
						s1 = <sdb>.get(i,i1);	i1++;
						match(s1)	{
							"-nr"	=>	brand = false;
							"-once"	=>	{ bonce = <sdb>.get(i,i1);	i1++;}
							"-par"=>	bpar = true;
							"-r"	=>	brand = true;
							"-nb"=>	bblock = false;
							"-b"=>		bblock = true;
							"-en"=>	{	ienumer = <sdb>.get(i,i1);	i1++;}
							"-bif"=>	{	iifsave = 1;
								sifsave = <sdb>.get(i,i1);	i1++;
								sifvar=true;
							}
							"-bnif"=>	{	iifsave = 0;
								sifsave = <sdb>.get(i,i1);	i1++;
								sifvar=true;
							}
							"-if"	=>	{	iifsave = 1;
								sifsave = <sdb>.get(i,i1);	i1++;
								sifvar = <sdb>.get(i,i1);	i1++;
							}
							"-nif" =>	{	iifsave = 0;
								sifsave = <sdb>.get(i,i1);	i1++;
								sifvar = <sdb>.get(i,i1);	i1++;
							}
							?	=>	{	bread = false;
								<s0>.setasstarter(bonce, brand, bpar, bblock, ienumer, iifsave, sifsave, sifvar);
								//this.loadbeh(sdb, i, i0, i1-1, s0, s0, brand, bpar);
								
								// loadbeh(string sdb, int irow, int icol, int id, string sstarter, string sprevobj, bool brand, bool bpar)	{
								/*if( id < icol )	{
									this.loadbeh(sdb,irow,icol,id,sstarter,s1,brand, bpar);
								}*/
								i1--;
								s1 = s0;	// sstarter
								while( i1<i0 )	{
									|s1, i1| = .loadbeh( sdb, i, i0, i1, s0, s1, brand, bpar);
								}
							}
						}
					}
				}
			}
		}
		<sdb>.readonly();
	}
	int analizeaninstr(string sdb,int irow,  int icol, string san)	{
		bool bread = true;
		if( icol >= <sdb>.getcolsno(irow) )	{	bread=false;	}
		bool banalize = false;
		if( san!=null )	{
			banalize=true;
			this.advanstand(san);
		}
		int i[3];
		string s[2];
		while(bread)	{
			s1 = <sdb>.get(irow,icol);	icol++;
			match(s1)	{
				"-z"		=>	{
					if( banalize)	<san>.setz( <sdb>.get(irow,icol) );
					icol++;
				}
				"-pos"	=>	{	s0 = <sdb>.get(irow,icol);	icol++;
					i2 = <sdb>.get(irow,icol);	icol++;
					if( banalize)	{
						if(s0=="-id")	{
							s0 = _spathpref+san;
							i0 = <s0>.getbyname(i2);
							i1 = <s0>.getxver(i0) - <s0>.getposx;
							i2 = <s0>.getyver(i0) - <s0>.getposy;
						} else i1=s0;
						//<san>.setpos( i1+ clcamera.getposx(), i2+ clcamera.getposy() );
						<san>.setpos( i1, i2 );
					}
				}
				"-putgr"	=>	if( banalize )	<san>.anputgr();
				"-vis"	=>	{	i0 = <sdb>.get(irow,icol);	icol++;
					if( banalize )	i0==false ? <san>.hide() : <san>.show();
				}
				"-show"	=>	if( banalize )	<san>.show();
				"-hide"	=>	if( banalize )	<san>.hide();
				"-dir"	=>	{s0 = <sdb>.get(irow,icol);	icol++;
					if( banalize)	{
						s1 = <san>.actionname();
						i0 = <san>.framenr();
						<san>.setframe( s1.strsube(2) + s0, 0 );
					}
				}
				"-play"	=>	{
					if( banalize)	<san>.play( <sdb>.get(irow,icol) );
					icol++;
				}
				"-nplay"	=>	{i0 = <sdb>.get(irow,icol);	icol++;
					if( banalize)	<san>.nplay( i0 );
				}
				"-lplay"	=>	{
					if( banalize)	<san>.anloopsplay( <sdb>.get(irow,icol) );
					icol++;
				}
				"-bgr"	=>	{s1 = <sdb>.get(irow,icol);	icol++;
					if( banalize)	{
						<s1>.add(san);
						if( engine.varexist( _spathpref + san ) )	<s1>.add( _spathpref+san );
					}
				}
				"-sc"		=>
					if( banalize)	{
						s1 = _spathpref+san;
						if( engine.varexist( s1 ) )	<s1>.scalean();
					}
				"-ssc"	=>	if( banalize)	clcamera.setscene();
				"-actor"	=>	if( banalize)	clcamera.setactor(san);
				"-mhero"	=>	if( banalize)	this.setmainhero(san);
				"-puty"	=>	{s0 = <sdb>.get(irow,icol);	icol++;
					if( banalize)	s0=="resy" ? <san>.anputy( iResY-1 ) : <san>.anputy(s0);
				}
				"-stopf"	=>	if( banalize )	<san>.stop(false);
				"-stoph"	=>	if( banalize )	{
					<san>.stop(false);
					<san>.hide;
				}
				"-setaction" =>	{s0 = <sdb>.get(irow,icol);	icol++;
					if( banalize)	{
						if( StringChecker::isdigit(s0) )	<san>.setframe(s0.to_i, 0);
						else <san>.setframe(s0, 0);
						<san>.stop(false);
					}
				}
				"-setframe"	=>	{s0 = <sdb>.get(irow,icol);	icol++;
					i0 = <sdb>.get(irow,icol);	icol++;
					if( banalize)	{
						if( StringChecker::isdigit(s0) )	<san>.setframe(s0.to_i, i0);
						else <san>.setframe(s0, i0);
						<san>.stop(false);
					}
				}
				"-stand"	=>	{
					if( banalize)	<san>.setstandbase(<sdb>.get(irow,icol));
					icol++;
				}
				"-delay"	=>	{
					if( banalize)	<san>.setdelay(<sdb>.get(irow,icol));
					icol++;
				}
				"-step" => {
					if( banalize)	< _spathpref + san >.setanstep(<sdb>.get(irow,icol));
					icol++;
				}
				"-sb1" => {	if( banalize)	< san >.setbutbase1(<sdb>.get(irow,icol));	// dla buttona
					icol++;	}
				"-sb2" => {	if( banalize)	< san >.setbutbase2(<sdb>.get(irow,icol));	// dla buttona
					icol++;	}
				?	=>	{	bread = false;		// natrafil na inny string
					icol--;		// przywroc go do analizy
				}
			}
			if( bread && icol>=<sdb>.getcolsno(irow) )	bread = false;
		}
		return icol;
	}
	/*******************************/
	cadvherofinish()	{}
	/*******************************/
	butmoveoff(string sbut)	{
		<sbut>.moveoff();
		this.< <sbut>.getbutname() + "_MOVEOFF">();
	}
	butmoveon(string sbut)	{
		<sbut>.moveon();
		this.< <sbut>.getbutname() + "_MOVEON">();
	}
	advmsmove()	{
		if ( !this.advgetlock() ){
			|int x, int y| = mouse.getpos();
			int id = grbuts.butisin(x,y,true,true);
			if( id )	{
				string s = grbuts.get(id-1);
				if( s!=_slastms )	{
					if( _slastms!=null )	this.butmoveoff(_slastms);
					_slastms = s;
					this.butmoveon(s);
				}
			} else {
				if( _slastms!=null )	{
					this.butmoveoff(_slastms);
					_slastms = null;
				}
			}
			grmsmove.eval2("onmousemove", x, y);
			moddbg.msmove();
		}
	}
	butclickon(string sbut)	{
		//string s = _spocketpref+this.getmainhero();
		//if( engine.varexist(s) )	<s>.skipitem();
		<sbut>.clickon();
		//this.< <sbut>.getbutname() + "_CLICKON">();
		if( !.behplaying )
			_b_rewind = !.playbehif( "beh_"+ <sbut>.getbutname +"_LCLICK" );
	}
	butrelease(string sbut)	{
		//string s = _spocketpref+this.getmainhero();
		//if( engine.varexist(s) )	<s>.skipitem();
		<sbut>.lrel();
		//this.< <sbut>.getbutname() + "_RELEASE">();
	}
	advmsclick()	{
		if( _tim_dbclk.isplaying )	{
			clwalkq.mulspeed(2);
			return;
		} else _tim_dbclk.play;
		_b_rewind = true;
		if( !bmslock )	{
			|int x, int y| = mouse.getpos();
			int id = grbuts.butisin(x,y,true,true);
			if( id )
				this.butclickon(grbuts.get(id-1));
			else {
				string s = _spocketpref+this.getmainhero();
				if( engine.varexist(s) )	<s>.itemhide;
				clwalkq.goto(x,y);
			}
			grmslclick.eval2("onmouselclick",x,y);
		}
		if(_b_rewind) this.behrewind();
		moddbg.mslclick();
	}
	advmsrclick	{
		if( !bmslock )	{
			grmsrclick.eval2("onmouserclick",mouse.getpos);
		}
	}
	advmslrel() {
		if( !bmslock )	{
			|int x, int y| = mouse.getpos();
			int id = grbuts.butisin(x,y,true,true);
			if( id )	this.butrelease(grbuts.get(id-1));
			grmslrel.eval2("onmouselrel",x,y);
		}
		moddbg.mslrel();
	}
	mousemove()	{
		if( igmstate==0 ) this.advmsmove();
		this.mouse_MOVE();
	}
	mouselclick()	{
		if( igmstate==0 ) this.advmsclick();
		this.mouse_LCLICK();
	}
	mouselrel()	{
		if( igmstate==0 ) this.advmslrel();
		this.mouse_LREL();
	}
	mouserclick()	{
		if( igmstate==0 ) .advmsrclick;
		this.mouse_RCLICK();
	}
	keydown()	{
		moddbg.dbkeydown();
		this.keyboard_KEYDOWN();
	}
	exit()	{
		modadvglob.onexit();
		if( igmsubtitle )	{
			subtitle.reset;
		}
	}
	onmusicfin	{
		_music.play;
	}
	/*******************************/
	sndplayobfin(string s, string sob, string sfun)	{
		__sndplay.load( .getsndpath + s + ".wav" );
		if( igmsubtitle )	{
			subtitle.register("__sndplay", this.getsndpath() + s + ".wav");
		}
		__sndplay.sob = (sob);
		__sndplay.sfun = (sfun);
		.cbsplay("__sndplay");
	}
	sndplayfin(string s, string sfun)	{	.sndplayobfin(s,null,sfun);	}
	sndplay(string s)	{	.sndplayobfin(s, null, null);	}
	/*******************************/
	advsaveonstart	{
		//clsave.set("GAME_game", this);
		clsave.set("GAME_game", gameapi.getgamename);
		clsave.set("GAME_sgmgame", sgmgame);
		clsave.set("GAME_sgmglobpath", sgmglobpath);
		clsave.set("GAME_sgmlastscene", sgmlastscene);
		clsave.set("GAME_ccs", ccs.isvisible);
		.advautosave;
	}
	advautosave	{
		clsave.save("saves/autosave.txt");
		modadvglob.savepck("autosave");
	}
	advautoload	{	._advload("autosave");	}
	advcacheload	{	._advload("cache");	}
	advcachesave	{	._advsave("cache");	}
	_advload(string s)	{
		modadvglob.delheros;
		modadvglob.loadpck(s);
		
		clsave.load("saves/"+s+".txt");
		sgmgame = clsave.get("GAME_sgmgame");
		sgmglobpath = clsave.get("GAME_sgmglobpath");
		sgmlastscene = clsave.get("GAME_sgmlastscene");
		if( clsave.bis("GAME_ccs") ) ccs.show; else ccs.hide;
		gameapi.play( clsave.get("GAME_game") );
	}
	_advsave(string s)	{
		new classfullsave _saver("saves/" + s + ".txt");
		_saver.load("saves/autosave.txt");
		_saver.stdsave;
		delete _saver;
		new vector _vcsave;	_vcsave.type("string");
		new vector _vcsv2;	_vcsv2.type("string");
		_vcsave.vecload("saves/grpck_autosave.txt");
		_vcsave.vecsave("saves/grpck_"+s+".txt");
		@s2;
		for( int i=0; i<_vcsave.size; i++)	{
			s2 = _vcsave.get(i);
			_vcsv2.vecload("saves/" + s2 + "autosave_name.txt" );
			_vcsv2.vecsave("saves/" + s2 + s + "_name.txt" );
			_vcsv2.vecload("saves/" + s2 + "autosave_file.txt" );
			_vcsv2.vecsave("saves/" + s2 + s + "_file.txt" );
		}
		delete _vcsave;
		delete _vcsv2;
// 		arPocket.save( "saves/" + this+sfilepref + "_name.txt" );
// 		arPocketFile.save( "saves/" + this+sfilepref + "_file.txt" );
	}
	/*****************************/
	advloadsnd(string sfile)	{
		.load( this.getsndpath() + sfile );
		if( igmsubtitle )	{
			subtitle.register(.getfullname, this.getsndpath() + sfile);
		}
	}
}


module moddbg : classlocker	{
	init()	{
		classlocker::init();
		new string sstate = "init";
		new int ilastx;
		new int ilasty;
		new text txtpos;
		txtpos.setz(5000);
		txtpos.setpos( 0, 0 );
		txtpos.setbkg(0,0,64,16, 0,0,0,192);
		
		new text txtswin;
		txtswin.setz(5000);
		txtswin.setbkg(0,0,64,16, 0,0,0,192);

		new text txtpod;
		txtpod.setz(5000);
		txtpod.setbkg(0,0,128,16, 0,0,0,192);

		this.disable();

	}
	public enable()	{
		this.unlock();
		txtpos.show();
		txtswin.show();
		txtpod.show();
	}
	public disable()	{
		this.lock();
		txtpos.hide();
		txtswin.hide();
		txtpod.hide();
	}
	public updatetxtpos(int x, int y)	{
		txtpos.set("" + ( x-clcamera.getposx() ) + "," + ( y-clcamera.getposy() ));
		txtpos.setpos(x-32,y+46);
		txtpod.setpos(x-64,y+30);
		txtpod.set( engine.getimg(x,y,true,true,-1000,1000));
	}
	public updateswin()	{
		txtswin.set(" " + (swinka.getposx()-clcamera.getposx()) + "," + (swinka.getposy()-clcamera.getposy()) );
		txtswin.setpos( swinka.getposx()-32, swinka.getposy() );
	}
	msminit(int x, int y)	{	this.updatetxtpos(x,y);	}
	msmmove(int x, int y)	{
		clcamera.moveplans(x-ilastx, y-ilasty);
		this.updatetxtpos(x,y);
	}
	public msmove()	{
		if( this.getlock() )	{	return;	}
		int x = mouse.getpx();
		int y = mouse.getpy();
		this.<"msm"+sstate>(x,y);
		ilastx=x;
		ilasty=y;
	}
	public mslclick()	{
		if( this.getlock() )	{	return;	}
		if( keyboard.iskeydown("space")==true )	{
			sstate="move";
		}
	}
	public mslrel()	{
		if( this.getlock()==true )	{	return;	}
		sstate = "init";
	}
	msrclick()	{
		int x = mouse.getpx();
		int y = mouse.getpy();
		int id = grbuts.isin(x,y,true,true);
		if( id!=false )	{
			string s = grbuts.get(id-1);
			s.print();
		} 
//		txtpod.set( engine.getimg(x,y,true,true,-1000,1000));
	}
	dbkeydown(){
		if( !igmdebug ) return;
		if( keyboard.iskeydown("lctrl") ) {
			if( keyboard.iskey("l") )	<gameapi.getgamename>.advcacheload;
			else if( keyboard.iskey("s") )	{
				<gameapi.getgamename>.advcachesave;
			}
		}
		if( keyboard.iskey("d") )	{
			if(.getlock)	{
				this.enable();
			} else {
				this.disable();
			}
		}
		if( this.getlock() )	{	return;	}
		if( keyboard.iskey("s")==true )	{
			this.updateswin();
		}
	}
}

game Tclassmenu	{
	init()	{
		new db _dbl;
		new gmobjvec gr1;
		gr1.add("bkg");
	}
	public tload(string spath, string sbuts, string sdbfile)	{
		this.setgraphpath(spath);
		if( sdbfile!=null )	{
			_dbl.loadscript(this.getgraphpath()+sdbfile);
			for(int i=0; i<_dbl.getrowsno();i++)	{
				this.newsnd("snd"+_dbl.get(i,0), _dbl.get(i,1)+".wav");
			}
		}
		new classbutton _clb;
		_clb.build2( this.getgraphpath() + sbuts, 10, "imglobcurs", "gr1" );
		_clb.clickfunc("_gmbutclick");
		_clb.movonfunc("_gmbutmove");
		if(engine.varexist("sndintro"))	this.cbplay("sndintro");
	}
	mouselclick()	{
		this.cactsndstop(true);
	}
	_gmbutmove(string s)	{
		sndakskermovon.play();
		if( engine.varexist("sndintro") && sndintro.isplaying() )	return;
		if( engine.varexist("snd"+s) )	this.crselfplay("snd"+s);
	}
	_gmbutclick(string s)	{
		this.<s+"_BUTCLICK">();
	}
}

class TMenu 	{
	init()	{}
	tinit(string sbuts)	{
		new Buttons but1(sbuts);
	}
	mousel_click()	{
		.cactsndstop(true);
	}
	but1_moveon	{
		string s = but1.sobject;
		sndakskermovon.play;
		if( !(engine.varexist("sndintro") && sndintro.isplaying) )
			if( engine.varexist("snd"+s) )	this.cbselfplay("snd"+s);
		.<s+"_MOVEON">;
	}
	but1_moveoff	{	.<but1.sobject + "_MOVEOFF">;	}
	but1_lclick()	{
		this.<but1.sobject+"_BUTCLICK">();
	}
}

/************ template game Painter **************/
class TPainter {
	init()	{}
	tinit(string sndbase, string spath, string sfilebg, string sfilebrush, string sfile, string sfarby, @dir, string ssavefile)	{
		if( sndbase!=null )
			GameController::init(sndbase);
		this.unlock();
		if( spath!=null )
			this.setgraphpath(spath);
		
		if( sfilebg!=null )
			this.newanima("anbkg",sfilebg,0);
		this.newanima("anbrush1", sfilebrush, 3000);
		this.copyanima("anbrush1","anbrush2");
		anbrush2.setframe(0,1);
		anbrush2.setz(anbrush1.getz-1);
		anima_pack::resizemethods("anbrush1");		// galka
		anima_pack::resizemethods("anbrush2");		// pedzel
		int x, int y;
		match( dir )	{
			"ru" => { x = anbrush2.getex;
				y = anbrush2.getpy; }
			"rd" => { x = anbrush2.getex;
				y = anbrush2.getey; }
			"ld" => { x = anbrush2.getpx;
				y = anbrush2.getey; }
			? => { x = anbrush2.getpx;
				y = anbrush2.getpy; }
		}
		anbrush1.saverelpos(x, y);	// lewy dolny rog - kursor myszy
		anbrush2.saverelpos(x, y);	// lewy dolny rog - kursor myszy
		mouse.hide();
		
		this.newanima("anfg", sfile, 100);
		anfg.setframe("foreground",0);
		
		new gmimgvec grdraw;
		_ = this.newanframesgr("anfg", "andraw", anfg.actionnr("draw"), "grdraw");
		grdraw.setz(10);
		
		new gmimgvec grpaleta;
		//_ = this.newanframesgr("anfg", "anpaleta", anfg.actionnr("paleta"), "grpaleta");
		"grpaleta" ..< sfarby;
		grpaleta.setz(20);
		
		new int _ibrx = anbrush2.getpx();
		new int _ibry = anbrush2.getpy();
		while( !anbrush2.isin(_ibrx, _ibry, false, true) )	{
			_ibrx++;
			if( _ibrx==anbrush2.getex() ) {
				_ibrx = anbrush2.getpx();
				_ibry++;
			}
		}
		_ibrx-=anbrush2.getpx();
		_ibry-=anbrush2.getpy();
		TPainter::tp_mouse_move;		// ustawienie pedzla w pozycji myszy
		
		if( ssavefile!=null )	{
			new string savefile = ssavefile;
			new db dbkolory;
			@s = ssavefile;
			//if( engine.fileexist(s) )	{
			if( .saveexist(s) )	{
				dbkolory.vecload(s);
				grdraw.each( func { (@id)
					.paint( dbkolory.get(id,0), dbkolory.get(id,1), dbkolory.get(id,2), 255, 0);
					} );
			} else {
				grdraw.each( func { (@id)
					.paint(.white,255,0);
					dbkolory.dbaddstringrow("255 255 255"," ");
					} );
				.tp_savekols;
			}
		}
	}
	game_exit()	{
		mouse.show();
		GameController::game_exit();
	}
	tp_exit	{
		mouse.show;
	}
	tp_mouse_move()	{
		anbrush1.mssetrelpos();
		anbrush2.mssetrelpos();
	}
	tp_mouse_lclick()	{
		if( !this.getlock() )	{
			|int x, int y| = mouse.getpos();
			if( grdraw.isin(x,y,true,true) )	{
				<grdraw.getsfound()>.paint(
					anbrush2.getrgba(anbrush2.getpx()+_ibrx,anbrush2.getpy()+_ibry), 0 );
				.onpaint;
			} else if ( grpaleta.isin(x,y,false,true) )	{
				|@c[4]| = <grpaleta.getsfound()>.getrgba(x,y);
				c3 = 255;
				anbrush2.paint( c0, c1, c2, c3, 0 );
				.onsetbrush;
			}
		}
	}
	tp_savekols	{
		if( !<GAME>.hasvar("dbkolory") ) return;
		grdraw.each( func { (@id)
			int c[4];
			//|c0, c1| = .anfirstnontr;
			int ex = .getex , int ey = .getey;
			int x = .getpx, int y=.getpy;
			while( x!=ex && y!=ey )	{
				if( .isin(x,y,false,true) ) { c0=x; c1=y; x=ex; }
				else x++;
			}
			|c0,c1,c2,_| = .getrgba(c0,c1);
			dbkolory.set(id,0,c0);
			dbkolory.set(id,1,c1);
			dbkolory.set(id,2,c2);
			} );
		dbkolory.vecsave( savefile );
	}
	tp_default_erase	{	.tp_erase(.white,255);	}
	tp_erase(int r, int g, int b, int a)	{
		for( int i=0; i< grdraw.size; i++)	{
			<grdraw.get(i)>.paint(r,g,b,a,0);
			dbkolory.set(i,0,255);
			dbkolory.set(i,1,255);
			dbkolory.set(i,2,255);
		}
		.tp_savekols;
	}
}

class TPainterCon : TPainter, GameController	{
	init	{}
}
new int iMemoTryb=1;	// 0 - player na czas, 1 - player vs computer, 2 - player vs player
new int iMemoW;
new int iMemoH;
new int iMemoAI = 0;	// poziom trudnosci

class TMemo 	{
	init()	{}
	public tinit(string sbkg, string stafle, string snakl, int dt)	{
		
		.newanima("anbkg", sbkg, 0);
		.newanima("antaf", stafle, 20);
		.newanima("annak", snakl, 20);
		
		new int ipredkosc = 25;
		new gmimgvec grtaf;
		new gmimgvec grnak;
		new vector veci	{
			.vecnewint( antaf.nofframes(0) );
			.hash;
		};
		string s, int i[3], int j;
		i0 = 0;
		for( int i=0; i<iMemoW; i++)	{
			for( j=0; j<iMemoH; j++)	{
				new anima <"antaf"+i0>(i0) {
					(int i)
					.copy("antaf");
					.setframe(0, veci.get(i/2));
					.anaddfilter;
					.unlink;
					grtaf.add( this );
				};
				new anima <"annak"+i0> (i0) { (int i)
					.copy("annak");
					.anaddfilter;
					.unlink;
					grnak.add(this);
				};
				i0++;
			}
		}
		antaf.hide;
		annak.hide;
		grtaf.hash;
		i0=0;
		i1 = antaf.getw + dt;
		i2 = antaf.geth + dt;
		for( i=0; i<iMemoW; i++)	{
			for( j=0; j<iMemoH; j++)	{
				s = grtaf.get(i0);
				<s>.ansetbpos( i1*i, i2*j );
				<s>.ansetbpos( i1*i, i2*j );
				<s>.vars2(A, "col", i, "row", j);
				<s>.setz(10 + 2*i0-1);
				<grnak.get(i0)>.setz(10+2*i0);
				i0++;
			}
		}
		grtaf.eval("link");
		grnak.eval("link");
		i1 = (iResX-grtaf.getw())/2;
		i2 = (iResY-grtaf.geth())/2;
		grtaf.move( i1, i2 );
		grnak.move( i1, i2 );
		new int iplayer=1;
		new int icompplayer = 0;	// 1v2
		new classfadeinout clfio;
		new classfadeinout clfio2;
		new int imemostate=0;
		new string staf1;
		new string staf2;
		new string snak1;
		new string snak2;
		new int ileai = .between(1, .between(5, iMemoW*iMemoH*0.2, 10) + iMemoAI, 20);
		new string sset1;
		new string sset2;
		new vector vecai	{
			.mresize;
			.type("string");
		};
		new int iaistate = 0;
		.newtimer("timwait", 500, 1);
		timwait.mresize;
		.cnewtimerfin("timpoka", 500, 1, "endset22");
	}
	tm_start()	{
		imemostate = 1;
		if( iMemoTryb==1 )	{
			icompplayer=2;
		}
	}
	/******************************************************/
	aigo()	{
		imemostate=11;
		.tclicks( sset1 );
	}
	aigo2()	{
		.tclicks( sset2 );
	}
	int aifind1(string sob, int i,  int ile)	{
		if( sob==null )	return -1;
		int ifr = <sob>.framenr;
		string s;
		for (; i<ile; i++)	{
			s = .get(i);
			if( s!=null && s!=sob && ifr==<s>.framenr && .tstats(i))	return i;
		}
		-1;
	}
	bool tstats(int id)	{	.stats(100-id*10);	}
	startai(string sfun)	{
		if( iplayer==icompplayer )	{
			int ile = .min(vecai.size, ileai);
			if( sfun=="aigo" )	{
				imemostate = 11;
				int i[3];
				i2 = -1;
				for(i0=0; i0<ile; i0++)	{
					i2 = vecai.aifind1( vecai.get(i0), i0+1, ile );
					if( i2>=0 && .tstats(i0))	{
						i1 = i0;
						i0 = ile;
					} else
						i2=-1;
				}
				if( i2>=0 )	{		// znalazl pare
					sset1 = vecai.get(i1);
					sset2 = vecai.get(i2);
				} else {
					sset1 = grtaf.rand;
					sset2 = null;
				}
			} else {
				if( sset2 == null )	{
					int id = vecai.aifind1( sset1, 0, ile );
					if (id>=0 && .tstats(id))	sset2 = vecai.get(id);
					else 	sset2 = grtaf.randdiff( sset1 );
				}
			}
			"timwait" ..< sfun;
			timwait.play;
		}
	}
	/******************************************************/
	endset3()	{
		imemostate=1;
		if( iMemoTryb>0 )	{
			.tnextplayer;
			.startai("aigo");
		}
	}
	endset2	{	timpoka.play;	}
	endset22	{
		imemostate=3;
		<snak2>.hide;
		if( <staf1>.framenr == <staf2>.framenr )	{
			_ = "grnak" .- snak1 .- snak2;
			_ = "grtaf" .- staf1 .- staf2;
			vecai.set( vecai.find( staf1 ), null );
			vecai.set( vecai.find( staf2 ), null );
			if( grtaf.empty )	{
				imemostate = 5;
				clfio.setopacity(1, -ipredkosc, staf1, null );
				clfio2.setopacity(1, -ipredkosc, staf2, null );
				.tfinish;
			} else {
				clfio.setopacity(1, -ipredkosc, staf1, func {
						<staf1>.hide;	<staf2>.hide;
						if( iplayer!=icompplayer) imemostate=1;
						.startai("aigo");
					});
				clfio2.setopacity(1, -ipredkosc, staf2, null );
				.tpoint;
			}
		} else {
			<snak1>.show;
			<snak2>.show;
			clfio.setopacity(1, ipredkosc, snak1, "endset3");
			clfio2.setopacity(1, ipredkosc, snak2, null );
			.terror;
		}
	}
	tclicks(string sob)	{	.tclick(<sob>.getcx, <sob>.getcy);	}
	tclick(int x, int y)	{
		if( grnak.isin( x, y, true, true ) )	string s = grnak.getsfound;
		else return;
		.tchoose;
		//engine.setdebugstate(true);
		if( imemostate==1 || imemostate==11 ) {
			imemostate--;
			snak1 = s;
			staf1 = grtaf.getimg(<s>.getcx, <s>.getcy, true, true );
			vecai.vecset( staf1, null );
			vecai.addbegin( staf1 );
			vecai.veclimes(30);
			clfio.setopacity(1, -ipredkosc, s, func {
				<snak1>.hide;
				imemostate+=2;
				.startai("aigo2");
				});
		} else if (imemostate==2 || imemostate==12)	{
			imemostate-=2;
			snak2 = s;
			staf2 = grtaf.getimg(<s>.getcx, <s>.getcy, true, true );
			vecai.vecset(staf2,null);
			vecai.addbegin( staf2 );
			vecai.veclimes(30);
			clfio.setopacity(1, -ipredkosc, s, "endset2");
		}
	}
	tnextplayer	{	iplayer = iplayer==1 ? 2 : 1;	}
	tfitinsurf(int x, int y)	{
		grtaf.eval("unlink");
		grnak.eval("unlink");
		@w = x/iMemoW;
		@h = y/iMemoH;
		@dw = <grtaf.first>.getw;
		@dh = <grtaf.first>.geth;
		@dy = h - dh;
		@dx = w - dw;
		@i0 = 0;
		
		for( int i=0; i< iMemoW; i++)	{
			for( int j=0; j<iMemoH; j++)	{
				@s = grtaf.get(i0);
				<s>.ansetbpos(w*i, h*j);
				if( dx<0 && i%2 ) <s>.move(0, dy/2);
				<grnak.get(i0)>.ansetbpos( <s>.getpx, <s>.getpy );
				i0++;
			}
		}
		x = (iResX-grnak.getex)/2;
		y = (iResY-grnak.getey)/2;
		grnak.move( x, y );
		grtaf.move( x, y );
		grtaf.eval("link");
		grnak.eval("link");
	}
	/*********************/
	tm_mouselclick	{
		if( imemostate.in(A,1,2))	.tclick( mouse.getpos );
	}
	virtual tfinish	{}
	virtual tpoint		{}
	virtual terror		{}
	virtual tchoose	{}
}


module dzmouse	{
	init()	{
		new anima anmsc;
	}
	public load(string sname)	{
		anmsc.load(sname);
		anmsc.hide();
	}
	set(string saction)	{
		anmsc.show();
		anmsc.setframe( saction, 0 );
		mouse.setcursor("anmsc");
		anmsc.hide();
	}
	setstd()	{	this.set("std");	}
	setact()	{	this.set("act");	}
	setbut()	{	this.set("but");	}
	get()		{	return anmsc.actionname();	}
	isact	{	.get=="act";	}
	isstd	{	.get=="std";		}
	isbut	{	.get=="but";	}
}


new string sAskerGame;
class Game : classadv, GameController, Localize	{
	init(string s)	{
		igmstate = 0;
		classadv::init;
		GameController::init(s);
		Localize::init;
		clbuts.setcursorpos(0, 0);
		claskexit.setcursorpos(0, 0);
		|new int X1, new int Y1, new int X2, new int Y2| = 117, 85, 916, 684;
		.path = (s);
		.setwavpath(SNDPATH);
		.sfxs=(A,"pop 50", "pik1");
		bsms.setstd;		// ustawia standardowo 
		clmusic.play;
		clbuts.reset;
		dzmouse.setstd;
		new Music mus;
		if( igmdemo )	{
			new anima anpieczatka {
				.load("scripts/common/pieczatka.pyz");
				.setz(2000);
				.hide;
			};
		}
		new int _idialvolume = 100;
		ccs.hide;
		
		new Button butleaf;
	}
	/***********************************************/
	_button_click	{	.<this+"_click">;	}
	cstrzalki	{
		.newanima("angoleft", "$scripts/common/goleft.pyz", 1000);
		.newanima("angoright", "$scripts/common/goright.pyz", 1000);
		angoleft.Button_stdalpha;
		angoright.Button_stdalpha;
		angoleft.addmethod("butclick", "_button_click");
		angoright.addmethod("butclick", "_button_click");
		butleaf.add("angoleft");
		butleaf.add("angoright");
	}
	cbutexit	{
		.newanima("anbutexit", "$scripts/common/butexit.pyz", 1000);
		anbutexit.Button_stdalpha;
		anbutexit.addmethod("butclick", "_button_click");
		butleaf.add("anbutexit");
	}
	cshowbut(@dir)	{	clp.show(cbok.getimgfunc("getcx"), cbok.getimgfunc("getcy"), dir); }
	napisshow(int x, int y)	{
		.show;
		.move(x,y);
	}
	napispod(string s)	{	.napisshow(<s>.getcx-.getw/2, <s>.getey+5); }
	crect	{	new Rect rec(600,196,403,497);	}
	crect2	{	new Rect rec2(6,174,1012,530);	}
	inpiecz(int x, int y)	{
		if( igmdemo )	{
			anpieczatka.setpos(x,y);
			anpieczatka.show;
		}
	}
	askfor(@s)	{ if( igmstate!=111) {sAskerGame=s; claskexit.askexittomenu; }	}
	outpiecz	{	if(igmdemo)	anpieczatka.hide;	}
	/***********************************************************/
	onmusicfin      {       mus.play;       }
	exit	{
		bsms.setstd;
		.game_exit;
		if( igmsubtitle )	{
			subtitle.reset;
		}
	}
	public askrestart	{	claskexit.askrestart;	}
	/***********************************************************/
	advclick()	{
		if( igmdebug && (igmstate==0 || igmstate==5) )	{
			this.cactsndstop(true);
		}
	}
	cvol=(int ivol)	{	_idialvolume = .between(0, ivol, 100);	}
	cvol	{ _idialvolume;	}
	cvplay(string ssnd)	{
		.cbplay(ssnd);
		<ssnd>.setvol(.cvol);
	}
	gotoadv(string spath, string sgame)	{
		sgmlastscene = gameapi.getgamename;
		sgmglobpath = spath;
		sgmgame = sgame;
		gameapi.play("gameadvdef");
	}
}

class Jogi : Game	{
	init(string s)	{
		Game::init(s);
		.cstrzalki;
		.cbutexit;
	}
	anbutexit_click	{ gameapi.play("Menu"); }
}
new classgamepause clpause;
new classgamemusic clmusic;
clmusic.sndbgrpath("sounds/bgr/");
clmusic.musicpath("sounds/music/");
clmusic.load("sounds/music.db");

new snd sndakskermovon;
sndakskermovon.load("sounds/sfx/butmovon.wav");
sndakskermovon.setvol(50);

class classasker2 : classasker	{
	init()	{
		classasker::init();
		
		new snd sndaskexit;		sndaskexit.setstartstopflag(false,true);
		new snd sndaskexitgame;	sndaskexitgame.setstartstopflag(false,true);
		new snd sndyes;			sndyes.setstartstopflag(false,true);
		new snd sndno;			sndno.setstartstopflag(false,true);
		new snd sndaskrestart;	sndaskrestart.setstartstopflag(false,true);
		new snd sndaskrestart2;	sndaskrestart2.setstartstopflag(false,true);

		.reload;
		this.load( "scripts/common/asker.pyz", 12000 );
		this.fxonmovon("sndakskermovon");
	}
	reload	{
		this.setwavpath(SNDPATH);
		@s = .getsndpath;
		sndaskexit.load( s + "nar07.wav");
		sndaskexitgame.load( s + "nar12.wav");
		sndyes.load( s + "nar08.wav");
		sndno.load( s + "nar09.wav");
		sndaskrestart.load( s + "nar11.wav");
		sndaskrestart2.load( s + "nar14.wav");
	}
	askexittomenu()	{
		this.ask( "sndaskexit", "sndyes", "sndno", "myestomenu", "mnotomenu");
	}
	askexitgame	{	.ask( "sndaskexitgame", "sndyes", "sndno", "myestomenu", "mnotomenu");	}
	askrestart()	{
		this.ask( "sndaskrestart", "sndyes", "sndno", "myesrestart", "mnorestart");
	}
	askrestart2()	{
		this.ask( "sndaskrestart2", "sndyes", "sndno", "myesrestart", "mnorestart");
	}
	mnotomenu()	{}
	myestomenu()	{
		modadvglob.delheros;
		clsave.free;
		match( gameapi.getgamename() )	{
			"Memo" => "exit";
			? => "SubMenu";
		}
		gameapi.play;
	}
	mnorestart()	{
		match(gameapi.getgamename)	{
			"Memo" => "exit";
			? => "MainMenu";
		}
		gameapi.play;
	}
	myesrestart()	{	this.crestart();	}
	/*****************************************************************/
	ask( string sask, string syes, string sno, string sf1, string sf2 )	{
		if( !ccs.isplaying )	classasker::ask( sask, syes, sno, sf1, sf2 );
	}
}

new classasker2 claskexit;

public LANG=(@s)	{
	LANG = s;
	SNDPATH = "sounds/";
	if( LANG=="pl" ) LANG="";
	if( LANG.length > 0 ) SNDPATH += LANG + "/";
	
	claskexit.reload;
}

module clbuts	{
	init()	{}
	load()	{
		new classbutton buts;
		buts.build("scripts/common/buttons.pyz", 4000, "imglobcurs");
		buts.transclickfunc( engine.actclassname(), "butclick");
		buts.transmovonfunc( engine.actclassname(), "butmovon");
		buts.transmovofffunc( engine.actclassname(), "butmovoff");
		buts.disableall();
		new db dbb;
		dbb.load("scripts/common/buts.db");
		new snd sndfxglobon;
		sndfxglobon.load("sounds/sfx/globbutmovon.wav");
		sndfxglobon.setvol(50);
		new @bvisible = true;
	}
	reset()	{
		buts.disableall();	
		@sgame = gameapi.getgamename;
		int pos = dbb.findbyrow( sgame );
		if( pos>=0 )	{
			int ile = dbb.getcolsno( pos );
			for( int i=1; i<ile; i++)	{
				buts.enable( dbb.get( pos, i ) );
			}
		}
	}
	setcursorpos(int x, int y)	{	buts.setcursorpos(x,y);	}
	enable(string sbu)	{
		buts.enable( sbu );
	}
	/*****************************************/
	butmovon(string sc)	{
		sndfxglobon.play();
		bvisible = mouse.isvisible;
		mouse.show;
		.<this + "_" + sc + "_butmoveon">;
	}
	butmovoff(string sc)	{
		if( !bvisible ) mouse.hide;
		.<this + "_" + sc + "_butmoveoff">;
	}
	butclick(string sc)	{
		if( sc=="pause" )	{
			clpause.pause();
		} else if( sc=="exit" )	{
			match( gameapi.getgamename )	{
				"MenuGry", "MenuTest", "MenuBaj" => gameapi.play("MainMenu");
				"SubMenu" => {
					if( sSubMenu == "quiz" ) gameapi.play("MainMenu");
					else gameapi.play("MenuGry");
				}
				? => claskexit.askexittomenu();
			}
		} else if (sc=="restart")	{
			claskexit.askrestart();
		}
		.<this + "_" + sc + "_butclick">;
	}
}

class classplacepointer2 : classplacepointer    {
	init()  {
		classplacepointer::init();
		this.load("scripts/common/strzalka.pyz");
	}
}

/***************************************************/
// new classnextgame clnextgm;
igmstate = 0;
|igmdebug, igmwinlocal, igmeasy, igmdemo, igmbegin| = true, false, false, false, true;

if( igmwinlocal )	{
	string s = engine.getspecialpath("appdata");
	if( s!=null && engine.mkdir(s+"/"+sgmproject)==0 )	{
		engine.mkdir(s + "/" + sgmproject + "/saves");
	}
}

bsms.setstd;

//clnextgm.load("scripts/common/games.db");
clbuts.load;
dzmouse.load("scripts/common/cursors.pyz");

gameapi.play("MainLoader");
game MainLoader : Game	{
	init	{
		Game::init("mainloader");
		
		
		// ADV
		advmouse.load("scripts/common/cursors.pyz");
		modadv.load("scripts/common/defaults.adv");
		modadv.loadsounds("scripts/common/sounds.db");
		modadv.settalktype("snd");
		modadv.loadscript("scripts/common/initscript.dsc");
		clsave.load("saves/global.txt");
		sgmlastscene = this;
		
// 		gameapi.play("Egipt");
// 		gameapi.play("cs1");
		gameapi.play(modadv.get("startgame:",1) );
// 		gameapi.play("tmpg2");
// 		gameapi.play("tmpg1");
	}
}
/***************************************************/


class Gracze	{
	init(int imode)	{
		new int idrugi = 1;
		if( imode==1 )	idrugi=2;	// 1 - p vs comp, 2 - p vs p
		new anima angracz1;
		angracz1.load("scripts/memo/gracze.pyz");
		.copyanima("angracz1", "anactive1");
		anactive1.setframe(0,1);
		.copyanima("angracz1", "angracz2");
		angracz2.setframe(idrugi,0);
		.copyanima("angracz1", "anactive2");
		anactive2.setframe(idrugi,1);
		.var("aktualny");
		.set(1);
		new gmimgvec gracz1;
		_ = "gracz1" .+ "angracz1" .+ "anactive1";
		new gmimgvec gracz2;
		_ = "gracz2" .+ "angracz2" .+ "anactive2";
		gracz1.addtogamevars("gracz1");
		gracz2.addtogamevars("gracz2");
	}
	set(int id)	{
		anactive1.setframe(0,1);
		anactive2.setframe(idrugi,1);
		if( id==1 )	anactive1.setframe(0,2);
		else	anactive2.setframe(idrugi,2);
	}
}

|iMemoW, iMemoH| = 4, 4;
iMemoTryb = 1;
new int iMemoLevel = 3;

game Memo : Jogi, TMemo {
	init()	{
		Jogi::init("memo");
		
		//iMemoH = 3;
		//iMemoW = 3 + iMemoLevel;
		
		.tinit("bkgame.pyz", "tmale.pyz", "tafmaly.pyz", 2);
		
		.imgs = (A, "belka.pyz");
		
		.tfitinsurf( 600, 500 );
		
		.sfxs = (A, "elektropik", "mikrofala", "brawo", "buu");
		.sounds = ( A,
			"sndintro0", "Znajd wszystkie pary najszybciej jak potrafisz!", func { ttc.play; .tm_start; },
			"sndintro1", "Zaczyna gracz pierwszy", "tm_start",
			"sndwin1", "Zwyciy Gracz pierwszy!", "askrestart2",
			"sndwin2", "Zwyciy Gracz drugi!", "askrestart2",
			"sndwincomp", "Zwyciy komputer!", "askrestart",
			"sndremis", "Ale zacity pojedynek! Mamy remis prosz pastwa!", "askrestart2",
			"sndrekord", "Brawo! Brawo! Rekord czasowy pobity!", "askrestart",
			"sndnierekord", "Niestety nie udao si pobi rekordu", "askrestart"
			);
		
		if( iMemoTryb==0 )	{
			//.newanima("anbgcnt", "counterbg.pyz", 0);
			.newimg("anbgcnt", "licznik1.png", 0);
			@skala = 0.75;
			new TextTimeCounter ttc(null,skala*30, 220,220,220,
				anbgcnt.getpx+15, anbgcnt.getpy+13,1000, "hms");
			.cbplay("sndintro0");
		} else {
			new Cypher ct1(null,40, .black, 10,150, 1000);
			new Cypher ct2(null,40, .black, 760,150, 1000);
			.cbplay("sndintro1");
			new Gracze gracze( iMemoTryb );
			gracz2.setpos( iResX-gracz2.getw, 0 );
		}
	}
	angoleft_click	{
		if(iMemoTryb==1)	{
			gameapi.play("Lada");
		} else {
			|iMemoW, iMemoH| = 6, 3;
			iMemoTryb = 1;
			gameapi.play("Memo");
		}
	}
	angoright_click	{
		if(iMemoTryb==1)	{
			|iMemoW, iMemoH| = 6, 5;
			iMemoTryb = 2;
			gameapi.play("Memo");
		} else {
			gameapi.play("Tasma");
		}
	}
	tnextplayer	{
		TMemo::tnextplayer;
		gracze.set( iplayer );
	}
	askrestart2()	{
		if( iMemoTryb==1 )		claskexit.askrestart;
		else	claskexit.askrestart2;
	}
	tfinish()	{
		if( iMemoTryb==0 )	{
			ttc.stop;
			int ile = ttc.gettime;
			@sfile = "saves/memrek"+iMemoW+iMemoH;
			int iczas;
			if( engine.fileexist(sfile) )	{
				iczas.load( sfile, 0 );
				if (iczas>ile) {
					.cbplay("sndrekord");
					ile.save( sfile );
				} else .cbplay( "sndnierekord" );
				_ = .consttext("Dotychczasowy rekord na planszy: "+ clstrdigit::gettime(iczas,"hms"),
					210, 20, 20, 242, 242, 242);
			} else {
				ile.save( sfile );
				.cbplay("sndrekord");
			}
		} else {
			<"ct" + iplayer>.++;
			int c1 = ct1.get;
			int c2 = ct2.get;
			if( c1==c2 )	{.cbplay("sndremis"); fxbrawo.play;}
			else if (c1>c2)	{.cbplay("sndwin1"); fxbrawo.play;	}
			else	if( iMemoTryb==2)	{ .cbplay("sndwin2"); fxbrawo.play;	}
			else {.cbplay("sndwincomp"); fxbuu.play;	}
		}
	}
	tpoint()	{
		if( iMemoTryb>0 )	{
			<"ct" + iplayer>.++;
		}
		fxmikrofala.play;
	}
	tchoose	{	fxelektropik.play;	}
	terror	{	}
	mouse_lclick()	{
		.tm_mouselclick;
	}
}


game Profil : Game {
	init	{
		Game::init("profil");
		.imgs = (A, "bkg.pyz", "suwak.pyz 10");
		
		new Buttons cbut("buts.pyz");
	}
	cbut_lclick	{
		match(sobject)	{
			"p1", "p2", "p3", "ok" => gameapi.play("Wybor");
			"exit" => gameapi.play("Outro");
			? => ;
		}
	}
	mouse_lclick()	{
		
	}
}

game Wybor : Game {
	init	{
		Game::init("wybor");
		.imgs = (A, "bkg.pyz");
		
		new Buttons cbut("buts.pyz");
	}
	cbut_lclick	{
		match(sobject)	{
			"exit" => gameapi.play("Profil");
			? => gameapi.play("Menu");
		}
	}
	mouse_lclick()	{
		
	}
}


game Menu : Game {
	init	{
		Game::init("menu");
		.imgs = (A, "bkg.pyz");
		new Buttons cbut("buts.pyz");
	}
	cbut_lclick	{
		match(sobject)	{
			"exit" => gameapi.play("Outro");
			"ranking" => gameapi.play("Top");
			"opcje" =>  gameapi.play("Opcje");
			"gra" =>  gameapi.play("Lada");
			? => ;
		}
	}
	mouse_lclick()	{
		
	}
}

game Top : Game {
	init	{
		Game::init("top");
		.imgs = (A, "bkg.pyz");
		new Buttons cbut("buts.pyz");
		new gmimgvec gralf;
		"gralf" ..< "alfabet.pyz";
		
		new gmimgvec grp;
		new int ialflimit = 10;
		new int ialfstep = 45;
		for( int i=0; i<ialflimit; i++)	{
			@s = "analf"+i;
			.copyanima("analfabet", s);
			<s>.hide;
			grp.add(s);
		}
		new int iposalf = 0;
	}
	cbut_lclick	{
		match(sobject)	{
			"exit" => gameapi.play("Menu");
			"del" => {
				<grp.get(iposalf)>.hide;
				iposalf--;
				if( iposalf<0 ) iposalf=0;
			}
			? => ;
		}
	}
	mouse_move	{
		
	}
	mouse_lclick()	{
		if( gralf.isin(mouse.getpos,1,1) )	{
			@s = grp.get(iposalf);
			<s>.setframe( 0, <gralf.getsfound>.framenr );
			<s>.ansetbpos( 136 + iposalf*ialfstep, 16);
			<s>.show;
			<s>.setz(20);
			iposalf++;
			if( iposalf>=ialflimit )
				iposalf = ialflimit-1;
		}
	}
}

game Opcje : Game {
	init	{
		Game::init("opcje");
		.imgs = (A, "bkg.pyz", "mson.pyz 5", "dzwiek.pyz 10", "muzyka.pyz 10");
		
		new Buttons cbut("buts.pyz");
	}
	cbut_lclick	{
		match(sobject)	{
			"exit" => gameapi.play("Menu");
			? => ;
		}
	}
	mouse_lclick()	{
		
	}
}

game Outro : Game {
	init	{
		Game::init("outro");
		.imgs = (A, "bkg.pyz");
		
		.timer = ("timout", 3000, "mexit");
		timout.play;
	}
	mexit	{ gameapi.play("exit"); }
	mouse_lclick()	{
		.mexit;
	}
}


game Lada : Jogi {
	init	{
		Jogi::init("lada");
		
		.imgs = (A, "bkg.pyz", "ludek1.pyzP 100", "ludek2.pyzP 100", "klient.pyz 200", "mowi.pyzH 250", "ladaup.pyz 300",
			"ladadown.pyz 120");
		
		new gmimgvec grtorty;
		"grtorty" .* "torty.pyz";
		grtorty.setz(20);
		
		.timer = ("timstart", 2000, func {
			anklient.anplayfin(-1, func {
				anmowi.show;
				timgo.play;
				} );
			} );
		.timer = ("timgo", 1000, func {
			<grtorty.first>.setz(130);
			<grtorty.first>.play(-1);
			} );
		timstart.play;
	}
	angoleft_click	{
		gameapi.play("Tasma");
	}
	angoright_click	{
		|iMemoW, iMemoH| = 6, 3;
		iMemoTryb = 1;
		gameapi.play("Memo");
	}
}

game Tasma : Jogi {
	init	{
		Jogi::init("tasma");
		.imgs = (A, "bkg.pyz", "ludek.pyzP 10");
	}
	angoleft_click	{
		|iMemoW, iMemoH| = 6, 5;
		iMemoTryb = 2;
		gameapi.play("Memo");
	}
	angoright_click	{
		gameapi.play("Lada");
	}
}
