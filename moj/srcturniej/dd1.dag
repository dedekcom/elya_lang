/******** konstrukcje  ********************/
new string	A = "!!!";
new real		PI = 3.14159265358979323846;
new int		BYTE0 = "0"->getbyte(0);
new int		BYTE9 = "9"->getbyte(0);
new int		BYTEa = "a"->getbyte(0);
new int		BYTEz = "z"->getbyte(0);
new int		BYTEA = "A"->getbyte(0);
new int		BYTEZ = "Z"->getbyte(0);
new int		BYTE_ = "_"->getbyte(0);
new int		BYTESPACE = " "->getbyte(0);

// engine.setdebugstate(2);

public varget(string svar)				{	[svar];				}
public varset(string svar, def val)			{	<svar> = val;			}
public varnew(string styp, string svar)	{	new <styp> <svar>;	}
public varnewif(string styp, string svar)	{	if( !.hasvar(svar) )	.varnew(styp,svar);}
public vardelif(string svar)				{	if( .hasvar(svar) )	.vardel(svar);		}
public vardel(string svar)				{	delete <svar>;		}
public reader(string sname)	{
	.varnewif("def", sname);
	.addmethod( sname, func { [.methodname]; } );
}
public writer(string sname)	{
	.varnewif("def", sname);
	.addmethod( sname+"=", func { (def val) <.methodname->strsube(1)> = val; } );
}
public var(string sname)	{
	.reader(sname);
	.writer(sname);
}
public var2(string sname, def val)	{
	.var(sname);
	<sname> = val;
}
public withlist(string sfun)	{
	@s = _;
	while( A != s )	{
		.<sfun>(s);
		@s = _;
	}
}
public withlist2(string sfun)	{
	@s = _;
	while( A != s )	{
		@s1 = _;
		.<sfun>(s1,s);
		@s = _;
	}
}
public vars	{	.withlist("var");}
public vars2	{	.withlist2("var2");}
/*****************************************************/
public bool in	{
	bool b = false;
	@x = .get;
	@y = _;
	while( A != y )	{
		if( !b )	b = x==y;
		@y=_;
	}
	b;
}
public with(string sfun)	{
	string sob = _;
	while( sob!=A )	{
		<sob>.<sfun>();
		sob=_;
	}
}
public copycall(string sfun, string sob)	{
	string s = "__call" + sfun;
	new string <s>;
	<s> = sob;
	.addmethod( sfun, func {
		string sf = .methodname;
		< [ "__call" + sf ] >.<sf>();
		});
}
public copycalls(string sobj)	{
	string s = _;
	while( s!=A )	{
		.copycall( s, sobj ); 
		s=_;
	}
}
/***********************************/
public mresize()	{	< .gettype + "_pack">::resizemethods( this );	}
/******** petle ********************/
public times(string sfun)		{	this.for_plus(0, this.get()-1, sfun );		}
public upto(int ito, string sfun)	{	this.for_plus( this.get(), ito, sfun );	}
public downto(int ito, string sfun)	{	this.for_minus( this.get(), ito, sfun );	}
public for_plus(int ifrom, int ito, string sfun)	{
	if( ito-ifrom<=0 )	return;
	for( ; ifrom<=ito; ifrom++)	this.<sfun>(ifrom);
}
public for_minus(int ifrom, int ito, string sfun)	{
	if( ifrom-ito<=0 )	return;
	for( ; ifrom>=ito; ifrom--)	this.<sfun>(ifrom);
}
public double_for(int w, int h, string sfun)	{
	int j;
	for( int i=0; i<w; i++)	{
		for( j=0; j<h; j++)	{
			this.<sfun>(i,j);
		}
	}
}
/****************************************/

// klasa do np. dynamicznego tworzenia obiektow z prefixem+id
class classobjcounter	{
	init(string sprefix)	{
		new string _sprefix=sprefix;
		new int _iile=0;
	}
	string get()	{
		_iile++;
		return _sprefix + (_iile-1);
	}
	int size()	{_iile;}
	int getid(int id)	{	_sprefix + (_iile-1-id);	}
}

/*class classvsigobj	{
	init()	{
		new bool bplaying=false;
	}
	virtual play()	{	bplaying=true;	}
	virtual stop(bool bstop)	{ 
		bplaying=false;
		if( bstop )	{	this.onfinish();	}
	}
	virtual bool isplaying()	{	bplaying;	}
}*/

/***************************************************************************/

class classsignals	{
	init()	{}
	/********** std obj **********************/
	stdfinish(string sob) { <sob>.addmethod("onfinish",func { this.<this.getname()+"_FINISH">();}); }
	stdstart(string sob) { <sob>.addmethod("onstart",func { this.<this.getname()+"_START">(); }); }
	stdsigs(string sob)	{
		this.stdstart(sob);
		this.stdfinish(sob);
	}
	/********** anima **********************/
	buildanima(string san)	{
		this.stdsigs(san);
		<san>.addmethod("onendframe", func { this.<this.getname()+"_ENDFRAME">(); } );
	}
	/********** snd **********************/
	buildsnd(string ssnd)	{	this.stdsigs(ssnd);		}
	/********** timer **********************/
	buildtimer(string stimer)	{
		this.stdsigs(stimer);
		<stimer>.addmethod("ontick", func { this.<this.getname()+"_TICK">(); });
	}
	/********** button *******************/
	buildbut(string sbut)	{
		<sbut>.addmethod("onclick", func { this.<this.getname()+"_CLICK">(); });
		<sbut>.addmethod("onrel", func { this.<this.getname()+"_REL">(); });
		<sbut>.addmethod("onmoveon", func { this.<this.getname()+"_MOVEON">(); });
		<sbut>.addmethod("onmoveoff", func { this.<this.getname()+"_MOVEOFF">(); });
	}
}

/******************************************************************/

class classlocker	{
	init()	{
		new bool _block = true;
	}
	public lock()	{	_block=true;	}
	public unlock()	{	_block=false;	}
	public setlock(bool b)	{	_block=b;	}
	public bool getlock()	{	return _block;	}
	public bool unlocked	{	_block==false;	}
	public setaslocker(string sob)	{
		<sob>.addmethod("buildlocker", func { new bool _block=true; });
		<sob>.buildlocker;
		<sob>.addmethod("lock", "lock");
		<sob>.addmethod("unlock", "unlock");
		<sob>.addmethod("setlock", "setlock");
		<sob>.addmethod("getlock", "getlock");
		<sob>.addmethod("unlocked", "unlocked");
	}
}

/***************************************************************************/

module classdbreader	{
	init()	{
		new db dbl;
	}
	readdb( string sfunc )	{
		int id = 0;
		int ile = dbl.getrowsno();
		while( id < ile )	{
			this.<sfunc>( id );
			id++;
		}
	}
	readrow( string srow, string sfunc )	{
		int ipos = dbl.findbyrow( srow );
		if( ipos >= 0 )	{
			this.<sfunc>( ipos );
		}
	}
}

/***************************************************************************/


/***************************************************************************/
class collection	{
	init(string styp)	{	new string stype=styp;	}
	public string type()	{	return stype;		}
}

class array : collection {
	init(string styp, int idimens, int isiz)	{
		collection::init(styp);
		new int idim = idimens;
		new int isize = isiz;
		new vector vec;
		vec.type(styp);
		if( idimens<=0 || isiz<=0 )	return;
		//vec.resize( isiz.pow(isiz,idimens), 0 );
		vec.resize( isiz.pow(idimens), 0 );
	}
	int getid()	{
		int pos=0;
		int dim=idim-1;
		while(dim>0)	{
			pos+=_;
			pos*=isize;
			dim--;
		}
		return pos+_;
	}
	public def get()	{	return vec.get( this.getid() );	}
	public set(def svar)	{	vec.set( this.getid(), svar);	}
	public int getsize()	{	return isize;			}
	public int getdim()	{	return idim;			}
}

class stack : collection	{
	init(string styp)	{
		collection::init(styp);
		new vector vec;
		vec.type(styp);
		new <styp> var;
	}
	public push(string svar){	vec.add(svar);		}
	public def top()	{	return vec.last();	}
	public def pop()	{
		var = this.top();
		vec.removeat( vec.size()-1 );
		return var;
	}
	public free	{	vec.free;	}
}

class map : collection	{
	init(string styp)	{
		collection::init(styp);
		new int isize=0;
	}
	set(string svar, def val)	{
		if( !this.hasvar("v"+svar) )	this.add(svar);
		<"v"+svar>.set(val);
	}
	add(string svar)	{	new <stype> <"v"+svar>;		}
	def get(string svar)	{	return ["v"+svar];		}
	remove(string svar)	{	delete <"v"+svar>;		}
	bool contains(string svar){	return this.hasvar("v"+svar);	}
}
class map2 : collection	{
	init(string styp)	{
		collection::init(styp);
		new vector vn;
		vn.type("string");
		new vector vec;
		vec.type(styp);
	}
	add(string svar, def val)	{	vn.add(svar);	vec.add(val);	}
	set(string svar, def val)	{	vec.set( vn.find(svar), val );	}
	bool contains(string svar)	{	return vn.contains(svar);	}
	def get(string svar)		{	return vec.get( vn.find(svar) );}
	remove(string svar)	{
		int id = vn.find(svar);
		if( id>=0 )	{
			vec.removeat( id );
			vn.removeat(id);
		}
	}
	free()	{	vn.free();	vec.free();	}
}


/***************************************************************************/
class classgamemusic : classdbreader	{
	init()	{
		classdbreader::init();
		new string smuspath = "";
		new string sbgrpath = "";
		new snd _sndbgr;
		_sndbgr.addmethod("onfinish", "_stdsndloop");
	}
	reset()	{
		gameapi.stopmusic();
		this.stopbgr();
	}
	_stdsndloop()	{	this.play(); }
	load(string sfile)	{	dbl.loadscript( sfile );	}
	musicpath(string s)	{	smuspath = s;	}
	sndbgrpath(string s)	{	sbgrpath=s;	}
	_play(int ipos)	{
		int i[3], string s[2];
		i0 = 1;
		i1 = dbl.getcolsno( ipos );
		while( i0 < i1 )	{
			s0 = dbl.get( ipos, i0 );	i0++;
			if( s0 == "music" )	{
				s1 = smuspath + dbl.get( ipos, i0 );
				i0++;
				if( i0 < i1 )	{
					if( dbl.get( ipos, i0 )=="vol" )	{
						i0++;
						gameapi.setmusicvol( dbl.get( ipos, i0 ) );
						i0++;
					}
				} else {
					gameapi.setmusicvol( 100 );
				}
				gameapi.playmusic( s1 );
			} else if (s0 == "bgr")	{
				_sndbgr.load( sbgrpath + dbl.get( ipos, i0 ) );
				i0++;
				if( i0 < i1 )	{
					if( dbl.get( ipos, i0 )=="vol" )	{
						i0++;
						_sndbgr.setvol( dbl.get( ipos, i0 ) );
						i0++;
					}
				} else {
					_sndbgr.setvol( 100 );
				}
				this.playbgr();
			} else {	i0++;	}
		}
	}
	play()	{
		this.reset();
		this.readrow( gameapi.getgamename(), "_play" );
	}
	playbgr()		{	_sndbgr.play();	}
	stopbgr()	{	_sndbgr.stop(false);	}
}

class Music	{
	init	{
		new vector vmus;
		vmus.type("string");
		new int ilastid;
	}
	playdb(string s, int row, int icol)	{
		vmus.free;
		while (icol < <s>.getcolsno(row) )	{
			vmus.add( <s>.get(row, icol) );
			icol++;
		}
		ilastid = 0;
		.play;
	}
	playvec(string s, int id)	{
		vmus.free;
		while( id< <s>.size )	{
			vmus.add( <s>.get(id) );
			id++;
		}
		ilastid = 0;
		.play;
	}
	playstr(string s)	{
		vmus.vecbuildfromstring(s, " ");
		ilastid = 0;
		.play;
	}
	play	{
		if( ilastid >= vmus.size ) return;
		@s = MUSICPATH + vmus.get(ilastid);
		ilastid++;
		bool bloop=false;
		int fin=0;
		int fout = 0;
		int vol = 100;
		for( int i=ilastid; i<vmus.size; i++)	{
			@s1 = vmus.get(i);
			match(s1)	{
				"-l" => bloop = true;
				"-v" => { i++; vol = vmus.get(i); }
				"-fin" => { i++; fin = vmus.get(i); }
				"-fout" => { i++; fout = vmus.get(i); }
				"-p" => ;
				? => { ilastid=i; i = vmus.size; }
			}
		}
		gameapi.setmusicvol(vol);
		if( bloop ) {
			gameapi.playmusic(s);
			ilastid = vmus.size;
			return;
		}
		gameapi.loadmusic(s);
		if (fin) gameapi.fadeinmusic(fin);
		else gameapi.startmusic;
		if (fout) gameapi.fadeoutmusic(fout);
	}
	fadeout(int ms)	{
		if( gameapi.ismusicplaying ) {
			gameapi.fadeoutmusic(ms);
			ilastid=vmus.size;
		}
	}
}
/**************************************************************/
	// zmienne globalna - stany gry
new int igmstate;
new int igmdebug;
new int igmeasy;
new int igmdemo;
new int igmbegin;

new string sgmfontfile = "configs/fonts/normal.ttf";
new string sgmfontmono = "configs/fonts/mono.ttf";
new string sgmfontmonobold = "configs/fonts/monobold.ttf";
new string sgmfontbold = "configs/fonts/monobold.ttf";
new string sgmfontitalic = "configs/fonts/timesit.ttf";

new string SFXPATH = "sounds/sfx/";
new string BGRPATH = "sounds/bgr/";
new string MUSICPATH = "sounds/music/";
new string LANG = "pl";	// pl, eng, cze, slo
new string SNDPATH = "sounds/";
if( LANG=="pl" ) LANG="";
if( LANG.length > 0 ) SNDPATH += LANG + "/";

new int iResX = 800;
new int iResY = 600;

/**************************************************************/
	// standardowa klasa do tworzenia zmiennych
class newvars		{
	init()	{
		new string _sclpath = "";
		new string _sclwavpath = "";
	}
	string _checkfont(string sfont, int isize, string sfnt)	{
		if( sfont==null )	sfont=sgmfontfile;
		if( sfont.contains(".ttf") )	{
			new font <sfnt>;
			<sfnt>.load( sfont, isize );
			sfont = sfnt;
		}
		sfont;
	}
	string checkfont(string sfont, int isize)	{
		._checkfont(sfont, isize, "_fnt");
	}
	bool begingame()	{
		igmbegin = !igmbegin;
		!igmbegin;
	}
	newarray(string styp, string sbase, int size)	{
		if( size<= 0 )	return;
		size--;
		while(size>=0)	{
			new <styp> <sbase+size>;
			size--;
		}
	}
	setgraphpath(string spath)	{	_sclpath = spath;	}
	setwavpath(string spath)	{ _sclwavpath = spath; }
	string getgraphpath()	{	return _sclpath; }
	string getsndpath()	{	return _sclwavpath; }
	getpath(string sfile)	{
		if( sfile.getb(0,1)=="$" ) sfile.strsubb(1);
		else .getgraphpath + sfile;
	}
	newanima(string sname, string sfile, int z)	{
		new anima <sname>;
		<sname>.load( .getpath(sfile) );
		<sname>.setz(z);
	}
	newstdanima(string sname, string sfile, int z)	{
		this.newanima(sname, sfile, z);
		this.stdanaction(sname);
	}
	copyanimaactz(string ssrc, string sdest, string saction, int z)	{
		this.copyanimaact(ssrc, sdest, saction);
		<sdest>.setz(z);
	}
	copyanimaact(string ssrc, string sdest, string saction)	{
		this.copyanima(ssrc, sdest);
		<sdest>.setframe( saction, 0 );
	}
	copyanima(string ssrc, string sdest)	{
		new anima <sdest>;
		<sdest>.copy( ssrc );
	}
	copyanimas(string san, string sname, int istart, int ilosc)	{
		if (ilosc<0)	return;
		for(int i=0; i<ilosc; i++)	this.copyanima( san, sname + (istart + i)  );
	}
	newanimas(string sname, string sfile, int z, int ilosc)	{
		if(ilosc<0) return; 
		this.newanima(sname+"0", sfile, z);		// pierwsza load z zerem
		this.copyanimas(sname+"0", sname, 1, ilosc-1);		// pozostale kopiowane z niej
	}
	int newanframesgr(string san, string sname, int iaction, string sgr)	{	// tworzy animacje z klatek
		int ile = <san>.nofframes( iaction );
		this.copyanimas( san, sname, 0, ile );
		for(int i=0; i<ile; i++)	{
			<sname+i>.setframe(iaction, i);
			if( sgr!=null )	{	<sgr>.add( sname+i );	}
		}
		return ile;		// zwraca ilosc stworzonych animacji
	}
	int newanframes(string san, string sname, int iaction)	{	// tworzy animacje z klatek
		return this.newanframesgr(san,sname,iaction,null);
	}
	newcanvas(string sname, int w, int h, int r, int g, int b, int a, int z)	{
		new img <sname>;
		<sname>.create(w,h,r,g,b,a);
		<sname>.setz(z);
	}
	newimg(string sname, string sfile, int z)	{
		new img <sname>;
		<sname>.load( .getpath( sfile ) );
		<sname>.setz(z);
	}
	copyimg(string ssrc, string sdest)	{
		new img <sdest>;
		<sdest>.copy(ssrc);
	}
	playmusic(string sfile)	{gameapi.playmusic( MUSICPATH + sfile );	}
	newsndfree(string sname, string sfile)	{
		new snd <sname>;
		<sname>.setstartstopflag(false, true);
		<sname>.load( this.getsndpath() + sfile);
	}
	snewsnd(string sname, string sfile)	{
		this.newsnd(sname,sfile);
		<sname>.addmethod("onfinish","__std_finish");
	}
	_newsnd(string sname, string sfile)	{
		new snd <sname>;
		if( !sfile.contains(".") ) sfile += ".wav";
		<sname>.load( sfile);
	}
	newsfx(string sname, string sfile)	{	._newsnd(sname, SFXPATH + sfile);	}
	newbgr(string sname, string sfile)	{	._newsnd(sname, BGRPATH + sfile);	}
	newbgrloop(string s, string s2)	{	.newbgr(s,s2); .sndplayloop(s);	}
	newsnd(string sname, string sfile)	{	._newsnd(sname, .getsndpath+sfile);	}
	newsndloop(string sname, string sfile)	{
		this.newsnd(sname,sfile);
		this.looponfinish1( sname );
	}
	looponfinish1( string sob )	{<sob>.addmethod("onfinish","_stdsndloop");	}
	sndplayloop(string sob)	{
		this.looponfinish1( sob );
		<sob>.play();
	}
	newsnds(string sbase, int inamestart, string sfilebase, int ifilefrom, int ifileto)	{
		string s;
		int ile = ifileto-ifilefrom+1;
		for(int i=0; i<ile; i++)	{
			s = sbase + (inamestart + i);
			new snd <s>;
			<s>.load( this.getsndpath() + sfilebase + (ifilefrom+i) + ".wav" );
		}
	}
	newtimer(string sname, int idelay, int iticks)	{
		new timer <sname>;
		<sname>.settick(iticks);
		<sname>.delay(idelay);
	}
	newtimercycle(string sname, int icycle, int iticks)	{
		new timer <sname>;
		<sname>.settick(iticks);
		<sname>.setcycle(icycle);
	}
	stdanaction(string san)	{
		string s = <san>.actionname();
		if( s.contains("L")  )	this.looponfinish(san);
		else if( s.contains("H")  )	this.hideonfinish(san);
		if( s.contains("P")  )	<san>.play(-1);
	}
	int newanactionsgr(string san, string sname, string sgr)	{
		int ile = <san>.nofactions();
		this.copyanimas( san, sname, 0, ile );
		string s;
		for(int i=0; i<ile; i++)	{
			s = sname+i;
			<s>.setframe(i,0);
			this.stdanaction(s);
			if( sgr!=null )	{<sgr>.add( s );}
		}
		return ile;
	}
	int newanactions(string san, string sname)	{return this.newanactionsgr(san,sname,null);	}
	int newanfrbyactgr(string san, string sname, string sgr)	{
		int ile = <san>.nofactions();
		for( int i=0; i<ile; i++)	_ = this.newanframesgr(san, sname+i+"_", i, sgr);
		return ile;
	}
	int newanfrbyact(string san, string sname)	{return this.newanfrbyactgr(san,sname,null);	}
	int loadanfrbyact(string san, string sfile, int z)	{
		string s = "_"+san;
		this.newanima(s,sfile,z);
		int ile = this.newanfrbyact(s, san);
		<s>.hide();
		return ile;
	}
	int loadanactions(string san, string sfile, int z)	{
		string s = "_"+san;
		this.newanima(s, sfile, z);
		int ile = this.newanactions(s, san);
		<s>.hide();
		return ile;
	}
	int loadanframes(string san, string sfile, int iaction, int z)	{
		string s = "_"+san;
		this.newanima(s, sfile, z);
		int ile = this.newanframes(s, san, iaction);
		<s>.hide();
		return ile;
	}
	newbutimg(string sbut, string sstd, string smov, string sclick, string smouse)	{
		new button <sbut>;
		<sbut>.set(sstd, smov, sclick);
		<sbut>.setmouse(smouse);
	}
	newbutan(string sbut, string sanstd, string sanmov, string sanclick, string smouse)	{
		new button <sbut>;
		<sbut>.setan(sanstd, sanmov, sanclick);
		<sbut>.setmouse(smouse);
	}
	/*****************************************************/
	newdb(string sdb, string sfile)	{
		new db <sdb>;
		<sdb>.load( .getpath(sfile) );
	}
	newdbscript(string sdb, string sfile)	{
		new db <sdb>;
		//<sdb>.loadscript( this.getgraphpath() + sfile );
		<sdb>.loadscritp( .getpath(sfile) );
	}
	vargmset(string svar, def val)	{
		string sg = gameapi.getgamename();
		if( !<sg>.hasvar(svar) )	<sg>.varnew( val.gettype(), svar );
		<svar> = val;
	}
}

/**************************************************************/
new img imglobcurs;		// globalny kursor aktywnosci
bsms.load("configs/kursorstd.png","configs/kursoract.png" );
	// modul obslugi standardowych kursorow myszy
module bsms {
	init()	{
		new img imgstd;
		new img imgact;
		new int msid = 0;		// 0- brak kursora 1-std lapka 2- active lapka 3- wlasny (wczytany w jakiejs grze)
	}
	load(string spath1, string spath2)	{
		imgstd.load(spath1);
		imgact.load(spath2);
		imglobcurs.copy("imgact");
		imglobcurs.hide();
		imgstd.hide();
		imgact.hide();
		this.reset();
		engine.stdbutcursor("imgstd");
	}
	setinitial()	{	mouse.stdcursor();	msid = 0;	}
	setstd()	{
		if( msid!=1 )	{
			mouse.setcursor("imgstd");
			engine.stdbutcursor("imgstd");
			msid = 1;
		}
	}
	setact()	{
		if( msid!=2 )	{
			mouse.setcursor("imgact");
			msid = 2;
		}
	}
	setown()	{	msid=3;	}
	bool isinitial()	{	msid==0;	}
	bool isstd()	{	msid==1;	}
	bool isact()	{	msid==2;	}
	bool isown()	{	msid==3;	}
}

/***************************************************************************/

module clsurf	{
	init()	{}
	bool isin(int x, int y, int x1, int y1, int x2, int y2)	{	x >= x1 && x<=x2 && y>=y1 && y<=y2;	}
	bool isin2(int x, int y, int x1, int y1, int w, int h)	{	x >= x1 && x < x1+w && y>=y1 && y<y1+h;	}
	bool inscreen(int x, int y, int dx, int dy)	{	this.isin( x, y, 0-dx, 0-dy, 800+dx, 600+dy );	}
	bool insurf(int x, int y, string simg) { .isin(x,y,<simg>.getpx, <simg>.getpy, <simg>.getex-1, <simg>.getey-1);}
	bool issurfin(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)	{
		this.isin(x1,y1, x3,y3,x4,y4) || this.isin(x2,y1, x3,y3,x4,y4) ||
				this.isin(x1,y2, x3,y3,x4,y4) || this.isin(x2,y2, x3,y3,x4,y4);
	}
	bool commonsurface(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)	{
		this.issurfin(x1,y1,x2,y2, x3,y3,x4,y4) || 
				this.issurfin(x3,y3,x4,y4, x1,y1,x2,y2);
	}
	bool commonimgs(string simg1, string simg2)	{
		this.commonsurface(<simg1>.getpx(), <simg1>.getpy(), <simg1>.getex()-1, <simg1>.getey()-1,
				<simg2>.getpx(), <simg2>.getpy(), <simg2>.getex()-1, <simg2>.getey()-1 );
	}
	bool surfwithinsurf(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)	{
		this.isin(x1,y1, x3,y3,x4,y4) && this.isin(x2,y1, x3,y3,x4,y4) &&
				this.isin(x1,y2, x3,y3,x4,y4) && this.isin(x2,y2, x3,y3,x4,y4);
	}
	bool imgwithinimg(string simg1, string simg2)	{
		this.surfwithinsurf(<simg1>.getpx(), <simg1>.getpy(), <simg1>.getex()-1, <simg1>.getey()-1,
				<simg2>.getpx(), <simg2>.getpy(), <simg2>.getex()-1, <simg2>.getey()-1 );
	}
}

/* modul do obliczen odleglosci */

module cllen	{
	init()	{
		new int il1;
		new int ilx;
		new int ily;
	}
	int ilenx()	{ return ilx; }
	int ileny()	{ return ily; }
	int ilen4(int x1, int x2)	{	return (x1-x2)->abs();	}
	int ilen3(string simg1, string simg2)	{
		return this.ilen( <simg1>.getcx(), <simg1>.getcy(), <simg2>.getcx(), <simg2>.getcy() );
	}
	int ilen5(string simg1, string simg2)	{
		return this.ilen( <simg1>.getpx(), <simg1>.getpy(), <simg2>.getpx(), <simg2>.getpy() );
	}
	int ilen2(string simg1, int x, int y)	{return this.ilen( <simg1>.getcx(), <simg1>.getcy(), x,  y );	}
	int ilen(int x1, int y1, int x2, int y2)	{
		ilx = x1-x2;
		ily = y1-y2;
		return il1.length( ilx, ily );
	}
	int iclenx(string simg1, int x)	{	return <simg1>.getcx() - x;	}
	int iclenx2(string simg1, string simg2)	{	return <simg1>.getcx() - <simg2>.getcx();	}
	int icleny(string simg1, int y)	{	return <simg1>.getcy() - y;	}
	int icleny2(string simg1, string simg2)	{	return <simg1>.getcy() - <simg2>.getcy();	}
	int isbetween2(string simg1, string simg2, int x1, int y1, int x2, int y2)	{
		return this.isbetween(simg1, <simg2>.getcx(), <simg2>.getcy(), x1, y1, x2, y2);
	}
	int isbetween(string simg1, int xx, int yy, int x1, int y1, int x2, int y2)	{
		il1 = this.ilen( simg1, xx, yy );
		return ilx>=x1 && ilx<=x2 && ily>=y1 && ily<=y2;
	}
	int ilodlen(string s1, string s2)	{	.ilen(<s1>.lodx,<s1>.lody, <s2>.lodx, <s2>.lody);	}
	int iposlen(string simg1, string simg2)	{
		.ilen( <simg1>.getpos, <simg2>.getpos );
	}
}

/****************************************************/
class classansearcher	{
	init()	{}
	def _findnotr(string san, int x, int y, int dx, int dy)	{
		int ex = <san>.getex() , int ey = <san>.getey();
		while( x!=ex && y!=ey )	{
			if( <san>.isin(x,y,false,true) ) return x,y;
			x+=dx;	y+=dy;
		}
		return -1,-1;
	}
	def firstnotrx1y(string san)	{	return ._findnotr(san,<san>.getpx(), <san>.getpy(), 1, 0);	}
	def firstnotrexy1(string san)	{	return ._findnotr(san,<san>.getex()-1, <san>.getpy(), 0, 1);	}
	def firstnotrxy1(string san)	{	return ._findnotr(san,<san>.getpx(), <san>.getpy(), 0, 1);	}
	def firstnotrx1ey(string san)	{	return ._findnotr(san,<san>.getpx(), <san>.getey()-1, 1, 0);	}
}

class signal_pack	{
	init()	{}
	addsignals(string san)	{
		<san>.addmethod("operator<", func { (string sfun) this.addmethod("onfinish", sfun ); } );
	}
}
/***************************************************************************/
class ImagePos	{
	init	{}
	getex	{	.getpx + .getw;	}
	getey	{	.getpy + .geth;	}
	getcx	{	.getpx + .getw/2;	}
	getcy	{	.getpy + .geth/2;	}
	setpos(int x, int y)	{	.move(x-.getpx, y-.getpy);	}
}
class ImageVisible	{
	init	{
		new bool _isvisible=1;
	}
	isvisible	{	_isvisible;	}
	show		{	_isvisible=1;	}
	hide		{	_isvisible=0;	}
}
class Image	{
	init	{}
	public resizemethods(string sob)	{
		<sob>.vars2(A, "getz",0, "getpx",0, "getpy",0, "getw",0, "geth",0, "isvisible", 0);
		<sob>.addmethod("show", func { isvisible=1; }	);
		<sob>.addmethod("hide", func { isvisible=0; }	);
		<sob>.addmethod("setz", func { (int z) getz=z; } );
		<sob>.addmethod("setpos", func { (int x, int y) getpx=x; getpy=y; } );
		<sob>.addmethod("move", func { (int x, int y) getpx+=x; getpy+=y; } );
		<sob>.addmethod("getex", func { getpx+getw; } );
		<sob>.addmethod("getey", func { getpy+geth; } );
		<sob>.addmethod("getcx", func { getpx+getw/2; } );
		<sob>.addmethod("getcy", func { getpy+geth/2; } );
		<sob>.addmethod("isin", func { (int x, int y, int bv, int ba)
			if( !ba ) {
				if( !bv || (bv&&isvisible) )	{
					x>=getpx && x<.getex && y>=getpy && y<.getey;
				} else 0;
			} else 0;
			} );
	}
}
	// rozszerzenia dla animcaji
class anima_pack : signal_pack	{
	init()	{}
	public resizemethods(string san)	{
		<san>.addmethod("_clanbuildpomvars", func { new int _ixp; new int _iyp; } );
		<san>._clanbuildpomvars();
		<san>.addmethod("setbpos", func {(int x, int y) .setpos( x-.lodx, y-.lody ); });
		<san>.addmethod("saverelpos", func {(int x,int y)_ixp=x-.getpx;_iyp=y-.getpy;} );
		<san>.addmethod("setrelpos", func{(int x, int y) .setbpos( x - _ixp, y - _iyp );});
		<san>.addmethod("mssaverelpos", func {.saverelpos( mouse.getpos );} );
		<san>.addmethod("mssetrelpos", func {.setrelpos( mouse.getpos );});
		<san>.addmethod("rplay", func {(string sact)if( !.isplaying(sact) ) .play(sact);});
		<san>.addmethod("setcpos", func {(int x, int y).setbpos( x-.getw/2, y-.geth/2 );});
		<san>.addmethod("operator=", func { (string s) .copy(s); } );
		<san>.addmethod("operator==", func { (string s)
			.actionnr==<s>.actionnr && .framenr==<s>.framenr; } );
		this.addsignals(san);
	}
}

class timer_pack : signal_pack	{
	init()	{}
	resizemethods(string sob)	{
		this.addsignals(sob);
	}
}
/***************************************************************************/
class vector_pack	{
	init()	{}
	each(string sfun)	{	for( int i=0; i<.size; i++) this.<sfun>(.get(i));	}
	resizemethods(string svec)	{
		<svec>.addmethod("each", "each");
		<svec>.addmethod("operator-", func { (def x) this.remove(x); this; } );
		<svec>.addmethod("operator+", func { (def x) this.add(x); this; } );
	}
}

/***************************************************************************/

public new_object(string styp, string sob)	{
	new <styp> <sob>;
	<styp+"_pack">::resizemethods(sob);
}
public new_anima(string s)	{	.new_object("anima",s);	}
public new_vector(string s)	{	.new_object("vector",s);	}

/***************************************************************************/

class classanfilter	{
	init()	{}
	buildanfilter()	{
		new filter ft;
		ft.link( this.getname() );
		ft.setpivottype(1);
	}
	public build(string san)	{
		<san>.addmethod("buildanfilter","buildanfilter");
		<san>.buildanfilter();
		<san>.addmethod("setopacity",	func {	(int iop) ft.setopacity(iop); }		);
		<san>.addmethod("setzoom",		func {	(real r) ft.setzoom(r); }			);
		<san>.addmethod("setangle",		func {	(real r) ft.setangle(r); }			);
		<san>.addmethod("getangle",		func {	return ft.getangle; }			);
		<san>.addmethod("rotate",		func {	(real r)	ft.rotate(r); }			);
		<san>.addmethod("setpivottype",	func {	(int ityp) ft.setpivottype(ityp); }	);
		<san>.addmethod("unlink",		func {	ft.unlink(); }					);
		<san>.addmethod("link",			func {	ft.link(this); }					);
		<san>.addmethod("blend",		func {	(string s) ft.blend(s); }			);
		<san>.addmethod("mask",		func {	(string s) ft.mask(s); }			);
	}
}

/***************************************************************************/

class classancounter	{
	init()	{
		new int iile;
		new int id;
		new string _san;
		new vector _vs;
		new int _pos;
	}
	set(string sname, int ile)	{
		_san = sname;
		iile = ile;
		id = 0;
		_pos = sname.length();
		_vs.resize( ile, false );
	}
	string get()	{
		string s = _san+id;
		id = (id+1)%iile;
		return s;
	}
	string getf()	{
		for(int i=0; i<iile; i++)	{
			if( !_vs.get(i) )	{
				_vs.set(i, true);
				return _san+i;
			}
		}
		return null;	// brak wolnych
	}
	retf(string s)	{	_vs.set( s.getb( _pos, 10 ), false );	}
	isfree(int pos)	{	return _vs.get(pos);	}
	int getile()	{	return iile;	}
}

/**************************************************************/
	// operacje na obrazach, dzwiekach, timerach i animacjach
class gmobjvec {
	init()	{
		new vector lsim;
		lsim.type("string");
	}
	operator=(string sgr)	{
		if( engine.varexist(sgr) )	{
			match(<sgr>.gettype())	{
				"vector" => this.copy(sgr);
				"gmobjvec" => this.copy(sgr);
				"gmimgvec" => this.copy(sgr);
				? => {	this.free(); this.add(sgr); }
			}
		} else {
			this.free();
			this.add(sgr);
		}
	}
	save(string s)	{	lsim.save(s);	}
	load(string s)	{	lsim.load(s);	}
	operator+(string sob)	{	this.add(sob);		return this;	}
	operator-(string sob)	{	this.remove(sob);	return this;	}
	removegr(string sgr)	{	for( int i=0; i < <sgr>.size; i++)	.remove( <sgr>.get(i) );	}
	addtogr(string sgr)	{	for( int i=0; i<this.size(); i++)	<sgr>.add(this.get(i));	}
	addgr(string sgr)	{	for( int i=0; i< <sgr>.size(); i++)	this.add( <sgr>.get(i) );	}
	addgroups	{	.withlist("addgr");	}
	copy(string sgr)	{
		this.free();
		this.addgr(sgr);
	}
	free()	{ lsim.free();	}
	int size()	{ return lsim.size(); }
	bool empty()	{	return this.size()==0;	}
	hash()	{ lsim.hash(); }
	string first()	{ return lsim.get(0); }
	string last()	{ return lsim.get( lsim.size()-1 ); }
	print()	{	lsim.print();	}
	string get(int i)	{ return lsim.get(i); }
	set(int pos, string sval)	{	lsim.set(pos,sval);	}
	add(string simg)	{	lsim.add(simg);	}
	additer(string s, int ifrom, int iile)	{
		while( iile>0 )	{
			.add(s+ifrom);
			ifrom++;
			iile--;
		}
	}
	buildarray(string styp, string sname, int ilosc)	{
		<gameapi.getgamename>.newarray(styp,sname,ilosc);
		.additer(sname,0,ilosc);
	}
	deleteall	{	for( int i=0; i<.size; i++)	delete <.get(i)>;	}
	deleteallgm	{
		@s = gameapi.getgamename;
		for( int i=0; i<.size; i++)	<s>.vardel(.get(i));
	}
	deleteallgmobj	{
		@s = gameapi.getgamename;
		for( int i=0; i<.size; i++)	<s>.deletegmobj(.get(i));
	}
	lockall	{	.eval("lock");	.print;	}
	unlockall	{	.eval("unlock");	}
	addbegin(string simg)	{	lsim.addbegin(simg);	}
	swap(int i, int j)	{	lsim.swap(i,j);	}
	addonce(string simg)	{	if( !lsim.contains(simg) )	lsim.add(simg);	}
	sepadd(string separator)	{
		string s = _;
		while( s!=separator )	{
			this.addbegin(s);
			s = _;
		}
	}
	addlist	{	.sepadd(A);	}
	removelist	{ .withlist("remove");	}
	insertat(string sob, int pos)	{
		@ile = .size;
		if( pos<=0 )	.addbegin(sob);
		else if (pos>=ile)	.add(sob);
		else {
			.add(null);
			for( @i=ile; i>pos; i--)	.set( i, .get(i-1) );
			.set(pos, sob );
		}
	}
	remove(string simg)	{	lsim.remove(simg);	}
	removeat(int pos)		{	lsim.removeat(pos);	}
	removefirst			{	lsim.removeat(0);	}
	removelast			{	lsim.removeat(.size-1);	}
	removealloccurs(string simg)	{	while(this.contains(simg))	this.remove(simg);	}
	removeif(string sfun)	{
		for( int i=0; i<.size; i++)
			if( <.get(i)>.<sfun>() )  .removeat(i);
	}
	int find(string simg)	{ return lsim.find(simg); }
	int contains(string simg)	{ return lsim.contains(simg); }
	addgroup(string sob, int ile)	{	this.addgroup2( sob, 0, ile-1 );	}
	addgroup2(string sob, int ifrom, int ito)	{
		while( ifrom <= ito )	{
			this.add( sob+ifrom );
			ifrom++;
		}
	}
	string rand()	{
		int ile = .size;
		ile>0 ? .get(ile.rand) : null;
	}
	string randdiff(string s)	{
		int ile = .size;
		if( ile>0 )	{
			int id = ile.rand;
			int i = id;
			while( .get(id)==s )	{
				id = (id+1)%ile;
				if( id==i )	return null;
			}
			return .get(id);
		}
		null;
	}
	buildfullvars	{	.each( func { (@id) .buildfullname; } );	}
	buildvars		{	.each( func { (@id) .addtogamevars(this); } );	}
	/******************* metody na obiektach grupy *****************************/
	movefrom(string simg, int x, int y)	{
		int i = this.find(simg);
		if( i>=0 )	{
			while( i<lsim.size() )	{
				<lsim.get(i)>.move(x,y);
				i++;
			}
		}
	}
	move(int x, int y)	{	this.eval2("move",x,y);	}
	setpos(int x, int y)	{	this.eval2("setpos",x,y);	}
	show()	{	this.eval("show");	}
	hide()	{	this.eval("hide");	}
	stop(int fin)	{	this.eval1("stop",fin);	}
	play()	{	this.eval("play");	}
	setdelay(int d)	{	this.eval1("setdelay",d);	}
	graddmethod(string sdest, string ssrc)	{	this.eval2("addmethod",sdest,ssrc);	}
	string getimg(int x, int y, int bignorehidden, int bignorealpha)	{
		for( int i=lsim.size()-1; i>=0; i--)	{
			if( <lsim.get(i)>.isin( x,y,bignorehidden,bignorealpha ) )	return lsim.get(i);
		}
		return null;
	}
	int isin(int x, int y, bool bignorehidden, bool bignorealpha)	{
		for( int i=lsim.size()-1; i>=0; i--)	{
			if( <lsim.get(i)>.isin( x,y,bignorehidden,bignorealpha ) )	return i+1;
		}
		return false;
	}
	setframe(def ac, int ifr)	{	this.eval2("setframe",ac,ifr);	}
	setz(int z)	{	this.eval1("setz",z);	}
	/**************/
	eval(string sfunc)	{
		for(int i=0; i<lsim.size(); i++)	{<lsim.get(i)>.<sfunc>();	}
	}
	eval1(string sfunc, def darg)	{
		for(int i=0; i<lsim.size(); i++)	{<lsim.get(i)>.<sfunc>(darg);}
	}
	eval2(string sfunc, def darg1, def darg2)	{
		for(int i=0; i<lsim.size(); i++)	{<lsim.get(i)>.<sfunc>(darg1, darg2);}
	}
	eval3(string sfunc, def darg1, def darg2, def darg3)	{
		for(int i=0; i<lsim.size(); i++)	{<lsim.get(i)>.<sfunc>(darg1, darg2, darg3);}
	}
	int _find(string sfun, def id)	{
		for( int i=0; i<this.size; i++) if ( <this.get(i)>.<sfun>()==id ) return i;
		-1;
	}
	int _find1(string sfun, @id)	{
		for( int i=0; i<.size; i++) if ( <this.get(i)>.<sfun>(id) ) return i;
		-1;
	}
	each(string sfun)	{	for( int i=0; i<.size; i++) <.get(i)>.<sfun>(i);	}
	each1(string sfun, @d1)	{	for( int i=0; i<.size; i++) <.get(i)>.<sfun>(i, d1);	}
	each2(string sfun, @d1, @d2)	{	for( int i=0; i<.size; i++) <.get(i)>.<sfun>(i, d1, d2);	}
	bool ineach(string sfun)	{
		for( int i=0; i<.size; i++) if( !<.get(i)>.<sfun>(i) )	return false;
		true;
	}
	int find_closest(string sob, string sfun)	{
		if( .empty ) return;
		int id = 0, real il;
		real ilen = <.get(0)>.<sfun>(sob);
		for( int i=1; i<.size; i++)	{
			il = <.get(i)>.<sfun>(sob);
			if( il < ilen )	{
				id = i;
				il = ilen;
			}
		}
		id;
	}
	/**************/
	sortimgsfun(string sfun)	{	lsim.vecsort(sfun);	}
	sortimgs()	{	// sortowanie od najmniejszych
		lsim.vecsort("_scmpimg1");
	}
	bool _scmpimg1(string s0, string s1)	{
		return ( <s0>.getz() < <s1>.getz() || ( <s0>.getz()==<s1>.getz() && <s0>.getidobj() < <s1>.getidobj() ) );
	}
}

class gmimgvec : gmobjvec	{
	init()	{
		gmobjvec::init();
		new int _ix = 0;
		new int _iy = 0;
		new int _iz = 0;
		new int _ifound = -1;
	}
	_setpos(int x, int y)	{	|_ix, _iy| = x,y;	}
	int lodx()	{0;}
	int lody()	{0;}
	int getposx()	{	return _ix;	}
	int getposy()	{	return _iy;	}
	int getpos()	{	return _ix, _iy;	}
	int getpx() {	return _ix;	}
	int getpy() {	return _iy;	}
	int getw()	{	return this.getex()-this.getpx();	}
	int geth()	{	return this.getey()-this.getpy();	}
	int getcx() {	return this.getpx()+this.getw()/2;	}
	int getcy() {	return this.getpy()+this.geth()/2;	}
	int getz()	{	return _iz;	}
	int getex()	{
		int ile = this.size();
		if( ile<=0 )	{	return _ix;	}
		int x = <this.get(0)>.getex();
		int x2;
		for( int i=1; i<ile; i++)	{
			x2 = <this.get(i)>.getex();
			if( x2>x )	{	x=x2;	}
		}
		return x;
	}
	int getey()	{
		int ile = this.size();
		if( ile<=0 )	{	return _iy;	}
		int y = <this.get(0)>.getey();
		int y2;
		for( int i=1; i<ile; i++)	{
			y2 = <this.get(i)>.getey();
			if( y2>y )	{	y=y2;	}
		}
		return y;
	}
	int _getpx()	{
		int ile = this.size();
		if( ile<=0 )	{	return _ix;	}
		int x = <this.get(0)>.getpx();
		int x2;
		for( int i=1; i<ile; i++)	{
			x2 = <this.get(i)>.getpx();
			if( x2<x )	{	x=x2;	}
		}
		return x;
	}
	int _getpy()	{
		int ile = this.size();
		if( ile<=0 )	{	return _iy;	}
		int y = <this.get(0)>.getpy();
		int y2;
		for( int i=1; i<ile; i++)	{
			y2 = <this.get(i)>.getpy();
			if( y2<y )	{	y=y2;	}
		}
		return y;
	}
	int _getw	{	.getex-._getpx;	}
	int _geth	{	.getey-._getpy;	}
	/*minx	{	.find_closest(null, func {(@s) .getpx; } );	}
	miny	{	.find_closest(null, func {(@s) .getpy; } );	}
	countborders	{
		_ix = .minx;
		_iy = .miny;
	}*/
	setz(int z)	{
		_iz = z;
		this.eval1("setz",z);
	}
	move(int x, int y)	{
		_ix +=x;
		_iy +=y;
		this.eval2("move",x,y);
	}
	setpos(int x, int y)	{
		_ix = x;
		_iy = y;
		this.eval2("setpos",x,y);
	}
	setpos2(int x, int y)	{
		_ix = x;
		_iy = y;
		if( !.empty )	{
			x -= <.get(0)>.getpx;
			y -= <.get(0)>.getpy;
			.move(-x,-y);
		}
	}
	changeframe(int ifr) {
		string s;
		for( int i=0; i<.size; i++)	{
			s = .get(i);
			<s>.setframe( <s>.actionnr(-1), ifr );
		}
	}
	nplay(int n)	{	.eval1("play",n);	}
	txtreset	{	for( int i=0; i<.size; i++) <.get(i)>.txtset("");	}
	anputgr()	{	this.eval("anputgr");	}
	anputy(int ypos)	{	this.eval1("anputy", ipos);	}
	int isin(int x, int y, bool bignorehidden, bool bignorealpha)	{
		for( int i=lsim.size()-1; i>=0; i--)	{
			if( <lsim.get(i)>.isin( x,y,bignorehidden,bignorealpha ) )	{
				_ifound=i;
				return i+1;
			}
		}
		_ifound = -1;
		return false;
	}
	int isinfunc(int x, int y, string sfunc)	{
		for( int i=lsim.size()-1; i>=0; i--)	{
			if( <lsim.get(i)>.<sfunc>( x,y ) )	{
				_ifound=i;
				return i+1;
			}
		}
		_ifound = -1;
		return false;
	}
	int isincut(int x, int y, bool bignorehidden, bool bignorealpha)	{
		for( int i=lsim.size()-1; i>=0; i--)	{
			if( <lsim.get(i)>.withincut(x,y) && <lsim.get(i)>.isin( x,y,bignorehidden,bignorealpha ) )	{
				_ifound=i;
				return i+1;
			}
		}
		_ifound = -1;
		return false;
	}
	int findif(string sfunc)	{	._find( sfunc,true);	}
	int getfound()	{	return _ifound;	}
	string getsfound()	{	return this.get(_ifound);	}
	int findfr(int id)	{	._find("framenr", id);	}
	int findsfr(string s)	{	._find("framename", s);	}
	int findac(int id)	{	._find("actionnr", id);	}
	int findsac(string sac)	{	._find("actionname", sac);	}
	int nearest_to(string sob)	{
		//.find_closest(sob, func {(string s) 0->length( .getpx-<s>.getpx, .getpy-<s>.getpy ); } );
		.find_closest(sob, func {(string s) cllen.ilen5(this,s); } );
	}
	string getsac(string sac)	{	.get( .findsac(sac) );	}
	string getsacfr(string sac, int fr)	{	for(int i=0; i<.size; i++) if( <.get(i)>.actionname==sac && <.get(i)>.framenr==fr ) return .get(i); null; }
	/*def find_min(string s)	{
		if( .empty ) return;
		int x = <s>.getpx;
		int y = <s>.getpy;
		int id = 0, int il;
		int ilen = id.length( <.get(0)>.getpx-x, <.get(0)>.getpy-y );
		for( int i=1; i<.size; i++)	{
			il = id.length( <.get(i)>.getpx-x, <.get(i)>.getpy-y );
			if( il < ilen )	{
				id = i;
				il = ilen;
			}
		}
	}*/
	blitto(string simg)	{
		for( int i=0; i<.size; i++)	<simg>.blit(.get(i));
	}
	/****************************/
	loadallan(string sname, string sfile, int z)	{
		string s = gameapi.getgamename();
		<s>.newanima(sname,sfile,z);
		_ = <s>.newanfrbyactgr(sname, sname, this);
		<sname>.hide();
	}
	operator*(string s)	{
		string sg = gameapi.getgamename;
		string san;
		if ( s.contains(".pyz") ) {
			san = "an" + s.strsubes(".pyz");
			<sg>.newanima(san,s,0);
		} else san = s;
		_ = <sg>.newanactionsgr(san, san, this);
		<san>.hide();
	}
	operator<(string s)	{
		string sg = gameapi.getgamename;
		string san;
		if ( s.contains(".pyz") ) {
			san = "an" + s.strsubes(".pyz");
			<sg>.newanima(san,s,0);
		} else san = s;
		_ = <sg>.newanfrbyactgr(san, san, this);
		<san>.hide();
	}
}

class gmadvvec : gmimgvec	{
	init	{	gmimgvec::init;	}
	int butisin(int x, int y, bool bignorehidden, bool bignorealpha)	{
		for( int i=lsim.size()-1; i>=0; i--)	{
			if( <lsim.get(i)>.butisin( x,y,bignorehidden,bignorealpha ) )	{
				_ifound=i;
				return i+1;
			}
		}
		_ifound = -1;
		return false;
	}
}

class gmmaskvec : gmadvvec	{
	init()	{	gmadvvec::init;	}
	int butisin(int x, int y, bool bigvis, bool bigalpha)	{	gmimgvec::butisin(x,y,false,bigalpha);	}
}



class classsound {
	init()	{
		new string _csplay = null;
	}
	creset()	{ _csplay = null; }
	string cgetactsnd()	{ return _csplay; }
	crselfplay(string ssnd)	{
		if( !this.cisplaying() )	this.cbplay(ssnd);
		else if ( this.cgetactsnd()!=ssnd )	this.cbplay(ssnd);
	}
	cbselfplay(string ssnd)	{
		if( !.cisplaying || .cgetactsnd!=ssnd )	.cbplay(ssnd);
	}
	cbplay(string ssnd)	{
		if(this.cisplaying())	<_csplay>.stop(true);
		_csplay = ssnd;
		if( ssnd!=null )	<ssnd>.play();
	}
	cbplayfin(string ssnd, string sfun)	{
		<ssnd>.addmethod("onfinish", sfun);
		.cbplay(ssnd);
	}
	cbplay2(string ssnd)	{
		if(this.cisplaying())	<_csplay>.stop(false);
		_csplay = ssnd;
		if( ssnd!=null )	<ssnd>.play();
	}
	crplay(string ssnd)	{
		if(_csplay!=null && <_csplay>.isplaying() )	return;
		_csplay = ssnd;
		if( ssnd!=null )	<ssnd>.play();
	}
	crbgplay(string ssnd)	{	if( ssnd != null && !<ssnd>.isplaying() )	<ssnd>.play();	}
	crandplay(string ssnd, int irand, string styp)	{
		if( irand.rand()==0 )	this.<"c"+styp+"play">( ssnd );
	}
	cplayf(string styp, string ssnd, string sfun)	{
		this.<"c"+styp+"play">(ssnd);
		if( <ssnd>.isplaying() && sfun!=null)	<ssnd>.addmethod("onfinish",sfun);
	}
	//cactsndstop(bool bfin)	{	if(_csplay!=null)	<_csplay>.stop(bfin);	}
	cactsndstop(bool bfin)	{
		if(.cisplaying)	<_csplay>.stop(bfin);
	}
	cstopsnds(bool b)	{
		if( _csplay.in && .cisplaying )
			.cactsndstop(b);
	}
	bool cisplaying()	{	_csplay!=null ? <_csplay>.isplaying() : false;	}
}

/***************************************************************************/
class classsndbank	{
	init()	{
		new int itype;
		new int ilicz = 0;
		new int iile;
		new string splay=null;
		new string ssnd = "snd";
	}
	/********************************/
	loadsingle(string sfile, int ile)	{
		if( ile<=0)	{	iile=0;	return;	}
		iile=ile;
		itype=0;
		for( int i=0; i<ile; i++)	newvars::newsnd( ssnd+i, sfile );
	}
	/********************************/
	load(string sfilebase, int ifilefrom, int ifileto, int ityp, int itypstart)	{
		iile = ifileto-ifilefrom+1;
		if(iile<=0)	{
			iile = 0;
			return;
		}
		newvars::newsnds( ssnd, 0, sfilebase, ifilefrom, ifileto);
		itype = ityp;			// 0 - po kolei, 1 - random
		if(itypstart==1)	{	// 0 - od pierwszego, 1 - randomowy
			ilicz = iile.rand( );
		}
	}
	addmethod(string ssig, string sfunc)	{
		for( int i=0; i<iile; i++)	<ssnd+i>.addmethod( ssig, sfunc );
	}
	stop(int ifin)	{	if(splay!=null)	<splay>.stop(ifin);	}
	int isplaying()	{	splay!=null ? <splay>.isplaying() : false;	}
	randplay( int irand )	{	if( irand.rand()==0 )	this.play();	}
	playid(int id)	{
		ilicz=id%iile;
		this.play();
	}
	play()	{
		this.stop(false);
		this.bgplay();
	}
	reset()	{	ilicz=0;	}
	/************************************************/
	rbgplay()	{	if( !this.isplaying() )	this.bgplay();	}
	rplay()	{	if( !this.isplaying() )	this.play();	}
	bgplay()	{
		splay = ssnd + ilicz;
		<splay>.play();
		if( itype==0)	ilicz = (ilicz+1)%iile;
		else if (itype==1)	ilicz = iile.rand();
	}
	setvol(int vol)	{	for( int i=0; i<iile; i++)	<ssnd+i>.setvol( vol );	}
}

class SoundSource	{
	init	{	}
	setvol(string ssnd, int srcvol, int outvol, real rad, real length)	{
		if( length.abs>=rad ) <ssnd>.setvol(outvol);
		else <ssnd>.setvol((1.0-length.abs/rad)*srcvol + outvol);
	}
}

/**************************************************************/
	// standardowe czynnosci przy grach, popakowane w metody
class classgame : newvars , classsound {
	init()	{
		newvars::init();
		classsound::init();
		new int _iconstid;
	}
	/**************************************************************/
	bkg=(@sfile)	{
		if( sfile.contains(".pyz") ) .newanima("anbkg", sfile, 0);
		else .newimg("imgbkg",sfile,0);
	}
	bgr=(@sfile)	{
		//this.csndplayloop("sndbgr",sfile);
		.csndbgr(sfile);
	}
	path=(@s)	{	.setgraphpath("scripts/"+s+"/");	}
	cycle=(@stimer, @sfun)	{	.cnewtimercyclefin(stimer,1,1,sfun);	}
	timer=(@stimer, @itime, @sfun) { .cnewtimerfin(stimer,itime,1,sfun);	}
	def _getflags(string s)	{
		@bloop = false;
		if( s.contains("L") )	{
			s.strremove("L");
			bloop=true;
		}
		@bplay = false;
		if( s.contains("P") )	{
			s.strremove("P");
			bplay=true;
		}
		@bhide = false;
		if( s.contains("H") )	{
			s.strremove("H");
			bhide=true;
		}
		return s,bloop,bplay,bhide;
	}
	img=(@sfile)	{
		|sfile,@bloop,@bplay,@bhide| = ._getflags(sfile);
		@iz = 0;
		if( sfile.contains(" ") )	{
			iz = sfile.strgetfrom(" ");
			sfile = sfile.strgetto(" ");
		}
		string sname = sfile.strsube(4);
		string s;
		if( sfile.contains(".pyz") ) {
			s = "an" + sname;
			.newanima(s, sfile, iz);
		} else {
			s = "img" + sname;
			.newimg(s, sfile, iz);
		}
		if( bloop ) <s>.anloopfin;
		if( bplay ) <s>.play(-1);
		if( bhide ) <s>.hide;
	}
	imgs=	{	.withlist("img=");	}
	clone(string sob)	{
		<gameapi.getgamename> (this, .gettype, sob) { (@sthis, @styp, @sob)
			new <styp> <sob>;
			<sob>.copy(sthis);
		};
	}
	clones=	{	.withlist("clone");	}
	list=(@sname)	{
		@s=_;
		new gmobjvec <sname>;
		while(A!=s)	{
			<sname>.addbegin(s);
			s = _;
		}
	}
	list2={
		@s = .newconst("gmobjvec");
		.list=(s);
		s;
	}
	debug=(@b)	{	engine.setdebugstate(b);	}
	sfx=(string s)	{
		bool bloop2 = s.contains("N");
		if( bloop2 )	{
			s.strremove("N");
		}
		|s,@bloop,@bplay,_| = ._getflags(s);
		@ivol = 100;
		if( s.contains(" ") )	{
			ivol = s.strgetfrom(" ");
			s = s.strgetto(" ");
		}
		string sf = "fx"+s;
		//.newsnd(sf, "sfx/"+s+".wav");
		.newsfx( sf, s+".wav");
		<sf>.setvol( ivol );
		if( bloop ) <sf>.addmethod("onfinish","_stdsndloop");
		if( bplay ) <sf>.play;
		else if( bloop2 ) <sf>.playloop;
	}
	sfxs=	{	.withlist("sfx=");	}
	tickstart	{
		if( !.hasvar("__timspeed") )	new TicksCounter __timspeed;
		__timspeed.start;
	}
	tickstop	{	__timspeed.print("ticker: ");	}
	/**************************************************************/
	csndplayloop(string ssnd, string sfile)	{
		this.newsndloop(ssnd,sfile);
		<ssnd>.play();
	}
	csndbgr(string sfile)	{
		//this.csndplayloop("sndbgr",sfile);
		.newbgr("sndbgr", sfile );
		.sndplayloop("sndbgr");
	}
	cloadcursor(string sfile)	{
		if( sfile.contains(".") )	{
			.newimg("imgkursor", sfile,0);
			sfile = "imgkursor";
		}
		<sfile>.hide();
		mouse.setcursor(sfile);
		engine.stdbutcursor(sfile);
		bsms.setown();
	}
	/****************************************************************/
	newimgarray(string sname, string styp, string sn, int ile)	{
		new gmimgvec <sname>;
		<sname>.buildarray(styp,sn,ile);
	}
	newfont(string sfnt, string sfile, int isize)	{
		new font <sfnt>;
		<sfnt>.load( sfile, isize );
	}
	monofont(string sfnt, int isize)	{	.newfont(sfnt, sgmfontmono, isize);	}
	newfontbold(string sfnt, int isize)	{	.newfont(sfnt, sgmfontbold, isize);	}
	string snewfont(string sfontfile, int isize)	{
		string s = .newconst("font");
		<s>.load( sfontfile, isize );
		return s;
	}
	string stdfont(int isize)	{	.snewfont( sgmfontfile, isize	);	}
	string stdmono(int isize)	{	.snewfont( sgmfontmono, isize);	}
	string stdbold(int isize)	{	.snewfont( sgmfontbold, isize);	}
	int getconstid	{	_iconstid++;	_iconstid-1;	}
	string newconst(string styp)	{
		string s = "const"+styp+.getconstid;
		new <styp> <s>;
		return s;
	}
	string consttext(string stext, int x, int y, int isize, int r, int g, int b)	{
		string s = this.newconst("text");
		string sf = .stdfont(isize);
		<s>.setfont(sf);
		<s>.set(stext);
		<s>.createtxt(r,g,b);
		<s>.setpos(x,y);
		return s;
	}
	newtext(string stxt, string stext, string sfont, int r, int g, int b)	{
		new text <stxt>;
		<stxt>.set(stext);
		<stxt>.setfont(sfont);
		<stxt>.createtxt(r,g,b);
	}
	newtextposz(string stxt, string stext, string sfont, int r, int g, int b, int x, int y, int z)	{
		.newtext(stxt,stext,sfont,r,g,b);
		<stxt>.anposz(x,y,z);
	}
	/****************************************************************/
	cfinmethod(string sobj, string sfuncfin)	{	<sobj>.addmethod("onfinish", sfuncfin);	}
	cnewsndfin(string sname, string sfile, string sfunc)	{
		this.newsnd(sname,sfile);
		this.cfinmethod(sname,sfunc);
	}
	cnewsndsfin(string sbase, int inamestart, string sfilebase, int ifilefrom, int ifileto, string sfunc)	{
		this.newsnds(sbase, inamestart, sfilebase, ifilefrom, ifileto);
		this.caddobjsfunfin(sbase, inamestart, inamestart+( ifileto-ifilefrom), sfunc);
	}
	cnewsndfinbplay(string sname, string sfile, string sfunc)	{
		this.cnewsndfin(sname,sfile,sfunc);
		this.cbplay(sname);
	}
	cnewtimerfin(string sname, int idelay, int iticks, string sfunc)	{
		this.newtimer(sname,idelay,iticks);
		this.cfinmethod(sname,sfunc);
	}
	cnewtimercyclefin(string sname, int icycle, int iticks, string sfunc)	{
		this.newtimercycle(sname,icycle,iticks);
		this.cfinmethod(sname,sfunc);
	}
	/****************************************************************/
	caddobjsfun(string ssnd, int ifrom, int ito, string ssig, string sfunc)	{
		while( ifrom <= ito )	{
			<ssnd+ifrom>.addmethod( ssig, sfunc+ifrom );
			ifrom++;
		}
	}
	caddobjsfunfin(string ssnd, int ifrom, int ito, string sfunc)	{
		this.caddobjsfun( ssnd, ifrom, ito, "onfinish", sfunc );
	}
	/****************************************************************/
	newancounter(string scounter, string sname, string sfile, int z, int ile)	{
		this.newanimas( sname, sfile, z, ile);
		new classancounter <scounter>;
		<scounter>.set( sname, ile );
	}
	newancounterh(string scounter, string sname, string sfile, int z, int ile)	{
		this.newancounter( scounter, sname, sfile, z , ile );
		for( int i=0; i<ile; i++)	<sname+i>.hide();
	}
	newancounterf(string scounter, string sname, string sfile, int z, int ile, string sfun)	{
		this.newancounter( scounter, sname, sfile, z , ile );
		for( int i=0; i<ile; i++)	<sname+i>.addmethod("onfinish", sfun);
	}
	newancounterhf(string scounter, string sname, string sfile, int z, int ile, string sfun)	{
		this.newancounter( scounter, sname, sfile, z , ile );
		for( int i=0; i<ile; i++)	{
			<sname+i>.addmethod("onfinish", sfun);
			<sname+i>.hide();
		}
	}
	cnewanimafin(string sname, string sfile, int z, string sfunc)	{
		this.newanima(sname, sfile, z);
		<sname>.addmethod("onfinish", sfunc );
	}
	ccopyanimafin(string sname, string snew, string sfunc)	{
		this.copyanima(sname, snew);
		<snew>.addmethod("onfinish", sfunc );
	}
	/****************************************************************/
	cloadwavs(string sdb, string sfile)	{
		this.newdb( sdb, sfile );
		int id = 0;
		int ile = <sdb>.getrowsno();
		int i[6], string s[5];
		while( id < ile )	{
			i1 = <sdb>.getcolsno(id);
			i2 = 0;
			s1 = <sdb>.get( id, i2 );	i2++;
			if( s1.getb(0,1)!="#" )	{
				s3 = <sdb>.get( id, i2 );	i2++;
				if( s1=="wav" || s1=="sfx" )	{
					s2 = <sdb>.get( id, i2 );	i2++;
					if( s1=="sfx")	{
						this.newsfx( s3, s2 );
					} else { this.newsnd( s3, s2 ); }
					if( i2 < i1 )	{
						s1 = <sdb>.get( id, i2 );	i2++;
						s2 = <sdb>.get( id, i2 );	i2++;
						if( s1=="method" )	{
							<s3>.addmethod("onfinish", s2 );
						} else if (s1.gete(0,4)=="play")	{
							this.<"c"+s1.gete(4,10)+"playonfin">(s3, s2);
						} else if ( s1=="vol" )	{
							<s3>.setvol( s2 );
						}
					}
				} else if (s1=="group")	{
					s2 = <sdb>.get( id, i2 );	i2++;
					i3 = <sdb>.get( id, i2 );	i2++;
					i4 = <sdb>.get( id, i2 );	i2++;
					if( i2 < i1 )	{		// jest method
						s1 = <sdb>.get( id, i2 );	i2++;
						if( s1=="method" )	{
							s4 = <sdb>.get( id, i2 );	i2++;
							this.cnewsndsfin( s3, i3, s2, i3, i4, s4 );
						}
					} else {
						this.newsnds( s3, i3, s2, i3, i4 );
					}
				} else if (s1=="bank")	{
					s2 = <sdb>.get( id, i2 );	i2++;
					i0 = <sdb>.get( id, i2 );	i2++;
					i3 = <sdb>.get( id, i2 );	i2++;
					i4 = <sdb>.get( id, i2 );	i2++;
					i5 = <sdb>.get( id, i2 );	i2++;
					new classsndbank <s3>;
					<s3>.load( s2, i0, i3, i4, i5);
					if( i2<i1)	{
						s1 = <sdb>.get( id, i2 );	i2++;
						if( s1=="method")	{
							s4 = <sdb>.get( id, i2 );	i2++;
							<s3>.addmethod( "onfinish", s4 );
						} else if (s1=="vol")	{
							<s3>.setvol( <sdb>.get( id, i2 ) );
						}
					}
				} else if ( s1=="method" )	{
					s2 = <sdb>.get( id, i2 );	i2++;
					i3 = <sdb>.get( id, i2 );	i2++;
					i4 = <sdb>.get( id, i2 );	i2++;
					while( i3<=i4)	{
						<s2+i3>.addmethod("onfinish", s3);
						i3++;
					}
				} else if ( s1=="singlebank")	{
					s2 = <sdb>.get( id, i2 );	i2++;
					i3 = <sdb>.get( id, i2 );	i2++;
					new classsndbank <s3>;
					<s3>.loadsingle( s2, i3 );
				} else if ( s1=="bgr" )	{
					this.csndbgr( s3 );
					if( i2 < i1 )	{
						if( <sdb>.get( id, i2 )=="vol" )	{
							i2++;
							sndbgr.setvol( <sdb>.get( id, i2 ) );
							i2++;
						}
					}
				} else if ( s1=="music" )	{
					this.playmusic( s3 );
					if( i2 < i1 )	{
						if( <sdb>.get( id, i2 )=="vol" )	{
							i2++;
							sndbgr.setvol( <sdb>.get( id, i2 ) );
							i2++;
						}
					}
				}
			}
			id++;
		}
	}
	/****************************************************************/
	crestart()	{	gameapi.play( gameapi.getgamename() );	}
}


/***************************************************************************/

class clfindfunc	{
	init()	{}
	int _stdfindfunc(string sobj, int ifirst, int ilast, string sname, string sfunc)	{	
		while(ifirst<=ilast)	{
			if( <sobj + ifirst>.<sfunc>() ==sname )	return ifirst;
			ifirst++;
		}
		-1;
	}
	int _stdfindfunc2(string sobj, int iile, string sname, string sfunc)	{	
		._stdfindfunc(sobj, 0, iile-1, sname, sfunc);
	}
	/****************************************************************/
	cfindandeval2(string sobj, int iile, string sname, string sfunc, string seval)	{	
		.cfindandeval(sobj, 0, iile-1, sname, sfunc, seval);
	}
	cfindandeval(string sobj, int ifirst, int ilast, string sname, string sfunc, string seval)	{	
		int pos = ._stdfindfunc(sobj, ifirst, ilast, sname, sfunc);
		if(pos>=0)	<sobj+pos>.<seval>();
	}
}



/*****************************************************************/
class classbutton 	{
	init()	{
		new string san = "anbut";
		new string sbut = "but";
		new int iilebut = 0;
		new string sfxmon = null;
	}
	_cbuildbutname(string sname)	{	new string _sbutname=sname; }
	string cgetbutname()	{ return _sbutname; }
	build(string sfile, int z, string smouse)	{this.build2(sfile,z,smouse,null);	}
	build2(string sfile, int z, string smouse, string sgrp)	{	// wczytuje animacje i buduje z niej przyciski
		string smain = "_" + san;
		new anima <smain>;
		<smain>.load( sfile );
		<smain>.setz(z);
		int ile = <smain>.nofactions();
		int j;	int k;
		int iliczans = 0;
		string sn1, string sn2, string sn3;
		string spom;
		for(int i=0; i<ile; i++)	{
			sn1 = null;	sn2 = null;	sn3 = null;
			j = <smain>.nofframes(i);
			for(k=1; k<=j; k++)	{
				spom = san + iliczans;
				if(k==1)	{	sn1=spom; } 
				else if (k==2)	{ sn2 = spom; }
				else if (k==3)	{ sn3 = spom; }
				newvars::copyanima( smain, spom );
				<spom>.setframe( i, k-1 );
				iliczans++;
			}
			if( sgrp!=null && <sgrp>.contains( <smain>.nameofaction(i)) ) {
				<sn1>.setz(z-1);
			} else this.addbut(sn1, sn2, sn3, smouse);
		}
		<smain>.hide();
	}
	/***************************** \/ \/ \/ \/ \/ wewnetrzne \/ \/ \/ \/ \/ *************************************************/
	_buildfuncclick( string sname )	{	new string _sfunclick = sname; }
	_stdbutclick()	{	this.<_sfunclick>( this.getbutname() );		}
	_buildfuncrel( string sname )	{	new string _sfuncrel = sname; }
	_stdbutrel()	{	this.<_sfuncrel>( this.getbutname() );	}
	_buildfuncmovon( string sname )	{	new string _sfunmovon = sname; }
	_stdbutmovon()	{
		if( sfxmon!=null )	<sfxmon>.play();
		this.<_sfunmovon>( this.getbutname() );
	}
	_buildfuncmovoff( string sname )	{	new string _sfunmovoff = sname; }
	_stdbutmovoff()	{	this.<_sfunmovoff>( this.getbutname() );	}
	butsigfun(string sb, string sfunc, string ssig, string sfun1, string sfun2)	{
		if( sfunc==null )	return;
		<sb>.addmethod(sfun1, sfun1);
		<sb>.<sfun1>( sfunc );
		<sb>.addmethod(ssig, sfun2);
	}
	sigfunc(string sfunc, string ssig, string sfun1, string sfun2)	{
		for(int i=0; i<iilebut; i++)	this.butsigfun(sbut + i, sfunc, ssig, sfun1, sfun2);
	}
	print()	{for(int i=0; i<iilebut; i++)	engine.print( <sbut+i>.getbutname() );}
	setrect()	{
		string s;
		for( int i=0; i<iilebut; i++)	{
			s = <sbut+i>.getimg;
			<sbut+i>.setrect( <s>.getpx, <s>.getpy, <s>.getex, <s>.getey );
		}
	}
	setflags(bool bvis, bool balph)	{	for(int i=0; i<iilebut; i++)	<sbut+i>.setflags(bvis,balph);	}
	/***************************** /\ /\ /\ /\ /\ wewnetrzne /\ /\ /\ /\ /\ ************************************************/
	sfxonmovon(string ssnd)	{	sfxmon=ssnd;	}
	clickfunc(string sfunc)	{this.sigfunc(sfunc,"onclick", "_buildfuncclick", "_stdbutclick");	}
	relfunc(string sfunc)	{this.sigfunc(sfunc,"onrel", "_buildfuncrel", "_stdbutrel");	}
	movonfunc(string sfunc)	{this.sigfunc(sfunc,"onmoveon", "_buildfuncmovon", "_stdbutmovon");	}
	movofffunc( string sfunc)	{this.sigfunc( sfunc,"onmoveoff", "_buildfuncmovoff", "_stdbutmovoff");}
	/*****************************************************************/
	int ilebuts()	{	return iilebut;	}
	/*****************************************************************/
	int ifind(string sname)	{return clfindfunc::_stdfindfunc2(sbut, iilebut, sname, "getbutname");	}
	string sfind(string sname)	{
		int pos = clfindfunc::_stdfindfunc2(sbut, iilebut, sname, "getbutname");
		return pos>=0 ? sbut+pos : null;
	}
	/*****************************************************************/
	_cbutfun(string sname, string sfunc)	{
		clfindfunc::cfindandeval2(sbut, this.ilebuts(), sname, "getbutname", sfunc );
	}
	_callbutfunc(string sfunc)	{	for(int i=0; i<iilebut; i++)	<sbut+i>.<sfunc>();	}
	_cibutfunc(string sfunc, int ile)	{
		if( ile > iilebut )	ile = iilebut;
		for(int i=0; i<ile; i++)	<sbut+i>.<sfunc>();
	}
	ienable( int ile )	{	this._cibutfunc("enable", ile);	}
	benableall()	{	this.resumeall();	this.enableall();	}
	pauseall()	{	this._callbutfunc("pause");	}
	resumeall()	{	this._callbutfunc("resume");	}
	enableall()	{	this._callbutfunc("enable");	}
	disableall()	{	this._callbutfunc("disable");	}
	disabled	{	<sbut+0>.disabled;	}
	
	benable(string sname)	{	this.resume(sname);	this.enable(sname);	}
	disable(string sname)	{	this._cbutfun( sname, "disable");	}
	enable(string sname)	{	this._cbutfun( sname, "enable");	}
	pause(string sname)	{	this._cbutfun( sname, "pause");	}
	resume(string sname)	{	this._cbutfun( sname, "resume");	}
	/*****************************************************************/
	string getimg(string sname)	{
		string s= this.sfind(sname);
		return s!=null ? <s>.getimg() : null;	
	}
	callimgfun(string sname, string sfun)	{	<.getimg(sname)>.<sfun>;	}
	/*****************************************************************/
	newmouse(string sname, string snewmouse)	{
		string s = this.sfind(sname);
		if(s!=null)	<s>.setmouse( snewmouse );
	}
	addbut(string san1, string san2, string san3, string smouse)	{
		string spom = sbut + iilebut;
		newvars::newbutan( spom, san1, san2, san3, smouse);
		<spom>.addmethod("getbutname","cgetbutname");
		<spom>._cbuildbutname( <san1>.actionname() );	// nazwa buttonu to nazwa akcji
		iilebut++;
	}
	/*****************************************************************/
	_addfunc(string s, string sfclick, string sfrel, string sfmvon, string sfmvoff)	{
		if( s== null)	return;
		this.butsigfun( s, sfclick, "onclick", "_buildfuncclick", "_stdbutclick");
		this.butsigfun( s, sfrel, "onrel", "_buildfuncrel", "_stdbutrel");
		this.butsigfun( s, sfmvon, "onmoveon", "_buildfuncmovon", "_stdbutmovon");
		this.butsigfun( s, sfmvoff, "onmoveoff", "_buildfuncmovoff", "_stdbutmovoff");
	}
	addfuncto(string sname, string sfclick, string sfrel, string sfmvon, string sfmvoff)	{
		this._addfunc( this.sfind(sname), sfclick, sfrel, sfmvon, sfmvoff);
	}
	addfunctolast(string sfclick, string sfrel, string sfmvon, string sfmvoff)	{
		this._addfunc( sbut + (iilebut-1) , sfclick, sfrel, sfmvon, sfmvoff);
	}
	/*****************************************************************/
	_transmet(string sob, string sfunc, string smet, string s)	{
		new string <"_sob" + s> = sob;
		new string <"_sf" + s> = sfunc;
		this.<smet>( "_trf"+s );
	}
	transclickfunc(string sob, string sfunc)	{this._transmet( sob, sfunc, "clickfunc", "cl" );	}
	transrelfunc(string sob, string sfunc)	{this._transmet( sob, sfunc, "relfunc", "rl" );	}
	transmovonfunc(string sob, string sfunc){this._transmet( sob, sfunc, "movonfunc", "mn" );	}
	transmovofffunc(string sob, string sfunc){this._transmet( sob, sfunc, "movofffunc", "mf" );	}
	_trfcl(string s)	{	<_sobcl>.<_sfcl>(s);		}
	_trfrl(string s)	{	<_sobrl>.<_sfrl>(s);		}
	_trfmn(string s)	{
		if( sfxmon!=null )	<sfxmon>.play();
		<_sobmn>.<_sfmn>(s);
	}
	_trfmf(string s)	{	<_sobmf>.<_sfmf>(s);		}
}

class classsimplebutton {
	init()	{
		new string simgob=null;
		new gmimgvec grbut;
	}
	public stdbuild(string sfile, string smouse, int z)	{this.build(this.getgraphpath()+sfile, smouse, 0, 0, z, 0);	}
	public getimgfunc(string sfunc)	{	simgob==null ? 0 : <simgob>.<sfunc>();	}
	public setbutpos(int x, int y)	{	grbut.setpos(x,y);	}
	public build(string sfile, string smouse, int x, int y, int z, int iact)	{
		new button but1;
		but1 (this.getname()) {(string s) new string sbut = s; };
		but1.addmethod("onclick", func { this.<sbut+"_CLICK">(); });
		but1.addmethod("onrel", func { this.<sbut+"_REL">(); } );
		but1.addmethod("onmoveon", func { this.<sbut+"_MOVEON">(); });
		but1.addmethod("onmoveoff", func { this.<sbut+"_MOVEOFF">(); });
		
		if( sfile.contains(".pyz") )	{
			new anima anbut0;
			anbut0.load( sfile );
			anbut0.setpos(x,y);
			anbut0.setz(z);
			anbut0.setframe(iact,0);
			simgob="anbut0";
			grbut.add(simgob);
			string s0="anbut0";
			string s1=null;
			string s2=null;
			int ile = anbut0.nofframes(iact);
			if( ile>1 )	{
				new anima anbut1;
				anbut1.copy("anbut0");
				anbut1.setframe(iact,1);
				s1 = "anbut1";
				grbut.add(s1);
			}
			if (ile>2)	{
				new anima anbut2;
				anbut2.copy("anbut0");
				anbut2.setframe(iact,2);
				s1 = "anbut2";
				grbut.add(s1);
			}
			but1.setan(s0,s1,s2);
		} else {
			new img imgbut;
			simgob="imgbut";
			grbut.add(simgob);
			imgbut.load(sfile);
			imgbut.setpos(x,y);
			imgbut.setz(z);
			but1.set("imgbut",null,null);
		}
		but1.setmouse(smouse);
	}
}

/*****************************************************************/

class classmask : classbutton	{
	init()	{
		classbutton::init();
	}
	buildmask(string sfile, string smouse)	{
		this.build(sfile, 0, smouse);
		int ile = this.ilebuts();
		for(int i=0; i<ile; i++)	{
			<sbut+i>.setflags(false, false);
			<sbut+i>.hide();
		}
	}
	buildmaskfunc(string sfile, string smouse, string sfunc)	{
		this.buildmask(sfile, smouse);
		this.clickfunc(sfunc);
	}
	addmask(string sanim, string sname, string smouse, int bhide)	{		// dodanie np. ludka jako maski
		string spom = sbut + iilebut;
		newvars::newbutan( spom, sanim, null, null, smouse);
		<spom>.addmethod("getbutname","cgetbutname");
		sname==null ? <spom>._cbuildbutname(<sanim>.actionname()) : <spom>._cbuildbutname(sname);
		if(bhide)	{
			<spom>.setflags(false, false);
			<spom>.hide();
		}
		iilebut++;
	}
	addadvmask(string sanim, string sname, string smouse, string sfuncclick)	{
		this.addmask( sanim, sname, smouse, false );
		this.addfunctolast( sfuncclick, null, null, null);	
	}
}

/*****************************************************/
public callfun(string sob, string sfun)	{if( sfun!=null ) sob==null ? this.<sfun>() : <sob>.<sfun>();}
public _stdanloop()	{	this.play(-1); }
public _stdanhide()	{	this.hide();	}
public _stdsndloop()	{	this.play(); }
public __std_finish()	{	this.<this+"_FINISH">();	}
public looponfinish(string san)	{	<san>.addmethod("onfinish", "_stdanloop");	}
public hideonfinish(string san)	{	<san>.addmethod("onfinish", "_stdanhide");	}
/*****************************************************/
public string strsube(int ile)	{	return this.getb( 0, this.length()-ile );	}
public string strsubb(int ile)	{	return this.getb( ile, this.length() - ile );	}
public string strsubbs(string s)	{	return this.strsubb( s.length() );	}
public string strsubes(string s)	{	return this.strsube( s.length() );	 }
public string strgetto(string schar)	{
	@id = .find(schar);
	id<0 ? .get : .getb(0, id);
}
public string strgetfromto(int ipos, string schar)	{	return this.getb(ipos, this.find(schar));	}
public string strgetfrom(string schar)	{	return .getb(.find(schar)+schar.length, .length );	}
public strremove(string s)	{	.set( .strgetto(s) + .strgetfrom(s) ); }
public bool strisbetween(int b1, int b2)	{
	int ib;
	for(int i=0; i<.length; i++)	{
		ib = .getbyte(i);
		if( ib<b1 || ib>b2 )	return false;
	}
	true;
}
public bool strisint		{	.strisbetween(BYTE0, BYTE9);	}
public bool strisbin	{	.strisbetween(BYTE0, BYTE0+1);	}
public bool strisalpha	{	.strisbetween(BYTEa, BYTEz);	}
public streach(string sfun)	{
	string s;
	for( int i=0; i<.length; i++) {
		s = .getb(i,1);
		<s>.<sfun>(i);
	}
}
public string strdotpos(int pos)	{	.strgetto(".") + "." + .strgetfrom(".")->getb(0,pos);}
/*****************************************************/
public swap(string s1, string s2)	{
	[s1];
	<s1> = [s2];
	<s2> = _;
}
public bool stats(int ile)	{	(ile <= 0) ? false : ( 100->rand <= ile );}
public def between(def i1, def i, def i2)	{	( i < i1 ) ? i1 : (i>i2) ? i2 : i;}
public def max(def val1, def val2)	{	val1>val2 ? val1 : val2;	}
public def min(def val1, def val2)		{	val1<val2 ? val1 : val2;	}
/*************** do wykorzystania na obiektach!! ***********************************/
public imgborders(int w, int r, int g, int b, int a)	{	.imgborderss(w,r,g,b,a,"1111"); }
public imgborderss(int w, int r, int g, int b, int a, string sbor)	{
	new img _img_bor;
	_img_bor.create(.getw, w, r,g,b,a);
	_img_bor.setpos(.getpx, .getpy );
	if(sbor.getb(3,1)=="1")
		.blit("_img_bor");
	_img_bor.move(0, .geth-w);
	if(sbor.getb(1,1)=="1")
		.blit("_img_bor");
	_img_bor.create(w,.geth,r,g,b,a);
	_img_bor.setpos(.getpx, .getpy);
	if(sbor.getb(0,1)=="1")
		.blit("_img_bor");
	_img_bor.move(.getw-w, 0);
	if(sbor.getb(2,1)=="1")
		.blit("_img_bor");
	delete _img_bor;
}
public imgroundborder(int w, int r, int g, int b, int a)	{
	.imgborders(w,r,g,b,a);
	.imgerasecorners;
}
public imgerasecorners	{
	@x = .getpx;
	@y = .getpy;
	.putrgba(x,y,.transparent);
	.putrgba(.getex-1,y,.transparent);
	.putrgba(.getex-1,.getey-1,.transparent);
	.putrgba(x,.getey-1,.transparent);
}
public real imgdrawline(string sbrush, int xstart, int ystart, int xstop, int ystop, real istep, real rdy)	{
	.imgfuncline("blit",sbrush,xstart,ystart,xstop,ystop,istep,rdy);
}
public real imgeraseline(string sbrush, int xstart, int ystart, int xstop, int ystop, real istep, real rdy)	{
	.imgfuncline("erase",sbrush,xstart,ystart,xstop,ystop,istep,rdy);
}
public imgputoncenter(string simg)	{	.setpos( <simg>.getcx-.getw/2, <simg>.getcy-.geth/2);	}
public real imgfuncline(string sfun, string sbrush, int xstart, int ystart, int xstop, int ystop, real istep, real rdy)	{
	@dx = xstop-xstart;
	@dy = ystop-ystart;
	real r;
	if( dx==0 )	{
		if( dy<0 )	{
			r = rdy+ystart;
			while( r>=ystop )	{
				<sbrush>.setpos(xstart, r);
				.<sfun>(sbrush);
				r-=istep;
			}
			ystop-r;
		} else if (dy>0)	{
			r = rdy+ystart;
			while( r<=ystop )	{
				<sbrush>.setpos(xstart, r);
				.<sfun>(sbrush);
				r+=istep;
			}
			r-ystop;
		} else rdy;
	} else {
		r = rdy.length(dx, dy);
		real rd;
		while( rdy<=r )	{
			rd = 1.0 - (r-rdy)/r;
			<sbrush>.setpos( (rd*dx)+xstart, (rd*dy)+ystart );
			.<sfun>(sbrush);
			rdy+=istep;
		}
		rdy-r;
	}
}
public anresizemets()	{	anima_pack::resizemethods(this.getname());	}
//public def anfirstnontr	{	classansearcher::firstnotrx1y(this);	}
public def anfirstnontr	{	classansearcher::_findnotr(this,.getpx, .getpy, 1, 0);	}
public anloopfin()	{	this.addmethod("onfinish", "_stdanloop");	}
public anloopplay(int iact)	{	this.anloopfin();	this.play(iact);	}
public anloopsplay(string sact)	{	this.anloopfin();	this.play(sact);	}
public anhidefin()	{	this.addmethod("onfinish","_stdanhide");	}
public anputgr()	{	this.setz( this.getey() );	}
public anputy(int ypos)	{	this.move(0, ypos - this.geth() - this.getpy());	}
public anputx(int xpos)	{	this.move(0, xpos - this.geth() - this.getpy());	}
public ansetposgr(int x, int y)	{	this.setpos(x,y);	this.anputgr();	}
public anplayz(int id, int z)	{	this.setz(z);	this.play(id);	}
public anplaygr(int id)	{	this.play(id);	this.anputgr();	}
public anplayzpos(int id, int z, int x, int y)	{	this.setpos(x,y);	this.anplayz(id,z);	}
public anplaypos(int x, int y)	{	this.setpos(x,y);	this.play(-1);	}
public anplayposgr(int x, int y)	{	this.ansetposgr(x,y);	this.play(-1);	}
public anplaypos2(int x, int y, string sact)	{	this.setpos(x,y);	this.play(sact);	}
public anplaypos3(int x, int y, int iact)	{	this.setpos(x,y);	this.play(iact);	}
public anhide()	{	this.stop(false);	this.hide();	}
public andownpos(int x, int y)	{	this.setpos( x, y-this.geth() );	}
public ansetbpos(int x, int y)	{	this.setpos( x-this.lodx(), y-this.lody() );	}
public ansetcpos(int x, int y)	{	.ansetbpos( x - .getw/2, y - .geth/2 );	}
public ancenterscreen {       .ansetcpos( iResX/2, iResY/2 ); }
public ansetframe(int id)	{	this.setframe( this.actionnr(-1), id );	}
public ansetsframe(def d, string s)	{
	.setframe(d,0);
	int id = 0;
	while( id < .nofframes(-1) && .framename!=s )	{
		id++;
		.setframe(-1,id);
	}
}
public int anonscreen()	{	return clsurf.inscreen(this.getcx(), this.getcy(), this.getw()/2, this.geth()/2);	}
public objplayfin(string sfun)	{	this.addmethod("onfinish", sfun);	this.play();	}
public objloop()	{	this.addmethod("onfinish","_stdsndloop");	}
public objplayloop()	{	this.objloop;	this.play();	}
public anplayfin(int iact, string sfun)	{	this.addmethod("onfinish", sfun);	this.play(iact);	}
public anytoz()	{	this.setz(this.getposy());	}
public anposz(int x, int y, int z)	{	.setpos(x,y);	.setz(z);	}
public string annextaction(string sact)	{return this.nameofaction( (this.actionnr(sact)+1)%this.nofactions() );}
public ansetnextact	{	.setframe( (.actionnr(-1)+1)%.nofactions, 0 ); }
public ansetnextfr		{	.setframe( -1, (.framenr+1)%.nofframes(-1)); }
public anaddfilter()	{	classanfilter::build(this.getname());	}
public anaddfx	{	AnimaFx::build( this );	}
public anputc(int x1, int y1, int x2, int y2)	{
	.ansetbpos(x1,y1);
	.move( (x2-x1-.getw)/2, (y2-y1-.geth)/2 );
}
public aninlod(int itoler)	{	itoler.length( .getpx - .lodx, .getpy - .lody ) <= itoler; }
public angetcpos	{	return .getcx, .getcy;	}
public angetcrgba	{	.getrgba(.getcx, .getcy);	}
public anisin(int x, int y, bool bv, bool ba)	{
	for( int i=0; i<.nofactions; i++)	{
		.setframe(i, 0);
		if( .isin(x,y,bv,ba) ) return i;
	}
	-1;
}
public anreload(string sfile)	{
	int id = .actionnr(-1);
	int fr = .framenr;
	bool bplay = .isplaying(-1)!=false;
	|int x, int y| = .getpos;
	int z = .getz;
	.load( .getpath(sfile) );
	.setpos(x, y);
	.setz(z);
	if( id < .nofactions ) {
		if( bplay ) .play(id);
		.setframe(id ,fr );
	} else .setframe(0 ,0);
}
public anclipob(string sob)	{	.clip(<sob>.getpx, <sob>.getpy, <sob>.getex, <sob>.getey);	}
public ancopyan(string san)	{
	.setframe( <san>.actionnr(-1), <san>.framenr );
	<san>.isvisible ? .show : .hide;
	.setpos( <san>.getpos );
}
/***************** text ****************/
public txtset(string s)	{	.set(s);	.create;	}
public txtsetcol(string s, int r, int g, int b)	{	.set(s);	.createtxt(r,g,b);	}
public txtshadow(int w, string sfont)	{
	if( !.hasvar("txts") )	{
		new text txts;
		txts.setfont(sfont);
	}
	txts.set(.get);
	txts.setpos(.getpx+w, .getpy+w);
	txts.setz(.getz-1);
	txts.show;
	txts.createtxt(0,0,0);
}
public txthides	{	.hide; if(.hasvar("txts")) txts.hide; }
public txtisin(int x, int y)	{
	x>=.getpx && x<.getpx+.getw && y>=.getpy && y<=.getpy+.geth;
}
public txtcenter(string sob)	{	.setpos( <sob>.getcx - .getw/2, <sob>.getcy - .geth/2 );}
public txtright(string sob)	{	.setpos( <sob>.getex - .getw, <sob>.getcy - .geth/2 );}
/***************** vector ****************/
public vecinc(int pos)	{	this.set( pos, this.get(pos)+1 );	}
public vecdec(int pos)	{	this.set( pos, this.get(pos)-1 );		}
public vecnewint(int ile)	{
	this.free();
	if( ile>0 )	for( int i=0; i<ile; i++)	{	this.add(i);	}
}
public veccopy(string svec)	{
	this.free();
	for( int i=0; i< <svec>.size(); i++ )	this.add( <svec>.get(i) );
}
public int vecnextid(def val)	{
	int id = .find(val);
	if( id>=0 )	id = (id+1)%.size;
	id;
}
public int vecprevid(def val)	{
	int id = .find(val);
	if( id>0 )	id--;
	else if (id==0)	id = .size-1;
	id;
}
public def vecget(int id)	{
	( id>=0 && id<.size) ? .get(id) : null;
}
public def vecnext(def val)	{	.vecget( .vecnextid(val) );	}
public def vecprev(def val)	{	.vecget( .vecprevid(val) );	}
public def veclast()	{
	int ile = this.size();
	ile>0 ? this.get(ile-1) : null;
}
public def vecpop()	{
	@x = .last;
	.removeat( .size - 1 );
	x;
}
public veclimes(int ile)	{	while( .size > ile )	_ = .vecpop;	}
public def vecpopfront()	{
	def x = this.get(0);
	this.removeat( 0 );
	return x;
}
public vecreplace(def d1, def d2)	{
	@id = .find(d1);
	if( id>=0 )	.set(id,d2);
}
public insertsort(int ile, string sgetfun, string scomparefun, string sswapfun)	{
	if( ile<=1 )	{	return;	}
	def s[2], int id, int i, int j;
	for( i=0; i<ile; i++)	{
		s0 = this.<sgetfun>(i);
		id = i;
		for( j=i+1; j<ile; j++)	{
			s1 = this.<sgetfun>(j);
			if( this.<scomparefun>(s1,s0) )	{
				s0 = s1;
				id = j;
			}
		}
		this.<sswapfun>(i,id);
	}
}
public obbuildfromstring(string s, string separator, string sfunadd)	{
	int pos = s.find(separator);
	while( pos>-1 )	{
		this.<sfunadd>( s.getb(0,pos) );
		s = s.strsubb(pos+1);
		pos = s.find(separator);
	}
	if( s.length()>0 )	{	this.<sfunadd>(s);	}
}
public obbuildfromstring2(string s, string separator, string sfunadd)	{
	int pos = s.find(separator);
	while( pos>-1 )	{
		if( pos>0 )	this.<sfunadd>( s.getb(0,pos) );
		s = s.strsubb(pos+1);
		pos = s.find(separator);
	}
	if( s.length()>0 )	{	this.<sfunadd>(s);	}
}
public vecsort(string scomparefun)	{ .insertsort( .size, "get", scomparefun,"swap" ); }
public string vecbuildfromstring(string s, string separator)	{
	this.free();
	this.obbuildfromstring(s,separator,"add");
}
public string vecbuildfromstring2(string s, string separator)	{
	this.free();
	this.obbuildfromstring2(s,separator,"add");
}
public vecremoveto(int ito)		{	for( int i=0; i<ito; i++ ) this.removeat(0);		}
public vecremovefrom(int ifrom)	{	while( ifrom<this.size() ) this.removeat(ifrom);	}
public vecfindfrom(int ifrom, def d)	{
	while (ifrom<.size)	{
		if( .get(ifrom)==d ) return ifrom;
		else ifrom++;
	}
	return -1;
}
public vecposfromto(int i1, int i2)	{
	if( i1==i2 || .size==0 )	return;
	def x = .get(i1);
	if( i1>i2 )	for( int i=i1; i>i2; i--)	{	.set(i, .get(i-1));		}
	else if (i1<i2)	for( int i=i1; i<i2; i++)	{	.set(i, .get(i+1));	}
	.set(i2,x);
}
public vecposfirst( def x )	{
	int id = .find(x);
	if( id>=0 )	.vecposfromto(id, 0);
	else	.addbegin(x);
}
public vecposlast( def x )	{
	int id = .find(x);
	if( id>=0 )	.vecposfromto(id, .size-1);
	else	.addbegin(x);
}
public vecset(def x, def d2)	{
	int id = .find(x);
	if( id>=0 )	.set(id,d2);
}
public bool veceq(string svec)	{
	int id = .size;
	if( id != <svec>.size  )	return false;
	for( int i=0; i< id; i++)	if( .get(i)!=<svec>.get(i) ) return false;
	true;
}
public vecbuild	{	.withlist("addbegin");}
public bool veceq2	{
	new vector ___v;
	___v.type(.getvectype);
	___v.vecbuild;
	bool b = .veceq("___v");
	delete ___v;
	b;
}
public veccopydbrow(string sdb, int irow)	{	.free;	 .vecadddbrow(sdb,irow);	}
public vecadddbrow(string sdb, int irow)	{	for( int i=0; i< <sdb>.getcolsno(irow); i++)	.add( <sdb>.get(irow,i) );	}
public def vecchecknext(int id)	{
	id++;
	id < .size ? .get(id) : null;
}
public def vecsum	{
	if( .size )	{
		def sum = .get(0);
		for( int i=1; i<.size; i++)	{
			sum+=.get(i);
		}
		sum;
	} else 0;
}
/************** db ************************/
public dbbuild(int icol)	{
	if( icol<=0 )	return;
	icol--;
	.free;
	string s = _, int id;
	for( int i = 0; s!=A; )	{
		if( i==0 )	id = this.addbeginrow() - 1;
		this.addbegin(0,s);
		s = _;
		i = (i<icol)? i+1 : 0;
	}
}
public dbbuild2	{
	.free;
	string s = _;
	while( s!=A )	{
		if( s==null )	_ = .addbeginrow;
		else .addbegin(0,s);
		s = _;
	}
}
public dbaddvec(string svec)	{
	@id = .addrow-1;
	for( int i=0; i< <svec>.size; i++)	.add(id, <svec>.get(i));
}
public dbcopy(string sdb)	{	.dbcopyfromto(sdb, 0, <sdb>.getrowsno);}
public dbcopyrow(string sdb, int irow)	{	.dbcopyfromto(sdb,irow,irow+1);	}
public dbcopyfromto(string sdb, int i1, int i2)	{
	.free;
	int i, int j, int row;
	for( i =i1; i< i2; i++)	{
		row = .addrow-1;
		for( j=0; j< <sdb>.getcolsno(i); j++)	{
			.add( row, <sdb>.get(i,j) );
		}
	}
}
public dbadddbrowtorow(int myrow, string sdb, int row)	{
	for( int i=0; i< <sdb>.getcolsno(row); i++)	{
		.add( myrow, <sdb>.get(row,i) );
	}
}
public dbremovecol(int col)	{	for(int i=0; i<.getrowsno; i++) if( .getcolsno(i)>col ) .removeat(i,col);	}
public dbcopyfromtos(string sdb, string sfrom, string sto)	{
	.dbcopyfromto(sdb, <sdb>.findbyrow(sfrom)+1, <sdb>.findbyrow(sto));
}
public dbremovelast()	{
	.removerow( .getrowsno-1 );
}
public dbcuttosize(int isize)	{
	if( isize>0 ) while( .getrowsno > isize )	.dbremovelast;
	else	.free;
}
public dbaddlast(string svar)	{	this.add( this.getrowsno()-1, svar );	}
public dbaddstringrow(string s, string separator)	{
	_ = this.addrow();
	this.obbuildfromstring(s,separator,"dbaddlast");
}
public dbgetstringrow(int row)	{
	string s="";
	int ile = .getcolsno(row);
	for( int i = 0; i<ile; i++) s+= .get(row,i);
	s;
}
public dbaddrow	{
	@id = .addrow - 1;
	@s = _;
	while(A!=s)	{
		.addbegin(id, s);
		@s = _;
	}
}
public dbaddrowfrom(string sdb, int irow, int icol)	{
	if( <sdb>.rowinrange(irow) && icol>=0)	{
		int id = this.addrow()-1;
		int ile = <sdb>.getcolsno(irow);
		while( icol < ile )	{
			this.add( id, <sdb>.get( irow, icol ) );
			icol++;
		}
	}
}
public string dbchecknext(int irow, int icol)	{
	icol++;
	icol < this.getcolsno(irow) ? this.get(irow,icol) : null;
}
public string dbgets(string s, int icol)	{return this.get( this.findbyrow(s), icol );}
public int dbinsertless(int i1)	{
	int id = this.addrow()-1;
	this.add(id,i1);
	this.dbsort("cmpless");
	while( id>=0 )	{
		if( i1==this.get(id,0) )	return id;
		id--;
	}
	return -1;
}
public bool dbdelvar(int irow, string svar)	{return this.dbdelvarn(irow,svar,1);}
public bool dbdelvarn(int irow, string svar, int n)	{
	int id = this.dbfindinrow(irow,svar);
	if( id>=0 )	{
		this.removen(irow,id,n);
		return true;
	}
	return false;
}
public int dbfindinrow(int irow, string svar)	{
	if( this.rowinrange(irow) )	{
		for( int i=0; i<this.getcolsno(irow); i++)	if( this.get(irow,i)==svar )	return i;
	}
	return -1;
}
public int dbfindbycol(int icol, string svar)	{
	for( int i=0; i<this.getrowsno(); i++)	{if( this.get(i,icol)==svar ) return i;}
	return -1;
}
public bool dbrowcontains(int irow, string svar)	{	return this.dbfindinrow(irow,svar)!=-1;	}
public string dbfirst(int id)		{	return this.get(id,0);	}	
public bool cmpless(int i1, int i2)	{	return i1<i2;	}
public bool cmpabove(int i1, int i2)	{	i1>i2;	}
public bool dbfirstless(int i1, int i2)	{	.get(i1,0) < .get(i2,0);	}
public dbsort(string scomparefun)	{	.insertsort( .getrowsno, "dbfirst",scomparefun, "swap" ); }
public dbsetall(string svar)	{	for( @i=0; i<.getrowsno; i++)	for(@j=0; j<.getcolsno(i); j++)	.set(i,j,svar);	}
public dbeach_row(string sfun)	{	for( @i=0; i<.getrowsno; i++) .<sfun>(i);	}
public dbeq(string sdb)	{
	if( .getrowsno != <sdb>.getrowsno ) return false;
	int ile, int j;
	for( int i=0; i<.getrowsno; i++)	{
		ile = .getcolsno(i);
		if( ile!=<sdb>.getcolsno(i) ) return false;
		for( j=0; j<ile; j++)	{
			if( .get(i,j)!=<sdb>.get(i,j) ) return false;
		}
	}
	true;
}
/************** int ************************/
public int randdiff(int zakres, int odjakiej)	{
	if( zakres<=1 )		return -1;
	for( int i1 = zakres.rand; i1==odjakiej; i1= zakres.rand )	{}
	return i1;
}
public int bin_to_i	{
	string s = .get;
	int idwa = 1;
	int iout = 0;
	for( int i=s.length-1; i>=0; i--)	{
		if( s.getb(i,1)=="1") iout+=idwa;
		idwa*=2;
	}
	iout;
}

/***************************************************************************/
class classgamepause	{
	init()	{
		new button butpause;
		butpause.setrect( 0, 0, 800, 600 );
		butpause.addmethod("onclick", "resume");
		butpause.disable();
	}
	resume()	{
		butpause.disable();
		gameapi.resume();
	}
	pause()	{
		gameapi.pause();
		butpause.enable();
		butpause.resume();
	}
}

class TicksCounter	{
	init()	{
		new int istart;
	}
	start()	{	istart = engine.getticks();	}
	stop()	{	istart = engine.getticks() - istart;	}
	get()		{	return istart;	}
	int stopget()	{	this.stop();	return this.get();	}
	print(string s)	{	engine.print(s+" delay: "+this.stopget()+" ms");	}
	put()	{	.print("");	}
}

class ObjController	{
	init()	{
		new string _sme = this.getname();
		<GAME>.addgmobj(_sme);
	}
	removefromgame	{	<GAME>.removegmobj(_sme); }
}
class LObjController : ObjController, classlocker	{
	init()	{
		ObjController::init;
		classlocker::init;
	}
}

class gmbankvec : gmobjvec	{
	init	{
		gmobjvec::init;
		.var2("iid", -1);
	}
	startrand	{	if(.size>0) iid=.size->rand;	}
	play()	{
		this.stop(false);
		int ile = this.size();
		if( ile==0 ) return;
		iid = (iid+1)%ile;
		<this.get(iid)>.play();
	}
	onfinish()	{}
	stop(bool bfin)	{
		if( this.isplaying() )	{
			<this.getplay()>.stop(bfin);
			if( bfin ) this.onfinish();
		}
	}
	isplaying	{	( iid>=0 )	? <.getplay>.isplaying : false;	}
	getplay()	{	return this.get(iid);	}
}

class GameController : classlocker {
	init(string ssndbase)	{
		classlocker::init();
		new gmobjvec __grobj;
		
		new db _dbsnd;
		_dbsnd.setseparator("|");
		new string _sndbase = ssndbase;
		new string GAME = this;
		
		new timer __dblclick;
		__dblclick.delay(250);
		__dblclick.settick(1);
	}
	public game_exit()	{
		//this.stdexportsnd();
	}
	/*************************************************/
	public setsndbase(string sb)	{	_sndbase=sb;	}
	public say(string styp, string stxt)	{	this.sayf(styp,stxt,null);	}
	public sayf(string styp, string stxt, string sfun)	{
		string s = this.getsndtxt(stxt);
		<s>.setstartstopflag(false,true);
		this.cplayf(styp, s, sfun);
	}
	public string getsndtxt(string stxt)	{
		string ssnd = "snd" + _sndbase + _dbsnd.getrowsno();
		this.addsnd( ssnd, stxt );
		return ssnd;
	}
	_sndtimerstart()	{
		int id = _dbsnd.dbfindbycol(1,this.getname());
		if( id>=0 )	engine.print( _dbsnd.get( id,2) );
		else 		engine.print( this.getname() + " not in _dbsnd");
		engine.print("");
	}
	public addsndf(string ssnd, string stxt, string sfun)	{
		this.addsnd(ssnd,stxt);
		if( sfun!=null )	{
			if( ssnd.getb(0,1)==":" ) ssnd = ssnd.strsubb(1);
			<ssnd>.addmethod("onfinish", sfun );
		}
	}
	public asf(string ssnd, string stxt)	{	this.addsndff( "snd" + ssnd, stxt, "end" + ssnd);	}
	public addsndff(string ssnd, string stxt, string sfun)	{
		this.addsndf(ssnd,stxt,sfun);
		//<ssnd>.setstartstopflag(false,true);
	}
	gmconsnd(string ssnd, string swav)	{
		new snd <ssnd>;
		<ssnd>.setstartstopflag(false,true);
		<ssnd>.load( .getsndpath+swav );
	}
	public addsnd(string ssnd, string stxt)	{
		int id = _dbsnd.addrow()-1;
		string swav;
		if( ssnd.getb(0,1)==":" )	{
			ssnd = ssnd.strsubb(1);
			swav = _sndbase + "_" + ssnd + id + ".wav";
		} else swav = _sndbase + id + ".wav";
		string sg = gameapi.getgamename();
		if( engine.fileexist( this.getsndpath() + swav ) )	{
			<sg>.gmconsnd( ssnd, swav );
		} else {
			<sg>.newtimer( ssnd, stxt.length()*40, 1);
			<ssnd>.addmethod("onstart", "_sndtimerstart");
			<ssnd>.addmethod("setstartstopflag", func { (bool b1, bool b2) ; });
		}
		_dbsnd.add(id, swav);
		_dbsnd.add(id, ssnd);
		_dbsnd.add(id, stxt);
	}
	public addbank(string sbank, string sfunc)	{
		new gmbankvec <sbank>;
		string s = _;
		string s2;
		while( s!=A )	{
			s2 = this.getsndtxt(s);
			<sbank>.addbegin( s2 );
			if( sfunc!=null ) <s2>.addmethod("onfinish", sfunc );
			s = _;
		}
	}
	public exportbank(string sbase)	{
		new db <"__db"+sbase> (sbase)	{ (@sbase)
			.dbbuild(1);
			.setseparator("|");
			.dbeach_row( func { (@id)
				@s = this->strsubbs("__db");
				.addbegin(id, "snd"+s+id);
				.addbegin(id, s+id+".wav");
				} );
			if( igmdebug )
				.save("exports/"+sbase+".dlg");
		};
		delete <"__db"+sbase>;
	}
	public importbank(string sbank, string sbase, string sfun)	{
		new gmbankvec <sbank>;
		.importgroupto(sbase, sfun, null, sbank);
	}
	public exportsnd(string sfile)	{	if( igmdebug) _dbsnd.save(sfile);	}
	public stdexportsnd()	{	this.exportsnd( "exports/" + _sndbase + ".dlg" );	}
	public sounds=()	{	.buildsnds;	}
	public sounds_from(string sbase)	{
		new db __tmpdb;
		@stmpbase = _sndbase;
		.setsndbase(sbase);
		__tmpdb.load("exports/"+sbase+".dlg");
		_dbsnd.free;
		@s = _;
		int id, string sf;
		while( A!=s )	{
			@s1 = _;
			id = __tmpdb.dbfindbycol(1, s1);
			if( id>=0 )	{
				sf = .getsndpath + __tmpdb.get(id,0);
				if( engine.fileexist( sf ) )	{
					<GAME>.gmconsnd( s1, __tmpdb.get(id,0) );
					<s1>.addmethod("onfinish", s );
				} else	.addsndf( s1, __tmpdb.get(id,1), s );
			}
			@s = _;
		}
		_dbsnd.free;
		delete __tmpdb;
		.setsndbase(stmpbase);
	}
	public buildsnds()	{
		_dbsnd.free;
		new db __dbsnd;
		__dbsnd.dbbuild(3);
		.buildfromdb("__dbsnd");
		delete __dbsnd; 
	}
	public buildfromdb(string sdb)	{
		for( int i=0; i< <sdb>.getrowsno; i++)	{
			.addsndf( <sdb>.get(i,0), <sdb>.get(i,1), <sdb>.get(i,2) );
		}
		.stdexportsnd;
	}
	public importsnd(string sbase, string sfun)	{	this.importgroup(sbase, sfun, null );	}
	public importgroup(string sbase, string sfun, string sgr)	{	.importgroupto(sbase,sfun,sgr,null);	}
	public importgroupto(string sbase, string sfun, string sgr, string sgrto)	{
		new db __tmpdb;
		@stmpbase = _sndbase;
		.setsndbase(sbase);
		__tmpdb.load("exports/"+sbase+".dlg");
		_dbsnd.free();
		string s;
		for( int i=0; i<__tmpdb.getrowsno(); i++)	{
			s = __tmpdb.get(i,1);
			if( sgr==null || <sgr>.contains(s) )	{
				.addsndf( s, __tmpdb.get(i,2), sfun );
				if( sgrto!=null ) <sgrto>.add(s);
			}
		}
		_dbsnd.free();
		__tmpdb.free();
		delete __tmpdb;
		.setsndbase(stmpbase);
	}
	public freesnd()	{	_dbsnd.free();	}
	/*************************************************/
	public addgmobj(string s)		{	__grobj.add(s);		}
	public removegmobj(string s)	{	__grobj.remove(s);	}
	public isgmobj(string s)	{	__grobj.contains(s);	}
	public deletegmobj(string s)	{
		if( .hasvar(s) )	{
			.removegmobj(s);
			delete <s>;
		}
	}
	public lockall()		{
		__grobj.eval("lock");
		this.lock();	
	}
	public unlockall()		{
		__grobj.eval("unlock");
		this.unlock();
	}
	public gmunlockall	{	<GAME>.unlockall;	}
	public gmlockall	{	<GAME>.lockall;	}
	public lock=(bool b)	{	b ? .gmlockall : .gmunlockall; }
	mousemove()	{
		__grobj.eval("onmousemove");
		this.mouse_move();
	}
	mouselclick()	{
		__grobj.eval("onmouselclick");
		this.mouse_lclick();
		if( __dblclick.isplaying )	.mouse_dblclick;
		else __dblclick.play;
	}
	mouserclick()	{
		__grobj.eval("onmouserclick");
		this.mouse_rclick();
	}
	mouselrel()	{
		__grobj.eval("onmouselrel");
		this.mouse_lrel();
	}
	mouserrel()	{
		__grobj.eval("onmouserrel");
		this.mouse_rrel();
	}
	keydown()	{
		__grobj.eval("onkeydown");
		this.key_down();
	}
}

/* classadv : klasa do przygodowek	*/

class classadv : classgame {
	init()	{
		classgame::init();
	}
	/**************************************************************************/
	newclpathf(string spt, string san, string sfile, int x, int y, real rstep, int ityp)	{
		new classpathf <spt>;
		<spt>.build(san, this.getgraphpath() + sfile, x, y, rstep, ityp);
	}
	newclpathfcopy(string spt, string san, string sptf, real rstep)	{
		new classpathf <spt>;
		<spt>.buildfrom( san, sptf, rstep );
	}
	newpathf(string spathf, string sfile, int x, int y)	{
		new path <spathf>;
		<spathf>.build( this.getgraphpath() +sfile, x, y, 2.0, 1 );
	}
	/**************************************************************************/
	newclbut(string sbut, string sfile, int z, string smouse)	{
		new classbutton <sbut>;
		<sbut>.build( this.getgraphpath() + sfile, z, smouse );
	}
	newclmask(string sm, string sfile, string smouse)	{
		new classmask <sm>;
		<sm>.buildmask( this.getgraphpath() + sfile, smouse );
	}
	newclmaskfunc(string sm, string sfile, string smouse, string sfunc)	{
		new classmask <sm>;
		<sm>.buildmaskfunc( this.getgraphpath() + sfile, smouse, sfunc );
	}
}

class classquest	{
	init()	{
		new vector vqst;
		vqst.type("string");
	}
	int isdone(string sqst)	{	return vqst.contains(sqst);	}
	int notdone( string sqst )	{	return !vqst.contains(sqst);	}
	done(string sqst)	{	if( !vqst.contains(sqst) )	vqst.add(sqst);		}
	reset()	{	vqst.free();	}
	save(string sfile)	{	vqst.save( sfile );	}
	load(string sfile)	{	vqst.load( sfile );	}
}

new classquest clqs;

/***************************************************************************/

class classfullsave	{
	init(string sfile)	{
		new db dbsav;
		new string sstdfile;
		.setfile(sfile);
	}
	public save(string sfile)	{	dbsav.save(sfile);	}
	public load(string sfile)	{
		if( engine.fileexist(sfile) )	{
			dbsav.free;
			dbsav.load(sfile);
		}
	}
	public print()	{	dbsav.print();	}
	public setfile(string sf)	{	sstdfile = sf;	}
	public stdload()	{	this.load(sstdfile);	}
	public stdsave()	{	this.save(sstdfile); }
	public free()	{	dbsav.free();	}
	public set(string sname, string svar)	{
		int id = dbsav.findbyrow(sname);
		if( id>=0 )	{
			dbsav.set(id,1,svar);
		} else {
			id = dbsav.addrow()-1;
			dbsav.add( id, sname );
			dbsav.add( id, svar );
		}
		this.stdsave();
	}
	public bset(string sname)	{	this.set(sname,true);	}
	public string get(string sname)	{
		int id = dbsav.findbyrow(sname);
		return id>=0?dbsav.get(id,1):null;
	}
	public bool is(string sname, string svar)	{
		int i = dbsav.findbyrow(sname);
  		return i>=0?dbsav.get(i,1)==svar:false;
	}
	//public bool bis(string sname)	{	return this.is(sname,true);	}
	public bool bis(string sname)	{
		int i = dbsav.findbyrow(sname);
		return i>=0?dbsav.get(i,1)!=false:false;
	}
}



class StringChecker	{
	init()	{}
	/*bool isdigit(string s)	{	s.to_i == s;	}
	int getint(string s)	{	return s.to_i();	}
	real getreal(string s)	{	return s.to_r();	}	
	bool isreal(string s)	{	return this.isdigit(s)&&s.contains(".");	}
	bool isstring(string s) {	return s.getb(0,1)=="\"";	}
	string getstring(string s)	{	return s.strsubb(1);	}*/
	bool isdigit(string s)	{	return s.to_i()!=0||s.getb(0,1)=="0";	}
	int getint(string s)	{	return s.to_i();	}
	real getreal(string s)	{	return s.to_r();	}	
	bool isreal(string s)	{	return this.isdigit(s)&&s.contains(".");	}
	bool isstring(string s) {	return s.getb(0,1)=="\"";	}
	string getstring(string s)	{	return s.strsubb(1);	}
}

class Script	{
	init(string sfile)	{
		new db __dbcode;
		new string __sdb;
		new int __irow;
		new int __icol;
		new string __sreads;
		
		new vector __vec;
		__vec.type("string");
		
		new string __sarg;
		new int __iarg;
		new real __rarg;
		
		new StringChecker __csc;
		new map2 __mp("int");		// odnosniki do funkcji
		for( int i=0; i<10; i++)	new string <"ARG"+i>;
		
		this.load(sfile);
	}
	public ARG=(int id, string s)	{ <"ARG"+id> = s; }
	public ARG(int id)	{ ["ARG"+id]; }
	public load(string sfile)	{
		if( sfile==null )	return;
		if( sfile.contains(".") )	{		// znaczy sie plik jest
			__sdb = "__dbcode";
			__dbcode.loadbeh(sfile);
		} else {
			__sdb = sfile;		// odwolanie przez inna baze
		}
		__mp.free();
		for( int i=0; i < <__sdb>.getrowsno(); i++)	{
			if( <__sdb>.get(i,0)=="func" )
				__mp.add( <__sdb>.get(i,1), i );
		}
		this.call("init");
	}
	public def get(string svar)	{	return [svar];	}
	bool isvar(string s)	{	return s.contains("$");	}
	string getvar(string s)	{
		s = s.strsubb(1);
		if( !engine.varexist(s) )
			new def <s>;
		return s;
	}
	bool isfunc(string s)	{	return s.contains(".")&&!__csc.isreal(s);	}
	getfunc(string sfun)	{
		__vec.free();
		__vec.add( sfun.strgetto(".") );
		__vec.add( sfun.strgetfrom(".") );
	}
	string _get()	{
		__icol++;
		return <__sdb>.get(__irow,__icol-1);
	}
	bool isnext()	{
		if( __icol < <__sdb>.getcolsno(__irow) )	{
			__sreads=<__sdb>.get(__irow,__icol);
			return true;
		}
		return false;
	}
	perror(bool expr, string sout)	{
		if( expr )
			engine.print("error: " + sout);
	}
	interpcall(string scal)	{
		this.getfunc(scal);
		string sob = __vec.get(0);
		if( sob.getb(0,1)=="*" ) sob=[sob.strsubb(1)];
		string sfun = __vec.get(1);
		if( sfun.getb(0,1)=="*" ) sob=[sfun.strsubb(1)];
		__vec.free();
		__icol++;	// omin '('
		string s = this._get();
		while( s!=")" )	{
			this.getexpr(s);	// odloz na stos argumenty
			s = this._get();
		}
		if( sob=="this" ) sob=null;
		this.callfun(sob,sfun);
	}
	string getvname(string s)	{
		if( this.isvar(s) )	{
			s=this.getvar(s);
		} else if( __csc.isdigit(s) ) {
			__iarg = s;
			s = "__iarg";
		} else if( __csc.isstring(s) ) {
			__sarg = __csc.getstring(s);
			s = "__sarg";
		} else if(__csc.isreal(s))	{
			__rarg = s.to_r();
			s = "__rarg";
		}
		return s;
	}
	bool isscriptfun(string s)	{	return s.contains("->");	}
	string getscriptfun(string s)	{	return s.strsubb(2);	}
	getexpr(string sexpr)	{
		if( __csc.isstring(sexpr) )	{
			<this.getvname(sexpr)>.get();
		} else if( this.isfunc(sexpr) )	{
			this.interpcall(sexpr);
		} else if(this.isscriptfun(sexpr))	{
			int r = __irow;
			int c = __icol;
			this.call( this.getscriptfun(sexpr) );
			__irow = r;
			__icol = c;
		} else {
			<this.getvname(sexpr)>.get();
		}
	}
	bool cmp()	{
		bool bodp=false;
		def d0 = this.getexpr(this._get());
		string s2 = this._get();		// typ porownania
		def d1 = this.getexpr( this._get() );
		match(s2)	{
			"==" =>	{	bodp = d0 == d1;	}
			"!=" =>	{	bodp = d0 != d1;	}
			"<" =>	{	bodp = d0 < d1;	}
			">" =>	{	bodp = d0 > d1;	}
			"<=" =>	{	bodp = d0 <= d1;	}
			">=" =>	{	bodp = d0 >= d1;	}
			? => ;
		}
		s2 = this._get();
		if( s2=="||" )	return bodp || this.cmp();
		else if (s2=="&&")	return bodp && this.cmp();
		else return bodp;
	}
	public containsfun(string sfun)	{	__mp.contains(sfun);	}
	public call(string sfun)	{
		if( !__mp.contains(sfun) )	return;
		
		__irow = __mp.get( sfun );
		__irow++;
		__icol=0;
		
		bool bgo = true;
		bool bif = false, bool bifexp, bool bwhile=false;
		bool belif=false;
		int iwhilerow;
		string s[3], int i[3];
		while( bgo )	{
			__icol=0;
			s0 = this._get();
			match(s0)	{
				"new"=>{	s0 = this._get();
					s1 = this._get();
					s1 = s1.strsubb(1);	// pozbadz sie $
					if( this.isnext() )	{
						if( __sreads=="[" )	{
							__icol++;
							i0 = this._get();
							for(i1=0; i1<i0; i1++)	{
								new <s0> <s1+i1>;
							}
						} else {		// powinien byc "(" dla konstruktora
							__icol++;
							while( this.isnext() && __sreads!=")" )	this.getexpr( this._get() );
							new <s0> <s1>;
						}
					} else {
						new <s0> <s1>;
					}
					__irow++;
				}"delete" =>	{	delete <this.getvar(this._get())>;	__irow++;	}
				(s0=="if" || belif || bwhile)?s0:"" => {
	// 				belif ? this.perror(!bif,"else without if") : this.perror(bif,"if within if");
					__icol++;		// '('
					bifexp = this.cmp();
					if(s0=="if") bif=true;
					belif=false;
					bwhile = false;
					__irow++;
					if( !bifexp )	{
						i1=1;
						while(i1)	{
							s0 = <__sdb>.get(__irow,0);
							if( s0=="else"||s0=="elif"||s0=="fi"||s0=="done") i1=0;
							else	__irow++;
						}
					}
				}"else" => { 	this.perror(!bif,"else without if");
					__irow++;
					if( bifexp )	{
						while(<__sdb>.get(__irow,0)!="fi")
							__irow++;
					}
				} "fi" =>	{	this.perror(!bif,"fi without if");
					bif=false;
					bifexp = false;
					belif=false;
					__irow++;
				} "elif"=>	{
					if( bifexp )	{
						__irow++;
						while(<__sdb>.get(__irow,0)!="fi")
							__irow++;
					} else {
						belif = true;
					}
				} "end" =>	bgo=false;
				"while" =>	{
					iwhilerow = __irow;
					bwhile = true;
				}"done" =>	{
					if( bifexp )	{
						__irow = iwhilerow;
					} else {
						__irow++;
					}
				}"print" =>	{
					s0 = "";
					while( this.isnext() )
						s0 += this.getexpr( this._get() ); 
					engine.print( s0 );
					__irow++;
				}"return" => 	{
					if( this.isnext() )	{
						this.getexpr( __sreads );
					}
					return;
				} ? => { 
					if (s0.contains("$"))	{
						s0 = this.getvar( s0 );
						__icol++;		// olej <<
						<s0> = this.getexpr(this._get());
						while( this.isnext() )	{
							__icol++;		// omin znak dzialania
							def d2 = this.getexpr( this._get() );
							match(__sreads)	{
								"+"	=>	<s0> += d2;
								"-"	=> 	<s0> -= d2;
								"*"	=>	<s0> *= d2;
								"/"	=>	<s0> /= d2;
								"%"	=>	<s0> %= d2;
								?	=>	;
							}
						}
					} else
						this.getexpr( s0 );
					__irow++; 
				}
			}
			if( __irow >= <__sdb>.getrowsno() )	{
				this.perror(1,"function "+sfun+" not finished!");
				bgo=false;
			}
		}
	}
}

public transparent	{	return 0,0,0,0;	}
public red			{	return 255,0,0;	}
public green		{	return 0,255,0;	}
public blue			{	return 0,0,255;	}
public white		{	return 255,255,255; }
public black		{	return 0,0,0;		}
public grey(int c)	{	return c,c,c;		}
public yellow		{	return 255,255,0;	}

class Color	{
	init	{
		.vars(A,"r","g","b","a");
	}
	operator=(string scol)	{	this.set( <scol>.get() );	}
	img=(@simg)	{
		|r,g,b,a| = <simg>.getrgba( classansearcher::firstnotrx1y(simg) );
	}
	get			{	return r,g,b,a;	}
	set(int r2, int g2, int b2, int a2)	{	|r,g,b,a| = r2,g2,b2,a2;	}
	rgb=(int r2, int g2, int b2)	{	|r,g,b|=r2,g2,b2;	}
	rgb	{	return r,g,b;	}
	print	{	engine.print("Color::" + this + " (r,g,b,a) = ("+r+","+g+","+b+","+a+")");	}
}

/***************************************************************************/

class classasker : newvars	{
	init()	{
		newvars::init();
		new string sfuncyes = null;
		new string sfuncno = null;
		new string ssndask;
		new string ssndyes;
		new string ssndno;
		new classsound clsnd;
	}
	reset()	{	sfuncyes=null;	sfuncno=null;	}
	setfuncs(string syes, string sno)	{
		sfuncyes = syes;
		sfuncno = sno;
	}
	fxonmovon(string ssnd)	{	buts.sfxonmovon(ssnd);	}
	setmouse(string smouse)	{
		buts.newmouse("yes", smouse);
		buts.newmouse("no", smouse);
	}
	load(string sfile, int z)	{
		new classbutton buts;
		buts.build(sfile, z, null);
		buts.transclickfunc( engine.actclassname(), "butclick");
		buts.transmovonfunc( engine.actclassname() , "butmovon");
		buts.disableall();
	}
	ask( string sask, string syes, string sno, string sf1, string sf2 )	{
		this.setfuncs(sf1,sf2);
		this.ask2( sask, syes, sno );
	}
	ask2( string sask, string syes, string sno )	{
		ssndask=sask;
		ssndyes = syes;
		ssndno = sno;
		gameapi.pause();
		buts.benableall();
		buts.pause("bkg");
		clsnd.creset();
		clsnd.cbplay( sask );
		.<this+"_ask">;
	}
	/**********************************************/
	butmovon(string sc)	{
		/*if( ssndask!=null )	{
			if( <ssndask>.isplaying()==true )	{
				return;
			}
		}*/
		if( sc=="yes" )	{
			<ssndask>.stop(false);
			clsnd.cbplay( ssndyes );
		} else if (sc=="no")	{
			<ssndask>.stop(false);
			clsnd.cbplay( ssndno );
		}
	}
	butclick(string sc)	{
		if( sc=="bkg" )	return;
		gameapi.resume();
		buts.disableall();
		clsnd.cactsndstop(false);
		if( sc=="yes" && sfuncyes!=null)	{
			this.<sfuncyes>();
			.<this+"_yes">;
		} else if( sc=="no" && sfuncno!=null)	{
			this.<sfuncno>();
			.<this+"_no">;
		}
	}
	disabled	{	buts.disabled;	}
}

/***************************************************************************/
class classplacepointer	{
	init()	{
		new anima anpointer;
		anpointer.addmethod("onfinish", func { this.play(-1); } );
		new int _iz = 1000;
	}
	public load(string sfile)	{
		anpointer.load(sfile);
		this.setz(_iz);
		anpointer.hide();
	}
	public setz(int iz)	{
		_iz = iz;
		anpointer.setz(iz);
	}
	public stop()	{	anpointer.stop(false);	}
	public stoph()	{	anpointer.stop(false);	anpointer.hide();	}
	public show(int x, int y, string sdir)	{
		anpointer.setpos(x,y);
		anpointer.play(sdir);
	}
	move(@x, @y)	{	anpointer.move(x,y);	}
	public showob(string sob, string sdir)	{	this.show(<sob>.getcx(), <sob>.getcy(), sdir);	}
	public showpob(string sob, string sdir)	{	this.show(<sob>.getpx(), <sob>.getpy(), sdir);	}
}

class SimpleCounter	{
	init(int ilength)	{
		.var2("length", ilength );
		new int iid = 0;
	}
	int next()	{	iid = (iid+1)%length;		iid;	}
	set(int i)	{	iid=i;	}
	reset()	{	iid=0;	}
	get()	{	iid;	}
}

/******************************************/

module clstrdigit	{
	init()	{}
	public string getdigit(int idigit, int ilepozycji)	{
		string s = idigit;
		while( s.length() < ilepozycji )	s = "0" + s;
		return s;
	}
	public string gettime(int itime, string smod)	{
		return this.getstime( this.geth(itime), this.getm(itime), this.gets(itime), 
			smod.contains("h"), smod.contains("m"), smod.contains("s") );
	}
	public string getstime(int ih, int im, int is, bool bh, bool bm, bool bs)	{
		string s = "";
		if( bh ) s+= ih;
		if( bm ) s+= (bh?":":"") + this.getdigit(im,2);
		if( bs ) s+= ((bh||bm)?":":"") + this.getdigit(is,2);
		return s;
	}
	public int geth(int itime)	{	return itime/3600;	}
	public int getm(int itime)	{	return (itime/60)%60;	}
	public int gets(int itime)	{	return itime%60;	}
	public string getns(int itime, int n)	{	return this.getdigit( this.gets(itime),n );	}
	public string getnm(int itime, int n)	{	return this.getdigit( this.getm(itime),n );	}
	string getbinary(int ival)	{
		string s = "";
		while(ival>0)	{
			s = "" + (ival%2) + s;
			ival/=2;
		}
		return s;
	}
	string bintohex(string sval)	{
		string s;
		match(sval.length%4)	{
			3=>"0"; 2=> "00"; 1=> "000";
			? => "";
		}
		s = _;
		sval = s + sval;
		s = "";
		for( int i=0; i<sval.length; i+=4)	{
			match(sval.getb(i,4))	{
				"0000" => "0";	"0001" => "1";	"0010" => "2";	"0011" => "3";
				"0100" => "4";	"0101" => "5";	"0110" => "6";	"0111" => "7";
				"1000" => "8";	"1001" => "9";	"1010" => "A";	"1011" => "B";
				"1100" => "C";	"1101" => "D";	"1110" => "E";	"1111" => "F";
				? => ;
			}
			s += _;
		}
		s;
	}
}

public string getbinary			{	clstrdigit::getbinary(.get);		}
public string getdigit(int ile)		{	clstrdigit::getdigit(.get,ile);		}
public string getbindigit(int ile)	{	clstrdigit::getdigit( .getbinary,ile);	}

class Text	{
	init(string sfont, int ifontsize, int ifr, int ifg, int ifb, int x, int y, int z)	{
		if( sfont==null )	sfont = sgmfontfile;
		if( sfont.contains(".ttf") )	{
			new font _fnt;
			_fnt.load( sfont, ifontsize );
			sfont = "_fnt";
		}
		new int iR = ifr;
		new int iG = ifg;
		new int iB = ifb;
		new int iFontSize = ifontsize;
		new text txt;
		txt.setfont(sfont);
		txt.setz(z);
		txt.setpos(x,y);
		txt.show;
		
		new text txtbg;
		txtbg.hide();
	}
	public hide()	{	txt.hide;	}
	public show()	{	txt.show;	}
	public setpos(int x, int y)	{	txt.setpos(x,y);	}
	public set(string s)	{
		txt.set( s );
		txt.createtxt( iR, iG, iB );
	}
	public string get()	{	return txt.get;	}
	public setbg(int ir, int ig, int ib, int ia)	{
		txtbg.setbkg(txt.getpx()-iFontSize/2, txt.getpy()-iFontSize/2,
			txt.getw()+iFontSize, iFontSize*2, ir, ig, ib, ia );
		txtbg.setborders(1,255,255,255,128);
		txtbg.show();
	}
	operator=(string val)	{	this.set(val);	}
}

class Cypher : Text	{
	init(string sfont, int ifontsize, int ifr, int ifg, int ifb, int x, int y, int z)	{
		Text::init(sfont, ifontsize, ifr, ifg, ifb, x, y, z );
		this.set(0);
	}
	add(int dt)	{	this.set( dt + this.get );	}
	iget()		{	this.get->to_i;		}
	operator+(int val)	{	this.add(val);	}
	operator++()	{	this.add(1);	}
	operator--()	{	this.add(-1);	}
	operator-(int val)	{	this.add(-val);	}
	operator=(int val)	{	this.set(val);	}
	operator==(int val)	{	.get==val;	}
	operator!=(int val)	{	.get!=val;	}
	operator>(int val)	{	.get>val;	}
	operator<(int val)	{	.get<val;	}
}

class SecCounter	{
	init(string sdigits)	{
		new string sdigit = sdigits;
		new int itime;
		this.reset();
		this.cnewtimerfin("timcyk",1000,1, func { .update(1); .play; } );
	}
	public play()	{	timcyk.play();	}
	public stop()	{	timcyk.stop(false);	}
	public string sgettime()	{	return clstrdigit.gettime(itime, sdigit);	}
	public int gettime()	{	return itime;	}
	public reset()	{	this.update(-itime);	}
	public update(int isec)	{	itime+=isec;	}
}

class TextTimeCounter : Text, SecCounter	{
	init(string sfont, int ifontsize, int ifr, int ifg, int ifb, int x, int y, int z, string sdigits)	{
		Text::init(sfont, ifontsize, ifr, ifg, ifb, x, y, z);
		SecCounter::init(sdigits);
		.reset;
	}
	public update(int isec)	{
		SecCounter::update(isec);
		this.set( this.sgettime() );
	}
}

class gfxObject	{
	init(string sob)	{	new string sgfxobj = sob; }
	setpos		{	<sgfxobj>.setpos;	}
	move		{	<sgfxobj>.move;	}
	getpos		{	<sgfxobj>.getpos;	}
	getposx		{	<sgfxobj>.getposx;	}
	getposy		{	<sgfxobj>.getposy;	}
	getpx		{	<sgfxobj>.getpx;	}
	getpy		{	<sgfxobj>.getpy;	}
	getw			{	<sgfxobj>.getw;	}
	geth			{	<sgfxobj>.geth;	}
	getcx		{	<sgfxobj>.getcx;	}
	getcy		{	<sgfxobj>.getcy;	}
	getex		{	<sgfxobj>.getex;	}
	getey		{	<sgfxobj>.getey;	}
	lodx			{	<sgfxobj>.lodx;	}
	lody			{	<sgfxobj>.lody;	}
	setz			{	<sgfxobj>.setz;		}
	getz			{	<sgfxobj>.getz;	}
	show		{	<sgfxobj>.show;	}
	hide			{	<sgfxobj>.hide;	}
	isvisible		{	<sgfxobj>.isvisible;	}
	bool isin		{	<sgfxobj>.isin;		}
}

class gfxSquare : Color, gfxObject	{
	init(int x1, int y1, int w1, int h1)	{
		Color::init;
		.vars(A, "w", "h");
		w=w1; h=h1;
		new img imggfx;
		imggfx.setpos(x1,y1);
		gfxObject::init("imggfx");
	}
	build	{	imggfx.create(w,h,r,g,b,a);	}
	shadow(int dx, int dy, int alpha)	{
		|@x,@y| = imggfx.getpos;
		imggfx.setpos(0,0);
		new img _img1;
		new img _img2;
		if( imggfx.getw>0 )	{
			_img1.create(w,h,.transparent);
			_img1.blit("imggfx");
		} else _img1.create(w,h,.get);
		_img2.create(w,h,.black,alpha);
		if( dx<0 )	{
			_img1.move(-dx, 0);
			x+=dx;
		} else	_img2.move( dx, 0 );
		if( dy<0 )	{
			_img1.move(0,-dy);
			y+=dy;
		} else	_img2.move( 0, dy );
		w += dx.abs;
		h += dy.abs;
		imggfx.create(w, h, .transparent);
		imggfx.blit("_img2");
		imggfx.blit("_img1");
		delete _img1;
		delete _img2;
		imggfx.move(x,y);
	}
	blackborder(int width, int a2)	{	.border(width,width, .black,a2);	}
	border(int width, int height, int r2, int g2, int b2, int a2)	{
		|@x,@y| = imggfx.getpos;
		imggfx.setpos(0,0);
		new img _img;
		if( imggfx.getw>0 )	{
			_img.create(w,h,.transparent);
			_img.blit("imggfx");
		} else _img.create(w,h,.get);
		_img.move(width,height);
		w += 2*width;
		h += 2*width;
		imggfx.create(w,h,r2,g2,b2,a2);
		imggfx.blit("_img");
		delete _img;
		imggfx.move(x,y);
	}
}

class Rect	{
	init(int _x, int _y, int _w, int _h)	{
		.vars(A, "x", "y", "w", "h");
		.set(_x, _y, _w, _h);
	}
	x2	{	x+w;	}
	y2	{	y+h;	}
	set(int _x, int _y, int _w, int _h)	{ x=_x; y=_y; w=_w; h=_h; }
	fit(string simg)	{
		if( <simg>.gettype=="gmimgvec") {
			@dx = x-<simg>._getpx;
			if( dx>0 ) <simg>.move(dx,0);
			@dy = y-<simg>._getpy;
			if( dy>0 ) <simg>.move(0,dy);
		} else {
			@dx = x-<simg>.getpx;
			if( dx>0 ) <simg>.move(dx,0);
			@dy = y-<simg>.getpy;
			if( dy>0 ) <simg>.move(0,dy);
		}
		dx = .x2-<simg>.getex;
		if( dx<0 ) <simg>.move(dx,0);
		dy = .y2-<simg>.getey;
		if( dy<0 ) <simg>.move(0,dy);
	}
	fitrand(string simg)	{	<simg>.ansetbpos( x+(w-<simg>.getw)->rand, y+(h-<simg>.geth)->rand);	}
	fitgrouprand(string sgr)	{	for( int i=0; i< <sgr>.size; i++) .fitrand( <sgr>.get(i) );	}
	fitgroup(string sgr)	{	for( int i=0; i< <sgr>.size; i++) .fit( <sgr>.get(i) );	}
}
/***************************************************************************/

class classfadeinout		{
	init()	{
		new timer timf;
		new string _sob;
		new int _istep;
		new int _ival;
		new int _ib1;
		new int _ib2;
		new string _sfun;
		new string _sfunfin;
		new string _sobfin;
		timf.addmethod("onfinish", "_ctimffin");
	}
	/***************\/\/\/\/\/ wewnetrzne \/\/\/\/\/\/************************************/
	_cfinito(int v)	{
		<_sob>.<_sfun>( v );
		if( _sfunfin!=null)	{
			if( _sobfin==null )
				this.<_sfunfin>();
			else <_sobfin>.<_sfunfin>;
		}
	}
	_ctimffin()	{
		_ival+=_istep;
		if( _ival >= _ib2 )	{
			this._cfinito( _ib2 );
		} else if( _ival<=_ib1 )	{
			this._cfinito( _ib1 );
		} else {
			<_sob>.<_sfun>( _ival );
			this.play();
		}
	}
	_play( int icycle, int istep, string sob, string sfun, int ib1, int ib2, string sob2, string sfun2 )	{
		_sobfin = sob2;
		_sfunfin = sfun2;
		_ib1 = ib1;
		_ib2 = ib2;
		int i = istep.abs();
		if( icycle <= 0 || i==ib1 || i>ib2 )	return;
		_sfun = sfun;
		timf.setcycle( icycle );
		_sob = sob;
		if( istep>0 )	_ival = _ib1;
		else if( istep<0 )	_ival=_ib2;
		else return;
		<sob>.<sfun>( _ival );
		_istep = istep;
		timf.play();
	}
	/******************* /\/\/\/\/\/\/\ wewnetrzne /\/\/\/\ ****************************/
	imgtransparency(int icycle, int istep, string simg, string sfun)	{
		this._play( icycle, istep, simg, "transparency", 0, 255, null, sfun );
	}
	setopacity(int icycle, int istep, string simg, string sfun)	{
		this._play( icycle, istep, simg, "setopacity", 0, 255, null, sfun );
	}
	sndvolume(int icycle, int istep, string ssnd, string sfun)	{
		this._play( icycle, istep, ssnd, "setvol", 0, 100, null, sfun );
	}
	/***************************************************/
	isplaying	{	timf.isplaying;	}
}

class CutScene : gfxObject	{
	init(int x1, int y1, int x2, int y2)	{
		new int X1;	new int Y1;
		new int X2;	new int Y2;
		new img _gsq;
		.build(x1, y1, x2, y2);
		gfxObject::init("_gsq");
		new string _sfunc1;
		new string _sob1;
		new string _sfunc2;
		new string _sob2;
		new int _idelay = 10;
		new classfadeinout _clfio;
	}
	build(int x1, int y1, int x2, int y2)	{
		|X1, Y1, X2, Y2| = x1, y1, x2, y2;
		_gsq.create(X2-X1,Y2-Y1,.black,255);
		_gsq.setpos(X1,Y1);
		_gsq.hide;
		_gsq.transparency(0);
	}
	delay(int n)	{	_idelay=n;	}
	transparency(int n)	{	_gsq.transparency(n);	}
	playfin(string sfunc1, string sfunc2)	{	.playobfin(null,sfunc1, null, sfunc2);	}
	playobfin(string sob1, string sfunc1, string sob2, string sfunc2)	{
		_sob1 = (sob1==null) ? gameapi.getgamename : sob1;
		_sfunc1 = sfunc1;
		_sob2 = (sob2==null) ? gameapi.getgamename : sob2;
		_sfunc2 = sfunc2;
		_gsq.show;
		_gsq.transparency(0);
		_clfio._play( 1, _idelay, this, "transparency", 0, 255, this, func {
			.callfun(_sob1, _sfunc1);
			_gsq.show;
			_clfio._play( 1, -_idelay, this, "transparency", 0, 255, this, "_callfun2" );
			} );
	}
	close(string sfunc1)	{	.obclose(gameapi.getgamename, sfunc1);	}
	obclose(string sob, string sfunc1)	{
		_sob1 = sob;
		_sfunc1 = sfunc1;
		_gsq.transparency(0);
		_gsq.show;
		_clfio._play( 1, _idelay, this, "transparency", 0, 255, this, func {
			_gsq.hide;
			.callfun(_sob1, _sfunc1);
			} );
	}
	enter(string sfunc2)	{	.obenter(gameapi.getgamename, sfunc2);	}
	obenter(string sob, string sfunc2)	{
		_sob2 = sob;
		_sfunc2 = sfunc2;
		_gsq.transparency(255);
		_gsq.show;
		_clfio._play( 1, -_idelay, this, "transparency", 0, 255, this, "_callfun2" );
	}
	_callfun2	{
		_gsq.hide;
		.callfun(_sob2, _sfunc2);
	}
	isplaying	{	_clfio.isplaying;	}
}


public string allchars	{	"a0 t_!@#$%^&*()_+-=[]\\|}{;':\",./<>?`~"; }

class TextTyper : classlocker, gfxObject {
	init(string sfont, int isize, int ir, int ig, int ib, string schars, int ilimit)	{
		classlocker::init();
		sfont = .checkfont(sfont, isize);
		new int iR = ir;
		new int iG = ig;
		new int iB = ib;
		new string sChars = schars;
		new int iLimit = ilimit;		// 0 - unlimited
		
		.vars2(A,"Sdir","left", "W", 0, "iFontSize", isize, "X", 0, "Y", 0);
		
		new text txt1;
		txt1.setfont(sfont);
		txt1.set("");
		new text txt2;
		txt2.setfont(sfont);
		txt2.set("_");
		txt2.createtxt(iR,iG,iB);
		txt2.hide();
		
		new text txtpass;
		txtpass.setfont(sfont);
		txtpass.hide;
		new bool bpass = false;
		
		new string _sob=null;
		new string _sfun=null;
		
		this.cnewtimerfin("timcyk",300,1,"fintimcyk");
		
		gfxObject::init("txt1");
	}
	setaspasswd	{
		bpass = true;
		txt1.hide;
		txtpass.setz( txt1.getz );
		txtpass.show;
		.copytopass;
	}
	copytopass	{
		@id = txt1.get->length;
		string s = "";
		for( int i=0; i<id; i++)	s += "*";
		txtpass.txtset(s);
		txtpass.setpos( txt1.getpx, txt1.getpy );
	}
	setastext	{
		bpass = false;
		txt1.show;
		txtpass.hide;
	}
	public isin(int x, int y, bool bv, bool ba)	{	txt1.isin(x,y,bv,ba);	}
	getcol	{	return iR,iG,iB;	}
	fintimcyk()	{
		if( this.getlock() )	return;
		this.updatecyk();
		this.play();
	}
	updatecyk()	{
		if( txt2.isvisible() )	{
			txt2.hide();
		} else {
			txt2.setpos( txt1.getex(), txt1.getpy() );
			txt2.show();
		}
	}
	public enable()	{
		this.unlock();
		this.updatecyk();
		timcyk.play();
	}
	public disable()	{
		txt2.hide();
		timcyk.stop(false);
		this.lock();
	}
	public onenter(string sob, string sfun)	{	_sob=sob;	_sfun=sfun;	}
	public setpos(int x, int y)	{
		X = x;
		Y = y;
		//txt1.setpos(x,y);
		.updatetxt(.get);
	}
	public move(int x, int y)	{	.setpos(X+x, Y+y); }
	public setz(int z)	{	txt1.setz(z);txt2.setz(z);	}
	public get()	{
		string s = txt1.get();
		( s.length()>0 ) ? s : "";
	}
	getpx	{	txt1.getpx;	}
	getpy	{	txt1.getpy;	}
	getcx	{	txt1.getcx;	}
	getcy	{	txt1.getcy;	}
	geth	{	txt1.geth;	}
	getey	{	txt1.getpy + iFontSize;	}
	clip(int x1, int y1, int x2, int y2)	{
		txt1.clip(x1,y1,x2,y2);
		txt2.clip(x1,y1,x2,y2);
	}
	public length	{	txt1.get->length;	}
	public set(string s)	{	txt1.set(s);	}
	public txtset(string s)	{	txt1.txtsetcol(s,.getcol);	}
	public limit=(int il)	{	iLimit=il;	}
	public onkeydown()	{
		if( this.getlock() )	return;
		.<this+"_ontype">;
		if( keyboard.iskeydown("enter") )	{
			this.disable();
			this.callfun(_sob,_sfun);
			.<this+"_onenter">;
			return;
		}
		string s;
		if( sChars.contains("t") && keyboard.iskey("tab") )	s = " ";
		else s = keyboard.getkey();
		string s2 = txt1.get();
		if( ( (keyboard.isalpha && sChars.contains("a") ) || ( keyboard.isdigit && sChars.contains("0") )
			|| sChars.contains(s) ) && (iLimit<=0 || iLimit>s2.length)  )	{
			//txt1.set( s2+s );
			//txt1.createtxt(iR,iG,iB);
			.updatetxt(s2+s);
			this.updatecyk();
		} else if (keyboard.iskey("backspace") && s2.length()>0)	{
			//txt1.set( s2.strsube(1) );
			//txt1.createtxt(iR,iG,iB);
			.updatetxt( s2.strsube(1) );
			this.updatecyk();
		}
	}
	updatetxt(string s)	{
		txt1.set(s);
		txt1.createtxt(iR, iG, iB);
		if( Sdir == "center" )	txt1.setpos( X+(W-txt1.getw)/2, Y );
		else if (Sdir=="right")	txt1.setpos( X+W-txt1.getw, Y );
		else txt1.setpos(X, Y);
		if( bpass )	.copytopass;
		.<this+"_onwrite">;
	}
}

class ConTextTyper : TextTyper, ObjController	{
	init()	{
		TextTyper::init();
		ObjController::init();
	}
}

new string sTextBoxTyperSys = null;
class TextBoxTyper : LObjController, ImagePos	{
	init(string sfont, int ish, int isw, int ir, int ig, int ib, string schars, int x, int y, int w, int h, int dy)	{
		LObjController::init;
		ImagePos::init;
		new @Font = .checkfont(sfont, ish);
		.vars2(A,"Cols", w/isw, "Rows", h/(ish+dy), "X", x, "Y", y, "Row", 0, "enablemove", true, "W", w,
			"insystem", false, "H", h, "isvisible", 1, "clipx1", x, "clipy1", y, "clipx2", 0, "clipy2", 0, "clipped", false );
		new @Size = ish;
		new @Dy = dy;
		new @Z = 0;
		string s;
		new gmimgvec grtt;
		new gmimgvec gren;
		for( int i=0; i<Rows; i++)	{
			s = "tt"+i;
			new TextTyper <s>(Font,ish,ir,ig,ib,schars,Cols);
			<s>.W = (w);
			<s>.Sdir = ("left");
			<s>.setpos( x, y+i*(ish+dy) );
			grtt.add(s);
		}
	}
	settyper(int id, string sfont, int ish, int isw, int ir, int ig, int ib, string schars, string sdir)	{
		int x;
		int y;
		string s;
		string stext = "";
		if( id<0 ) {
			x = <grtt.last>.X;
			y  = <grtt.last>.getey+Dy;
			id = grtt.size;
			grtt.add("tt"+id);
		} else {
			s = grtt.get(id);
			x = <s>.X;
			y = <s>.getpy;
			stext = <s>.get;
			grtt.movefrom( s, 0, ish - <s>.iFontSize );
			delete <s>;
		}
		s = "tt" + id;
		new TextTyper <s>(sfont,ish,ir,ig,ib,schars,W/isw);
		<s>.W = (W);
		<s>.Sdir = (sdir);
		<s>.updatetxt(stext);
		<s>.setz(Z);
		<s>.setpos( x, y );
	}
	move(int x, int y)	{	grtt.move(x,y); gren.move(x,y); X+=x; Y+=y;	}
	size	{	grtt.size;	}
	setz(int z)	{	Z = z; grtt.setz(z);	gren.setz(z); }
	getz	{	Z;	}
	show	{	isvisible=1; grtt.show;	}
	hide		{	isvisible=0;	grtt.hide;		}
	clip(int x1, int y1, int x2, int y2)	{
		clipped = true;
		clipx1=x1;	clipy1=y1;	clipx2=x2;	clipy2=y2;
		for( int i=0; i<grtt.size; i++) <grtt.get(i)>.clip(x1,y1,x2,y2);
	}
	getw	{	W;	}
	geth	{	H;	}
	enumerate(int dx)	{
		string s[2];
		for( int i=0; i<grtt.size; i++)	{
			s0 = "txte"+i;
			new text <s0>;
			gren.add(s0);
			<s0>.setz(Z);
			<s0>.setfont(Font);
			<s0>.txtsetcol(""+(i+1)+".", tt0.getcol);
			<s0>.setpos(X-<s0>.getw-dx,Y+i*(Size+Dy));
		}
	}
	cut(int id)	{	Rows=id;	}
	enable	{	.unlock;	.activateact;	}
	disable	{	.lock; grtt.eval("disable");	}
	actual	{	"tt"+Row;	}
	activate(int id)	{
		.unlock;
		if( id>=0 && id<Rows )	{
			if( insystem )	{
				if( <GAME>.isgmobj(sTextBoxTyperSys) && sTextBoxTyperSys!=this )	<sTextBoxTyperSys>.deactivate;
				sTextBoxTyperSys = this;
			}
			.deactivate;
			Row = id;
			<"tt"+ Row>.enable;
			.<this+"_activate">;
		}
	}
	activateact	{	.activate(Row);	}
	deactivate	{	<"tt"+Row>.disable;	}
	onkeydown	{
		if(.getlock)	return;
		.<this+"_boxontype">;
		if( keyboard.iskeydown("enter") )		{
			@s = .getid(Rows-1);
			s.clear;
			if( s.length==0 && enablemove )	{
				for( @i=Rows-1; i>Row+1; i--)	.setid( .getid(i-1), i);
				if( Row+1<Rows) .setid("", Row+1);
			}
			.activate(Row+1);
		} else if (keyboard.iskey("up") && Row>0) .activate(Row-1);
		else if (keyboard.iskey("down") && Row<Rows-1) .activate(Row+1);
		else if (keyboard.iskey("pgdown"))	{
			if(Row<Rows-10) .activate(Row+10);
			else .activate(Rows-1);
		} else if (keyboard.iskey("pgup"))	{
			if(Row>9) .activate(Row-10);
			else .activate(0);
		} else if ((keyboard.iskey("backspace") || keyboard.iskey("delete")) && <.actual>.length==0 ) {
			if( enablemove )	{
				for( @i=Row; i<Rows-1; i++)	.setid( .getid(i+1), i);
				.setid("",Rows-1);
			}
			if( keyboard.iskey("backspace") )
				.activate(Row-1);
		} else grtt.eval("onkeydown");
	}
	onmouselclick	{
		if(.getlock)	return;
		|int x, int y| = mouse.getpos;
		//if(  )	{
		if( (clipped && clsurf.isin(x,y,clipx1,clipy1,clipx2,clipy2)) || (!clipped && clsurf.isin2(x,y,X,Y,W,H)) )	{
			.deactivate;
			//.activate( ((y-Y)*Rows)/H );
			for( int i=0; i<.size; i++)	{
				if( <"tt"+i>.getey > y ) {
					.activate(i);
					return;
				}
			}
		} else {
			.<this+"_OUTSIDE">;
		}
	}
	int isin(int x, int y, bool bv, bool ba)	{
		if( bv && !isvisible ) return 0;
		clsurf.isin2(x,y,X,Y,W,H);
	}
	string getid(int id)	{	<"tt"+id>.get;	}
	string getact		{	<"tt"+Row>.get;	}
	int idpx(int id)	{	<"tt"+id>.getpx;	}
	int idpy(int id)	{	<"tt"+id>.getpy;	}
	//int getpy	{	.idpy(0);	}
	//int getpx	{	.idpx(0);	}
	int getpx	{	X;	}
	int getpy	{	Y;	}
	string get	{	.getfrom(0);	}
	string getfrom(int id)	{	.getlinesfrom(id,"");	}
	string getlinesfrom(int id, string send)	{
		string s = "";
		for( int i=id; i<grtt.size; i++) s += <"tt"+i>.get + send;
		s;
	}
	string getlines	{	.getlinesfrom(0," ");	}
	int nonempty(int id)	{
		string s;
		for( ; id<grtt.size; id++)	{
			s = <"tt"+id>.get;
			s.clear;
			if( s.length > 0 ) return id;
		}
		-1;
	}
	clear	{	grtt.txtreset;	}
	setid(string s, int id)	{	if( grtt.size>=id )	<"tt"+id>.txtset(s);	}
	settext(int ile)	{
		while(ile>0)	{
			ile--;
			.setid(_,ile);
		}
	}
	copytodb(string sdb)	{
		<sdb>.free;
		for( int i=0;i<grtt.size; i++)	{
			<sdb>.add( <sdb>.addrow-1, <grtt.get(i)>.get);
		}
	}
	copyfromdb(string sdb)	{	.copyfromdbii(sdb, 0, <sdb>.getrowsno);	}
	copyfromdbss(string sdb, string s1, string s2)	{	.copyfromdbii(sdb, <sdb>.findbyrow(s1)+1, <sdb>.findbyrow(s2) );	}
	copyfromdbii(string sdb, int row1, int row2)	{
		if( row1==-1 || row2==-1 ) return;
		.clear;
		if( row2-row1 > .size ) row2 = row1+.size;
		for( int i=row1; i<row2; i++)	{
			if( <sdb>.getcolsno(i) )
				.setid( <sdb>.get(i,0), i-row1 );
		}
	}
	copyfromdbrow(string sdb, int row, int startcol)	{
		int size = <sdb>.getcolsno(row);
		if( size>.size ) size = .size;
		for( int i=startcol; i<size; i++)
			.setid( <sdb>.get(row,i), i-startcol );
	}
	save(string sfile)	{
		new db __tmpdb;
		.copytodb("__tmpdb");
		__tmpdb.setseparator("|");
		__tmpdb.save(sfile);
		delete __tmpdb;
	}
	load(string sfile)	{
		new db __tmpdb;
		__tmpdb.load(sfile);
		.copyfromdb("__tmpdb");
		delete __tmpdb;
	}
	/*H	{
		if( grtt.size )	<grtt.last>.getey-<grtt.first>.getpy;
		else 0;
	}*/
}

class GUITextBoxTyper : TextBoxTyper	{
	init(string sfont, int ish, int isw, int ir, int ig, int ib, string schars, int x, int y, int w, int h, int dy)	{
		TextBoxTyper::init(sfont,ish,isw,ir,ig,ib,schars,x,y,w,h,dy);
		.vars2(A,"rewinder", null, "rewinderbg", null);
	}
	setrewinder(string s)	{
		rewinder = s;
		rewinderbg = s + "bg";
	}
	activate(int id)	{
		TextBoxTyper::activate(id);
		.updaterewactual;
	}
	updaterewactual	{	.updaterewpos(Row);	}
	updaterewpos(int id)	{
		if( rewinder!=null )	{
			@s = "tt"+id;
			if( <s>.getpy < <rewinderbg>.getpy )		<rewinder>.rewind( 0, <rewinderbg>.getpy - <s>.getpy );
			else if (<s>.getey > <rewinderbg>.getey)		<rewinder>.rewind( 0, <rewinderbg>.getey - <s>.getey );
		}
	}
}

/****************************************************************/
class DelayTaker	{
	init()	{
		new bool bonrel = false;
		new bool bstart = false;
		new bool bclickrel = true;
		this.cnewtimerfin("timwez",300,1, func { bonrel=true; } );
	}
	public setclickrel(bool b)	{	bclickrel=b;	}
	public setdelay(int idelay)	{	timwez.delay(idelay);	}
	public take()	{
		if( bclickrel )	{
			timwez.play();
			bonrel=false;
		} else bonrel=true;
		bstart=true;
		
	}
	public ret()	{
		bonrel=false;
		bstart=false;
		timwez.stop(false);
	}
	public bool isonclick()	{
		this.stoptimer();
		( bstart && !bonrel );
	}
	public bool isonrel()	{
		this.stoptimer();
		( bstart && bonrel );
	}
	public bool istaken()	{	bstart;	}
	public stoptimer()	{	timwez.stop(false);	}
}


class ImgMover	{
	init()	{
		new string smoved=null;
		new int ilastx;
		new int ilasty;
		new int irelx;
		new int irely;
	}
	public mssetobj(string s)	{	this.setobj(s,mouse.getpos);	}
	public setobj(string s, int x, int y)	{	this.set(s,x,y,0,0);	}
	public setcobj(string s)	{	.setobj(s, <s>.getcx, <s>.getcy);	}
	public setpobj(string s)	{	.setobj(s, <s>.getpx, <s>.getpy);	}
	public set(string s, int x, int y, int dx, int dy)	{
		ilastx = <s>.getposx()-dx;
		ilasty = <s>.getposy()-dy;
		irelx = x-<s>.getpx();
		irely = y-<s>.getpy();
		smoved = s;
	}
	public msmove()	{	this.move(mouse.getpos);	}
	public msftmove()	{	this.ftmove(mouse.getpos);	}
	public move(int x, int y)	{
		if( smoved!=null )	<smoved>.setpos( x-<smoved>.lodx()-irelx, y-<smoved>.lody()-irely );
	}
	public ftmove( int x, int y)	{	if( smoved!=null )	<smoved>.setpos( x, y );	}
	public retobj()	{	this.ret(0,0);	}
	public ret(int dx, int dy)	{
		<smoved>.setpos(ilastx+dx, ilasty+dy);
		this.free();
	}
	public put(int x, int y)	{
		<smoved>.setpos(x,y);
		this.free();
	}
	public free()	{	smoved=null;	}
	public string getmover()	{	return smoved;	}
	public string getfree	{	@s = smoved; .free; s; }
	public bool moving()	{	return smoved!=null;	}
}

class ConImgMover : ImgMover, ObjController	{
	init()	{
		ImgMover::init();
		ObjController::init();
	}
	onmousemove()	{	this.msmove();	}
	onmouselclick	{	.<_sme+"_GET">;	}
	onmouselrel	{	if( smoved!=null ) .<_sme+"_PUT">;	}
}

class DelayMover : ImgMover, LObjController	{
	init()	{
		ImgMover::init();
		LObjController::init();
		new DelayTaker cldt; 
	}
	public setclickrel(bool b)	{	cldt.setclickrel(b);	}
	public reset	{	cldt.ret;	}
	_put()	{
		cldt.ret();
		this.<_sme+"_PUT">();
	}
	set(string s, int x, int y, int dx, int dy)	{
		ImgMover::set(s,x,y,dx,dy);
		cldt.take;
	}
	onmousemove()	{	this.msmove();	}
	onmouselclick()	{
		if( this.getlock() ) return;
		if( cldt.isonclick() )	this._put();
		else if (!cldt.istaken())
			this.<_sme+"_GET">();
	}
	onmouselrel()	{
		if( this.getlock() ) return;
		if( cldt.isonrel() )
			this._put();
	}
}

class Rewinder : classlocker	{
	init()	{
		classlocker::init();
		new string sarrowdir;
		new int ilenx;
		new int ileny;
		new string sgr;
		new string sorientation;
		new bool bvertical;
		new bool bfilteritem = false;
		
		// clip obiektow
		new int ibx1=0;
		new int ibx2=800;
		new int iby1=0;
		new int iby2=600;
		
		new int iodleg = 2;	// odleglosc pomiedzy przedmiotami
		
		new ImgMover clmv;
		
		this.cnewtimercyclefin("timtick", 1, 1, "timfin");
		
		new snd fxrew;
// 		fxrew.addmethod("onfinish", func { this.play(); } );
	}
	public movefilter()		{	bfilteritem=true;	}
	public movenormal()	{	bfilteritem=false;	}
	public setfxrew(string sfile)	{
		fxrew.load(this.getsndpath()+sfile);
	}
	public getitem(string s, int x, int y)	{
		/*clmv.set(s,x,y,<sgr>.getpx(),<sgr>.getpy());
		<s>.clip(0,0,800,600);
		<sgr>.movefrom(s, 0, -<s>.geth);
		<sgr>.remove(s);*/
		<s>.setz( <s>.getz+1 );
		clmv.set(s,x,y,<sgr>.getpx(),<sgr>.getpy());
		<s>.clip(0,0,800,600);
		if( sorientation=="up" || sorientation=="down")	{
			<sgr>.movefrom(s, -(<s>.getw+iodleg), 0 );
			<s>.move( <s>.getw,0 );
		} else {
			<sgr>.movefrom(s, 0, -(<s>.geth+iodleg));
			<s>.move(0, <s>.geth );
		}
		<sgr>.remove(s);
	}
	public bool pickup(int x, int y)	{
		if( <sgr>.isin(x,y,true,true) )	{
			this.getitem( <sgr>.getsfound(), x, y );
			return true;
		}
		return false;
	}
	public bool mspickup()	{	return this.pickup(mouse.getpos );	}
	public freeitem()	{	clmv.free();	}
	public moveitem()	{
		if( bfilteritem )		clmv.msftmove();
		else		clmv.msmove();
	}
	public retitem()	{
		string s = clmv.getmover();
		clmv.ret(<sgr>.getpx(),<sgr>.getpy());
		this.putitem(s);
	}
	public putitem(string s)	{
		if( sorientation=="up" || sorientation=="down")	{
			<s>.move( <sgr>.getex-<s>.getpx+iodleg, 0);
		} else {
// 			@dx = anupstd.getex - <s>.getw;
// 			<s>.setpos( dx - <s>.lodx, <sgr>.getey-<s>.lody);
			<s>.move( 0, <sgr>.getey-<s>.getpy+iodleg);
		}
		<sgr>.add(s);
		<s>.setz( <s>.getz-1 );
		<s>.clip(ibx1,iby1,ibx2,iby2);
	}
	public string getmoved()	{	return clmv.getmover();	}
	public int getbutw()	{	return anupstd.getw();	}
	public int getbuth()	{	return anupstd.geth();	}
	public movearrows(int x, int y)	{	grarrows.move(x,y);	}
	public build(string sfile, int z, string scursor, string sorient, int dt, string sgrelem)	{
		sgr = sgrelem;
// 		this.newanima("anupstd",sfile,z);
		new anima anupstd;
		anupstd.load(sfile);
		anupstd.setz(z);
		
		anupstd.setframe("up",0);
		this.copyanima("anupstd","anupact");
		anupact.setframe("up",1);
		this.copyanima("anupstd","andownact");
		andownact.setframe("down",1);
		this.copyanima("anupstd","andownstd");
		andownstd.setframe("down",0);
		this.newbutan("butup","anupstd","anupact",null,scursor);
		this.newbutan("butdown","andownstd","andownact",null,scursor);
		butup.addmethod("onmoveon","_rewbutmoveon");
		butdown.addmethod("onmoveon","_rewbutmoveon");
		butup.addmethod("onmoveoff","_rewstrzalkaoff");
		butdown.addmethod("onmoveoff","_rewstrzalkaoff");
		butup.addmethod("onclick","_rewbutclick");
		butdown.addmethod("onclick","_rewbutclick");
		butup.addmethod("onrel","_rewbutrel");
		butdown.addmethod("onrel","_rewbutrel");
		sorientation=sorient;
		new gmimgvec grarrows;
		_ = "grarrows" .+ "anupstd" .+ "anupact" .+ "andownact" .+ "andownstd";
		
		int dy, int dx, int ix, int iy;
		if( sorientation=="up" || sorientation=="down")	{
			bvertical = false;
			ilenx = dt;
			if( sorientation=="down")	{
				anupstd.setpos(0,600-anupstd.geth());
				anupact.setpos(0,600-anupact.geth());
				andownstd.setpos(800-andownstd.getw(),600-andownstd.geth());
				andownact.setpos(800-andownact.getw(),600-andownact.geth());
				dy = andownstd.getey();
			} else {
				anupstd.setpos(0,0);
				anupact.setpos(0,0);
				andownstd.setpos(800-andownstd.getw(),0);
				andownact.setpos(800-andownact.getw(),0);
				dy = 0;
			}
			ibx1 = anupstd.getex()+iodleg;
			ibx2 = andownstd.getpx()-iodleg;
			dx = ibx1;
		} else {
			bvertical = true;
			ileny = dt;
			if( sorientation=="right")	{
				anupstd.setpos(800-anupstd.getw(),0);
				anupact.setpos(800-anupact.getw(),0);
				andownstd.setpos(800-andownstd.getw(),600-andownstd.geth());
				andownact.setpos(800-andownact.getw(),600-andownact.geth());
				dx = anupstd.getex();
			} else {
				anupstd.setpos(0,0);
				anupact.setpos(0,0);
				andownstd.setpos(0,600-andownstd.geth());
				andownact.setpos(0,600-andownact.geth());
				dx = 0;
			}
			iby1 = anupstd.getey()+iodleg;
			iby2 = andownstd.getpy()-iodleg;
			dy = iby1;
		}
		butup._rewbuildbut(this.getname(),"up");
		butdown._rewbuildbut(this.getname(),"down");
		
		int ile = <sgrelem>.size();
		<sgrelem>._setpos(dx,dy);
		new int ilimx = dx;
		new int ilimy = dy;
		string s;
		for(int i=0; i<ile; i++)	{
			s = <sgr>.get(i);
			if( sorientation=="right")	{
				<s>.setpos( dx - <s>.getw() - <s>.lodx(), dy - <s>.lody() );
				dy += <s>.geth()+iodleg;
			} else if (sorientation=="left")	{
				<s>.setpos( dx - <s>.lodx(), dy - <s>.lody() );
				dy += <s>.geth()+iodleg;
			} else if (sorientation=="up")	{
				<s>.setpos( dx - <s>.lodx(), dy - <s>.lody() );
				dx += <s>.getw()+iodleg;
			} else if (sorientation=="down")	{
				<s>.setpos( dx - <s>.lodx(), dy - <s>.geth() - <s>.lody() );
				dx += <s>.getw()+iodleg;
			}
			<s>.clip(ibx1,iby1,ibx2,iby2);
		}
	}
	/*************************************/
	_rewbuildbut(string s, string s2)	{
		new string _sob = s;
		new string _sdir;
		if( s2=="up" )	{
			if(bvertical==false)	{	_sdir = "left";	}
			else {	_sdir = "up";	}
		} else if (s2=="down")	{
			if(bvertical==false)	{	_sdir = "right";	}
			else {	_sdir = "down";	}
		}
	}
	_rewbutmoveon()	{
		//this.mstrzalkaon(_sdir);
		this.<_sob+"_"+_sdir+"_MOVEON">();
	}
	_rewbutclick()	{
		this.mstrzalkaon(_sdir);
		this.<_sob+"_"+_sdir+"_CLICK">();
	}
	mstrzalkaon(string s)	{
		sarrowdir=s;
		timtick.play();
	}
	_rewbutrel	{
		sarrowdir=null;
		timtick.stop(false);
		fxrew.stop(false);
	}
	_rewstrzalkaoff()	{
		sarrowdir=null;
		timtick.stop(false);
		fxrew.stop(false);
		this.<_sob+"_"+_sdir+"_MOVEOFF">();
	}
	timfin()	{
		if( this.getlock() )	{	return;	}
		bool bok = false;
		if( sarrowdir!=null && !<sgr>.empty())	{
			if( sarrowdir=="up")	{
				if( <sgr>.getey() > andownstd.getpy() - ileny )	{
					<sgr>.move(0,-ileny);
					bok=true;
				}
			} else if (sarrowdir=="down") {
				if( <sgr>.getpy() < ilimy )	{
					<sgr>.move(0,ileny);
					bok=true;
				}
			} else if (sarrowdir=="left")	{
				if( <sgr>.getex() > andownstd.getpx() - ilenx )	{
					<sgr>.move(-ilenx,0);
					bok=true;
				}
			} else if (sarrowdir=="right") {
				if( <sgr>.getpx() < ilimx )	{
					<sgr>.move(ilenx,0);
					bok=true;
				}
			}
		}
		if( bok )	{
			if( !fxrew.isplaying() )	fxrew.play();
		} else {
			fxrew.stop(false);
		}
		this.play();
	}
}

class ConRewinder : Rewinder, ObjController {
	init()	{
		Rewinder::init();
		ObjController::init();
		new DelayTaker cldt; 
	}
	public getitem(string s, int x, int y)	{
		Rewinder::getitem(s,x,y);
		cldt.take();
	}
	_put()	{
		cldt.ret();
		this.<_sme + "_PUT">();
	}
	onmousemove()	{	this.moveitem();	}
	onmouselrel()	{
		if( this.getlock() )	return;
		if( cldt.isonrel() )	{	this._put();	}
	}
	onmouselclick()	{
		if( this.getlock() ) return;
		if( cldt.isonclick() )	{
			this._put();
		} else if ( !cldt.istaken() )	{
			this.<_sme+"_GET">();
		}
	}
}

class Button : LObjController	{
	init	{
		LObjController::init;
		.unlock;
		new gmimgvec grbuts;
		.vars2(A,"sobject", null, "sclicked",null);
	}
	sort	{ grbuts.sortimgs; }
	addgroups	{	grbuts.addgroups;	grbuts.sortimgs;	}
	addgroup(string s)	{	grbuts.addgr(s);	grbuts.sortimgs;	}
	addlist		{	grbuts.addlist;		grbuts.sortimgs;	}
	add(string sob)	{	grbuts.add(sob);	grbuts.sortimgs;	}
	addlocker(string sob)	{
		.add(sob);
		classlocker::setaslocker(sob);
	}
	removebutlist	{	.withlist("removebut"); }
	removebut(string sbut)	{
		grbuts.remove(sbut);
		if( sbut==sobject ) sobject=null;
		if( sbut==sclicked ) sclicked = null;
	}
	load(string sname, string sfile, string sfuninit) {
		<GAME>.varnew("gmimgvec", sname);
		sname .* sfile;
		<sname>.each( sfuninit );
		.addgroup(sname);
	}
	remove(string sname)	{
		if( <GAME>.hasvar(sname) )	{
			//for( int i=0; i < <sname>.size; i++ )	grbuts.remove( <sname>.get(i) );
			grbuts.removegr(sname);
		}
	}
	loadfrom(string sname, string spath, string sfile, string sfuninit) {
		@s = .getgraphpath;
		.setgraphpath(spath);
		.load(sname,sfile,sfuninit);
		.setgraphpath(s);
	}
	onmouselclick	{
		if( .getlock ) return;
		.<this + "_lclick">;
		if( sobject!=null)	{
			sclicked = sobject;
			if (<sobject>.hasaddedmet("butclick") )
				<sobject>.butclick;
		}
	}
	onmouselrel	{
		if( .getlock ) return;
		.<this + "_lrel">;
		if( sclicked!=null && <sclicked>.hasaddedmet("butlrel") )	{
			<sclicked>.butlrel;
		} else sclicked=null;
	}
	onmousemove	{
		if( .getlock ) return;
		if( sclicked!=null )	{
			if( <sclicked>.hasaddedmet("butmoving") )	<sclicked>.butmoving;
		}
		|int x, int y| = mouse.getpos;
		if(grbuts.isinfunc(x,y,"isbutin") )	{
			@s = grbuts.getsfound;
			if( s!=sobject )	{
				.lastoff;
				sobject = s;
				.<this + "_moveon">;
 				if( <s>.hasaddedmet("butmoveon") )
					<s>.butmoveon;
			}
		} else {
			.lastoff;
		}
	}
	lastoff	{
		if( sobject!=null )	{
			.<this + "_moveoff">;
			if( <sobject>.hasaddedmet("butmoveoff") )
				<sobject>.butmoveoff;
			sobject = null;
		}
	}
	/*
	virtual bool isbutin(int x, int y)	{ 0; }
	virtual butclick	{}
	virtual butmoveon {}
	virtual butmoveoff {}*/
}
public Button_isin			{	.addmethod("isbutin", func { (@x,@y) .isin(x,y,1,0); } );	}
public Button_isinalpha	{	.addmethod("isbutin", func { (@x,@y) .isin(x,y,1,1); } );	}
public Button_moveon		{
	.addmethod("butmoveon", func {
		sndakskermovon.play;
		advmouse.setbut;
		if( .nofframes(-1)>1 ) .setframe(-1,1);
	} );
}
public Button_moveoff		{	.addmethod("butmoveoff", func { advmouse.setstd; .setframe(-1,0);} );	}
public Button_moveonms	{	.addmethod("butmoveon", func { advmouse.setbut; } );	}
public Button_moveoffms	{	.addmethod("butmoveoff", func { advmouse.setstd; } );	}
public Button_std			{ .Button_isin; .Button_moveon; .Button_moveoff;	}
public Button_stdalpha		{ .Button_isinalpha; .Button_moveon; .Button_moveoff;	}

class Buttons : LObjController	{
	init(string sfile)	{
		LObjController::init;
		.unlock;
		new gmimgvec grbuts;
		new int __id = 0;
		new string sanbut = "anbut";
		.newanima(sanbut, sfile, 10);
		_ = .newanactionsgr(sanbut, sanbut, "grbuts");
		anbut.hide;
		grbuts.setz(10);
		grbuts.removeif( func {
			if( .actionname=="bkg" ) { .setz( .getz-1); true; }
			else false; 
			});
		new string slastb = null;
		.vars2(A,"sobject", null, "bvisible", true, "balpha", true);
	}
	_release()	{
		<slastb>.setframe(-1,0);
		.copyobj;
		.<this + "_moveoff">();
		slastb = null;
		bsms.setstd;
	}
	getbut	{	grbuts.getsfound;	}
	onmousemove()	{
		if( .getlock ) return;
		grbuts.setframe(-1,0);
		def id =  grbuts.isin(mouse.getpos,bvisible,balpha);
		if( slastb!=null ) <slastb>.setframe(-1, 1);
		if( id ) {
			string s = grbuts.getsfound;
			if( s!=slastb )	{
				if( slastb!=null )	._release;
				slastb = s;
				<s>.setframe(-1,1);
				.copyobj;
				bsms.setact;
				.<this + "_moveon">();
			}
		} else if( slastb!=null )	{
			._release;
		}
		//slastb==null ? bsms.setstd : bsms.setact;
	}
	copyobj()	{	sobject = <slastb>.actionname;	}
	onmouselclick()	{
		if( .getlock ) return;
		if( slastb!=null )	{
			.copyobj;
			.<this + "_lclick">;
		}
	}
	onmouselrel	{
		if( .getlock ) return;
		if( slastb!=null )	{
			.copyobj;
			.<this + "_lrel">;
		}
	}
	disable	{
		.lock;
		grbuts.hide;
		if( slastb!=null )	{
			bsms.setstd;
			slastb=null;
		}
	}
	enable	{
		.unlock;
		grbuts.show;
	}
}

class TextDb : classlocker, ObjController, gfxObject {
	init(string sfont, int isize, string sdbfile, int r, int g, int b, int x, int y, int dy, int z, string sdir)	{
		classlocker::init;
		ObjController::init;
		new string sFont = sfont;
		sfont = .checkfont( sfont, isize );
		new int iFontSize = isize;
		string s;
		int id, int i;
		.var2("Z",z);
		if( sdbfile.contains(".db") )	{
			if( sdbfile.getb(0,6)=="$path:" )	{
				new db dbtxt;
				dbtxt.load( sdbfile.strsubb(6) );
			} else .newdb( "dbtxt", sdbfile );
		} else {
			new db dbtxt;
			match(sdbfile.getb(0,5))	{
				"$var:" => dbtxt.dbcopy( sdbfile.strsubb(5) );
				"$row:" => {
					s = sdbfile.strsubb(5)->strgetto(",");
					id = sdbfile.strgetfrom(",");
					for( i=0; i< <s>.getcolsno(id); i++)	{
						_ = dbtxt.addrow;
						dbtxt.add(i, <s>.get(id,i) );
					}
				}
				? => dbtxt.dbaddlast( sdbfile );
			}
		}
		int w = 0, int ile = dbtxt.getrowsno;
		new gmimgvec grtxt;
		grtxt._setpos(x,y);
		for( i=0; i< ile; i++)	{
			s = "txt" + i;
			new text <s>;
			<s>.setfont( sfont );
			<s>.set( dbtxt.get(i,0) );
			<s>.setpos(x,y);
			y+=isize+dy;
			<s>.setz(z);
			<s>.createtxt(r,g,b);
			if( <s>.getw>w ) w = <s>.getw;
			grtxt.add(s);
		}
		if( sdir == "right" || sdir =="center" )	{
			for( i=0; i<ile; i++)	{
				s = "txt" + i;
				if( sdir == "center" )	{
					<s>.move( (w-<s>.getw)/2, 0 );
				} else {
					<s>.move( w-<s>.getw, 0 );
				}
			}
		}
		gfxObject::init("grtxt");
	}
	stdshadow(int dt)	{	.setshadow(0,0,0,dt);	}
	setshadow(int r, int g, int b, int dt)	{
		string s[2];
		string sfont = ._checkfont(sFont, iFontSize, "_fntbrd");
		for( int i=0; i< dbtxt.getrowsno; i++)	{
			s0 = "txt" + i;
			s1 = "txts" + i;
			new text <s1>;
			<s1>.set( <s0>.get );
			<s1>.setfont( sfont );
			<s1>.setz( <s0>.getz-1 );
			<s1>.setpos( <s0>.getpx+dt, <s0>.getpy+dt );
			<s1>.createtxt(r,g,b);
			grtxt.add(s1);
		}
	}
	setz(int z)	{
		/*for( int i=0; i< dbtxt.getrowsno; i++)	{
			<"txt" + i>.setz(z);
			<"txts" + i>.setz(z-1);
		}*/
		Z = z;
		grtxt.setz(z);
	}
	getz	{ Z;	}
	isin(int x, int y, bool bv, bool ba)	{	grtxt.isin(x,y,bv,ba);	}
	view	{
		@s = _;
		string s2;
		while(A!=s)	{
			s2 = grtxt.get(s);
			<s2>.show;
			s2 = "txts" + s2.strsubbs("txt");
			if( engine.varexist(s2) ) <s2>.show;
			@s=_;
		}
	}
	blitto(string simg)	{
		string s;
		for( int i=0; i<grtxt.size; i++)	{
			s = grtxt.get(i);
			<s>.buildfullname;
			<simg>.blit(<s>.getfullname);
			<GAME>.vardel(<s>.getfullname);
		}
	}
	setcol(int r, int g, int b)	{
		for( int i=0; i<grtxt.size; i++) <grtxt.get(i)>.createtxt(r,g,b);
	}
}

class Lexer	{
	init	{}
	buildlex	{
		.vars(A,"id","found");
		new vector vconsts;
		vconsts.type("string");
		new vector vtmp1;
		vtmp1.type("string");
		new vector vtmp2;
		vtmp2.type("string");
		
		new int dot = "."->getbyte(0);
		new string _literal_char = "\"";
	}
	setliteralchar(string s)	{	_literal_char=s;	}
	getliteralchar	{	_literal_char;	}
	bool _isvar(int b1, int b2)	{
		int i = id;
		found = "";
		int ib;
		while(i<.length)	{
			ib = .getbyte(i);
			if( ib>=b1 && ib<=b2 )	{
				found += .getb(i,1);
				i++;
			} else {
				if( (ib>=BYTEa && ib<=BYTEz) || (ib>=BYTEA && ib<=BYTEZ) || ib==BYTE_ )	found="";
				i = .length;
			}
		}
		found.length;
	}
	bool isreal	{
		int i = id;
		found = "";
		int ib;
		bool kropka=true;
		while(i<.length)	{
			ib = .getbyte(i);
			if( (ib>=BYTE0 && ib<=BYTE9) || (ib==dot&&kropka) )	{
				if( ib==dot ) kropka=false;
				found += .getb(i,1);
				i++;
			} else i = .length;
		}
		if( kropka || found.getb(0,1)=="." || found.gete(0,1)=="." ) found="";
		found.length;
	}
	bool isident	{
		int i = id;
		found = "";
		int ib;
		while(i<.length)	{
			ib = .getbyte(i);
			if( (ib>=BYTEa && ib<=BYTEz) || (ib>=BYTEA && ib<=BYTEZ) || ib==BYTE_ ||
				(i>id && ib>=BYTE0 && ib<=BYTE9) )	{
				found += .getb(i,1);
				i++;
			} else i = .length;
		}
		found.length;
	}
	bool isliteral	{
		if( .check!=.getliteralchar )	return false;
		int i = id+1;
		found = "";
		string s;
		while(i<.length)	{
			s = .getb(i,1);
			if( s==.getliteralchar )	{
				//found += s;
				return true;
			} else {
				found += s;
				i++;
			}
		}
		false;
	}
	bool isconst	{
		string s0;
		bool b = .isident;
		for( int i=0; i< vconsts.size; i++)	{
			s0 = vconsts.get(i);
			if( b )	{
				if( s0 == found )	return true;
			} else {
				found = .getb(id, s0.length);
				if( s0 == found ) return true;
			}
		}
		false;
	}
	gettoken(string svec, bool bideal)	{
		<svec>.free;
		while( .notend )	{
			if (.check==" ")	id++;
			else if (.isconst)	{	<svec>.add("$const"); <svec>.add(.read);	}
			else if (.isreal )		{<svec>.add( "$real" );	.next; if( bideal ) <svec>.add( found );}
			else if (.isint )		{<svec>.add( "$int" );	.next; if( bideal ) <svec>.add( found );}
			else if (.isident )	{<svec>.add( "$alpha" );	.next; if( bideal ) <svec>.add( found );}
			else if (.isliteral )	{<svec>.add( "$literal" );	.next; id+=2; if( bideal ) <svec>.add( found );}
			else	{<svec>.add("$error"); id++; }
		}
	}
	int expectdb(string sdb, bool bideal)	{	// identyczne lub parse
		int j, string s;
		for( int i=0; i< <sdb>.getrowsno; i++)	{
			//vtmp2.veccopydbrow(sdb,i);
			vtmp2.free;
			for( j=0; j< <sdb>.getcolsno(i); j++)	{
				s = <sdb>.get(i,j);
				s.clear;
				if( s!="" ) vtmp2.add(s);
			}
			if( .expectvec("vtmp2", bideal) )	return i;
		}
		-1;
	}
	bool expectvec(string svecsrc, bool bideal)	{
		id = 0;
		.gettoken("vtmp1", bideal);
		/*vtmp1.print;
		<svecsrc>.print;*/
		vtmp1.veceq(svecsrc);
		/*bool b = vtmp1.veceq(svecsrc);
		if( !b ) {
			("wrong expect "+.get)->print;
			vtmp1.print;
			<svecsrc>.print;
		}
		b;*/
	}
	bool expects(string s, string ssep, bool bideal)	{
		vtmp2.vecbuildfromstring(s,ssep);
		.expectvec("vtmp2", bideal);
	}
	consts=	{	vconsts.withlist("addbegin");	}
	setas(string sob)	{
		<sob>.addmethod("buildlex", "buildlex");
		<sob>.buildlex;
		<sob>.addmethod("start",	func { (string s) .set(s);	id=0; } );
		<sob>.addmethod("notend",	func {	id<.length;	} );
		<sob>.addmethod("getnext",	func { if( id==.length ) return null;
					id++;	.getb(id-1,1);	} );
		<sob>.addmethod("next",	func { id+=found.length;	} );
		<sob>.addmethod("check",	func { if( id==.length ) return null; found=.getb(id,1); found; });
		<sob>.addmethod("ischar",	func { (string s) s.contains( .getb(id,1) ); } );
		<sob>.addmethod("isint",	func{	._isvar(BYTE0, BYTE9);	} );
		<sob>.addmethod("isreal", "isreal");
		<sob>.addmethod("isbinary",	func{	._isvar(BYTE0, BYTE0+1);	} );
		<sob>.addmethod("isident",	"isident" );
		<sob>.addmethod("isconst",	"isconst" );
		<sob>.addmethod("_isvar", "_isvar");
		<sob>.addmethod("read",	func { .next;	found;	} );
		<sob>.addmethod("isliteral", "isliteral");
		<sob>.addmethod("gettoken", "gettoken");
		<sob>.addmethod("expects", "expects");
		<sob>.addmethod("expectvec", "expectvec");
		<sob>.addmethod("expectdb", "expectdb");
		<sob>.addmethod("consts=", "consts=");
		<sob>.addmethod("setliteralchar", "setliteralchar");
		<sob>.addmethod("getliteralchar", "getliteralchar");
	}
}


class AnimaFx	{
	init {}
	build(string san)	{
		<san>.addmethod("_buildanfx", func {
			new db dbsnd;
			dbsnd.dbbuild(3);
			for( int i=0; i<dbsnd.getrowsno; i++) dbsnd.set(i,0, dbsnd.get(i,0)+"_"+dbsnd.get(i,1));
			} );
		<san>._buildanfx;
		<san>.addmethod("onsetframe", func {
			@id = dbsnd.findbyrow(.actionname+"_"+.framenr);
			if( id>=0 ) {
				<"fx"+dbsnd.get(id,2)>.play;
			}
			} );
	}
}

class Localize	{
	init	{}
	_lang_db(string sname, string sfile, string sfunload)	{
		new db <sname>;
		<sname>.<"load"+sfunload>( .lang_path(sfile) + ".db");
	}
	lang_db(string sname, string sfile)	{ ._lang_db(sname,sfile,"");	}
	lang_dbscript(string sname, string sfile)	{ ._lang_db(sname,sfile,"script");	}
	lang_dbbeh(string sname, string sfile)	{ ._lang_db(sname,sfile,"beh");	}
	lang_path(string sfile)	{ "lang/" + gameapi.getgamename + "_" + sfile + LANG; }
}


class RPN {
	init	{
		new vector vout;
		vout.type("string");
		new vector vs;
		vs.type("string");
		new vector vr;
		vr.type("real");
		new int ierror = 0;
		new vector vvar;
		vvar.type("string");
	}
	int error	{	ierror;	}
	perror	{
		match(ierror)	{
			0 => "OK";
			1 => "missing )";
			2 => "unknown operator";
			3 => "missing )";
			4 => "bad output";
			5 => "division by 0";
			? => "unknown";
		}
	}
	start	{
		vout.free;
		vs.free;
		vvar.free;
		ierror = 0;
	}
	num(string s)	{	vout.add(s);	}
	op(string s)	{
		string s2;
		match (s)	{
			"(" => vs.add(s);
			")" => {
				while( vs.size>0 && vs.last!="(" )	{
					vout.add( vs.pop );
				}
				if( vs.size ) _ = vs.pop;
				else ierror = 1;		// missing (
			}
			"+","-" => {
				while( vs.size>0 && vs.last!="(" )	{
					vout.add(vs.pop);
				}
				vs.add(s);
			}
			"*","/","%" => {
				while( vs.size>0 && (vs.last=="*" || vs.last=="/" || vs.last=="%") )	{
					vout.add(vs.pop);
				}
				vs.add(s);
			}
			? => ierror = 2;		// unknown operator
		}
	}
	var(string s)	{
		vvar.add( vout.size-1 );
		vvar.add( s );
	}
	int end	{
		string s;
		while(vs.size)	{
			s = vs.pop;
			if( s=="(" ) ierror=3;	// missing )
			else vout.add( s );
		}
		vout.size;
	}
	get(int id)	{	vout.get(id);	}
	getvar(int id)	{	vvar.get(id);	}
	varsize	{	vvar.size;	}
	size	{	vout.size;	}
	copy(string srpn)		{
		.start;
		vout.veccopy(srpn);
	}
	copyvars(string srpn)	{
		.copy(srpn);
		for( int i=0; i< <srpn>.varsize; i+=2) {
			vout.set( <srpn>.getvar(i), [<srpn>.getvar(i+1)] );
		}
	}
	print	{	vout.print;	}
	real _get	{
		if( vs.size )	vs.pop->to_r;
		else {
			ierror=4;	// bad vout
			0.0;
		}
	}
	real count	{
		vs.free;
		real rout = 0;
		while( vout.size && ierror==0 )	{
			match(vout.first)	{
				"+" => vs.add( ._get+._get );
				"-" => vs.add( -._get+._get );
				"*" => vs.add( ._get*._get );
				"/" => {
					rout = ._get;
					if( rout==0 )	ierror=5;		// division by 0
					else vs.add( ._get/rout );
				}
				"%" => {
					rout = ._get->to_i;
					if( rout==0 )	ierror=5;		// division by 0
					else vs.add( ._get->to_i%rout->to_i );
				}
				? => vs.add(vout.first);
			}
			vout.removeat(0);
		}
		if( ierror==0 )	{
			if( vs.size!=1 )	{
				ierror=6;		// wrong rpn
				-1;
			} else vs.pop->to_r;
		} else -1; 
	}
	real countok	{
		//vr.free;
		real rout;
		while( vout.size )	{
			match(vout.first)	{
				"+" => vr.add( vr.pop + vr.pop );
				"-" => vr.add( -vr.pop+vr.pop );
				"*" => vr.add( vr.pop*vr.pop );
				"/" => {
					rout = vr.pop;
					if( rout==0 )	{
						ierror=5;		// division by 0
						vr.free;
						return -1;
					} else vr.add( vr.pop/rout );
				}
				"%" => {
					rout = vr.pop->to_i;
					if( rout==0 )	{
						ierror=5;		// division by 0
						vr.free;
						return -1;
					} else vr.add( vr.pop->to_i%rout->to_i );
				}
				? => vr.add(vout.first);
			}
			vout.removeat(0);
		}
		vr.pop;
	}
}


class GUI {
	init(string sgui)	{
		.var2("sGui", sgui);
		if( sgui!=null && !<GAME>.hasvar(sgui))	{
			//<GAME>.varnew("Button",sgui);
			new Button <sgui>;
			<sgui>.addtogamevars(sgui);
			<sgui>.addmethod(sgui+"_lclick", func {
				grouter.eval("butouterclick");
				.<this+"_gui_lclick">;
				} );
		}
		new gmobjvec grouter;
		//LObjController::init;
		new Color wndcol;		wndcol.set(.grey(239),255);
		new Color wndconcave;		wndconcave.set(.grey(199),255);
		new Color wndact;		wndact.set(103,141,178,255);
		new Color wndtextcol;		wndtextcol.set(.white,255);
		
		new Color wndborder;		wndborder.set(.black,255);
		new Color wndborderL;		wndborderL.set(.white,255);	// wypukly
		
		new bool bround = false;
		
		new Color wndshadow;	wndshadow.set(.black,128);
		
		new Color wndbar;	wndbar.set(60, 132, 204, 255);
		new Color wndbarb;	wndbarb.set(32, 71, 110, 255);
		.vars2(A,"iwndshadow", 1, "swndshadow", "0110", "ititlebar", 24, "ibar", 4, "iytextlength", 2, "istdfont", 13,
			 "iwndborder",1);
		
		new font stdfont;
		stdfont.load(sgmfontfile,istdfont);
		stdfont.buildfullname;
		new font stdmonofont;
		stdmonofont.load(sgmfontmono, istdfont);
		stdmonofont.buildfullname;
		new text txt1;
		txt1.setfont("stdmonofont");
		txt1.txtset("a");
		new int monowidth = txt1.getw;
		delete txt1;
		new Color fontcol;	fontcol.set(.black,255);
		new font stitlefont;
		stitlefont.load(sgmfontbold,istdfont);
		new Color titlecol;	titlecol.set(.white,255);
		
		new img imgquit;
		imgquit.create(20, 20, 93,152,211,255 );
		imgquit.imgroundborder(1,wndbarb.get);
		imgquit.hide;
		new img imgquitact;
		imgquitact.create(20, 20, 143,202,251,255 );
		imgquitact.imgroundborder(1,.white,128);
		imgquitact.hide;
		new string squit = this+"quit";
		imgquit.addtogamevars(squit);
		imgquitact.addtogamevars(squit+"act");
		
		new img im3;
		im3.create(2,2,wndbarb.get);
		imgquit.drawX(1);
		imgquitact.drawX(1);
		im3.create(2,2,.white,255);
		imgquit.drawX(0);
		imgquitact.drawX(0);
		
		// build arrows
		.buildguibut("arrowleft", null, 20, 20, false);
		.buildguibut("arrowleftact", null, 20, 20, true);
		.buildguibut("arrowright", "imgarrowleft", 0, 0, 0);
		.buildguibut("arrowrightact", "imgarrowleftact", 0, 0, 0);
		.buildguibut("arrowup", null, 20, 20, false);
		.buildguibut("arrowupact", null, 20, 20, true);
		.buildguibut("arrowdown", "imgarrowleft", 0, 0, 0);
		.buildguibut("arrowdownact", "imgarrowleftact", 0, 0, 0);
		im3.create(1,1,.black,255);
		
		imgarrowleft.drawarrow("left");
		imgarrowleftact.drawarrow("left");
		imgarrowright.drawarrow("right");
		imgarrowrightact.drawarrow("right");
		imgarrowup.drawarrow("up");
		imgarrowupact.drawarrow("up");
		imgarrowdown.drawarrow("down");
		imgarrowdownact.drawarrow("down");
		
		new timer timbutclick;
		timbutclick.delay(100);
		timbutclick.settick(1);
		new string sButClick = null;
		timbutclick.addmethod("onfinish", func {
				if( sButClick!=null )	{
					@s = sButClick;
					sButClick = null;
					.<s+"_lclick">;
				}
			} );
		
		.reset;
	}
	drawarrow(string sdir)	{
		@x = .getcx;
		@y = .getcy;
		match(sdir)	{
			"left" => {
				_ = .imgdrawline("im3", x-2, y, x-1, y, 1, 0);
				_ = .imgdrawline("im3", x-1, y-1, x-1, y+1, 1, 0);
				_ = .imgdrawline("im3", x, y-2, x, y+2, 1, 0);
				_ = .imgdrawline("im3", x+1, y-3, x+1, y+3, 1, 0);
			} "right" => {
				_ = .imgdrawline("im3", x-1, y-3, x-1, y+3, 1, 0);
				_ = .imgdrawline("im3", x, y-2, x, y+2, 1, 0);
				_ = .imgdrawline("im3", x+1, y-1, x+1, y+1, 1, 0);
				_ = .imgdrawline("im3", x+1, y, x+2, y, 1, 0);
			} "up" => {
				_ = .imgdrawline("im3", x, y-2, x, y-1, 1, 0);
				_ = .imgdrawline("im3", x-1, y-1, x+1, y-1, 1, 0);
				_ = .imgdrawline("im3", x-2, y, x+2, y, 1, 0);
				_ = .imgdrawline("im3", x-3, y+1, x+3, y+1, 1, 0);
			} "down" => {
				_ = .imgdrawline("im3", x-3, y-2, x+3, y-2, 1, 0);
				_ = .imgdrawline("im3", x-2, y-1, x+2, y-1, 1, 0);
				_ = .imgdrawline("im3", x-1, y, x+1, y, 1, 0);
				_ = .imgdrawline("im3", x, y, x, y+1, 1, 0);
			}
			? => ;
		}
	}
	drawX(int dx)	{
		int dt = 4;
		_ = .imgdrawline( "im3", .getpx+dt+dx, .getpy+dt+dx, .getex-dt-im3.getw+dx, .getey-dt-im3.geth+dx, 1, 0 );
		_ = .imgdrawline( "im3", .getex-dt-im3.getw+dx-1, .getpy+dt+dx, .getpx+dt+dx-1, .getey-dt-im3.geth+dx, 1, 0 );
	}
	buildguibut(string sname, string sfrom, int w, int h, bool bconcave)	{
		string s = "img" + sname;
		new img <s>;
		if( sfrom == null )	{
			if( bconcave ) 	{
				<s>.create(w, h, wndconcave.get );
				<s>.imgborderss(2, wndshadow.get, "1001");
				<s>.imgborderss(1, .black,255, "1001");
				<s>.imgborderss(1, .white,255, "0110");
			} else {
				<s>.create(w, h, wndcol.get );
				<s>.imgborderss(2, wndshadow.get, "0110");
				<s>.imgborderss(1, .black,255, "0110");
				<s>.imgborderss(1, .white,255, "1001");
			}
		} else <s>.clone(sfrom);
		<s>.hide;
		string s2 = "s" + sname;
		new string <s2>;
		<s2> = this+sname;
		<s>.addtogamevars( [s2] );
	}
	/************** sys ************************/
	addtogui	{
		if( sGui!=null )	{
			<sGui>.add(this);
		}
	}
	removefromgui	{
		if( sGui!=null )	{
			<sGui>.removebut(this);
		}
	}
	reset	{
		//advmouse.setstd;
	}
	dellist	{	.withlist("delobj");	}
	delobj(string sob)	{	.<"del"+ <sob>.guitype>(sob);	}
	/*********************************************/
	newwnd(string s, int w, int h)	{	._newwnd(s,w,h,"wndborder", "wndborder", "wndcol", iwndborder, swndshadow);	}
	newwndconvex(string s, int w, int h)	{	._newwnd(s,w,h,"wndborderL", "wndborder", "wndcol", iwndborder, swndshadow);	}
	newwndconcave(string swnd, int w, int h)	{	._newwnd(swnd,w,h,"wndborder", "wndborderL", "wndconcave", 2,"1001");	}
	newwndtext(string swnd, int w, int h)	{	._newwnd(swnd,w,h,"wndborder", "wndborderL", "wndtextcol", 2,"1001");	}
	_newwnd(string s, int w, int h, string swndsh0, string swndsh1, string swndcol, int iborder, string sshadow)	{
		new img <s>;
		<s>.addtogamevars(s);
		<s>.create(w,h,<swndcol>.get);
		<s>.var2("guitype","wnd");
		if( iborder )	{
			new img im1;
			im1.create(w,iborder,<swndsh0>.get);
			<s>.blit("im1");
			im1.create(w,iborder,<swndsh1>.get);
			im1.setpos(0, <s>.getey-iborder);
			<s>.blit("im1");
			im1.create(iborder,h,<swndsh0>.get);
			im1.setpos(0,0);
			<s>.blit("im1");
			im1.create(iborder,h,<swndsh1>.get);
			im1.setpos(<s>.getex-iborder,0);
			<s>.blit("im1");
			delete im1;
		}
		._mk_shadow(s, 0, iborder, iborder, w-2*iborder, iwndshadow, sshadow);
		._mk_shadow(s, 1, <s>.getex-iborder-iwndshadow, iborder, iwndshadow, h-2*iborder, sshadow);
		._mk_shadow(s, 2, iborder, <s>.getey-iborder-iwndshadow, w-2*iborder, iwndshadow, sshadow);
		._mk_shadow(s, 3, iborder, iborder, iwndshadow, h-2*iborder, sshadow);
	}
	_mk_shadow(string simg, int pos, int x, int y, int w, int h, string sshadow)	{
		bool b = sshadow.getb(pos,1);
		if( b && w && h )	{
			new img im1;
			im1.create(w, h, wndshadow.get);
			im1.setpos(x, y);
			<simg>.blit("im1");
			delete im1;
		}
	}
	newwndtitle(string s, string sico, string stitle, int w, int h)	{
		new img <s>;
		<s>.addtogamevars(s);
		<s>.var2("guitype","wnd");
		@w2 = 2*ibar+w;
		@h2 = ibar+ititlebar+h;
		<s>.create(w2, h2, wndcol.get);
		
		new img im1;
		im1.create(w2,ititlebar,wndbar.get);
		<s>.blit("im1");
		im1.create(w2,ibar,wndbar.get);
		im1.setpos(0,<s>.getey-ibar);
		<s>.blit("im1");
		im1.create(ibar,h2,wndbar.get);
		im1.setpos(0,0);
		<s>.blit("im1");
		im1.setpos(<s>.getex-ibar,0);
		<s>.blit("im1");
		
		<s>.putrgba(0,0,.transparent);
		<s>.putrgba(<s>.getex-1,0,.transparent);
		<s>.putrgba(<s>.getex-1,<s>.getey-1,.transparent);
		<s>.putrgba(0,<s>.getey-1,.transparent);
		
		im1.create(w2-2, 1, wndbarb.get);
		im1.setpos(1,0);
		<s>.blit("im1");
		im1.setpos(1,<s>.getey-1);
		<s>.blit("im1");
		im1.create(1,h2-2, wndbarb.get);
		im1.setpos(0,1);
		<s>.blit("im1");
		im1.setpos(<s>.getex-1,1);
		<s>.blit("im1");
		delete im1;
		
		if( sico!=null )	{
			<sico>.setpos(7, 4);
			<s>.blit(sico);
		}
		new text txt1;
		txt1.setfont("stitlefont");
		txt1.txtsetcol(stitle, wndbarb.rgb);
		txt1.setpos(33,8);
		<s>.blit("txt1");
		txt1.setpos(32,7);
		txt1.txtsetcol(stitle, titlecol.rgb);
		<s>.blit("txt1");
		delete txt1;
		
		<s> (squit) { (string s)
			new img imquit;
			imquit.copy(s);
			imquit.show;
			imquit.setpos(.getex-imquit.getw-5, .getpx+3);
			imquit.setz(.getz+1);
			new img imquitact;
			imquitact.copy(s+"act");
			imquitact.setpos( imquit.getpx, imquit.getpy );
			imquitact.setz(imquit.getz);
			imquitact.hide;
			//.blit("imquit");
		};
		<s>.stdlocker;
		<s>.addmethod("isbutin", func { (int x, int y)
			.unlocked && imquit.isin(x,y,0,0);
			} );
		<s>.addmethod("winmove", func { (int x, int y)
			.move(x,y);
			imquit.move(x,y);
			imquitact.move(x,y);
			} );
		.stdwinsetpos(s);
		<s>.addmethod("winsetz", func { (int z)	.setz(z); imquit.setz(z); imquitact.setz(z); <sGui>.sort; } );
		<s>.addmethod("butmoveon", func { imquit.hide; imquitact.show; /*advmouse.setbut;*/ } );
		<s>.addmethod("butmoveoff", func { imquit.show; imquitact.hide; /*advmouse.setstd;*/ } );
		<s>.addmethod("butclick", "stdclick");
		<s>.addtogui;
	}
	stdwinsetpos(string s)	{	<s>.addmethod("winsetpos", func { (int x, int y)	.winmove(x-.getpx, y-.getpy);	});	}
	stdwinmove(string s)	{	<s>.addmethod("winmove", func { (int x, int y) .move(x,y);	} );	}
	stdwinsetz(string s)	{	<s>.addmethod("winsetz", func { (int z) .setz(z); <sGui>.sort;	} );	}
	print(string sob, int x, int y, string stekst)	{
		.getstdtext(stekst);
		txt1.setpos(<sob>.getpx+x, <sob>.getpy+y);
		<sob>.blit("txt1");
		delete txt1;
	}
	getstdtext(string stekst)	{
		new text txt1;
		txt1.setfont("stdfont");
		txt1.txtsetcol(stekst, fontcol.rgb);
	}
	/************************ buttons **************************************/
	stdlocker	{	classlocker::setaslocker(this);	.unlock;	}
	stdbutin(int x, int y)	{	.unlocked && .isin(x,y,1,0);	}
	stdclick	{
		if( .unlocked && sButClick==null)	{
			sButClick = this;
			timbutclick.play;
		}
	}
	stdmoveon	{	.<this+"_moveon">;	}
	stdmoveoff	{	.<this+"_moveoff">;	}
	newbutton(string sbut, string stxt, int w, int h)	{
		.newwndconvex(sbut, w, h);
		.getstdtext(stxt);
		txt1.txtset(stxt);
		txt1.txtcenter(sbut);
		<sbut>.blit("txt1");
		@s = sbut+"clicked";
		.newwndconcave(s, w, h);
		<s>.blit("txt1");
		<s>.hide;
		delete txt1;
		
		<sbut>.stdlocker;
		<sbut>.addmethod("isbutin", "stdbutin" );
		<sbut>.addmethod("butmoveon", "stdmoveon");
		<sbut>.addmethod("butmoveoff", "stdmoveoff");
		<sbut>.vars2(A,"butstate","std","guitype","button");
		<sbut>.addmethod("butclick", func {
			if( .unlocked && sButClick==null)	{
				if( butstate=="std") 	{
					sButClick = this;
					.hide;
					@s = sButClick+"clicked";
					<s>.setpos(.getpx, .getpy);
					<s>.setz(.getz);
					<s>.show;
					butstate="clicked";
					timbutclick.play;
				} else if (butstate=="clicked")	{
					butstate = "clickclicked";
					sButClick = this;
					timbutclick.play;
				}
			}
			} );
		<sbut>.addmethod("unclick", func { .show; <this+"clicked">.hide; butstate="std"; });
		<sbut>.addmethod("clicked", func { butstate=="clicked"; });
		<sbut>.addmethod("unclicked", func { butstate=="clickclicked"; });
		.stdwinsetz(sbut);
		<sbut>.addtogui;
	}
	delbutton(string sbut)	{
		<sbut>.removefromgui;
		<GAME>.vardel(sbut);
		<GAME>.vardel(sbut+"clicked");
		delete <sbut>;
		delete <sbut+"clicked">;
	}
	delwnd(string swnd)	{
		<swnd>.removefromgui;
		<GAME>.vardel(swnd);
		delete <swnd>;
	}
	newmenubut(string sbut, int w, int h, string stekst)	{
		new img <sbut>;
		<sbut>.create(w, h, wndcol.get);
		@s = sbut + "act";
		new img <s>;
		.getstdtext(stekst);
		txt1.txtcenter(sbut);
		<sbut>.blit("txt1");
		<s>.create(w, h, wndact.get);
		<s>.blit("txt1");
		<s>.hide;
		delete txt1;
	}
	newsubmenu(string smenu, int wbut, int hbut, string svecname, string sdir)	{
		._newmenu(smenu,wbut,hbut,svecname,sdir);
		<smenu>.stdlocker;
		<smenu>.vars2(A,"active", null,"movedon",null, "idclicked", -1, "iwbut", wbut, "ihbut", hbut, "dir", sdir, "idmoved", -1, "hideonouter",false);
		<smenu> (svecname) { (string svec)
			new vector vsubmenu;
			vsubmenu.type("string");
			vsubmenu.resize( <svec>.size, null );
		};
		<smenu>.addmethod("hidesubmenus", func {
			@s;
			for( int i=0; i<vsubmenu.size; i++) {
				s = vsubmenu.get(i);
				if( s!=null ) <s>.hide;
			}
			} );
		<smenu>.addmethod("viewsubmenu", func { (int id)
			@s = vsubmenu.get(id);
			if( s!=null )	{
				.hidesubmenus;
				//<s>.unlock;
				<s>.show;
				true;
			} else false;
			} );
		<smenu>.addmethod("isbutin", func { (int x, int y)
			if( .getlock ) return;
			@s = .get(0);
			.removeat(0);
			@b = .stdbutin(x,y);
			if( b )	{
				movedon = .getsfound;
				idmoved = .getfound;
				//if( movedon.gete(0,3)=="act" ) movedon=movedon.strsube(3);
				.activate( movedon );
			} else .deactivate;
			.addbegin(s);
			b;
			} );
		<smenu>.addmethod("deactivate", func {
			if( active!=null )	{
				//<active>.show;
				<active+"act">.hide;
				active=null;
			}
			} );
		<smenu>.addmethod("activate", func { (string s)
			if( s!=active )	{
				.deactivate;
				active = s;
				//<s>.hide;
				@s2 = s+"act";
				<s2>.show;
				<s2>.setpos( <s>.getpx, <s>.getpy );
				<s2>.setz(<s>.getz+1);
			}
			} );
		//<smenu>.addmethod("butmoveon", func { .activate(movedon); } );
		//<smenu>.addmethod("butmoveoff", func { if( .unlocked ) .deactivate; } );
		<smenu>.addmethod("butmoveon", "stdmoveon");
		<smenu>.addmethod("butmoveoff", "stdmoveoff");
		<smenu>.addmethod("butclick", func {
			if( movedon!=null )
				idclicked=idmoved;
			if( !.viewsubmenu(idclicked) )
				.stdclick;
			} );
		grouter.add(smenu);
		<smenu>.addmethod("butouterclick", func {
			.deactivate;
			if( hideonouter ) .hide;
			} );
		<smenu>.addtogui;
	}
	_newmenu(string smenu, int wbut, int hbut, string svecname, string sdir)	{
		new gmimgvec <smenu>;
		<smenu>.addtogamevars(smenu);
		int x = iwndborder+iwndshadow;
		int y = x;
		@s = smenu+"bkg";
		int ile = <svecname>.size;
		if( sdir == "horizontal" )
			.newwnd(s, ile*wbut+2*x, hbut+2*y);
		else .newwnd(s, wbut+2*x, ile*hbut+2*y);
		<smenu>.add(s);
		for( int i=0; i<ile; i++)	{
			s = smenu+"_"+i;
			.newmenubut(s, wbut, hbut, <svecname>.get(i));
			<s>.setpos(x, y);
			<smenu>.add(s);
			//<smenu>.add(s+"act");
			if( sdir=="horizontal" )	x+=wbut;
			else y+=hbut;
		}
	}
	addsubmenu(string smainmenu, int id, string smenu, string svecname)	{
		@sdir = <smainmenu>.dir=="horizontal" ? "vertical" : "horizontal";
		@w = <smainmenu>.iwbut;
		@h = <smainmenu>.ihbut;
		.newsubmenu(smenu, w, h, svecname, sdir);
		<smainmenu> (smenu, id) { (@smenu, @id)
			vsubmenu.set(id, smenu);
		};
		<smenu>.hideonouter = (true);
		if( sdir == "horizontal" )	<smenu>.move( <smainmenu>.getpx+id, <smainmenu>.getpy+id*h );
		else <smenu>.move( <smainmenu>.getpx+id*w, <smainmenu>.getpy+h );
		<smenu>.setz( <smainmenu>.getz );
		<smenu>.hide;
	}
	newtextbox(string sbox, string schars, int w, int h)	{
		@swnd = sbox+"wnd";
		@dw = iwndborder+iwndshadow;
		.newwndtext(swnd, w+2*dw, h+2*dw);
		
		new TextBoxTyper <sbox>( stdmonofont.getfullname, istdfont, monowidth, fontcol.rgb, schars, dw+1, dw+1, w, h, iytextlength );
		<sbox>.insystem = (true);
		<sbox>.addtogamevars(sbox);
		<sbox>.addmethod("winsetz", func { (int z) .setz(z); <this+"wnd">.setz(z); <sGui>.sort; } );
		<sbox>.addmethod("winmove", func { (int x, int y) .move(x,y); <this+"wnd">.move(x,y); } );
		.stdwinsetpos(sbox);
		<sbox>.var2("guitype","textbox");
		<sbox>.unlock;
	}
	deltextbox(string sbox)	{
		<GAME>.deletegmobj(sbox);
		delete <sbox>;
		.delwnd(sbox+"wnd");
	}
	newsqltable(string stab, string sdb, string stxtdir)	{
		if( <sdb>.getrowsno==0 || <sdb>.getcolsno(0)==0 ) return;
		new AlgImg alg1;
// 		public textbox(string sdest, int x, int y, string stxt, string stext, int ilimit, int fontsize, int dy, string stxtdir);
// 		public def counttextrows(string stext, int ilimit)	{
		int h;
		int i[3];
		new vector vh;
		new vector vw;
		int cols = <sdb>.getcolsno(0);
		int rows = <sdb>.getrowsno;
		int dy = 2;
		int brzeg = (iwndshadow+iwndborder)*2;
		for( i0=0; i0<cols; i0++)	{
			vw.add( 0.6*istdfont * <sdb>.get(0,i0) + brzeg );
		}
		for( int i=1; i<rows; i++)	{
			h = 0;
			for( i0=0; i0<cols; i0++)	{
				i1 = alg1.counttextrows( <sdb>.get(i, i0), <sdb>.get(0,i0) );
				if( h<i1 ) h = i1;
			}
			vh.add(h*istdfont + (h-1)*dy + brzeg );
		}
		.newwnd(stab, vw.vecsum + brzeg, vh.vecsum + brzeg);
		int xstart = iwndborder + iwndshadow;
		int x = xstart;
		int y = xstart;
		new text txt1;
		txt1.setfont("stdfont");
		txt1.createtxt(.black);
		for( i0=0; i0<cols; i0++)	{
			alg1.textbox(stab, x, y, "txt1", <sdb>.get(1,i0), <sdb>.get(0,i0), istdfont, 0.6*istdfont, dy, stxtdir);
			x+=vw.get(i0);
		}
		y += vh.get(0);
		string s = stab + "tab";
		for( i=2; i<rows; i++)	{
			h = vh.get(i-1);
			x = xstart;
			for( i0=0; i0<cols; i0++)	{
				.newwndtext( s, vw.get(i0), h );
				alg1.textbox( s, 2, 2, "txt1", <sdb>.get(i,i0), <sdb>.get(0,i0), istdfont, 0.6*istdfont, dy, stxtdir);
				<s>.setpos( x, y );
				<stab>.blit(s);
				.delobj(s);
				x+=vw.get(i0);
			}
			y += vh.get(i-1);
		}
		delete txt1;
		delete vh;
		delete vw;
		delete alg1;
		
		.stdwinsetz(stab);
		.stdwinmove(stab);
		.stdwinsetpos(stab);
	}
	getbrzeg	{	iwndshadow + iwndborder;	}
	newrewinder(string srew, int x, int y, real w, real h, string swnd)	{
		string sbg = srew + "bg";
		int brzeg = .getbrzeg;
		bool bw = w!=0 && w < <swnd>.getw;
		bool bh = h!=0 && h < <swnd>.geth;
		if( !bw ) w = <swnd>.getw;
		if( !bh ) h = <swnd>.geth;
		.newwnd(sbg, w, h);
		
		new img <srew>;
		<srew>.addtogamevars(srew);
		<srew>.vars2(A,"guitype","rewinder", "srewinded", swnd,"bisw",bw,"bish",bh, "imover", 10);
		string s[2];
		if( bw )	{
			string sreww = srew+"w";
			.newwndconcave(sreww, w, 20);
			<sreww>.move(0, h);
			
			real w2 = <swnd>.getw;
			<srew>.var2("rwmover", w2/w);
			if( <srew>.rwmover<1 ) <srew>.rwmover = (1);
			real w3 = (w/w2)*(w - 40.0);
			if( w3 > w2 ) w3 = w2;
			else if (w3<1) w3 = 1+brzeg;
			s0 = srew + "tmpsuw";
			.newwndconvex(s0, w3, <sreww>.geth);
			<s0>.move(0, h);
		} else s0=null;
		if( bh )	{
			string srewh = srew+"h";
			.newwndconcave(srewh, 20, h);
			<srewh>.move(w,0);
			
			real h2 = <swnd>.geth;
			<srew>.var2("rhmover", h2/h);
			if( <srew>.rhmover<1 ) <srew>.rhmover = (1);
			real h3 = (h/h2)*(h - 40.0);
			if( h3 > h2 ) h3 = h2;
			else if (h3<1) h3 = 1+brzeg;
			s1 = srew + "tmpsuwh";
			.newwndconvex(s1, <srewh>.getw, h3);
			<s1>.move(w, 0);
		} else s1=null;
		<srew> (s0, s1) { (string ssuw, string suwh)
			new gmimgvec grels;
			grels.add(this+"bg");
			string s;
			.vars2(A,"bsuwakx", false, "bsuwaky", false, "suwakx",0,"suwaky",0,"ssuwed",null);
			if( bisw )	{
				s = this + "w";
				.var2("reww",s);
				grels.add(s);
				new img imgleft;
				imgleft.copy(sarrowleft);
				imgleft.show;
				imgleft.setpos( <s>.getpx, <s>.getpy );
				grels.add("imgleft");
				new img imgleftact;
				imgleftact.copy(sarrowleftact);
				imgleftact.hide;
				imgleftact.setpos( imgleft.getpx, imgleft.getpy);
				grels.add("imgleftact");
				new img imgright;
				imgright.copy(sarrowright);
				imgright.show;
				grels.add("imgright");
				imgright.setpos( <s>.getex-imgright.getw, <s>.getpy );
				new img imgrightact;
				imgrightact.copy(sarrowrightact);
				imgrightact.hide;
				imgrightact.setpos( imgright.getpx, imgright.getpy );
				grels.add("imgrightact");
				new img imgsuwak;
				imgsuwak.clone(ssuw);
				imgsuwak.setpos(imgleft.getex, imgleft.getpy);
				grels.add("imgsuwak");
				new real wsuw = imgright.getpx - imgleft.getex;
			}
			if( bish )	{
				s = this + "h";
				.var2("rewh",s);
				grels.add(s);
				new img imgup;
				imgup.copy(sarrowup);
				imgup.show;
				imgup.setpos( <s>.getpx, <s>.getpy );
				grels.add("imgup");
				new img imgupact;
				imgupact.copy(sarrowupact);
				imgupact.setpos( imgup.getpx, imgup.getpy );
				imgupact.hide;
				grels.add("imgupact");
				new img imgdown;
				imgdown.copy(sarrowdown);
				imgdown.show;
				grels.add("imgdown");
				imgdown.setpos( imgup.getpx, <s>.getey-imgdown.geth );
				new img imgdownact;
				imgdownact.copy(sarrowdownact);
				imgdownact.hide;
				imgdownact.setpos( imgdown.getpx, imgdown.getpy );
				grels.add("imgdownact");
				
				new img imgsuwaky;
				imgsuwaky.clone(suwh);
				imgsuwaky.setpos(imgup.getpx, imgup.getpy);
				grels.add("imgsuwaky");
				new real hsuw = imgdown.getpy - imgup.getey;
			}
		};
		if( s0!=null ) .delwnd(s0);
		if( s1!=null ) .delwnd(s1);
		
		.cycle = (srew+"tim", func {
			<this->strsubes("tim")>.winrewind;
			.play;
			} );
		<srew>.stdlocker;
		<srew>.addmethod("isbutin", func { (int x, int y)
			.unlocked && grels.isin(x,y,1,0);
			} );
		<srew>.addmethod("winmove", func { (int x, int y)
			.move(x,y);
			grels.move(x,y);
			@s = this+"bg";
			/*<srewinded>.clip( (bisw ? <reww>.getpx+.getbrzeg : 0), (bish ? <rewh>.getpy+.getbrzeg : 0),
				(bisw ? <reww>.getex-.getbrzeg : iResX), (bish ? <rewh>.getey-.getbrzeg : iResY) );*/
			<srewinded>.clip(<s>.getpx+.getbrzeg, <s>.getpy+.getbrzeg, <s>.getex-.getbrzeg, <s>.getey-.getbrzeg);
			} );
		.stdwinsetpos(srew);
		<srew>.addmethod("winmoveall", func { (int x, int y)
			if( <srewinded>.hasaddedmet("winmove") )	<srewinded>.winmove(x,y);
			else <srewinded>.move(x,y);
			.winmove(x,y);
			} );
		<srew>.addmethod("winsetallpos", func { (int x, int y) .winmoveall(x-.getpx, y-.getpy); } );
		<srew>.winmove( x, y );
		<srew>.addmethod("winsetz", func { (int z)	.setz(z); grels.setz(z); <sGui>.sort; } );
		<srew>.addmethod("setactsuw", func { (string s)
			ssuwed = s;
			<s>.hide;	<s+"act">.show;
			<this+"tim">.play;
			} );
		<srew>.addmethod("butclick", func {
			match( grels.getsfound )	{
				"imgleft" =>		.setactsuw("imgleft");
				"imgright" =>	.setactsuw("imgright");
				"imgsuwak" => {	bsuwakx = true; suwakx = mouse.getposx-imgsuwak.getpx;	}
				"imgup" => 		.setactsuw("imgup");
				"imgdown" => 	.setactsuw("imgdown");
				"imgsuwaky" => {	bsuwaky = true; suwaky = mouse.getposy-imgsuwaky.getpy;	}
				? => ;
			}
			} );
		<srew>.addmethod("butlrel", func {
			<this+"tim">.stop(false);
			if( ssuwed!=null )	{
				<ssuwed+"act">.hide;
				<ssuwed>.show;
				ssuwed = null;
			}
			bsuwakx = false;
			bsuwaky = false;
			} );
		<srew>.addmethod("winrewind", func {
			if( bisw )	{
				if( imgleftact.isvisible )	{
					<srewinded>.move(imover,0);
				} else if (imgrightact.isvisible )	{
					<srewinded>.move(-imover,0);
				}
			}
			if ( bish )	{
				if( imgupact.isvisible )	{
					<srewinded>.move(0,imover);
				} else if (imgdownact.isvisible )	{
					<srewinded>.move(0, -imover);
				}
			}
			.stabilizerew;
			.setrewinded;
			} );
		<srew>.addmethod("rewind", func { (int dx, int dy)
			if( bisw )	<srewinded>.move(dx,0);
			if( bish )	<srewinded>.move(0,dy);
			.stabilizerew;
			.setrewinded;
			} );
		<srew>.addmethod("stabilizerew", func {
			if( bisw )	{
				if( <srewinded>.getpx > <reww>.getpx+.getbrzeg ) <srewinded>.setpos( <reww>.getpx + .getbrzeg, <srewinded>.getpy );
				else if (<srewinded>.getex < <reww>.getex-.getbrzeg ) <srewinded>.move( <reww>.getex-.getbrzeg-<srewinded>.getex, 0);
			}
			if( bish )	{
				if( <srewinded>.getpy > <rewh>.getpy+.getbrzeg ) <srewinded>.setpos( <srewinded>.getpx, <rewh>.getpy + .getbrzeg );
				else if (<srewinded>.getey < <rewh>.getey-.getbrzeg ) <srewinded>.move( 0, <rewh>.getey-.getbrzeg-<srewinded>.getey);
			}
			} );
		<srew>.addmethod("butmoving", func {
			if( bsuwakx )	{
				real x = imgsuwak.getpx;
				imgsuwak.setpos( mouse.getposx-suwakx, imgsuwak.getpy );
				<srewinded>.move( rwmover*(x-imgsuwak.getpx), 0 );
				.stabilizerew;
				.setrewinded;
			} else if (bsuwaky)	{
				real y = imgsuwaky.getpy;
				imgsuwaky.setpos( imgsuwaky.getpx, mouse.getposy-suwaky );
				<srewinded>.move( 0, rhmover*(y-imgsuwaky.getpy) );
				.stabilizerew;
				.setrewinded;
			}
			} );
		<srew>.addmethod("setrewinded", func {
			if( bisw )	{
				real dx = (<reww>.getpx-<srewinded>.getpx)->to_r/<srewinded>.getw->to_r;
				//real dx = (imgleft.getex-<srewinded>.getpx)->to_r/(imgright.getpx-imgleft.getex)->to_r;
				imgsuwak.setpos( imgleft.getex+dx*wsuw, imgsuwak.getpy );
				dx = imgright.getpx - imgsuwak.getex;
				if( dx<0 ) imgsuwak.move(dx, 0);
			}
			if( bish )	{
				real dy = (<rewh>.getpy-<srewinded>.getpy)->to_r/<srewinded>.geth->to_r;
				//real dx = (imgleft.getex-<srewinded>.getpx)->to_r/(imgright.getpx-imgleft.getex)->to_r;
				imgsuwaky.setpos( imgsuwaky.getpx, imgup.getey+dy*hsuw );
				dy = imgdown.getpy - imgsuwaky.getey;
				if( dy<0 ) imgsuwaky.move(0, dy);
			}
			} );
		<srew>.setrewinded;
		<srew>.addtogui;
	}
	delrewinder(string srew)	{
		if( <srew>.bisw )	.delobj(srew+"w");
		if( <srew>.bish )	.delobj(srew+"h");
		<srew>.removefromgui;
		<GAME>.deletegmobj(srew);
		<GAME>.deletegmobj(srew+"bg");
		delete <srew>;
		delete <srew+"bg">;
		delete <srew+"tim">;
	}
	newcheckbox(string sbox)	{
		.newwndtext(sbox,15,15);
		<sbox> {
			new img imcheck;
			imcheck.create(15,15,.transparent);
			new img im1;
			im1.create(2,2,.black,255);
			_ = imcheck.imgdrawline("im1", 4, 7, 6, 9, 1, 0);
			_ = imcheck.imgdrawline("im1", 6, 9, 10, 5, 1, 0);
			delete im1;
			imcheck.hide;
		};
		<sbox>.stdlocker;
		<sbox>.addmethod("butclick", func {
			if( .getlock ) return;
			.checked ? .uncheck : .check;
			} );
		<sbox>.addmethod("check", func { imcheck.show;	} );
		<sbox>.addmethod("uncheck", func { imcheck.hide;	} );
		<sbox>.addmethod("checked", func { imcheck.isvisible;	} );
		<sbox>.addmethod("winmove", func { (int x, int y)
			.move(x,y);
			imcheck.move(x,y);
			} );
		.stdwinsetpos(sbox);
		<sbox>.addmethod("winsetz", func { (int z) .setz(z); imcheck.setz(z); } );
		<sbox>.addmethod("isbutin", "stdbutin");
		<sbox>.addtogui;
	}
	/*******************************************/
	/*load(string sfile)	{
		new db dbl;
		dbl.loadbeh( .getpath(sfile) );
		int i[3], string s[3];
		for( int i=0; i < dbl.getrowsno; i++)	{
			
		}
		delete dbl;
	}*/
}
/*************************************************************************/

class AlgImg	{
	init	{}
	public makehistogram(string sdest, int w, int h, string ssrc)	{
		new vector vhis;
		vhis.resize(256, 0);
		int i, int j, int id;
		int r, int g, int b;
		@x = <ssrc>.getpx;
		@y = <ssrc>.getpy;
		@w2 = <ssrc>.getw;
		@h2 = <ssrc>.geth;
		<ssrc>.move(-x,-y);
		for( i=0; i<h2; i++)	{
			for( j=0; j<w2; j++)	{
				|r,g,b| = <ssrc>.getrgb(j,i);
				id = 0.3*r + 0.59*g + 0.11*b;
				vhis.set( id, vhis.get(id)+1 );
			}
		}
		<ssrc>.move(x,y);
		j = 1;
		for( i=0; i<256; i++)	{
			if( vhis.get(i)>j ) j=vhis.get(i);
		}
		real r = h.to_r/j.to_r;
		<sdest>.create( w, h, .white, 255 );
		<sdest>.setpos(0,0);
		x = (<sdest>.getw-256)/2;
		y = <sdest>.getey-1;
		for( i=0; i<256; i++)	{
			id = r*vhis.get(i);
			for( j=0; j<id; j++)	{
				<sdest>.putrgb(x+i, y-j, .black);
			}
		}
		delete vhis;
	}
	public makegreypallete(string sdest, int dw, int h)	{
		<sdest>.create(dw*256, h, .white, 255);
		@s = ._newim1;
		for( int i=0; i<256; i++)	{
			im1.create(dw,h,.grey(i),255);
			im1.setpos(i*dw,0);
			<sdest>.blit(s);
		}
		._delim1;
	}
	public linexy(string sdest, int x1, int y1, int x2, int y2, int r, int g, int b, int a)	{
		@dx = (x1-x2)->abs+1;
		@dy = (y1-y2)->abs+1;
		@s = ._newim1;
		<sdest>.create(dx, dy, .transparent);
		<sdest>.setpos( .min(x1,x2), .min(y1,y2) );
		im1.create(1,1,r,g,b,a);
		_ = <sdest>.imgdrawline(s, x1, y1, x2, y2, 1, 0);
		._delim1;
	}
	public blittxt(string sdest, string stxt, int x, int y, int x2, string stxtdir)	{
		@xd = <sdest>.getpx;
		@yd = <sdest>.getpy;
		match(stxtdir)	{
			"right" => <stxt>.setpos( xd + x2 - <stxt>.getw, yd + y);
			"center" => <stxt>.setpos( xd + (x+x2-<stxt>.getw)/2, yd + y);
			? => <stxt>.setpos(x,y);
		}
		<sdest>.blit(stxt);
	}
	public textbox(string sdest, int x, int y, string stxt, string stext, int ilimit, int fontsize, int fontw, int dy, string stxtdir)	{
		if( ilimit<=0 ) return;
		new vector v1;
		v1.type("string");
		v1.vecbuildfromstring( stext, " " );
		string s = "";
		string s2;
		@w = ilimit*fontw;
		for( int i=0; i<v1.size; i++)	{
			s2 = s + " " + v1.get(i);
			if( s2.length <= ilimit ) s = s2;
			else {
				<stxt>.txtset(s);
				.blittxt(sdest, stxt, x, y, x+w, stxtdir);
				y += fontsize+dy;
				s = v1.get(i);
			}
		}
		<stxt>.txtset(s);
		.blittxt(sdest, stxt, x, y, x+w, stxtdir);
		delete v1;
	}
	public int counttextrows(string stext, int ilimit)	{
		if( ilimit<=0 ) return 0;
		int h = 1;
		new vector v1;
		v1.type("string");
		v1.vecbuildfromstring( stext, " " );
		string s = "";
		string s2;
		for( int i=0; i<v1.size; i++)	{
			s2 = s + " " + v1.get(i);
			if( s2.length <= ilimit ) s = s2;
			else {
				h++;
				s = v1.get(i);
			}
		}
		delete v1;
		h;
	}
	/****************************************************/
	string _newim1	{
		new img im1;
		im1.buildfullname;
		im1.getfullname;
	}
	_delim1	{
		<GAME>.vardel(im1.getfullname);
		delete im1;
	}
}
/*************************************************************************/
class LangTxt	{
	init(string sdbfile)	{
		.lang_db("dblt", sdbfile);
	}
	get(string s)	{	dblt.get( dblt.findbyrow(s), 1 );	}
	getvec(string svec, string s)	{
		@id = dblt.findbyrow(s);
		<svec>.free;
		for( int i=1; i< dblt.getcolsno(id); i++)	{
			<svec>.add( dblt.get(id, i) );
		}
	}
}
class SQL	{
	init	{
		new db dbtables;
		new string sscript;
		Lexer::setas("sscript");
		sscript.setliteralchar("'");
		sscript.consts = (A, "(", ")", "/", "%", "*","+","-",";",".",",",
			"OR", "SELECT","FROM","WHERE","ORDER","BY","ASC","DESC","AND","NULL",
			"=","<=","=>","<>","<",">");
		new vector vscr;
		vscr.type("string");
		new vector vtab;		vtab.type("string");
		new vector vtabid;	vtabid.type("string");
		new vector vtabn;		vtabn.type("string");
		
		new vector vrow;	vrow.type("string");
		new vector vrowid;	vrowid.type("string");
		new vector vrowint;
		new vector vtabprzesun;
		
		new db dboutnames;	dboutnames.buildfullname;
		new db dbout;		dbout.buildfullname;
		new vector vouttab; vouttab.type("string");
		new vector veq;		veq.type("string");
		new vector veq2;	veq2.type("string");
		new vector vcnt;	vcnt.type("string");
		new int ilicz;
		new bool basc;
		new int isortcol;
		.var2("serror",null);
	}
	load(string spath)	{
		@s = this;
		dbtables.load(spath + s + ".tables");
		string s2;
		for( int i=0; i< dbtables.getrowsno; i++)	{
			s2 = s +"_"+ dbtables.get(i,0);
			new db <s2>;
			<s2>.load( spath + s2 + ".db" );
		}
	}
	save(string spath)	{
		@s = this;
		dbtables.save(spath + s + ".tables");
		string s2;
		for( int i=0; i< dbtables.size; i++)	{
			s2 = s + dbtables.get(i,0);
			<s2>.save( spath + s2 + ".db" );
		}
	}
	insertvalues(string sdb, string srow)	{	<this+sdb>.dbaddstringrow(srow);	}
	int query(string script)	{
		script.clear;
		if( script.length==0 ) return .cerrors(1,null);
		sscript.start(script.to_u);
		sscript.gettoken("vscr", true);
		
		match( vscr.get(0) )	{
			"$const" => {
				match(vscr.get(1))	{
					"SELECT" => .ord_select;
					? => .cerror(3,1);
				}
			}
			? => .cerror(2,0);	// bad start
		}
	}
	droptable(string s)	{
		.vardelif(this+"_"+s);
	}
	ord_select	{
		string s[3];
		vtab.free;
		vtabid.free;
		vrow.free;
		vrowid.free;
		vrowint.free;
		vtabprzesun.free;
		veq.free;
		dbout.free;
		int ile = vscr.size;
		int i[3];
		i0 = vscr.vecfindfrom(0,"NULL");
		while(i0>=0 )	{
			vscr.set(i0-1, "$literal");		// zamiana 
			i0 = vscr.vecfindfrom(i0+1,"NULL");
		}
		int state = 10;
		for( int i=2; i<ile; i+=2)	{
			s0 = vscr.get(i);
			s1 = vscr.vecget(i+1);
			match(s0)	{
				"$const" => {
					if( state==10 )	{
						if( s1=="*" ) {
							state = 11;
							vrow.add(s1);
							vrowid.add(s1);
						} else return .cerror(9,i+1);
					} else if (state==11) {
						if (s1=="FROM")	{
							i0=i+2;
							i=ile;
							state = 15;	// end
						} else return .cerror(11,i+1);
					} else if (state==12 || state==16)	{
						if( s1=="." )	{		// table.row
							state=13;
						} else if (s1==",")	{	// r1, r2
							if(state==12) {
								vrowid.add(vrow.last);
								vrow.set(vrow.size-1,null);
							}
							state=14;
						} else if (s1=="FROM")	{
							if(state==12) {
								vrowid.add(vrow.last);
								vrow.set(vrow.size-1,null);
							}
							i0=i+2;
							i=ile;
							state = 15;	// end
						} else return .cerror(12,i+1);
					} else return .cerror(10,i+1);
				}
				"$alpha" => {
					if(state==10 || state==14)	{
						state=12;
						vrow.add(s1);
					} else if (state==13)	{
						state=16;
						vrowid.add(s1);
					} else return .cerror(13,i+1);
				}
				? => ;
			}
		}
		if( state!=15 ) return .cerrors(14,null);
		state = 0;
		for( i=i0; i<ile; i+=2)	{
			s0 = vscr.get(i);
			s1 = vscr.vecget(i+1);
			if( s0=="$alpha" )	{
				if(state==0 || state==3)	{
					if( vtab.contains(s1) ) return .cerror(27,i+1);
					vtab.add(s1);
					state=1;
				} else if (state==1 )	{	// tab t
					vtabid.add(s1);
					state=2;
				} else return .cerror(5,i+1);
			} else if (s0=="$const")	{
				if (state==1 || state==2)	{
					if( s1=="," )	{
						if(state==1)		vtabid.add(vtab.last);
						state=3;
					} else if (s1=="WHERE" || s1==";" || s1=="ORDER" )	{
						if(state==1)		vtabid.add(vtab.last);
						if( s1==";" && vscr.vecget(i+2)!=null ) return .cerrors(37,vscr.vecget(i+2));
						i0 = i+1;
						i=ile;
						state = 10;	// end
					}
				} else return .cerror(6,i+1);
			} else return .cerror(7,i+1);
		}
		if( state!=10 ) return .cerrors(8,null);
		
		s0 = this;
		vtabn.free;
		vtabprzesun.add(0);
		for(i=0; i< vtab.size; i++)	{
			s1 = s0+"_"+vtab.get(i)->to_l;
			vtabn.add(s1);
			if( !.hasvar(s1) )
				return .cerrors(24,vtab.get(i));
			vtabprzesun.add( <s1>.getcolsno(0) + vtabprzesun.last );
		}
		if( vrowid.vecget(0)=="*" )	{
			vrowid.removeat(0);
			vrow.removeat(0);
			for( i=0; i<vtab.size; i++)	{
				s2 = vtab.get(i);
				//s1 = s0+"_"+s2.to_l;
				s1 = vtabn.get(i);
				vrowid.vecadddbrow(s1, 1);
				for(i1=0; i1 < <s1>.getcolsno(1); i1++) vrow.add( s2 );
			}
		}
		for(i=0; i< vrow.size; i++)	{
			s1 = vrowid.get(i);
			if(vrow.get(i)==null ) vrow.set(i,vtab.first);
			i1 = vtabid.find(vrow.get(i));
			if( i1>=0 )	{
				s2 = vtab.get(i1);
				
				//vrow.set(i, s2);
				vrow.set(i, i1);	// zapisz index tabeli z vtab zamiast nazwy tabeli
				
				i2 = <vtabn.get(i1)>.dbfindinrow(1,s1);
				if( i2<0 )	return .cerrors(26,s2+"."+s1);
				vrowint.add(i2);
			} else return .cerrors(25,vrow.get(i));
		}
		
		match(vscr.get(i0))	{
			"WHERE" => {
				i=i0+1;
				while(i<ile)	{
					s0 = vscr.get(i);
					s1 = vscr.vecget(i+1);
					if(s0=="$alpha")	{
						if(state==10 || state==16 || state==17)	{
							veq.add(s1);
							if(state==17) state=18;
							else state=11;
							i+=2;
						} else if (state==12 || state==19)	{
							i1 = vtabid.find(veq.last);
							if( i1>=0 )	{
								veq.set( veq.size-1, vtab.get(i1) );
								veq.add( s1 );
								if(state==12)	state=14;
								else state=15;
								i+=2;
							} else return .cerror(17,i+1);
						} else if (state==13)	{
							state=17;	// found table.col or col
						} else return .cerror(18,i+1);
					} else if (s0=="$const")	{
						if(state==11 || state==18)	{
							if( s1=="." )	{
								if( vtabid.find(veq.last)<0 ) return .cerror(17,i-1);
								if(state==11) state=12;
								else state=19;
								i+=2;
							} else {
								if( !.table_has_col(vtab.first,veq.last) ) return .cerrors(26,veq.last);
								veq.add(veq.last);
								veq.set( veq.size-2, vtab.first );
								if( state==11 ) state=14;
								else state=15;
							}
						} else if (state==14)	{
							if ( s1.in(A,"=","<>","<",">","<=",">=") )	{
								veq.add(s1);
								state=13;
								i+=2;
							} else return .cerror(16,i+1);
						} else if (state==15)	{
							match(s1)	{
								"AND", "OR" => { veq.add(s1); state=16; i+=2; }
								//";" => return .count;
								";" => {
									state=20;
									i+=2;
								}
								"ORDER" => return .ord_order(i+2);
								? => return .cerror(19,i+1);
							}
						} else return .cerror(23,i+1);
					} else if (s0=="$int" || s0=="$real" || s0=="$literal")	{
						if(state==13)	{
							if( s0=="$literal" && !veq.last->in(A,"=","<>") ) return .cerror(20,i+1);
							veq.add(s0);
							veq.add(s1);
							state = 15;
							i+=2;
						} else return .cerror(21,i+1);
					}else return .cerror(15,i+1);
				}
				if( state==20 ) return .count;
				return .cerror(22,i+1);
			}
			";" => return .count;
			"ORDER" => return .ord_order(i0+1);
			? => ;
		}
		
		0;	// bez bledu
	}
	table_has_col(string stab, string scol)	{
		<this+"_"+stab.to_l>.dbrowcontains(1, scol);
	}
	int ord_order(int id)	{
		if( .count == 0 )	{
			int state = 0;
			string s[2];
			string ssortertab;
			string ssorter;
			basc = true;
			while(id<vscr.size )	{
				s0 = vscr.get(id);
				s1 = vscr.vecget(id+1);
				if(s0=="$const")	{
					if(state==0)	{
						if( s1=="BY" )	{
							state=1;
							id+=2;
						} else return .cerror(29,id+1);
					} else if (state==2)	{
						if( s1=="." )	{
							state=3;
							ssortertab=ssorter;
							id+=2;
						} else if (s1==";")	{
							state=5;
							ssortertab=vtab.first;
						} else if (s1=="ASC" || s1=="DESC")	{
							state=4;
							ssortertab=vtab.first;
						} else return .cerror(31,id+1);
					} else if (state==4)	{
						if(s1==";")	{
							state=5;
						} else if (s1=="ASC" || s1=="DESC" )	{
							basc = s1=="ASC";
							state=5;
							id+=2;
						} else return .cerror(32,id+1);
					} else if (state==5)	{
						if(s1==";")	{
							state=10;	// end!
							id+=2;
						} else return .cerror(33,id+1);
					} else return .cerror(30,id+1);
				} else if (s0=="$alpha")	{
					if(state==1)	{
						ssorter = s1;
						state=2;
						id+=2;
					} else if (state==3)	{
						ssorter=s1;
						state=4;
						id+=2;
					} else return .cerror(34,id+1);
				} else return .cerror(28,id+1);
			}
			if( state!=10 ) return .cerrors(35,state);
			
			ssortertab += "_" + ssorter;
			isortcol = vouttab.find(ssortertab);
			if( isortcol<0 ) return .cerrors(36,ssorter);
			dbout.insertsort( dbout.getrowsno, "dboutcol", (basc ? "dbcmpasc" : "dbcmpdesc"), "swap");
			0;
		} else
			1;
	}
	dboutcol(int id)	{	.get(id,isortcol);	}
	dbcmpasc(string s1, string s2)	{	s1.cmpalph(s2) < 0;	}
	dbcmpdesc(string s1, string s2)	{	s1.cmpalph(s2) > 0;	}
	int count	{
		dbout.free;
		vcnt.free;
		vouttab.free;
		ilicz = 0;
		
		dboutnames.free;
		_ = dboutnames.addrow;
		_ = dboutnames.addrow;
		string s;
		int id;
		for( int i=0; i<vrowid.size; i++)	{
			s = vtabn.get( vrow.get(i) );
			id = vrowint.get(i);
			dboutnames.add(0, <s>.get(0, id) );
			dboutnames.add(1, <s>.get(1, id) );
			vouttab.add( vtabid.get(vrow.get(i)) + "_" + vrowid.get(i) );	// do sortowania
		}
		veq2.free;
		i=0;
		while(i<veq.size)	{
			.getpoletabid( i );
			veq2.add( veq.get(i+2) );
			.getpoletabid( i+3 );
			if( i+5<veq.size )	{
				veq2.add( veq.get(i+5) );
			}
			i+=6;
		}
		.countrow(0, vtab.size);
		0;
	}
	getpoletabid(int id)	{
		match(veq.get(id))	{
			"$int", "$literal", "$real" => {
				veq2.add(veq.get(id));
				veq2.add(veq.get(id+1));
			}
			? => {
				veq2.add("$cell");
				@pos = vtab.find( veq.get(id) );	// pozycja tabeli
				veq2.add( vtabprzesun.get(pos) + <vtabn.get(pos)>.dbfindinrow(1, veq.get(id+1) ) );	// wylicz pozycje pola w wektorze
			}
		}
	}
	countrow(int itab, int ile)	{
		//@s = this+"_"+vtab.get(itab)->to_l;
		@s = vtabn.get(itab);
		
		@sv = "vtmp"+ilicz;
		ilicz++;
		new vector <sv>;
		<sv>.type("string");
		<sv>.copy("vcnt");
		
		for(int i=2; i< <s>.getrowsno; i++)	{
			//if(itab==0 ) dbout.dbaddrowfrom(s, i, 0);
			//else dbout.dbadddbrowtorow( dbout.getrowsno-1, s, i);
			vcnt.vecadddbrow(s,i);
			if( itab+1<ile )	{
				.countrow(itab+1, ile);
				vcnt.copy(sv);
			} else {
				// vrow - nazwa(index z vtab) tabeli
				// vrowid - nazwa pola tabeli
				// vrowint - numer pola tabeli
				// vtabprzesun - przesuniecie vtab
				bool b = .calcrow(0);
				if( b )	{
					@row = dbout.addrow-1;
					for( int j=0; j<vrow.size; j++)	{
						dbout.add( row, vcnt.get( vtabprzesun.get( vrow.get(j) ) + vrowint.get(j) ) );
						// wstaw wymagane pole z vcnt, ktore ma pozycje w vrowint + vprzesun[vrow]
					}
				}
				vcnt.copy(sv);
			}
		}
		delete <sv>;
		ilicz--;
		//dbout.dbaddvec("vcnt");
		//vcnt.free;
	}
	bool calcrow(int id)	{
		if( id<veq2.size )	{
			@d1 = .getpole(id);
			@d2 = .getpole(id+3);
			match( veq2.get(id+2) )	{
				"=" => d1==d2;
				"<>" => d1!=d2;
				"<" => d1<d2;
				">" => d1>d2;
				"<=" => d1<=d2;
				">=" => d1>=d2;
				? => ;
			}
			bool b = _;
			match( veq2.vecget(id+5) )	{
				"AND" => return b && .calcrow(id+6);
				"OR" => return b || .calcrow(id+6);
				? => return b;
			}
		}
		true;
	}
	def getpole(int id)	{
		match( veq2.get(id) )	{
			"$literal" => veq2.get(id+1);
			"$int" => veq2.get(id+1)->to_i;
			"$real" => veq2.get(id+1)->to_r;
			"$cell" => vcnt.get( veq2.get(id+1) );
			? => ;
		}
	}
// 	isref(int id)	{ vscr.vecget(id)=="$alpha" && vscr.vecget(id+2)=="$const" && vscr.vecget(id+3)=="." && vscr.vecget(id+4)=="$alpha";	}
	int cerror(int ierror, int id)	{	.cerrors(ierror,vscr.vecget(id));	}
	int cerrors(int ierror, string scom)	{
		serror = scom;
		match(ierror)	{
			0 => "OK";
			1 => "empty code";
			2 => "unknown start";
			3 => "bad key word on start";
			4 => "no FROM";
			5 => "no FROM tab";
			6 => "key word after ',' in FROM";
			7 => "no tab or ',' after FROM";
			8 => "wrong end of FROM";
			9 => "wrong const initial after SELECT";
			10 => "wrong const after SELECT";
			11 => "no FROM after SELECT";
			12 => "wrong const after SELECT list";
			13 => "wrong alpha after SELECT";
			14 => "wrong end SELECT state";
			15 => "wrong ident starting WHERE";
			16 => "wrong const after table.row in WHERE";
			17 => "no existing table in WHERE";
			18 => "wrong alpha in WHERE";
			19 => "wrong const after equation in WHERE";
			20 => "no = or <> before literal in WHERE";
			21 => "literal, int or real before equation in WHERE";
			22 => "bad end after WHERE";
			23 => "wrong const after WHERE";
			24 => "FROM: no such table";
			25 => "SELECT: no such table";
			26 => "SELECT: no such row in table";
			27 => "FROM: table already exist";
			28 => "ORDER: wrong word";
			29 => "ORDER: no BY word";
			30 => "ORDER BY: wrong const";
			31 => "ORDER BY: wrong const after alpha";
			32 => "ORDER BY: expected ';' or 'ASC', 'DESC'";
			33 => "ORDER BY: expected ';'";
			34 => "ORDER BY: wrong alpha";
			35 => "ORDER BY: wrong end";
			36 => "ORDER BY: no field to sort";
			37 => "words after ';'";
			? => "";
		}
		string s = _;
		if(scom!=null ) s+=": '"+scom+"'";
		if( igmdebug ) s.print;
		ierror;
	}
	copyresult(string sdb)	{
		@s = dbout.getfullname;
		@s2 = dboutnames.getfullname;
		<sdb>.dbaddrowfrom(s2, 0, 0);
		<sdb>.dbaddrowfrom(s2, 1, 0);
		for( int i=0; i< dbout.getrowsno; i++)
			<sdb>.dbaddrowfrom(s, i, 0);
	}
}

module advmouse	{
	init()	{
		new anima anmsc;
	}
	public load(string sname)	{
		anmsc.load(sname);
		anmsc.hide();
	}
	set(string saction)	{
		anmsc.show();
		anmsc.setframe( saction, 0 );
		mouse.setcursor("anmsc");
		anmsc.hide();
	}
	setstd()	{	this.set("normal");	}
	setactive()	{	this.set("active");	}
	setbut	{	this.set("active");	}
	setexit()	{	this.set("exit");	}
	setwait()	{	this.set("wait");	}
	get()		{	return anmsc.actionname();	}
}

class classadvobject	{
	init()	{
		this.addasadvobject();
	}
	addasadvobject()	{
		if( !AdventureGame ) return;
		string s = this.getname();
		grmsmove.add(s);
		grmslrel.add(s);
		grmslclick.add(s);
		grmsrclick.add(s);
	}
	removefromadvobjs()	{
		if( !AdventureGame ) return;
		string s = this.getname();
		grmsmove.remove(s);
		grmslrel.remove(s);
		grmslclick.remove(s);
		grmsrclick.remove(s);
	}
	virtual onmousemove(int x, int y)	{}
	virtual onmouselclick(int x, int y)		{}
	virtual onmouselrel(int x, int y)		{}
	virtual onmouserclick(int x, int y)		{}
}

/*
	klasa bazowa, zawiera podstawowe metody i zmienne bohatera przygodowki
	Dominik Dagiel 3 III 2006
*/

class classadvanhero	{
	init()	{}
	public setashero(string sanima, string sfunonfinish)	{
		<sanima>.addmethod("buildhero", "buildhero");
		<sanima>.addmethod("onendframe", "heroendframe1");
		<sanima>.buildhero();
		<sanima>.addmethod("buildheroframe", "buildheroframe");
		<sanima>.addmethod("onfinish", "herofinish");
		<sanima>.addmethod("getdir", "getdir");
		<sanima>.addmethod("setdir", "setdir");
		<sanima>.addmethod("thisfinish", "thisfinish");
		<sanima>.addmethod("playspec", "playspec");
		<sanima>.addmethod("playspec2", "playspec2");
		<sanima>.addmethod("herostop", "herostop");
		<sanima>.addmethod("herostart", "herostart");
		<sanima>.addmethod("herostand", "herostand");
		<sanima>.addmethod("setstdfin", "setstdfin");
		<sanima>.addmethod("getpocket", "getpocket");
		<sanima>.addmethod("haspocket", "haspocket");
		<sanima>.addmethod("setstandbase", "setstandbase");
		<sanima>.setstdfin( sfunonfinish );
	}
	buildheroframe(string san)	{	<san>.addmethod("onendframe", "heroendframe");	}
	setstdfin(string s)	{	this.addmethod("onstdfinish", s);	}
	setstandbase(string s)	{	_sstandbase = s;	}
	buildhero()	{
		new string _sbase;	// baza akcji
		new int _istate = 0;	// 0 - neutral, 1 - start, 2 - body, 3 - stop
		new string _sfinfun;	// metoda do wywolania na finish akcji bohatera
		new string _sobfin;	// obiekt na ktorym wywolac metode na finish (jak null to this)
		new bool _bplaystop;	// czy odegrac stop
		new int _iiloscsek;	// ilosc sekwencji
		new int _itypsort;		// 0 - po kolei, 1 - random
		new int idsort;		// kolejny nr kawalka
		new string _sobstart;	// obiekt na finish start
		new string _sfunfinstart;	// metoda na finish start
		new bool bthisfin = false;	// czy finish jest w animacji a nie z zewnatrz
		new string _sstandbase = "stand";
	}
	getpocket()	{	return _spocketpref + this.getname(); }
	bool haspocket()	{	return engine.varexist(_spocketpref+this.getname());	}
	thisfinish(bool bfin)	{	bthisfin=bfin;	}
	string getdir()	{	return this.actionname()->gete(0,2);	}
	setdir(string sdir)	{	.setframe( .actionname->strsube(2) + sdir, .framenr );	}
	playspec(string sbase, int iloscsek, int itypsort, bool bstart, string sobstart, string sfunfinstart,
		bool bstop, string sobfin, string sfinfun, string sdir)	{
		_sbase = sbase;
		_iiloscsek = iloscsek;
		_itypsort = itypsort;
		_bplaystop = bstop;
		_sobfin = sobfin;
		_sfinfun = sfinfun;
		_sobstart = sobstart;
		_sfunfinstart = sfunfinstart;
		if( iloscsek > 0 )	{
			if( itypsort==0 )	{	idsort = 1;	}
			else if (itypsort==1)	{	idsort = iloscsek.rand + 1; }
		}
		if( bstart )	{
			_istate = 1;
			this.play( sbase + "start" + sdir );
		} else {
			this.setframe( sbase + (iloscsek>0?"1"+sdir:sdir), 0 );
			this.herostart();
		}
	}
	playspec2(string sact, string sobfin, string sfinfun)	{
		string s = ( sact.length()<2 ) ? "" : sact.strsube(2);
		this.playspec( s, 0, 0, false, null, null, false, sobfin, sfinfun, sact.gete(0,2));
	}
	herostop()	{
		_istate = 3;
		if( _bplaystop )	{
			_bplaystop = false;
			this.thisfinish(true);
			this.play( _sbase + "stop" + this.getdir() );
		} else {
			this.stop(true);
		}
	}
	herostart()	{
		_istate = 2;
		this.play( _sbase + (_iiloscsek>0 ? idsort : "") + this.getdir() );
	}
	herofinish()	{
		if( _istate==2 && bthisfin )	_istate=3;
		if (_istate==0 )	{		// standardowy finish
			this.herostand();	// 28.V.2006
			this.onstdfinish();
// 			this.< this.getname() + "_FINISH">();
			string sanimo = this.getname();
			string sevent = <sanimo>.actionname();
			this.<sanimo+"_FINISH">();
			this.<sanimo+"_ACTION_"+sevent+"_FINISH">();
		} else if( _istate==1)	{
			this.herostart();
			this.callfun(_sobstart,_sfunfinstart);
		} else if( _istate==2 )	{
			string s;
			if( _iiloscsek > 0 )	{
				if( _itypsort==0)	{	idsort = (idsort%_iiloscsek)+1;	}
				else if (_itypsort==1)	{	idsort = _iiloscsek.rand + 1; }
				s = _sbase + idsort + this.getdir();
			} else s = this.actionname();
			this.play( s );
		} else if ( _istate==3 )	{		// koniec stop
			_istate = 0;
			this.herostand();	// 28.V.2006
			this.thisfinish(true);
			this.callfun(_sobfin,_sfinfun);
		}
	}
	herostand()	{
		string s = _sstndpref + this.getname();
		if( engine.varexist(s) )	{
			this.play( _sstandbase + this.actionname()->gete(0,2) );
			<s>.play();
		}
	}
	heroendframe1()	{	this.< this.getname() + "_ENDFRAME" >();	}
	heroendframe()	{
		this.setz( this.getposy()-clcamera.getposy );
		if( this.haspocket() )	{
			<this.getpocket()>.pocketpos( this.getposx(), this.getposy() - this.geth()/2);
		}
		this.< this.getname() + "_ENDFRAME" >();
	}
}

/******************************************************/

class classadvhero 	{
	init()	{
		new string _sanim;		// podlinkowana animacja
		new bool _bisvecile = false;	// czy operacja sklada sie z kawalkow
		
		new string _sbase = null;		// bazowa nazwa akcji
		new string _sbase2 = null;
		new int izakres = 0;		// length of string _sbase
		
		new string _sbs2;
		new string _sbutoper;
		new string _smetpart;
		
		new string _simgbut;	// button z ktorego czyta dane
		new string _sptfname = this.getname();
	}
	string getptfname()	{	return _sptfname;	}
	public link(string sanim)	{	_sanim = sanim;	}
	public link2(string sanima, string sbase)	{
		this.link(sanima);
		this.checkamounts( sbase );
	}
	public anstand()	{	<_sanim>.play("stand"+this.getdir());	}
	public ansay()		{	<_sanim>.play("talk"+this.getdir());	}
	public string getdir()	{	<_sanim>.actionname()->gete(0, 2);	}
	public int nofpieces()	{	return this.nofpiecesdir( this.getdir() ); }
	public int nofpiecesdir(string sdir)	{return _bisvecile ? vecile.get( vecdirs.find(sdir) ) : 0;	}
	public setbase2(string sbase, string sbase2)	{
		this.setbase(sbase);
		_sbase2 = sbase2;
	}
	public setbase(string sbase)	{
		_sbase = sbase;
		izakres = sbase.length();
	}
	public getpropdir(string sdir)	{	return sdir=="auto" ? this.getdir() : sdir;	}
	/*****************************/
	_buildamounts()	{
		if( !_bisvecile )	{
			_bisvecile = true;
			new vector vecdirs;
			vecdirs.type("string");
			vecdirs.beginadd("begin", "uu", "ru", "rr", "rd", "dd", "ld", "ll", "lu" );
			new vector vecile;
		}
	}
	_clearvecile()	{
		vecile.free();
		vecile.resize( 8, 0 );
	}
	public checkamounts(string sbase)	{
		this.setbase(sbase);
		this._buildamounts();
		this._clearvecile();
		if( _sanim == null )	return;
		int ile = <_sanim>.nofactions();
		string s1, int i1;
		
		for(int  i=0; i < ile; i++)	{
			s1 = <_sanim>.nameofaction(i);
			if( s1.getb(0,izakres) == sbase )	{
				i1 = s1.getb( izakres, 10 );
				if( i1>0 )	{	// jest kolejna animacja gadania
					vecile.vecinc( vecdirs.find( s1.gete(0,2) ) );
				}
			}
		}
	}
	public getanim	{	_sanim;	}
	/********************************/
	virtual calllastfun()	{
		this.< this.getcallfin() >();
		<_simgbut>.checkonce;
	}
	_calllastfunfin()	{
		this.calllastfunfin();
		this.advmsunlock();
	}
	virtual calllastfunfin()	{	this.< this.getcallfin() + "_FINISH" >();	}
	virtual string getcallfin()	{	return _sanim+_smetpart+_sbutoper;	}
	_cplay(string sbase, string sfun, string sdir)	{
		this.advmslock();		// blokuj mysz
		<_sanim>.thisfinish(true);
		if( sbase==null )	{
			<_sanim>.setdir( .getpropdir(sdir) );
			if( sfun!=null )	this.<sfun>();
		} else {
			<_sanim>.playspec( sbase, 0, 0, false, null, null, false, 
				this.getname(), sfun, this.getpropdir(sdir) );
		}
	}
	_cplay1(string sbase, string sdir)	{	this._cplay(sbase,"_cplay1_2", sdir);	}
	_cplay1_2()	{
		this.calllastfun();
		this._callbehs();
	}
	_callbehs()	{
		this.advmsunlock();
		this.callbehs();
	}
	virtual callbehs()	{
		string s = this.getcallfin();
		this.behexist("beh_"+s) ? this.playbehobfin( "beh_" + s, this.getname(), "_calllastfunfin" ) : this._calllastfunfin();
	}
	_cplay2_2()	{
		this.calllastfun();
		this._cplay(_sbs2, "_callbehs", this.getdir() );
	}
	_cplay2(string sbase1, string sbase2, string sdir)	{
		_sbs2 = sbase2;
		this._cplay(sbase1, "_cplay2_2", sdir);
	}
	bool no_turn(string sfun)	{
		string sptf = _spathpref + _sanim;
		string sdir = .getpropdir( <_simgbut>.getbutdir );
		if( engine.varexist(sptf) && .getdir != sdir )	{
			<sptf>.heroturn(sdir, this, sfun);
			false;
		} else true;
	}
	_heroplay1	{	.heroplay1(_simgbut);	}
	_heroplay2	{	.heroplay2(_simgbut);	}
	public heroplay1(string simg)	{
		_simgbut=simg;
		if( .no_turn("_heroplay1") )	{
			_sbutoper = <simg>.getbutname();
			this._cplay1( <simg>.getbase1(), this.getpropdir( <simg>.getbutdir() ) );
		}
	}
	public heroplay2(string simg)	{
		_simgbut=simg;
		if( .no_turn("_heroplay2") )	{
			_sbutoper = <simg>.getbutname();
			this._cplay2( <simg>.getbase1(), <simg>.getbase2(), this.getpropdir( <simg>.getbutdir() ) );
		}
	}
	_setbase2(string styp)	{	this.setbase2( modadv.get(styp,1), modadv.get(styp,2) );	}
	_setbase(string styp)	{	this.setbase( modadv.get( styp, 1 ) );	}
	public heroplay3(string simg, string sb)	{
		<simg>.setbutbase1(modadv.get(sb,1));
		<simg>.setbutbase2(modadv.get(sb,2));
		this.heroplay2(simg);
	}
	/********************************/
}

/******************************************************/
new snd _fxtakeitem;
class classherotaker : classadvhero	{
	init() {
		classadvhero::init();
		_smetpart = "_PICKUP_";
	}
	public herotake(string simg)	{	this.heroplay2(simg);	}
	virtual calllastfun()	{
		if( <_sanim>.haspocket() )	{
			_fxtakeitem.play;
			if( <_simgbut>.hideontake )
				<_simgbut>.hide();		// zabranie przedmiotu
			else <_simgbut>.setbuttyp("but");
			< <_sanim>.getpocket() >.additem( _sbutoper, <_simgbut>.getpocket );
		}
		classadvhero::calllastfun();
	}
}

/******************************************************/

class classherolooker : classadvhero	{
	init()	{
		classadvhero::init();
		_smetpart = "_OPERATE_";
	}
	public herolook(string simg)	{	this.heroplay2(simg);	}
	public herooperate(string simg)	{	this.heroplay2(simg);	}
	public heroopendoor(string simg)	{	this.heroplay3(simg,"open:");	}
	public heroclosedoor(string simg)	{	this.heroplay3(simg,"close:");	}
}

/******************************************************/

class classherouser : classadvhero	{
	init()	{
		classadvhero::init();
		new string _stool;
	}
	public herouse(string stool, string simg)	{
		//_stool = this.getusetool();
		_stool = stool;
		_smetpart = "_USE_"+_stool+"_ON_";
		< <_sanim>.getpocket() >.itemhide();
		//this.heroplay2(simg);
		_simgbut=simg;
		_sbutoper = <simg>.getbutname();
		this._cplay2( <simg>.baseuse1, <simg>.baseuse2, this.getpropdir( <simg>.getbutdir() ) );
	}
	virtual calllastfun()	{
		this.< _sanim + "_USE_" + _stool>();
		this.< _sanim + "_USE_ON_" + _sbutoper>();
		this.< this.getcallfin() >();
	}
	virtual calllastfunfin()	{
		this.< _sanim + "_USE_" + _stool + "_FINISH">();
		this.< _sanim + "_USE_ON_" + _sbutoper + "_FINISH">();
		this.< this.getcallfin() + "_FINISH" >();
	}
	virtual callbehs()	{
		string s = this.getname();
		if( this.behexist( "beh_" + this.getcallfin() ) )	{
			this.playbehobfin( "beh_" + this.getcallfin(), s, "_calllastfunfin" );
		} else  if( this.behexist( "beh_" + _sanim + "_USE_ON_" + _sbutoper ) )	{
			this.playbehobfin( "beh_" + _sanim + "_USE_ON_" + _sbutoper, s, "_calllastfunfin" );
		} else  if( this.behexist( "beh_" + _sanim + "_USE_" + _stool ) )	{
			this.playbehobfin( "beh_" + _sanim + "_USE_" + _stool, s, "_calllastfunfin" );
		} else if ( this.behexist( "beh_"+_sanim+"_USE" ) )	{
			this.playbehobfin( "beh_" + _sanim + "_USE", s,"_calllastfunfin" );
		} else {
			this._calllastfunfin();
		}
	}
}

/******************************************************/
/**	metody rozpoczynajace sie na "c" sa metodami klasy, natomiast na "ob" dotycza obiektu "pathf" **/

class classpathf : classadvhero	{
	init()	{ 
		classadvhero::init();
		new path ptf;
		new string swalkto = null;
		new string _sfunnopath = null;
		new string _sfunvisit = null;
		new int destx;	// dla startgo
		new int desty;	// jezeli jest startgo
		new bool bzmien = false;
		new bool bzatrzym = false;
		new string _sitem=null;
		new string _sobzmien = null;
		new string _sfunzmien = null;
		new int _istep;
		new int _itmpspeed;
		ptf.addmethod("onfinish", "_cptffin");
		ptf.addmethod("onvisit","_cptvisit");
		this.addsigs("_cptfstdreach", "_cptfstdarrive");
		this._setbase( "go:" );
	}
	_buildan(string san)	{
		ptf.linkanima(san);
		this.link(san);
	}
	public build(string san, string sfile, int x, int y, int istep, int ityp)	{
		_istep = istep;
		ptf.build(sfile, x, y, istep, ityp);
		this._buildan(san);
	}
	public buildfrom(string san, string spathf, int istep)	{
		_istep = istep;
		ptf.copy(spathf, istep );
		this._buildan(san);
	}
	public addsigs(string sreach, string sarrive)	{
		if(sreach!=null)	{
			ptf.addmethod("onreach", sreach);
		}
		if(sarrive!=null)	{
			ptf.addmethod("onarrive", sarrive);
		}
	}
	public sigonnopath(string snopath)	{	_sfunnopath = snopath;	}
	public sigonvisit(string svisit)	{	_sfunvisit = svisit;	}
	_cptfstdreach(string s)	{}
	_cptfstdarrive()	{}
	/************************** funkcje dla pathf ***************************************/
	public move(int x, int y)	{	ptf.move( x, y );	}
	public setpos(int x, int y)	{	ptf.setpos(x,y);	}
	public show()	{	ptf.show();	}
	public hide()	{	ptf.hide();	}
	public enable(int id)	{	ptf.enable(id);	}
	public disable(int id)	{	ptf.disable(id);	}
	public setanstep(int istep)	{	_istep=istep; ptf.setanstep(istep);	}
	public mulspeed(int speed)	{	_itmpspeed=speed*_istep; ptf.setanstep(_itmpspeed);	}
	public retstep	{	.setanstep(_istep);	}
	public int getanstep()	{	return _istep;	}
	public int getposx()	{	return ptf.getposx(); }
	public int getposy()	{	return ptf.getposy(); }
	public int getpx()	{	return ptf.getpx(); }
	public int getpy()	{	return ptf.getpy(); }
	public int getidan()	{	return ptf.getidan(); }
	public int getidan2()	{	return ptf.getidan2(); }
	public int getidgo()	{	return ptf.getidgo(); }
	public int getidanpath()	{	return ptf.getidanpath(); }
	public int getidan2path()	{	return ptf.getidan2path(); }
	public int getidgopath()	{	return ptf.getidgopath(); }
	public excludev(int id)	{	ptf.excludev(id);	}
	public linkfilter()	{	ptf.linkfilter();	}
	public unlinkfilter()	{	ptf.unlinkfilter();	}
	public unlinkanima()	{	ptf.unlinkanima();	}
	public linkanima(string san)	{ ptf.linkanima(san);	}
	public setscalepower(real rs)	{	ptf.setscalepower(rs);	}
	public setzsize(real rs)	{	ptf.setzsize(rs);	}
	public bool iswayto(int x, int y)	{	return ptf.iswayto(x,y);	}
	public scalean()	{	ptf.scalean();	}
	public int getfromver(int ifrom, int ile, int ito)	{	return ptf.getfromver(ifrom,ile,ito);	}
	public int getgover(int ile)	{	return ptf.getgover(ile);	}
	public int getanver(int ile)	{	return ptf.getanver(ile);	}
	public int getxver(int id)	{	return ptf.getxver(id);	}
	public int getyver(int id)	{	return ptf.getyver(id);	}
	public int getbyname(int idpath)	{	return ptf.getbyname(idpath);	}
	public walkbase(string sb)	{	ptf.setbase(sb);	}
	public letturn(int id)	{ ptf.letturn(id);	}
	public bool canturn	{	ptf.canturn;	}
	public string vecdir(int x, int y)	{	ptf.vecdir(x,y);	}
	public int ptfgoto(int x, int y)	{	ptf.goto( x, y );	}
	/*****************************************************************/
	public walkto2(string simg, int x, int y)	{
		swalkto = simg;
		if( this.cangoto(x,y) )	{
			x = ptf.goto( x, y );
		} else if ( _sfunnopath!=null )	{
			this.<_sfunnopath>();
		}
	}
	public int walkto(string simg, int x, int y)	{
		swalkto = simg;
		.letturn( simg == null );
		if( this.iswalking() )	{
			if( ptf.iswayto(x,y) )	{
				bzmien = true;
				destx = x;
				desty = y;
				return 0;
			} else {
				bzatrzym = true;
				return -1;
			}
		} else {
			return ptf.goto( x, y );
		}
	}
	public int goto(int x, int y)	{
		return this.walkto( null, x, y );
	}
	public int gotorel(int x, int y)	{
		return this.goto( <_sanim>.getpx() + x, <_sanim>.getey() + y );
	}
	public turn(string sdir)	{	ptf.turn(sdir);	}
	public int iswalking()	{	return ptf.iswalking();	}
	public stand()	{	ptf.stand(); 	}
	public stop(bool bstop)	{	ptf.stop(bstop);	}
	public int getidpath(int x, int y)	{	return ptf.getidpath( x, y);	}
	public bool cangoto(int x, int y)	{
		int id = ptf.getidpath(x,y);
		return id == -1 ? false : ptf.isenabled(id);
	}
	/************** wyjscia do zaawansowanego chodzenia ***********************/
	_cptfreachpocket()	{
		<this.getptfname()+"look">.herolook(swalkto);
	}
	_cptfreachbut()	{
		<this.getptfname()+"look">.herolook(swalkto);
	}
	_cptfreachdoors()	{
		<this.getptfname()+"look">.herooperate(swalkto);
	}
	_cptfreachitem()	{
		<this.getptfname()+"take">.herotake(swalkto);
	}
	_cptfherofin()	{
		this.herostand();
		if( swalkto!=null )	{
			this.<_sanim + "_REACH_" + <swalkto>.getbutname() >();	
			if( this.ismainhero( _sanim ) )	{
				string s = null;
				if( <_sanim>.haspocket() )
					s = < <_sanim>.getpocket()>.getitem();
				if( s!=null )	{
					<this.getptfname()+"use">.herouse(s,swalkto);
				} else {
					this.< "_cptfreach" + <swalkto>.gettyp() >();
				}
			}
			swalkto=null;
		} else {
			this.<_sanim+"_ARRIVE">();
			this._cptheroendpath();
		}
	}
	sigonzmien(string sob, string sfun)	{	_sobzmien=sob;	_sfunzmien=sfun;	}
	_cptheroendpath()	{
		this.callfun(_sfinob, _sfinfun );
		if( _bylfin )	_bylfin=false;
		else {
			_sfinfun = null;
			_sfinob = null;
		}
	}
	_cptfnopath()	{	this.< _sanim+"_NOPATH">();	}
	_cptfvisit()	{	this.<_sanim+"_VISIT">();	}
	public prepareforhero()	{
		ptf.addmethod("onfinish", "_cptfherofin");
		new string _sfinob;
		new string _sfinfun;
		new bool _bylfin;
		this.sigonnopath("_cptfnopath");
		this.sigonvisit("_cptfvisit");
	}
	public herowalkto2(int x, int y, string sob, string sfinfun)	{
		this.herowalkto(null,x,y,sob,sfinfun);
	}
	public herowalkto(string simg, int x, int y, string sob, string sfinfun)	{
		<_sstndpref + _sanim>.stop();		// wylaczenie standera
		_sfinob = sob;
		_sfinfun = sfinfun;
		if( sfinfun!=null )	_bylfin = true;
		if( this.walkto(simg, x,y)==-1 )	{
			//this.callfun(sob,sfinfun);
			//engine.print(this.getname() + " nie ma przejscia do " + simg + " call:"+sob+"."+sfinfun);
		}
	}
	public heroturn(string sdir, string sob, string sfinfun)	{
		_sfinob = sob;
		_sfinfun = sfinfun;
		if( sfinfun!=null )	_bylfin = true;
		.turn(sdir);
	}
	public advgoto(int x, int y)	{
		this.herowalkto2(x,y,null,null);
	}
	public advwalkto(string simg, int x, int y)	{
		this.herowalkto(simg,x,y,null,null);
	}
	public advvisit(string simg)	{
		if( <simg>.reachable() )
			this.advwalkto( simg, <simg>.getgox(), <simg>.getgoy() );
	}
	public herostand()	{
		.retstep;
		this.stand();
		<_sanim>.herostand();
	}
	public stophero	{
		.herostand;
		bzatrzym = true;
	}
	/*****************************************************************/
	_cptvisit()	{
		this.<_sfunvisit>();	// zmienione 27 vi 2008
		if( bzmien )	{
			bzmien = false;
			if( this.goto(destx, desty)==-1 )	{
				this.<_sfunnopath>();
			} else {
				.callfun(_sobzmien, _sfunzmien);
			}
		} else if (bzatrzym)	{
			bzatrzym=false;
			this.stop(true);
		} /*else {
			this.<_sfunvisit>();
		}*/
	}
	_cptffin()	{
		if( swalkto!=null )	{
			ptf.onreach(swalkto);		// dotarcie do zadanego obiektu
			swalkto=null;
		} else {
			ptf.onarrive();		// dotarcie do punktu
		}
	}
	/**********************/
	anposx	{	<_sanim>.getposx;	}
	anposy	{	<_sanim>.getposy;	}
	bzmien	{	bzmien;	}
	bzmien=(bool b)	{	bzmien = b;	}
}

class classwalkerqueue	{
	init()	{
		new timer timwq;
		timwq.settick(1);
		timwq.setcycle(1);
		timwq.addmethod("onfinish","_timwqfin");
		new vector vecpt;
		vecpt.type("string");
		new int iverlen = 1;
		new int igox;
		new int igoy;
		new string _simg;
		new bool bniezmien = true;
	}
	_timwqfin()	{
		this.checkqueue();
		this.play();
	}
	public start()	{
		//timwq.play();
	}
	int ptpos(string spt)	{	vecpt.find(spt);	}
	public remove(string spt)	{
		int id = .ptpos(spt);
		if( id>=0 )	{
			if( id==0 )	{
				<vecpt.first>.sigonzmien(null, null);
				vecpt.removeat(0);
				if( vecpt.size )
					<vecpt.first>.sigonzmien(this, "ptzmien");
			} else vecpt.removeat(id);
		}
	}
	public stop()	{	timwq.stop(false);	}
	public add(string spt)	{
		_ = <spt>.iswayto( <spt>.anposx, <spt>.anposy );
		vecpt.add(spt);
		if( vecpt.size==1 )
			<vecpt.first>.sigonzmien(this, "ptzmien");
	}
	ptzmien	{
		// zapisz stan: bzmien
		bniezmien = false;
		.walkto(_simg, igox+clcamera.getposx, igoy+clcamera.getposy);
		<vecpt.first>.bzmien = (false);
		bniezmien = true;
	}
	public goto(int x, int y)	{
		this.walkto(null,x,y);
	}
	public visit(string simg)	{
		if( <simg>.reachable() )
			this.walkto(simg, <simg>.getgox(), <simg>.getgoy() );
	}
	public setverlen(int ilen)	{	iverlen = ilen;	}
	public stand	{
		for( int i=0; i<vecpt.size; i++)	{
			<vecpt.get(i)>.stop(false);
			<vecpt.get(i)>.herostand;
		}
	}
	public mulspeed(int ile)	{
		for( int i=0; i<vecpt.size; i++)	<vecpt.get(i)>.mulspeed(ile);
	}
	public walkto(string simg, int x, int y)	{
		igox = x - clcamera.getposx;
		igoy = y - clcamera.getposy;
		_simg = simg;
		iverlen = 1;
		
		int ile = vecpt.size();
		if( ile<=0 )	{	return;	}
		string sfirst = vecpt.first;
		<sfirst>.advwalkto( simg, x, y );
		int i[2], string s;
		//i1 = <sfirst>.getidgo;
		for( int i=1; i<ile; i++ )	{
			s = vecpt.get(i);
			i1 = <sfirst>.getidgo;
			if( bniezmien )	{
				i0 = <sfirst>.getgover(iverlen);
			} else {
				<s>.advwalkto( simg, x, y );
				i0 = <s>.getgover(i*iverlen);
			}
			
			if( i0<0 ) {
				i0 = <sfirst>.getgover(iverlen);
				if( i0<0 ) i0 = <sfirst>.getidan;
			}
			if( i0==i1 && bniezmien ) i0=-1;
			sfirst = s;
			if( i0 >= 0 )	{
				<s>.advwalkto( null, <s>.getxver(i0), <s>.getyver(i0) );
			} else {
				<s>.stop(false);
				<s>.herostand();
			}
		}
		/*for( i=0; i<ile; i++)	{
			for(i0=i+1; i0<ile; i0++)	{
				s = vecpt.get(i);
				s2 = vecpt.get(i0);
				if( <s>.iswalking && !<s2>.iswalking && <s>.getidgopath==<s2>.getidgopath)	{
					<s>.stop(false);
					<s>.herostand;
					//i1 = <s>.getidanpath;;
					//<s>.advwalkto( simg, <s>.getxver(i1), <s>.getyver(i1) );
				}
			}
		}*/
		/*int j, string s;
		for( int i=0; i<ile; i++)	{
			s = vecpt.get(i);
			<s>.advwalkto(simg,x,y);
			for( j=i+1; j<ile; j++)	{
				<vecpt.get(j)>.excludev( <s>.getidgo() );
			}
		}*/
	}
	public checkqueue()	{
		int ile = vecpt.size();
		if( ile<=1 )	{	return;	}
		int j, string s[2], int ian, int ian2;
		for( int i=0; i<ile; i++)	{
			s0 = vecpt.get(i);
			if( <s0>.iswalking() )	{
				ian = <s0>.getidan();
				ian2 = <s0>.getidan2();
				for( j=i+1; j<ile; j++)	{
					s1 = vecpt.get(j);
					if( <s1>.iswalking() )	{
						<s1>.excludev( ian );
						<s1>.excludev( ian2 );
					}
				}
			}
		}
	}
}



class classstndgroup	{
	init()	{
		new gmobjvec grstnd;
	}
	public pause()	{
		grstnd.eval("lock");
		this.stop();
	}
	public resume()	{
		if( igmstate==0 )	{
			grstnd.eval("unlock");
			this.play();
		}
	}
	public add(string sstander)	{	grstnd.add(sstander);	}
	public remove(string sst)	{	grstnd.remove(sst);	}
	public stop()	{	grstnd.eval("stop");	}
	public play()	{	grstnd.eval("play");	}
	public reset()	{	grstnd.eval("reset");}
}

class classadvstander : classlocker 	{
	init()	{
		classlocker::init();
		new timer timstand;
		timstand.settick(1);
		timstand.delay(20000);
		timstand.addmethod("onfinish", "_timstandfin");
		
		new string sanim = this.getname();
		sanim = sanim.strsubbs( _sstndpref );
		
		new string _sbeh = "beh_" + sanim + "_IDLE";
		
		modstnd.add( this.getname() );
	}
	_timstandfin()	{
		string s = gameapi.getgamename();
		if( <s>.behexist( _sbeh )  && !this.getlock() )	<s>.playbeh( _sbeh );
	}
	public play()	{	if( !this.getlock() && !timstand.isplaying() )	timstand.play();	}
	public stop()	{	timstand.stop(false);	}
	public setdelay(int idelay)	{	timstand.setdelay(idelay);	}
	public reset()	{	this.stop();	this.play();	}
}


/*
	klasa obslugujaca "rozmawianie" postaci
	Dominik Dagiel	3 III 2006
*/

class classtalker : classadvhero	{
	init()	{
		classadvhero::init();
		this._setbase( "talk:" );
		
		new snd sndtalk;
		sndtalk.setstartstopflag(false, true);
		sndtalk.addmethod("onfinish", "_ctalkfin");
		
		new timer timtalk;
		timtalk.settick(1);
		new real rdelay = 1.0;
		timtalk.addmethod("onfinish","_ctalkfin");
		
		new gmimgvec txttalk;
		new int _iletxt=10;
		string s;
		for( int i=0; i<_iletxt; i++ )	{
			s = "txttalk"+i;
			new text <s>;
			txttalk.add(s);
		}
		new font fonttalk;
		txttalk.hide();
		new vector vecpom;
		vecpom.type("string");
		new int iTxtLim = 30;
		new int irtxt;
		new int igtxt;
		new int ibtxt;
		new string stextdb;		// baza z tekstem do mowienia
		new string _swav;
		
		this.buildfullname();
		
		new string stalktype;
		this.settalktype("snd");	// typ: (snd, txt, film) -> kombinacje
	}
	public set(string san)	{
		this.link(san);
	}
	public settextdb(string s)	{	stextdb=s;	}
	public setfont(string sfile, int size)	{
		fonttalk.load(sfile,size);
		txttalk.eval1("setfont","fonttalk");
	}
	public setsnd(string sfile)	{
		if( !sfile.contains(".wav") )	{
			_swav = sfile;
			sfile+=".wav";
		} else {
			_swav = sfile.strsubes(".wav");
		}
		sndtalk.load( this.getsndpath() + sfile );
	}
	public herosay1(string sfinfun)	{
		this.herosay(1, true, true, null, sfinfun );
	}
	public herosay(int itypsort, bool bstart, bool bstop, string sobfin, string sfinfun)	{
		this.herosaydir( itypsort, bstart, bstop, sobfin, sfinfun, this.getdir() );
	}
	public herosaydir(int itypsort, bool bstart, bool bstop, string sobfin, string sfinfun, string sdir)	{
		<_sanim>.thisfinish(false);
		if( !bstart )	{
			<_sanim>.playspec(_sbase, this.nofpiecesdir(sdir), itypsort, bstart, null, null,
					bstop, sobfin, sfinfun, sdir);
			this.<stalktype>();
		} else {
			<_sanim>.playspec(_sbase, this.nofpiecesdir(sdir), itypsort, bstart, this.getfullname(), "_ctalkstart",
					bstop, sobfin, sfinfun, sdir);
		}
	}
	public thisfinish(bool bthisfin)	{	<_sanim>.thisfinish(bthisfin);	}
	public stop(bool b)	{
		if( stalktype.contains("snd") )	{
			sndtalk.stop(b);
			timtalk.stop(false);
		} else {
			timtalk.stop(b);
		}
	}
	public settalktype(string stype)	{
		stalktype = "_cplay";
		if( stype.contains("snd") )	stalktype += "snd";
		if( stype.contains("txt") )		stalktype += "txt";
		if( stype.contains("film") )	stalktype += "film";
	}
	_csay()	{
		if( stextdb!=null )	{
			int id = <stextdb>.findbyrow(_swav);
			if( id<0 )	{	return;	}
			
			vecpom.vecbuildfromstring( <stextdb>.get(id,2), " " );
			string s="", int itlk=0, int x, int y;
			if( stalktype.contains("txt") )	{
				x = <_sanim>.getcx();
				y = <_sanim>.getpy();
			} else {
				x = 400;
				y = 590;
			}
			int x1=0, int x2=iResX, int y1=0, int y2=iResY;
			string s1;
			for( int i=0; i<vecpom.size(); i++)	{
				s+=vecpom.get(i)+" ";
				if( s.length()>iTxtLim )	{
					s1 = "txttalk"+itlk;
					<s1>._cprinttxt(s,x,y,itlk);
					if( <s1>.getpx() < x1 )	{	x1=<s1>.getpx();	}
					if( <s1>.getex() > x2 )	{	x2=<s1>.getex();	}
					if( <s1>.getpy() < y1 )	{	y1=<s1>.getpy();	}
					if( <s1>.getey() > y2 )	{	y2=<s1>.getey();	}
					s="";
					itlk++;
				}
			}
			if( s.length()>0 )	{
				s1 = "txttalk"+itlk;
				<s1>._cprinttxt(s,x,y,itlk);
				if( <s1>.getpx() < x1 )	{	x1=<s1>.getpx();	}
				if( <s1>.getex() > x2 )	{	x2=<s1>.getex();	}
				if( <s1>.getpy() < y1 )	{	y1=<s1>.getpy();	}
				if( <s1>.getey() > y2 )	{	y2=<s1>.getey();	}
				itlk++;
			}
			x2-=iResX;
			y2-=iResY;
			if( x1>0 )	{	x1=0;	}
			if( y1>0 )	{	x1=0;	}
			txttalk.move(0-x1+x2, -itlk*txttalk0.geth()-y1+y2 );
			if( txttalk0.getpy()<0 )	{
				txttalk.move(0,-txttalk0.getpy());
			}
			timtalk.delay( rdelay*500*vecpom.size() );
		}
	}
	_cprinttxt(string s, int x, int y,int id)	{
		this.set(s);
		this.createtxt(irtxt,igtxt,ibtxt);
		this.setpos( x-this.getw()/2, y+id*this.geth() );
		this.setz(2000);
		this.show();
	}
	public _cplaysnd()	{
		sndtalk.play();
	}
	public _cplaysndtxt()	{
		sndtalk.play();
		this._csay();
	}
	public _cplaysndtxtfilm()	{
		sndtalk.play();
		this._csay();
	}
	public _cplaysndfilm()	{
		this._csay();
	}
	public _cplaytxt()	{
		this._csay();
		timtalk.play();
	}
	public _cplaytxtfilm()	{
		this._csay();
		timtalk.play();
	}
	public _cplayfilm()	{
		this._csay();
		timtalk.play();
	}
	/******  do tekstu pisanego ****************************/
	public setdelay(real r)	{	rdelay=r;	}
	public settxtcolor(int r, int g, int b)	{
		irtxt=r;	igtxt=g;	ibtxt=b;
	}
	/**********************************/
	_ctalkstart()	{
		this.<stalktype>();
	}
	_ctalkfin()	{
		txttalk.hide();
		<_sanim>.herostop();
	}
	/**********************************/
}

class classtxttalker : classadvhero	{
	init()	{
		classadvhero::init();
		this._setbase( "talk:" );
		
		new int iR;
		new int iG;
		new int iB;
		new int ibR;
		new int ibG;
		new int ibB;
		new int ibA;
		new int ibrr;
		new int ibrg;
		new int ibrb;
		new int ibra;
		new int ibw;
		new db dbtxt;
		new int iSize;
		new gmimgvec grtxt;
		new gmimgvec grtxt2;
		string s;
		for( int i=0; i<25; i++ )	{
			s = "txt"+i;
			new text <s>;
			grtxt.add(s);
			<s>.hide();
		}
		new text imgtxt;
		imgtxt.hide();
		
		new bool bplaying = false;
		
		new string slang;
		this.setlang("pol");
	}
	public setlang(string s)	{	slang = s;	}
	public bool isplaying()	{	return bplaying;	}
	public setfont(string sfont)	{
		grtxt.eval1("setfont",sfont);
		iSize = <sfont>.getsize();
	}
	public setfontcolor(int ir, int ig, int ib)	{
		iR=ir; iG=ig; iB=ib;
	}
	public setfontbg(int ibr, int ibg, int ibb, int iba)	{
		ibR=ibr; ibG=ibg; ibB=ibb; ibA=iba;
	}
	public setbgframe(int iw, int ir2, int ig2, int ib2)	{
		ibrr = ir2; ibrg = ig2; ibrb = ib2; ibra=255; ibw=iw;
	}
	public set(string san, int iz)	{
		this.link(san);
		grtxt.setz(iz);
		imgtxt.setz(iz-1);
	}
	public herosay(string sfile, int x, int y)	{
		this.herosaydir(sfile,x,y,this.getdir());
	}
	public herosaydir(string sfile, int x, int y, string sdir)	{
		if( sdir=="auto")	{	sdir=this.getdir();	}
		bplaying = true;
		dbtxt.load( this.getgraphpath() + sfile + "." + slang);
		string s;
		grtxt2.free();
		int iw=0;
		int ile = dbtxt.getrowsno();
		for( int i=0; i<ile; i++)	{
			s = "txt"+i;
			<s>.set( dbtxt.get(i,0) );
			<s>.createtxt(iR, iG, iB);
			<s>.setpos(x,y);
			y+=iSize;
			<s>.show();
			if( <s>.getw()>iw)	{	iw=<s>.getw();	}
			grtxt2.add(s);
		}
		imgtxt.setbkg(txt0.getpx()-iSize/2, txt0.getpy()-iSize/2, iw+iSize, iSize*(ile+1), ibR, ibG, ibB, ibA );
		imgtxt.setborders(ibw,ibrr,ibrg,ibrb,ibra);
		imgtxt.show();
		if( _sanim!=null )	{
			<_sanim>.thisfinish(false);
			<_sanim>.playspec(_sbase, 0, 0, false, null, null,
					false, null, null, sdir);
		}
	}
	public stop()	{
// 		if( bplaying==false )	{	return;	}
		bplaying = false;
		grtxt2.hide();
		imgtxt.hide();
		if( _sanim!=null )	{
			<_sanim>.thisfinish(true);
			<_sanim>.play("stand" + this.getdir());
		}
	}
}



/*
	klasy obslugujace plany tla oraz kamere 
*/

class classbgplan : gmobjvec {
	init() {
		gmobjvec::init;
		new real rpx;
		new real rpy;
		new real scalex;
		new real scaley;
		new int _ix;
		new int _iy;
	}
	public setscale(real rsx, real rsy)	{	|scalex, scaley| = rsx, rsy;	}
	public move(real x, real y)	{
		rpx+=x;	rpy+=y;
		int ix = rpx, int iy = rpy;
		rpx-=ix;	rpy-=iy;
		if( ix || iy )	{
			_ix += ix;
			_iy += iy;
			gmobjvec::move(ix,iy);
		}
	}
	public movebgr(real x, real y)	{	.move( scalex*x, scaley*y );	}
	int getpx	{	_ix;	}
	int getpy	{	_iy;	}
}

class classgrplans : gmobjvec	{
	init()	{
		gmobjvec::init();
		new real _rxp;
		new real _ryp;
	}
	public move(real x, real y)	{
		_rxp += x;	_ryp += y;
		this.eval2("movebgr",x,y);
	}
	public real getposx()	{	return _rxp;	}
	public real getposy()	{	return _ryp;	}
	public shift(int x, int y)	{
		_rxp+=x;	_ryp+=y;
		this.eval2("move",x,y);
	}
}

class CameraPos	{
	init(int x, int y)	{
		new int _x;
		new int _y;
		.setpos(x,y);
	}
	setpos(int x, int y)	{ _x=x; _y=y;	}
	getposx	{	_x;	}
	getposy	{	_y;	}
}

class classadvcamera	{
	init()	{
		new classgrplans grbgrs;
		new string sancamera=null;
		new string smsmvfun = null;
		|new real _rxmod, new real _rymod| = 0.05, 0.05;
		|new real rleft, new real rtop, new real rright, new real rbottom| = 0.0, 0.0, iResX-1, iResY-1;
		|new int icamx, new int icamy| = 400, 300;
		|new real rborx, new real rbory| = iResX-1, iResY-1;
		new real _lastx = 0;
		new real _lasty = 0;
		new string _sfunxedge = null;
		new string _sfunyedge = null;
		new CameraPos _campos(0,0);
		
		new timer timcamera;
		timcamera.settick(1);
		timcamera.setcycle(1);
		timcamera.addmethod("onfinish","_camerafin");
	}
	_camerafin()	{
		this.checkcamera();
		this.play();
	}
	public remove(string sob)	{	for( int i=0; i< grbgrs.size; i++)	<grbgrs.get(i)>.remove(sob);	}
	public funxedge(string sfun)	{	_sfunxedge=sfun;	}
	public funyedge(string sfun)	{	_sfunyedge=sfun;	}
	public setcenter(int x, int y)	{	| icamx, icamy | = x, y;	}
	public setborders(int x, int y){	|rright, rbottom| = x, y;	}
	public countcenter	{	.setcenter( (rright-rleft)/2, (rbottom-rtop)/2 );	}
	public real getposx()	{	return grbgrs.getposx();	}
	public real getposy()	{	return grbgrs.getposy();	}
	public setmetonmsmove(string s)	{	smsmvfun=s;	}
	public start()	{	timcamera.play();	}
	public stop()	{	timcamera.stop(false);	}
	public setactor(string sactor)	{	sancamera=sactor;	}
	public setcampos(int x, int y)	{
		_campos.setpos(x,y);
		.setactor("_campos");
	}
	public bool isactor(string sob)	{	return sob==sancamera;	}
	public string getactor()	{	return sancamera;	}
	public scalemodifiers(real rx, real ry)	{	| _rxmod, _rymod | = rx, ry;	}
	public newbgr(string sbgr, real rscalex, real rscaley)	{
		new classbgplan <sbgr>;
		this.addbgr(sbgr,rscalex,rscaley);
	}
	public addbgr(string sbgr, real rscalex, real rscaley)	{
		<sbgr>.setscale(rscalex,rscaley);
		grbgrs.add(sbgr);
	}
	public addtobgr(string sbgr, string sob)	{	<sbgr>.add(sob);	}
	public setscene()	{	this._setscene(1.0,1.0);	}
	_setscene(real _rx, real _ry)	{
		if( sancamera==null ) return;
		real x = icamx - <sancamera>.getposx();
		x*=_rx;
		real y = icamy - <sancamera>.getposy();
		y*=_ry;
		real ix = this.getposx()+x;
		real iy = this.getposy()+y;
		if( ix >= rleft )	x = -this.getposx();
		else if (ix+rright<rborx)	x = rborx - (this.getposx()+rright);
		
		if( iy >= rtop )	y = -this.getposy();
		else if (iy+rbottom<rbory)	y = rbory - (this.getposy()+rbottom);
		
		if( x||y )	{
			grbgrs.move(x,y);
			if( smsmvfun!=null )	this.<smsmvfun>();
		}
		if( x==0 && _lastx!=0 && _sfunxedge!=null )	.<_sfunxedge>;
		if( y==0 && _lasty!=0 && _sfunyedge!=null )	.<_sfunyedge>;
		_lastx = x;
		_lasty = y;
	}
	public checkcamera()	{
		if( sancamera==null )	return;
		this._setscene( _rxmod, _rymod );
	}
	public moveplans(int x, int y)	{
		rleft+=x;	rright+=x;
		rtop+=y;	rbottom+=y;
		rborx+=x;
		rbory+=y;
		icamx+=x;	icamy+=y;
		grbgrs.shift(x,y);
	}
}

/*
	tworzy z button z obiektu graficznego
*/

class classadvbut	{
	init(string sname)	{
		this.setadvbutmets(sname, "but");
	}
	setasbutton(string san, string sname)	{
		classadvbut::setasbutton2(san,sname,"but");
	}
	setasbutton2(string san, string sname, string styp)	{	// rozszerzanie obiektu o button
		<san>.addmethod("setadvbutmets","setadvbutmets");
		<san>.addmethod("setbuttyp","setbuttyp");
		<san>.addmethod("setadvbutpos","setadvbutpos");
		<san>.addmethod("setbutdir","setbutdir");
		<san>.addmethod("setbutbase1","setbutbase1");
		<san>.addmethod("setbutbase2","setbutbase2");
		<san>.addmethod("setbutbase","setbutbase");
		<san>.addmethod("getbase1","getbase1");
		<san>.addmethod("getbase2","getbase2");
		<san>.addmethod("getbutdir","getbutdir");
		<san>.addmethod("getbutname","getbutname");
		<san>.addmethod("gettyp","gettyp");
		<san>.addmethod("reachable", "reachable");
		<san>.addmethod("setreach", "setreach");
		<san>.addmethod("getgox","getgox");
		<san>.addmethod("getgoy","getgoy");
		
		<san>.addmethod("enable","enable");
		<san>.addmethod("disable","disable");
		<san>.addmethod("enabled","enabled");
		<san>.addmethod("setonce", "setonce" );
		<san>.addmethod("checkonce", "checkonce" );
		
		<san>.addmethod("setpocket", func { (string s) _spocket = s; } );
		<san>.addmethod("getpocket", func { _spocket; } );
		
		<san>.addmethod("moveon","moveon");
		<san>.addmethod("moveoff","moveoff");
		<san>.addmethod("clickon","clickon");
		<san>.addmethod("lrel","lrel");
		
		<san>.addmethod("becomebut", func { classadvbut::setasbut(this); });
		<san>.addmethod("becomeitem", func { classadvbut::setasitem(this); });
		<san>.addmethod("becomedoors", func { classadvbut::setasdoors(this); });
		
		<san>.addmethod("copyposfrompt", func { (string spt, int id)
			int i0 = <spt>.getbyname(id);
			.setadvbutpos(<spt>.getxver(i0) - <spt>.getposx, <spt>.getyver(i0) - <spt>.getposy );
			} );
		
		<san>.addmethod("butisin", func { .isin; } );
		
		<san>.setadvbutmets(sname, styp);
		<san>.setreach(true);
	}
	setonce(string s)	{ _sonce = s; }
	checkonce	{
		if(_sonce!=null && !clsave.bis(_sonce))	{
			clsave.bset(_sonce);
			.disable;
		}
	}
	setadvbutmets(string sname, string styp)	{
		new string _styp = styp;
		new string _sname = sname;
		new int igox = this.getposx();		// jak dojsc do tego..
		new int igoy = this.getposy();
		new string sgox = null;
		new string sgoy = null;
		new string _sbutdir = "auto";
		new string _sbase1 = modadv.get("look:",1);
		new string _sbase2 = modadv.get("look:",2);
		new bool breachable = false;
		new string _spocket = sname;
		new string _sonce = null;
		
		.vars2(A, "baseuse1", _sbase1, "baseuse2", _sbase2, "hideontake", true);
		
		this.enable();
	}
	setasmask(string san)	{
		<san>.addmethod("butisin", func { (int x, int y, bool bv, bool ba) .isin(x, y, false, ba);	} );
	}
	/*********************************/
	enable()	{
		if( !AdventureGame ) return;
		grbuts.addonce( this.getname() );
	}
	disable()	{
		if( !AdventureGame ) return;
		grbuts.remove(this.getname());
	}
	enabled()	{
		if( !AdventureGame ) return;
		return grbuts.contains(this.getname());
	}
	/*********************************/
	setbutbase(string s1, string s2)	{
		.setbutbase1(s1);
		.setbutbase2(s2);
	}
	setreach(bool b)	{	breachable=b;	}
	reachable()	{	return breachable;	}
	setbuttyp(string s)	{	_styp = s;	}
	/*************************/
	lrel()	{}		// mouselrel
	clickon()	{	if( this.reachable() )	{	clwalkq.visit( this.getname() );	}	}
	moveon()	{	advmouse.setactive();	}
	moveoff()	{	advmouse.setstd();	}
	/*************************/
	setadvbutpos(string x, string y)	{	sgox=x; sgoy=y; igox = x; igoy=y;		}
	setbutdir(string sdir)	{	_sbutdir=sdir;	}
	setbutbase1(string sb1)	{	_sbase1=sb1; baseuse1 = sb1;	}
	setbutbase2(string sb2)	{	_sbase2=sb2; baseuse2 = sb2;	}
	string getbase1()	{	return _sbase1;	}
	string getbase2()	{	return _sbase2;	}
	string getbutdir()	{	return _sbutdir;	}
	string getbutname()	{	return _sname;	}
	string gettyp()	{	return _styp;	}
	int getgox()	{
		if( sgox=="-hero" )	{
			sgoy=="-main" ? <smainhero>.getposx() : <sgoy>.getposx();
		} else if (sgox=="-but")	{
			<sgoy>.getcx;
		} else igox + clcamera.getposx();
	}
	int getgoy()	{
		if( sgox=="-hero" )	{
			sgoy=="-main" ? <smainhero>.getposy() : <sgoy>.getposy();
		} else if (sgox=="-but")	{
			<sgoy>.getey;
		} else igoy + clcamera.getposy();
	}
	/*******  virtuale  ****/
	virtual int getposx()	{	return 0;	}
	virtual int getposy()	{	return 0;	}
	virtual int getz()		{	return 0;	}
	virtual int butisin(int x, int y, bool bigv, bool biga)	{	return 0;	}
	/***************************/
	public setasbut(string san)	{
		//<san>.setbutbase( modadv.get("take:",1), modadv.get("take:",2) );
		<san>.addmethod("moveon", "moveon");
	}
	public setasitem(string san)	{
		<san>.setbutbase( modadv.get("take:",1), modadv.get("take:",2) );
		<san>.addmethod("moveon", "moveon");
	}
	public setasdoors(string san)	{
		<san>.addmethod("moveon", func { advmouse.setexit; } );
		<san>.setbutbase( modadv.get("doors:",1), modadv.get("doors:",2) );
	}
}

class classadvitem : classadvbut	{
	init(string sname)	{
		classadvbut::init(sname, "item");
		this.setbutbase( modadv.get("take:",1), modadv.get("take:",2) );
	}
	setasbutton(string san, string sname)	{
		classadvbut::setasbutton2(san, sname, "item");
		<san>.setbutbase( modadv.get("take:",1), modadv.get("take:",2) );
	}
}

class classadvdoors : classadvbut	{
	init(string sname)	{
		classadvbut::init(sname, "doors");
		this.setbutbase( modadv.get("doors:",1), modadv.get("doors:",2) );
	}
	setasbutton(string san, string sname)	{
		classadvbut::setasbutton2(san, sname, "doors");
		<san>.addmethod("moveon","moveon");
		<san>.setbutbase( modadv.get("doors:",1), modadv.get("doors:",2) );
	}
	moveon()	{	advmouse.setexit();		}
}

/* 
	behavioury : skladowe cut-scen w przygodzie
*/

class classbehhero 	{
	init()	{
		new string _snextbeh = null;
		new string _stdfinfun = null;	// std funkcja przekazana do odegrania na finish
		new string _stdfinobj = null;
		new string _stype = null;	// typ behavioura
		new string _scaller;	// kto go wywoluje (tego behavioura)
		new bool bblock = true;	// blokuj przed dzialaniami gracza
		//new string bonce = null;	// jednorazowego uzytku
		new bool bparal = false;
	}
	public gonext(string scaller)	{
		bool bfin = false;
		if( bparal )	{
			bfin = <_sstarter>.behret( this.getname() );
		} else if ( <_sstarter>.isenumer() && _sstarter!=this.getname())	{
			bfin = true;
		} else {
			if( _snextbeh!=null )	{
				<_snextbeh>.eval( scaller );
			} else {
				bfin = true;
			}
		}
		if( bfin )	{
			this.finishbeh(scaller);
		}
	}
	public finishbeh(string scaller)	{
		if( scaller!=null )	{
			<scaller>.reteval();
		} else {
			modstnd.resume();
			string s = this.getactbeh();
			<_sstarter>.callbehfin();
			if( this.getactbeh()==s )	{
				this.setactbeh(null);
			}
		}
	}
	public playfin(string sob, string sfun)	{
		this.setfinfun(sob,sfun);
		_bmslock = this.advgetlock();
		this.advmssetlock( bblock );	// zapamietuje mysz
		modstnd.pause();	// stop standery
		this.eval(null);
	}
	public eval(string scaller)	{
		this.setactbeh( this.getname() );		// zapamietanie kto teraz "gra"
		_scaller = scaller;
		this._eval();	
	}
	public rewind()	{
		//if( bblock==false && .hasaddedmet("_rew")/* || igmdebug*/)	{
		if( .hasaddedmet("_rew") )	{
			this._rew();
		}
	}
	public reteval()	{
		this.gonext(_scaller);
	}
	callbehfin()	{
		this.advmssetlock( _bmslock );	// przywrocenie blocka myszy
		
		this.callfun(_stdfinobj,_stdfinfun);
		_stdfinobj = null;
		_stdfinfun = null;
		
		this.< this.getname()->strsubbs( _sbeh )+"_FINISH">();
	}
// 	_rewenter	{}
// 	_rewclose	{}
	_evalenter	{
		ccs.obenter(this, "reteval");
	}
	_evalclose	{
		ccs.obclose(this, "reteval");
	}
	_evalmusic	{
		_music.playvec(vmus.getfullname, 0);
		.reteval;
	}
	_evalscript()	{
		if( _id>=0 )	{
			int id = _id;
			@s = <_sdb>.get(_row,id);
			while( s!=")" )	{
				<_sscr>.ARG=(id-_id, s);
				id++;
				s = <_sdb>.get(_row,id);
			}
		}
		<_sscr>.call( _sfun2 );
		this.reteval();
	}
// 	_rewscript()	{}
	_evalmet()	{
		this.callfun(_sob2,_sfun2);
		this.reteval();
	}
// 	_rewmet()	{}
	_evalsave()	{
		clsave.set( ssavvar, ssavval );
		this.reteval();
	}
// 	_rewsave()	{}
	_evalgame()	{
		string s = gameapi.getgamename;
		match( _styp )	{
			"-def" => <s>.playfromscript(_spath, _sgame);
			"-adv" => <s>.playnewgamepath(_sgame, _spath);
			? => <s>.playnewgame(_sgame);
		}
		this.reteval();
	}
// 	_rewgame()	{}
	_evalread()	{	clhilarytxt.herosaydir( _sread, _ix, _iy, _sdir );	}
	_rewread()	{
		clhilarytxt.stop();
		this.reteval();
	}
	_evalwait()	{	timwait.play();	}
	//_rewwait()	{	timwait.stop(true);	}
	_evaltalk()	{
		string sptf = _spathpref + _san;
		string s = _stalkpref + _san;
		if( engine.varexist(sptf) && <s>.getdir != <s>.getpropdir(_sdir) )	{
			<sptf>.heroturn(_sdir, this, "_evaltalk");
			return;
		}
		this.advanstand(_san);
		<s>.settalktype( modadv.gettalktype() );
		<s>.setsnd( __swav );
		<s>.checkamounts( __sbase );
		<s>.herosaydir(isort, bstt, bstp, this.getname(), "reteval", <s>.getpropdir(_sdir) );
	}
	_rewtalk()	{	<_stalkpref+_san>.stop(true);	}
	_evalsetpos()	{
		int x, int y;
		string _sptf = _spathpref + _san;
		if( _idestx=="-id" )	{
			y=<_sptf>.getbyname(_idesty);
			x = <_sptf>.getxver(y);
			y = <_sptf>.getyver(y);
			<_san>.setpos(x ,y  );
		} else {
			x=_idestx;
			y=_idesty;
			<_san>.setpos(x + clcamera.getposx() ,y + clcamera.getposy() );
		}
		if( _bssc ) clcamera.setscene;
		if( engine.varexist(_sptf) ) <_sptf>.scalean();
		<_san>.setz( <_san>.getposy );
		if( _sdir!="auto" )	<_san>.setdir(_sdir);
		this.reteval();
	}
// 	_rewsetpos()	{}
	_evalwalk()	{
		int x, int y;
		if( _idestx=="-id" )	{
			y=<_sptf>.getbyname(_idesty);
			x = <_sptf>.getxver(y) - <_sptf>.getposx;
			y = <_sptf>.getyver(y) - <_sptf>.getposy;
		} else if (_idestx == "-hero")	{
			x = <_idesty>.getposx;
			y = <_idesty>.getposy;
			bool b = true;
			if( <_sptf>.ptfgoto(x,y)>=0 )	{
				y = <_sptf>.getgover(1);
				if( y>=0 )	{
					x = <_sptf>.getxver(y);
					y = <_sptf>.getyver(y);
					b = false;
				}
			}
			<_sptf>.stop(false);
			if(b)	{
				@s = _sptf.strsubbs( _spathpref );
				x = <s>.getposx;
				y = <s>.getposy;
			}
		} else {
			x=_idestx;
			y=_idesty;
		}
		<_sptf>.herowalkto2( x + clcamera.getposx(), 
			y + clcamera.getposy(), this.getname(), "reteval" );
	}
	_evalturn	{
		string s = _sdir;
		if( !s.in(A, "uu", "ru", "rr", "rd", "dd", "ld", "ll", "lu") )	{
			string s2 = <_sptf>.getanim;
			s = <_sptf>.vecdir( <s>.getposx-<s2>.getposx, <s>.getposy-<s2>.getposy );
		}
		<_sptf>.heroturn(s, this, "reteval");
	}
// 	_rewwalk()	{}
	_evalanorder()	{
		this.advanstand(_san);
		_ = this.analizeaninstr(_sdb, _irow, _icol, _san);
		this.reteval();
	}
// 	_rewanorder()	{}
	_evalanplay()	{
		if( !<_san>.hasvar("bthisfin") )	{
			<_san>.setasadvanima;
		}
		this.advanstand(_san);
		<_san>.thisfinish(true);
		if( StringChecker::isdigit(_sact) ) _sact = <_san>.nameofaction(_sact);
		<_san>.playspec2( _sact, this.getname(), "reteval");
	}
	_rewanplay()	{	/*<_san>.stop(true);*/	}
	_evalsndbg()	{
		_sndbg.play();
		this.reteval();
	}
// 	_rewsndbg()	{}
	_evalsndplay()	{
		sndp.play();
	}
	_rewsndplay()	{	sndp.stop(true);	}
	_evalcall()	{
		string s = scallobj;
		if( s.contains("$") )	{
			s = s.strsubb(1);
			s = engine.varexist(s) ? [s] : <sscript>.get(s);
			if( s==null )	{
				this.reteval();
				return;
			}
		}
		s = this.getbeh(s);
		<s>.eval( this.getname() );
	}
// 	_rewcall()		{}
	_evalnull()	{	this.reteval();	}		// obiekt niezdefiniowany
// 	_rewnull()	{}
	_evalstart()	{
		int i, string s;
		vbif.free;
		if( bonce!=null )	{
			//s = this.getname()->strsubbs( _sbeh );
			if( !clsave.bis( bonce ) )	{
				clsave.bset( bonce ); 
			} else {
				this.finishbeh(_scaller);
				return;
			}
		}
		if( (iisifsave==0&&clsave.is(sisifsave,sisifvar)) || (iisifsave==1&&!clsave.is(sisifsave,sisifvar)) )	{
			this.finishbeh(_scaller);
			return;
		}
		if( brand)	{
			i = vecbehs.size();
			i>0 ? < vecbehs.get( i.rand ) >.eval( _scaller ) : this.reteval();
		} else if( bparal)	{
			vecbehs2.veccopy("vecbehs");
			for( i=0; i<vecbehs.size(); i++)	{
				<vecbehs.get(i)>.eval( _scaller );
			}
		} else if (ienumer>0)	{
			<vecbehs.get( this.nextenum()-1 )>.eval( _scaller );
		} else	{
			this.reteval();
		}
	}
// 	_rewstart()	{}
	_ifst(bool b, bool b2)	{
		match(ifst)	{
			1 => b && b2;
			2 => b || b2;
			? => b;
		}
	}
	bool _oper_check(string s)	{
		//s=="|" ? 2 : s=="&";
		match(s)	{
			"|" => 2;
			"&" => 1;
			? => 0;
		}
	}
	_ifcheck	{
		bool b[2];
		string s[2];
		int i1 = istart;
		ifst = 0;	// initial state
		while(i1<istop)	{
			s0 = <_db>.get(irow, i1);
			s1 = <_db>.dbchecknext(irow, i1);
			match( s1 )	{
				"=" => {
					i1+=2;
					b1 = clsave.is(s0, <_db>.get(irow, i1) );
					b0 = ._ifst(b1, b0);
					ifst = ._oper_check( <_db>.dbchecknext(irow, i1) );
					if( ifst ) i1++;
				}
				"!=" => {
					i1+=2;
					b1 = !clsave.is(s0, <_db>.get(irow, i1) );
					b0 = ._ifst(b1, b0);
					ifst = ._oper_check( <_db>.dbchecknext(irow, i1) );
					if( ifst ) i1++;
				}
				"&" => { i1++;
					b1 = ( (s0.getb(0,1)=="!") ? (!clsave.bis(s0.strsubb(1))) : clsave.bis(s0) );
					b0 = ._ifst(b1, b0);
					ifst=1;
				}
				"|" => { i1++;
					b1 = ( (s0.getb(0,1)=="!") ? (!clsave.bis(s0.strsubb(1))) : clsave.bis(s0) );
					b0 = ._ifst(b1, b0);
					ifst=2;
				}
				? => {
					b1 = ( (s0.getb(0,1)=="!") ? (!clsave.bis(s0.strsubb(1))) : clsave.bis(s0) );
					b0 = ._ifst(b1, b0);
				}
			}
			i1++;
		}
		<_sstarter>.bif=(b0);
		b0;
	}
	_checkif	{
		if( ._ifcheck )	{
			.reteval;
		} else {
			<_sstarter> (this) { (string s)
				int poz = 0;
				int end = vecbehs.size;
				int found = 0;
				for(int i =vecbehs.find(s)+1; i<end; i++ )	{
					match( <vecbehs.get(i)>.gettyp )	{
						"IF" => poz++;
						"FI" => {
							if( poz==0 )	{
								found = i;
								i = end;
							} else poz--;
						}
						"ELSE", "ELIF" => {
							if( poz==0 )	{
								found = i;
								i = end;
							}
						}
						? => ;
					}
					//!<vecbehs.get(i)>.gettyp->in(A,"FI","ELSE","ELIF")
				}
				<vecbehs.get(found)>.eval(_scaller);
			};
		}
	}
	_evalIF	{
		<_sstarter>.ifpush;
		._checkif;
	}
	_gotofi(string s)	{
		int poz = 0;
		for( int i = vecbehs.find(s)+1; i<vecbehs.size; i++) {
			match(<vecbehs.get(i)>.gettyp)	{
				"IF" => poz++;
				"FI" => {
					if( poz==0 )	{
						<vecbehs.get(i)>.eval(_scaller);
						return;
					} else poz--;
				}
				? => ;
			}
		}
	}
	_evalELIF	{
		if( <_sstarter>.bif )	{
			<_sstarter>._gotofi(this);
		} else ._checkif;
	}
	_evalELSE	{
		if( <_sstarter>.bif ) <_sstarter>._gotofi(this);
		else .reteval;
	}
	_evalFI	{
		<_sstarter>.ifpop;
		.reteval;
	}
// 	_rewIF	{}
// 	_rewELSE	{}
// 	_rewFI	{}
// 	_rewELIF	{}
	/***********************/
	gettyp	{	_stype;	}
	settype(string stype)	{
		_stype = stype;
		this.addmethod("_eval", "_eval" + stype );
		if( .hasmet("_rew"+stype) )	{
			this.addmethod("_rew", "_rew" + stype );
		}
	}
	setflags(string snextob)	{
		 _snextbeh = snextob;	
	}
	setfinfun(string stdfinobj, string stdfinfun)	{
		_stdfinobj = stdfinobj;
		_stdfinfun = stdfinfun;
	}
	setasstarter(string bone, bool brandom, bool bpar, bool block, int ienum, int iifsave, string sifsave, string sifvar)	{
		this.settype("start");
		new string _sstarter=this.getname();
		new bool brand = brandom;
		new bool _bmslock;		// tmp do przechowania locka myszy
		new vector vecbehs;
		bblock = block;
		vecbehs.type("string");
		new string bonce = bone;
		bparal = bpar;
		new int ienumer = ienum;
		if( ienum>0 )	{
			new int _iencnt = 1;
		} else if( bpar )	{
			new vector vecbehs2;
			vecbehs2.type("string");
		}
		new int iisifsave=iifsave;
		if( iifsave>=0 )	{
			new string sisifsave = sifsave;
			if( sifvar!=null )
				new string sisifvar = sifvar;
		}
		new vector vbif;
	}
	bif	{	vbif.last;	}
	bif=(bool b)	{	vbif.set( vbif.size-1, b);	}
	ifpush	{	vbif.add(1);	}
	ifpop	{	_ = vbif.pop;	}
	int isenumer()	{
		return ienumer;	
	}
	int nextenum()	{
		if( _iencnt > vecbehs.size() )	{
			_iencnt = ienumer+1;
		} else {
			_iencnt++;
		}
		return _iencnt-1;
	}
	addtostarter(string sob)	{	vecbehs.add( sob );	}
	bool getblock()	{	return bblock;	}
	addflags(string sst,  bool block, bool bpar)	{
		new string _sstarter=sst;
		bblock = _stype=="read" ? false : block;
		bparal = bpar;	// czy nalezy wykonac rownolegle
	}
	bool behret(string sob)	{
		vecbehs2.remove(sob);
		return vecbehs2.size()==0;
	}
	_setasif(string sdb, int row, int i1, int i2)	{
		new int istart = i1;
		new int istop = i2;
		new string _db = sdb;
		new int irow = row;
		new int ifst = 0;
	}
	setasIF(string sdb, int row, int i1, int i2)	{
		.settype("IF");
		._setasif(sdb, row, i1, i2);
	}
	setasELIF(string sdb, int row, int i1, int i2)	{
		.settype("ELIF");
		._setasif(sdb, row, i1, i2);
	}
	setas(string s)	{	.settype(s);	}
	setasscript(string sscr, string sfun, string sdb, int row, int id)	{
		this.settype("script");
		new string _sscr = sscr;
		new string _sfun2 = sfun;
		new int _id = id;
		new string _sdb = sdb;
		new int _row = row;
	}
	setasuse(string sitem)	{
		.settype("use");
		new string _sitem = sitem;
	}
	_evaluse	{
		<_spocketpref+.getmainhero>.pckremove( _sitem );
		.reteval;
	}
// 	_rewuse	{ }
	_evaltopck	{
		<_spocketpref+.getmainhero>.additem( _sitem, _sfile );
		.reteval;
	}
// 	_rewtopck	{}
	setastopck(string sitem, string sfile)	{
		.settype("topck");
		new string _sitem = sitem;
		new string _sfile = sfile;
	}
	setasmet(string sob, string sfun)	{
		this.settype("met");
		new string _sob2 = sob;
		new string _sfun2 = sfun;
	}
	setassaver(string svar, string sval)	{
		this.settype("save");
		new string ssavvar = svar;
		new string ssavval = sval;
	}
	setasnewgamer(string styp, string spath, string sgame)	{
		this.settype("game");
		new string _sgame=sgame;
		new string _styp = styp;
		new string _spath = spath;
	}
	setasreader(string sfile, int x, int y, string sdir)	{
		this.settype("read");
		new string _sread = sfile;
		new int _ix = x;
		new int _iy = y;
		new string _sdir = sdir;
	}
	setaswaiter(int delay)	{
		this.settype("wait");
		new timer timwait;
		timwait.settick(1);
		timwait.delay(delay);
		timwait._csplbuild( this.getname(), "reteval" );
		timwait.addmethod("onfinish", "_csplfinish");
	}
	setassndbg(string ssnd, int vol)	{
		this.settype("sndbg");
		new snd _sndbg;
		_sndbg.setstartstopflag(false, true);
		_sndbg.load( this.getsndpath() + ssnd + ".wav" );
		_sndbg.setvol(vol);
	}
	setasanorder(string sdb,int irow,  int icol, string san)	{
		this.settype("anorder");
		new string _sdb = sdb;
		new int _irow = irow;
		new int _icol = icol;
		new string _san = san;
	}
	setascaller(string sbeh, string sscr)	{
		this.settype("call");
		new string scallobj = sbeh;
		new string sscript = sscr;
	}
	_csplbuild(string sob, string sfin)	{
		new string _sobj = sob;
		new string _sfinfun = sfin;
	}
	_csplfinish()	{
		this.callfun(_sobj, _sfinfun);
	}
	setassndplayer(string sfile, int vol)	{
		this.settype("sndplay");
		new snd sndp;
		sndp.setstartstopflag( false, true );
		sndp.load( this.getsndpath()+sfile+".wav" );
		sndp._csplbuild( this.getname(), "reteval" );
		sndp.addmethod("onfinish", "_csplfinish");
		sndp.setvol(vol);
	}
	setasposer(string san, string  idestx, int idesty, int bssc, string sdir )	{
		this.settype("setpos");
		new string _san = san;
		new string _idestx = idestx;
		new int _idesty = idesty;
		new bool _bssc = bssc;
		new string _sdir = sdir;
	}
	setasturn(string sptf, string sdir)	{
		this.settype("turn");
		new string _sptf = sptf;
		new string _sdir = sdir;
	}
	setaswalker(string sptf, string idestx, string idesty )	{
		this.settype("walk");
		new string _sptf = sptf;
		new string _idestx = idestx;
		new string _idesty = idesty;
	}
	setasanplayer(string san, string sact)	{	
		this.settype("anplay");
		new string _san = san;
		new string _sact = sact;
	}
	setastalker(string san, string swav, string sbase, int itypsort,
			bool bstart, bool bstop, string sdir )	{
		this.settype("talk");
		new string _san = san;
		
		new string __swav = swav;
		new string __sbase = sbase;
		
 		new int isort = itypsort;
 		new bool bstt = bstart;
 		new bool bstp = bstop;
 		new string _sdir = sdir;
	}
	setasenter	{	.settype("enter");	}
	setasclose	{	.settype("close");	}
	setasmusic(string sdb, int row, int colstart, int colend)	{
		.settype("music");
		new vector vmus;	vmus.type("string");
		vmus.buildfullname;
		while ( colstart>=0 && colstart<colend )	{
			vmus.add( <sdb>.get(row, colstart) );
			colstart++;
		}
	}
}

new snd _fx_pocket;
_fx_pocket.load("sounds/sfx/harfa.wav");

class classadvpocket : classadvobject, classadvbut, gmimgvec	{
	init(string sname)	{
		classadvobject::init();
		classadvbut::init(sname);
		gmimgvec::init();
		this.setbuttyp("pocket");
		.setreach(true);
		.setadvbutpos("-hero","-main");
		new int iX;
		new int iY;
		new int iNumItems = 0;
		new int iMaxItems = 14;
		new int iScale;
		new string sState = "closed";
		new string _sanim = this.getname();
		_sanim = _sanim.strsubbs( _spocketpref );
		new string sItem = null;
		new string sFocusItem = null;
		
		new string _sbase = "anpocket";
		new int _ibase = _sbase.length();
		
		this.setz(1000);
		
		new string sitempath;
		new vector arPocket;
		arPocket.type("string");
		new vector arPocketFile;
		arPocketFile.type("string");
		this.cnewtimercyclefin("tim", 1, 1, "evalpocket");
		
		sitempath = modadv.get("itempath:",1);
		
		int z = this.getz();
		new anima imitem;
		imitem.anloopfin();
		imitem.setz(z+1);
		new img immarker;
		immarker.load( sitempath + "itemmarker.png" );
		immarker.setz(z-1);
		immarker.hide();
		
		this.hide();
		
		new bool bskip=false;
	}
	/*******************************/
	addtoadv()	{		// jezeli jest globalna kieszen
		this.addtogamevars(this.getname());
		this.enable();
		this.addasadvobject();
	}
	removefromadv()	{
		this.disable();
		this.removefromadvobjs();
	}
	hidepocket()	{
		if( sState!="closed")	{
			if( sState!="close" )	{
				this.pockettoggle();
				tim.stop(false);
			}
			while(sState!="closed")	{
				tim.evalpocket();
				tim.stop(false);
			}
		}
	}
	exitpocket	{
		sState = "closed";
		tim.stop(false);
		.hide;
	}
	/*******************************/
	skip()	{	bskip=true;	}
	skipitem()	{	if( sItem!=null )	{	bskip=true;	}	}
	additem(string sname, string sfile)	{
		if( arPocket.contains(sname) ) return;
		arPocket.add(sname);
		arPocketFile.add(sfile);
// 		string s = _sbase+iNumItems;
		string s = _sbase + sname;
		new anima <s>;
		this.add(s);
		<s>.load( sitempath + sfile + ".pyz" );
		//<s>.setframe("in",0);
		<s>.play(0);
		<s>.setz( this.getz() );
		<s>.hide();
		iNumItems++;
	}
	savestate(string sfilepref)	{
		arPocket.save( "saves/" + this+sfilepref + "_name.txt" );
		arPocketFile.save( "saves/" + this+sfilepref + "_file.txt" );
	}
	loadstate(string sfilepref)	{
		new vector vpcp;	vpcp.type("string");
		new vector vpcf;		vpcf.type("string");
		vpcp.load( "saves/" + this+sfilepref + "_name.txt" );
		vpcf.load( "saves/" + this+sfilepref + "_file.txt" );
		for( int i=0; i< vpcp.size; i++)	.additem( vpcp.get(i), vpcf.get(i) );
		delete vpcp;
		delete vpcf;
	}
	removeitem(string sname)	{
		@id = arPocket.find(sname.strsubbs(_sbase));
		if( id<0 ) return;
		arPocket.removeat(id);
		arPocketFile.removeat(id);
		this.remove( sname );
		delete <sname>;
		iNumItems--;
		if ( sState == "opened" ){	this.hide();	}
	}
	useitem()	{
		if( sItem!=null )	{
			this.removeitem( sItem );
			this.itemhide();
		}
	}
	pckremove(string sname)	{	.removeitem( _sbase + sname );	}
	evalpocket(){
		this.play();
		if ( sState == "open" ){
			iScale+=16;
		} else if ( sState == "close" ){
			iScale-=16;
		}
		if ( iScale > 116 ){
			this.stop(false);
			iScale = 116;
			sState = "opened";
		} else if ( iScale < 0 ){
			this.stop(false);
			iScale = 0;
			sState = "closed";
		}
		real dRadius = (iScale * iScale )/550;
		//real dRadius = iScale.sqrt(iScale)*2;
		real dAngle;
		string s;
		for (int i=0; i< iNumItems; i++){
			dAngle = dRadius*i-(dRadius*iNumItems/2.0) -90.0 + dRadius/2;
			s = this.get(i);
			<s>.setpos( dAngle.cos() * iScale + iX - 76/2, dAngle.sin() * iScale + iY - 75/2 );
			//<s>.show();
			if( <s>.isvisible )
				<s>.play(0);
		}
		if ( sState == "closed" ){
			this.hide();
		}
	}
	pocketpos(int x, int y)	{
		int ix = x-iX;
		int iy = y-iY;
		this.move(ix,iy);
		iX=x;
		iY=y;
	}
	pockettoggle(){
		if ( sState == "opened" ){
			sState = "close";
			immarker.hide();
			tim.play();
		} else if ( sState == "closed" ){
			sState = "open";
			_fx_pocket.play;
			iX = <_sanim>.getposx();
			iY = <_sanim>.getposy()-<_sanim>.geth()/2;
			this.itemhide();
			this.show();
			tim.evalpocket();
			tim.play();
		} else if ( sState == "open" ){
			sState = "close";
		} else if ( sState == "close" ){
			sState = "open";
		}
	}
	string getitem()	{	return sItem!=null ? sItem.strsubbs(_sbase) : null;	}
	itemhide(){
		sFocusItem = null;
		sItem = null;
		imitem.stop(false);
		imitem.hide();
	}
	itemclick()	{
		this.skip();
		
		if ( sState == "closed" ){
			this.pockettoggle();
		} else if ( sState == "opened" ){
			if ( sFocusItem != null ){
				if( sItem!=null )	{
					.pockettoggle;
					_b_rewind = !.playbehif( "beh_"+_sanim+"_USE_"+sItem.strsubbs(_sbase)+"_ON_"+sFocusItem.strsubbs(_sbase) );
					.itemhide;
				} else {
					sItem = sFocusItem;
					imitem.copy(sItem);
					<sFocusItem>.hide();
					//imitem.play("out");
					imitem.play(1);
					imitem.setz( this.getz() + 1 );
					this.setitempos();
					//this.pockettoggle();
				}
			} else {
				this.pockettoggle();
			}
		} else if ( sState == "open" ){
			this.pockettoggle();
		} else if ( sState == "close" ){
			this.pockettoggle();
		}
	}
	int butisin(int x, int y, bool bignorehidden, bool bignorealpha)	{
		int id = gmimgvec::isin(x,y,bignorehidden,bignorealpha);
		if( id )	{
			sFocusItem = this.get( id-1 );
		} else {
			sFocusItem = null;
			id = <_sanim>.isin(x,y,bignorehidden,bignorealpha);
		}
		return id;
	}
	hide	{
		.eval1("stop",false);
		.eval("hide");
		immarker.hide;
	}
	setitempos()	{
		imitem.setpos( mouse.getpx()-76/2, mouse.getpy()-75/2 );
	}
	itemmoveoff()	{
		if ( sState == "opened" ){
			immarker.hide();
		}
	}
	itemmoveon()	{
		if ( sState == "opened" ){
			if (sFocusItem != null){
				immarker.show();
				immarker.setpos( <sFocusItem>.getcx-immarker.getw/2, <sFocusItem>.getcy-immarker.geth/2 );
			} 
		}
	}
	onmouselclick(int x, int y)	{
		if(bskip)	{
			bskip=false;
			if( sItem!=null && sState=="opened" && sFocusItem==null) .pockettoggle;
		} else {
			if( .getmainhero==_sanim )
				sState=="opened" || sState=="open"  ? this.pockettoggle() : this.itemhide();
		}
	}
	onmouserclick(int x, int y)	{
		if( .butisin(x,y,true,true) )	{
			if( sState=="opened" && sFocusItem!=null )	{
				_ = .playbehif( "beh_"+_sanim+"_ITEM_"+sFocusItem.strsubbs(_sbase) );
				//.pockettoggle;
			} else {
				_ = .playbehif( "beh_RCLICK_"+_sanim );
			}
		}
	}
	onmousemove(int x, int y)	{
		if ( sItem != null ){	this.setitempos();	}
		if ( sState == "opened" && this.butisin(x,y,true,true) )	{
			this.itemmoveon();
		}
	}
	/**************** button **********/
	moveoff()	{
		advmouse.setstd();
		this.itemmoveoff();	
	}
	clickon()	{
		if( .getmainhero == _sanim )	{
			//.skipitem;
			clwalkq.stand;
			.itemclick;
		} else {
			clwalkq.visit( this );
		}
	}
}

/* 
	klasa oblugujaca postac z gry
	Dominik Dagiel 3 III 2006
*/

new string sgmlastscene = null;
new string sgmglobpath = null;	// dla gier, ktore sa w innym katalogu niz ich nazwa
new string sgmgame = null;		// jezeli .adv inaczej sie nazywa niz game
new db gdbsound;			// baza dialogow
new classfullsave clsave("saves/save.txt");

new string _slhpref = "cllh";	// prefix do obiektu classloadedhero
new string _spathpref = "pt";	// prefix do obiektu classpathf
new string _spocketpref = "pc";	// prefix do pocket
new string _sstndpref = "stnd";	// prefix do standera
new string _stalkpref = "ctlk";

new bool AdventureGame;

new CutScene ccs(0, 0, iResX, iResY);
ccs.setz(2000);

module modadv	{
	init()	{
		new db dbload;
		new string stalktype;
		this.settalktype("snd");
		new Script scrl(null);
		new string _stalk;
	}
	/********************************/
	public execute(string sfunc)		{	scrl.call(sfunc);		}
	public loadscript(string sfile)		{	scrl.load(sfile);			}
	/********************************/
	public loadsounds(string sfile)	{
		gdbsound.load(sfile);
		if( igmdebug )	{
			gdbsound.save( "exports/adv.dlg" );
		}
	}
	public string gettalktype()	{	return stalktype;	}
	public settalktype(string s)	{	stalktype=s;	}
	/********************************/
	public load(string sfile)			{
		dbload.loadscript(sfile);
		_stalk = this.get("talk:",1);
	}
	public string get(string styp, int ipos)	{
		int id = dbload.findbyrow(styp);
		if( id<0 )	{
			engine.print("modadv.dbload: can't find "+styp);
			return null;
		} else
			return  dbload.get( id, ipos );
	}
}

module modadvglob	{
	init()	{
		new gmobjvec grhero;
		new gmobjvec grfiles;
		new gmobjvec grpck;
	}
	bool addhero(string sname, string sfile, bool bpocket)	{
		clsave.set("hero_"+sname+"_active",1);
		int id = grhero.find(sname);
		if( id>=0 ) {
			if( grfiles.get(id)!=sfile )	{
				grfiles.set(id, sfile);
				<sname>.load( .getpath(sfile) );
			}
			<sname>.addtogamevars(sname);
			if( bpocket )
				<_spocketpref+sname>.addtoadv();
			return false;
		} else {
			this.newanima(sname,sfile,0);
			<sname>.addtogamevars(sname);
			grhero.add(sname);
			grfiles.add(sfile);
			if( bpocket )	{
				string s = _spocketpref+sname;
				if( !.hasvar(s) )	{
					new classadvpocket <s>(sname);
					//<s>.addtogamevars(s);
					grpck.add(s);
					<s>.addtoadv;
					//<s>.enable;
				} else	{
					<s>.addtoadv;
				}
			}
			return true;
		}
	}
	reloadhero(string sname)	{
		int id = grhero.find(sname);
		if( id>=0 )	{
			string s = grfiles.get(id);
			._delhero(sname, false);
			_ = .addhero(sname, s, false);
		}
	}
	delhero(string sname)	{	._delhero(sname, true);	}
	delheros	{	while( grhero.size )	.delhero(grhero.first);	}
	_delhero(string sname, bool bdelpck)	{
		clsave.set("hero_"+sname+"_active",0);
		int id = grhero.find(sname);
		if(id>=0)	{
			delete <sname>;
			grhero.removeat(id);
			grfiles.removeat(id);
			/*if( <gameapi.getgamename>.hasvar("clcamera") )	{
				clcamera.remove(sname);
			}*/
			sname = _spocketpref + sname;
			if( this.hasvar(sname) && bdelpck)	{
				delete <sname>;
				grpck.remove(sname);
			}
		}
	}
	savepck(string s)	{
		grpck.save("saves/grpck_"+s+".txt");
		for( int i=0; i<grpck.size; i++)	{	<grpck.get(i)>.savestate(s);	}
	}
	loadpck(string sfile)	{
		@s2, @s;
// 		engine.setdebugstate(1);
		for( int i=0; i< grpck.size; i++)	{
			s2 = grpck.get(i);
			<s2>.removefromadv;
			delete <s2>;
		}
		grpck.load("saves/grpck_"+sfile+".txt");
		for( i=0; i<grpck.size; i++)	{
			s2 = grpck.get(i);
			new classadvpocket <s2>( s2.strsubbs(_spocketpref) );
			<s2>.loadstate(sfile);
			<s2>.removefromadv;
		}
	}
	onexit()	{
		string s;
		for( int i=0; i<grhero.size(); i++)	{
			s = grhero.get(i);
			<s>.stop(false);
			<s>.hide();
			if( .hasvar(_spocketpref+s) )	<_spocketpref+s>.exitpocket;
			s = _spathpref + s;
			<s>.unlinkanima();
		}
	}
}

class classloadedhero	{
	init()	{
		new string sanhero;
		new bool bplaystart = false;
		new bool bplaystop = false;
	}
	public setplaystart(bool b)	{	bplaystart = b;	}
	public setplaystop(bool b)	{	bplaystop = b;	}
	public getstartstop()	{	return bplaystart, bplaystop;	}
}

class classadvcontroller : classadv	{
	init()	{
// 		new TicksCounter ctc;
		AdventureGame = true;
		
		classadv::init();
		
// 		engine.setdebugstate(1);
		
		this.setwavpath( modadv.get("sndpath:", 1) );
		
		new snd __sndplay	{
			.vars2(A,"sfun", null,"sob",null);
			.setstartstopflag(false, true);
			.addmethod("onfinish", func {	.callfun(sob, sfun);	} );
		};
		
		igmstate = 0;
		
// 		new string _slhpref = "cllh";	// prefix do obiektu classloadedhero
// 		new string _spathpref = "pt";	// prefix do obiektu classpathf
// 		new string _spocketpref = "pc";	// prefix do pocket
// 		new string _sstndpref = "stnd";	// prefix do standera
// 		new string _stalkpref = "ctlk";
		
		new classstndgroup modstnd;
		new Music _music;
		
		new timer _tim_dbclk;
		_tim_dbclk.setdelay(200);
		
		new int _if_pos = -1;
		
		new classobjcounter clcbeh("_dbbh");		// prefix do bazy danych bahaviourow
		
		new string _sbeh = "clbeh";	// prefix obiektu behaviour
		new int iidbeh;		// id behavioura niedeklarowanego poprzez nazwe
		
		new classobjcounter clcadv("dbadv");	// bazy danych z przygoda
		
		new db dbmacros;
		new vector _vecarg;	// argumenty wolania makr
		_vecarg.type("string");
		
		new classadvcamera clcamera;	// kamera
		clcamera.setmetonmsmove("advmsmove");
		
		new classwalkerqueue clwalkq;	// kolejnosc chodzenia
		
		new gmadvvec grbuts;		// obiekty do analizowania (buttons)
		new gmimgvec grmsmove;		// kieszenie bohaterow i inne do move
		new gmimgvec grmslclick;
		new gmimgvec grmsrclick;
		new gmimgvec grmslrel;
		
		new string _susetool = null;
		new string _slastms = null;
		new bool bmslock = false;
		new bool _b_rewind = true;
		
		new string sactbeh = null;		// aktualny beh
		new string slastpathf;		// ostatni pathfinder to podawania pozycji buttonow
		
		new int licznik=0;
		
		new string smainhero = null;
		
		.advsaveonstart;
		
		string s, string s2;
		if( sgmgame==null )	{
			sgmgame = this.getname();
		}
		new string sprivgame = sgmgame;
		sgmgame = null;
		
		s2 = sprivgame.strsubbs("game");
		if( sgmglobpath!=null )	{
			s = sgmglobpath;
			sgmglobpath = null;
		} else {
			s = s2;
		}
		this.setgraphpath("scripts/" + s + "/" );
		this.loadadventure( s2 + ".adv");
		grbuts.sortimgs();
		
		if( smainhero==null )	{	smainhero = clcamera.getactor();	}
		
		clcamera.start();
		clcamera.setscene();
		clwalkq.start();
		clwalkq.setverlen(1);
		
		advmouse.setstd();
		
		if( .behexist("preinit") )	{
			.playbehobfin("preinit", this, "playbehinit");
		} else .playbehinit;
		
		grbuts.sortimgs();
	}
	public playbehinit	{
		if ( clsave.bis(sprivgame+"visited") ){
			if ( this.playpostinit( "behinit_FROM_" + sgmlastscene ) )	{
			} else if ( this.playpostinit( "behinit" ) )	{
			}
//			else <gameapi.getgamename()>.postinit();
		} else {
			clsave.bset(sprivgame+"visited");
			if( this.playpostinit( "behinit0_FROM_" + sgmlastscene ) )	{}
			else if ( this.playpostinit( "behinit0" ) )	{}
			else if ( this.playpostinit( "behinit_FROM_" + sgmlastscene ) )	{}
			else if ( this.playpostinit( "behinit" ) )	{}
//			else <gameapi.getgamename()>.postinit();
		}
	}
	public getmainhero()	{
		return smainhero;
	}
	public setmainhero(string s)	{
		smainhero=s;
	}
	public bool ismainhero(string s)	{	return smainhero==s;	}
	public setactbeh(string s)	{	sactbeh = s;	}
	public string getactbeh()	{	return sactbeh;	}
	public bool advgetlock()	{	return bmslock;	}
	public advmslock()	{
		bmslock=true;
		advmouse.setwait();
	}
	public advmsunlock()	{
		bmslock=false;
		advmouse.setstd();
	}
	public advmssetlock(bool block)	{
		block ? this.advmslock() : this.advmsunlock();
	}
	public setusetool(string s)	{	_susetool=s;	}
	public getusetool()	{	return _susetool;	}
	/********************************/
	bool playpostinit( string sbeh ){ 
		return this.playbehobfinif( sbeh, gameapi.getgamename(), "postinit");
	}
	public playbeh(string sname)	{
		this.playbehfin(sname,null);
	}
	public bool playbehif(string sname)	{
		if ( this.behexist( sname ) ){
			this.playbehfin(sname,null);
			return true;
		}
		return false;
	}
	public playbehfin(string sname, string sfunfin)	{
		this.playbehobfin(sname,null,sfunfin);
	}
	public bool playbehfinif(string sname, string sfunfin)	{
		if ( this.behexist( sname ) ){
			this.playbehfin(sname,sfunfin);
			return true;
		}
		return false;
	}
	public playbehobfin(string sname, string sobfin, string sfunfin)	{
		<this.getbeh(sname)>.playfin(sobfin, sfunfin);
	}
	public bool playbehobfinif(string sname, string sobfin, string sfunfin)	{
		if ( this.behexist( sname ) ){
			this.playbehobfin(sname,sobfin,sfunfin);
			return true;
		}
		return false;
	}
	public playnewgamepath(string sgame, string spath)	{
		sgmglobpath = spath;
		sgmlastscene = sprivgame;
		clsave.set("lastscene", sgmlastscene);
		gameapi.play(sgame);
	}
	public playnewgame(string sgame)	{
		this.playnewgamepath(sgame, null);
	}
	public playfromscript(string spath, string sgame)	{
		sgmgame = sgame;
		this.playnewgamepath( modadv.get("defaultadv:",1), spath );
	}
	/********************************/
	string getheroloader(string swavbase)	{
		swavbase = _slhpref + swavbase;
		engine.varexist(swavbase) ? swavbase : null;
	}
	/*********************************/
	public advanstand(string san)	{
		string s =  _spathpref + san;
		if( engine.varexist( s ) && <s>.iswalking() )	{
			<s>.stop(false);
			<s>.stand();
		}
	}
	public reloadhero(string sfile)	{
		.anreload(._getheropath(sfile));
		string sptf = _spathpref + this;
		<sptf>.linkanima(this);
		<sptf>.linkfilter;
		<sptf>.scalean;
	}
	analizeanopts(string sdb, int irow, int icol, int ilecol, string san, string sgrp, string styp)	{
		real r[2], string s1, string s2;
		bool b0 = false, bool b1 = false, int i[3], bool bfont=false;
		while( icol < ilecol )	{
			icol++;
			match(<sdb>.get(irow,icol-1))	{
				"-stt" => {	b0 = <sdb>.get(irow,icol);	icol++;	}
				"-stp"=> {	b1 = <sdb>.get(irow,icol);	icol++;	}
				"-wav"=> { s1 = _slhpref + <sdb>.get(irow,icol);	icol++;
					new classloadedhero <s1>;
					<s1>.varset( "sanhero", san );
					<sgrp>.add( s1 );
				}
				"-path" => {
					classadvanhero::buildheroframe(san);	// on end frame anputgr
					s1 = <sdb>.get(irow,icol);	icol++;	// pathfinder
					r0 = <sdb>.get(irow,icol);	icol++;	// step
					s2 = _spathpref+san;
					this.newclpathfcopy( s2, san, s1, r0);
					<s2>.prepareforhero();
					s1 = s2 + "look";	new classherolooker <s1>;	<s1>.link( san );
					s1 = s2 + "use";	new classherouser <s1>;		<s1>.link( san );
					s1 = s2 + "take";	new classherotaker <s1>;	<s1>.link( san );
				}
				"-ft"=> {	s2 = _spathpref+san;
					r0 = <sdb>.get(irow,icol);	icol++;	// z depth
					r1 = <sdb>.get(irow,icol);	icol++;	// scale power
					<s2>.linkfilter();
					<s2>.setzsize(r0);
					<s2>.setscalepower(r1);
				}
				"-stnd"=> { <_sstndpref+san>.setdelay(<sdb>.get(irow,icol)); icol++; }
				"-txt" => { i0 = <sdb>.get(irow,icol);	icol++;
					i1 = <sdb>.get(irow,icol);	icol++;
					i2 = <sdb>.get(irow,icol);	icol++;
					<_stalkpref+san>.settxtcolor(i0,i1,i2);
				}
				"-font" => {	bfont=true;
					s1 = <sdb>.get(irow,icol);	icol++;
					s2 = <sdb>.get(irow,icol);	icol++;
					if( styp=="hero:" )	{
						<_stalkpref+san>.setfont( s1, s2 );
					}
				}
				? => icol = this.analizeaninstr( sdb ,irow, icol-1, san);
			}
		}
		if( !bfont && styp=="hero:")	{
			<_stalkpref+san>.setfont( modadv.get("font:",1), modadv.get("font:",2) );
		}
		<sgrp>.eval1("setplaystart", b0 );
		<sgrp>.eval1("setplaystop", b1 );
		<sgrp>.free();
	}
	setasadvanima()	{
		classadvanhero::setashero( this.getname(), "cadvherofinish");
	}
	analizebut(string styp, string sdb, int irow, int icol)	{
		string s[3], int i[2];
		s0 = <sdb>.get(irow,icol);	icol++;	// nazwa
		s1 = <sdb>.get(irow,icol);	icol++;	// nazwa annki
		if( s1.contains(".pyz") )	{
			s2 = s1;
			s1 = "an" + s1.strsube(4);
			.newanima( s1, s2, 0);
		}
		styp = styp.strsube(1);
		//<"classadv"+styp.strsube(1)>::setasbutton(s1,s0);
		classadvbut::setasbutton2(s1, s0, styp);
		classadvbut::<"setas"+styp>(s1);
		<s1>.setadvbutpos( <s1>.getcx(), <s1>.getcy() );
		while( icol < <sdb>.getcolsno(irow) )	{
			icol++;
			match( <sdb>.get(irow,icol-1) )	{
				"-pos"=> {	s0 = <sdb>.get(irow,icol);	icol++;	// x
					s2 = <sdb>.get(irow,icol);	icol++;	// y
					if(s0=="-id" && slastpathf!=null)	{
						i0 = <slastpathf>.getbyname(s2);
						s0 = <slastpathf>.getxver(i0) - <slastpathf>.getposx();
						s2 = <slastpathf>.getyver(i0) - <slastpathf>.getposy();
					}
					<s1>.setadvbutpos(s0,s2);
				}
				"-bs1"	=> {	<s1>.setbutbase1( <sdb>.get(irow,icol) ); icol++;}
				"-bs2"	=> {	<s1>.setbutbase2( <sdb>.get(irow,icol) ); icol++;}
				"-us1" => {	<s1>.baseuse1=( <sdb>.get(irow,icol) ); icol++;}
				"-us2" => {	<s1>.baseuse2=( <sdb>.get(irow,icol) ); icol++;}
				"-useon"	=> {	<s1>.setbutbase1( modadv.get("use:",1) );
					<s1>.setbutbase2( modadv.get("use:",2) );
				}
				"-dir"	=> {	<s1>.setbutdir( <sdb>.get(irow,icol) ); icol++;}
				"-noreach"=> 	<s1>.setreach(false);
				"-nh" => <s1>.hideontake = (false);
				"-pck" =>  {	<s1>.setpocket( <sdb>.get(irow,icol) ); icol++;}
				"-mask" => { classadvbut::setasmask(s1); <s1>.hide;	}
				"-inpck" => {
					if( <s1>.hideontake )	{
						<s1>.hide();		// zabranie przedmiotu
					} else <s1>.setbuttyp("but");
					s0 = .getmainhero;
					if( s0==null ) s0 = clcamera.getactor;
					< <s0>.getpocket >.additem( <s1>.getbutname, <s1>.getpocket );
				}
				"-disable" => <s1>.disable;
				"-once" => {
					s0 = <sdb>.get(irow,icol);	icol++;
					<s1>.setonce( s0 );
					if( clsave.bis(s0) ) <s1>.disable;
				}
				? => ;
			}
		}
	}
	_getheropath(string s)	{
		string sp = .getpath(s);
		if( engine.fileexist(sp) )
			"$" + sp;
		else "$" + modadv.get("heropath:",1) + s;
	}
	public loadadventure(string sfile)	{
		string sdb = clcadv.get();
		string sgrp = "grpers"+clcadv.size();
		new db <sdb>;
		//<sdb>.loadbeh(this.getgraphpath()+sfile);
		<sdb>.loadbeh( .getpath(sfile) );
		int ile = <sdb>.getrowsno();
		int i[4], string s[3], bool b[2], bool bhero;
		real r[2];
		
		s0 = sdb + "script";
		new Script <s0>(sdb);
		
		string spath = "";
		new gmobjvec <sgrp>;
		for( int i=0; i<ile; i++)	{
			i0 =0 ;
			i1 = <sdb>.getcolsno(i);
			s0 = <sdb>.get(i,i0);	i0++;
			match(s0)	{
				"setpath:" => {
					spath = <sdb>.get(i,i0);	i0++;
					this.setgraphpath(spath);
				} "nopath:" => {
					spath = "";
					this.setgraphpath(spath);
				} "func"	=> {		// funkcja skryptu
					while( <sdb>.get(i,0)!="end" )	i++;
				} "sndpath:"	=> {
					s0 = <sdb>.get(i,i0);	i0++;
					this.setwavpath(s0);
				} "hero:", "an:"	=> {
					i2 = <sdb>.dbdelvar(i,"-global");
					i3 = <sdb>.dbdelvar(i,"-pck");
					s2 = <sdb>.get(i,i0);	i0++;	// anima
					if( s2.contains(".pyz") )	{
						s1 = s2;
						s2 = "an"+s2.strsubes(".pyz");
					} else {
						s1 = <sdb>.get(i,i0);	i0++;	// file
					}
					if( s0=="hero:" )	{
						/*if( s1.contains(".pyz") && !engine.fileexist(.getpath(s1)) )
							s1 = "$" + modadv.get("heropath:",1) + s1;*/
						if( s1.contains(".pyz") )
							s1 = ._getheropath(s1);
					}
					if( s1.contains(".pyz") )	{
						if( i2 )	{
							if(modadvglob.addhero(s2,s1,i3))
								<s2>.setasadvanima();
							i1--;
						} else {
							this.newanima(s2, s1, 0);
							<s2>.setasadvanima();
							if( s0=="hero:" && i3)	new classadvpocket <_spocketpref + s2>(s2);
						}
					} else {
						this.copyanima(s1, s2);
						<s2>.setasadvanima();
						if( s0=="hero:" && i3)	new classadvpocket <_spocketpref + s2>(s2);
					}
					if(i3)	i1--;
					if( s0=="hero:" )	{
						new classadvstander <_sstndpref+s2>;
						//classadvanhero::buildheroframe(s2);
						
						//new classadvpocket <_spocketpref + s2>(s2);
						
						s1 = _stalkpref+s2;
						new classtalker <s1>;
						<s1>.set(s2);
						<s1>.settextdb("gdbsound");
					}
					this.analizeanopts(sdb, i, i0, i1, s2, sgrp, s0);
				} "anaac:"	=>	{
					i2 = <sdb>.dbdelvar(i,"-mask");
					i3 = 0;
					s0 = <sdb>.get(i,i0);	i0++;	// anima
					if( s0.contains(".pyz") )	{
						s1 = s0;
						s0 = "an" + s0.strsubes(".pyz");
					} else {
						s1 = <sdb>.get(i,i0);	i0++;	// z ktorej..
					}
					if( i2 )	{
						i1--;
						new gmmaskvec <s0>;
					} else {
						new gmadvvec <s0>;
					}
					if( s1.contains(".pyz") )	{
						.newanima("_" + s0, s1, 0);
						s1 = "_" + s0;
						i3 = 1;
					}
					i2 = this.newanactionsgr(s1, s0, s0);
					i0 = this.analizeaninstr( sdb ,i, i0, s0);
					if( i3 ) <s1>.hide;
				} "anaf:"	=> {
					s0 = <sdb>.get(i,i0);	i0++;	// anima
					//s1 = <sdb>.get(i,i0);	i0++;	// z ktorej..
					if( s0.contains(".pyz") )	{
						s1 = s0;
						s0 = "an" + s0.strsubes(".pyz");
					} else {
						s1 = <sdb>.get(i,i0);	i0++;	// z ktorej..
					}
					new gmimgvec <s0>;
					if( s1.contains(".pyz") )	{
						.newanima("_" + s0, s1, 0);
						s1 = "_" + s0;
					}
					i2 = this.newanfrbyactgr(s1, s0, s0);
					i0 = this.analizeaninstr( sdb ,i, i0, s0);
				} "anfac:"	=> {
					i2 = <sdb>.dbdelvar(i,"-mask");
					s0 = <sdb>.get(i,i0);	i0++;	// anima
					if( i2 )	{
						i1--;
						new gmmaskvec <s0>;
					} else {
						new gmadvvec <s0>;
					}
					s1 = <sdb>.get(i,i0);	i0++;	// z ktorej..
					s2 = <sdb>.get(i,i0);	i0++;	// akcja
					i2 = this.newanframesgr(s1, s0, <s1>.actionnr(s2), s0);
					i0 = this.analizeaninstr( sdb ,i, i0, s0);
				} "anac:"	=> {
					i2 = <sdb>.dbdelvar(i,"-adv");
					s0 = <sdb>.get(i,i0);	i0++;	// anima
					s1 = <sdb>.get(i,i0);	i0++;	// z ktorej..
					s2 = <sdb>.get(i,i0);	i0++;	// akcja
					if( StringChecker::isdigit(s2) )	s2 = <s1>.nameofaction(s2);
					this.copyanimaact(s1, s0, s2);
					if( i2 )	{
						i1--;
						<s0>.setasadvanima();
					}
					i0 = this.analizeaninstr( sdb ,i, i0, s0);
				} "anf:" => {
					i2 = <sdb>.dbdelvar(i,"-mask");
					s0 = <sdb>.get(i,i0);	i0++;	// anima
					s1 = <sdb>.get(i,i0);	i0++;	// z ktorej..
					s2 = <sdb>.get(i,i0);	i0++;	// akcja
					i3 = <sdb>.get(i,i0);	i0++;	// klatka
					this.copyanima( s1, s0 );
					<s0>.setframe(s2,i3);
					if( i2 )	{
						i1--;
						<s0>.setasadvanima();
					}
					i0 = this.analizeaninstr( sdb ,i, i0, s0);
				} "anorder:" => {
					s0 = <sdb>.get(i,i0);	i0++;	// anima
					i0 = this.analizeaninstr( sdb ,i, i0, s0);
				} "behfile:" => {
					this.loadbehaviours( <sdb>.get(i,i0) );
					i0++;
				} "include:" =>	{	// another adv specification
					this.loadadventure( <sdb>.get(i,i0) );
					i0++;
				} "walkqueue:" => {
					while( i0<i1 )	{
						clwalkq.add( _spathpref + <sdb>.get(i,i0) );
						i0++;
					}
				} "font:" => {
					s0 = <sdb>.get(i,i0);	i0++;	// nazwa
					s1 = <sdb>.get(i,i0);	i0++;	// plik
					i2 = <sdb>.get(i,i0);	i0++;	// size
					new font <s0>;
					<s0>.load( s1, i2 );
				} "bkg:" => {
					s0 = <sdb>.get(i,i0);	i0++;	// plik
					//this.csetbkg(s0);
					if( s0.contains(".pyz") )	.newanima("imgbkg", s0, 0);
					else .newimg("imgbkg",s0,0);
				
					i0 = this.analizeaninstr( sdb ,i, i0, "imgbkg");
				} "img:" => {
					s0 = <sdb>.get(i,i0);	i0++;	// nazwa
					if( s0.gete(0,4)->in(A, ".jpg", ".png") )	{
						s1 = s0;
						s0 = "img" + s0.strsube(4);
					} else {
						s1 = <sdb>.get(i,i0);	i0++;	// plik
					}
					this.newimg(s0,s1,0);
					i0 = this.analizeaninstr( sdb ,i, i0, s0);
				} "but:", "doors:", "item:" => {
					this.analizebut(s0, sdb, i, i0);
				} "camera:" => {
					r0 = <sdb>.get(i,i0);	i0++;	// xmodfifier
					r1 = <sdb>.get(i,i0);	i0++;	// ymodifier
					clcamera.scalemodifiers(r0,r1);
					while(i0<i1)	{
						s0 = <sdb>.get(i,i0);	i0++;
						if( s0=="-size")	{
							i2 = <sdb>.get(i,i0);	i0++;
							i3 = <sdb>.get(i,i0);	i0++;
							clcamera.setborders( i2, i3 );
						} else if (s0=="-center")	{
							i2 = <sdb>.get(i,i0);	i0++;
							i3 = <sdb>.get(i,i0);	i0++;
							clcamera.setcenter( i2, i3 );
						} else if (s0=="-sizebg")	{
							clcamera.setborders(imgbkg.getw(), imgbkg.geth());
						}
					}
				} "actor:" => {	clcamera.setactor(<sdb>.get(i,i0)); i0++;
				} "bgr:" => {
					s0 = <sdb>.get(i,i0);	i0++;	// plan
					r0 = <sdb>.get(i,i0);	i0++;	// scalex
					r1 = <sdb>.get(i,i0);	i0++;	// scaley
					new classbgplan <s0>;
					clcamera.addbgr(s0, r0, r1);
				} "pathfinder:" => {
					slastpathf = <sdb>.get(i,i0);	i0++;	// nazwa
					s1 = <sdb>.get(i,i0);	i0++;	// file
					if( s1.contains(".ptf") )	{	
						i2 = 20;
						i3 = 20;
					} else {// znaczy, ze wgrywany z grafiki
						i2 = <sdb>.get(i,i0);	i0++;	// dx
						i3 = <sdb>.get(i,i0);	i0++;	// dy
					}
					this.newpathf(slastpathf, s1, i2, i3);
				} "script:" =>	{
					s0 = <sdb>.get(i,i0);	i0++;	// nazwa
					s1 = <sdb>.get(i,i0);	i0++;	// file
					new Script <s0>(s1);
				} "func:" => {		// wywolanie wewnetrznej funkcji
					s1 = <sdb>.get(i,i0); i0++;
					i1--;		// usuwamy nawiasy
					for(i2=clcadv.size-1; i2 >=0; i2--)	{
						s0 = clcadv.getid(i2) + "script";
						if( <s0>.containsfun(s1) )	{
							for(i2=3; i2< i1; i2++)
								<s0>.ARG = ( i2-3, <sdb>.get(i, i2) );
							i2 = -1;
							<s0>.call(s1);
						}
					}
				}
				"IF" => {
					_if_pos++;
					i = ._found_if(sdb, i, i0, i1);
				}
				"ELSE" => i = ._goto_fi(sdb, i+1);
				"FI" => {
					_if_pos--;
					if( _if_pos<-1 )	("FI error! "+this+"."+ .methodname)->print;
				}
				"bsave:" =>{ 	clsave.bset(<sdb>.get(i,i0)); i0++;}
				"save:" => {
					s0 = <sdb>.get(i,i0); i0++;
					s1 = <sdb>.get(i,i0); i0++;
					clsave.set(s0,s1);
				}
				"stdptf:" => {	slastpathf = <sdb>.get(i,i0); i0++;	}
				"sfxs:" => {
					while(i0<i1)	{
						s0 = <sdb>.get(i,i0); i0++;
						s2 = s0 + ".wav";
						i2=1;
						i3 = 100;
						b0 = false;
						b1 = false;
						r0 = 0.0;
						while(i2 && i0<i1)	{
							s1 = <sdb>.get(i, i0);
							match(s1)	{
								"-f" => {
									i0++;
									s2 = <sdb>.get(i,i0) + ".wav";
								}
								"-v" => {
									i0++;
									i3 = <sdb>.get(i,i0);
								}
								"-l" => b0 = true;
								"-p" => b1 = true;
								"-pl" => r0 = 1.0;
								? => {
									i0--;
									i2 = 0;
								}
							}
							i0++;
						}
						.newsfx(s0, s2);
						<s0>.setvol(i3);
						if( b0 ) <s0>.addmethod("onfinish","_stdsndloop");
						//if( b0 ) <s0>.loop;
						if( b1 ) <s0>.play;
						else if (r0) <s0>.playloop;
					}
				}
				? => ;
			}
		}
		<sdb>.readonly();
	}
	int _found_if(string sdb, int row, int col, int cols)	{
		col++;		// opusc nawias
		int i2 = 0;
		bool odp = 0;
		cols--;
		string s[2];
		while( col<cols )	{
			s0 = <sdb>.get(row, col);
			s1 = <sdb>.dbchecknext(row, col);
			match(s1)	{
				")","|", "&" => {
					odp = ._check_if(i2, odp, s0.getb(0,1)=="!" ? (!clsave.bis(s0.strsubb(1))) : clsave.bis(s0) );
					if( s1=="|" ) i2 = 1;
					else if (s1=="&") i2 = 2;
				}
				"=" => {
					col+=2;
					odp = ._check_if(i2, odp, clsave.is(s0, <sdb>.get(row, col)) );
					i2 = ._check_if2( <sdb>.dbchecknext(row, col) );
				}
				"!=" => {
					col+=2;
					odp = ._check_if(i2, odp, !clsave.is(s0, <sdb>.get(row, col)) );
					i2 = ._check_if2( <sdb>.dbchecknext(row, col) );
				}
				? => ;
			}
			col+=2;
		}
		if( !odp )	{
			._goto_fi(sdb, row+1);
		} else row;
	}
	_goto_fi(string sdb, int row)	{
		int poz = _if_pos;
		while( 1 )	{
			match( <sdb>.get(row,0) )	{
				"IF" => poz++;
				"ELSE" => if( poz==_if_pos ) return row;	// for robi potem i++
					//else poz--;
				"FI" => if( poz==_if_pos ) {
						_if_pos--;
						return row;	// for robi potem i++
					} else poz--;
				? => ;
			}
			row++;
		}
	}
	int _check_if2(string s)	{
		match(s)	{
			"|" => 1;
			"&" => 2;
			? => 0;
		}
	}
	bool _check_if(int opt, bool b, bool bnew)	{
		match( opt )	{
			1 => b || bnew;
			2 => b && bnew;
			? => bnew;
		}
	}
	behrewind()	{	if( sactbeh!=null )	<sactbeh>.rewind();	}
	bool behplaying()	{	return sactbeh!=null;	}
	bool behexist(string sname)	{	return engine.varexist( this.getbeh(sname) );	}
	string getbeh(string sname)	{	return _sbeh+sname;	}
	string newbehname()	{
		string s = _sbeh + "_" + iidbeh;
		iidbeh++;
		return s;
	}
	string newbeh()	{
		string s = this.newbehname();
		new classbehhero <s>;
		return s;
	}
	def _checkvol(string sdb,int irow, int id)	{
		if( <sdb>.dbchecknext(irow, id)=="-v" )	{
			id+=2;
			return <sdb>.get(irow, id), id+1;
		} else return 100, id+1;
	}
	loadbeh(string sdb, int irow, int icol, int id, string sstarter, string sprevobj, bool brand, bool bpar)	{
		string s[4], bool bblock = <sstarter>.getblock(), bool bread;
		s0 = <sdb>.get(irow,id);	id++;
		s1 = this.newbeh();
		int i[2];
		match(s0)	{
			"IF", "ELIF" => {
				i0 = id+1;
				while( <sdb>.get(irow, id)!=")" ) id++;
				<s1>.<"setas"+s0>(sdb, irow, i0, id);
				id++;
			}
			"FI", "ELSE" => <s1>.setas(s0);
			"call:" => {	s0 = <sdb>.get(irow,id);	id++;
				<s1>.setascaller( s0, sdb+"script" );
			}
			"walk:" => {	s0 = <sdb>.get(irow,id);	id++;	// kto
				s2 = <sdb>.get(irow,id);	id++;	// destx lub "id"
				s3 = <sdb>.get(irow,id);	id++;	// desty lub idpath
				<s1>.setaswalker( _spathpref + s0, s2, s3 );
			}
			"turn:" => {	s0 = <sdb>.get(irow,id);	id++;	// kto
				s2 = <sdb>.get(irow,id);	id++;	// dir
				<s1>.setasturn( _spathpref + s0, s2 );
			}
			"setpos:" => {	s0 = <sdb>.get(irow,id);	id++;	// kto
				s2 = <sdb>.get(irow,id);	id++;	// id lub x
				i1 = <sdb>.get(irow,id);
				i0 = 0;
				s3 = <sdb>.dbchecknext(irow,id);
				if( s3=="-ssc" )	{
					i0 = 1;
					id++;
					s3 = <sdb>.dbchecknext(irow,id);
				}
				if( s3=="-dir" )	{
					id+=2;
					s3 = <sdb>.get(irow, id);
				} else {
					s3 = "auto";
				}
				id++;
				<s1>.setasposer( s0, s2, i1, i0, s3 );
			}
			"game:" => {	s0 = <sdb>.get(irow,id);	id++;	// nazwa gry
				match( s0 )	{
					"-def", "-adv" => {
						<s1>.setasnewgamer(s0, <sdb>.get(irow, id), <sdb>.get(irow, id+1) );
						id+=2;
					}
					? => <s1>.setasnewgamer(null, null, s0);
				}
			}
			"ref:" => {		id = this.buildbeh( "_" + iidbeh, sdb, irow, id );
				s0 = this.newbehname();
				<s1>.setascaller( s0.strsubbs(_sbeh), sdb+"script" );
			}
			"anplay:" => {	s0 = <sdb>.get(irow,id);	id++;
				s2 = <sdb>.get(irow,id);	id++;
				<s1>.setasanplayer(s0, s2);
			}
			"anorder:" =>	{	s2 = <sdb>.get(irow,id);	id++;
				<s1>.setasanorder(sdb, irow, id, s2);
				id = this.analizeaninstr(sdb,irow,id,null);
			}
			"sndbg:" =>	{	s0 = <sdb>.get(irow,id);
				|i0, id| = ._checkvol(sdb,irow,id);
				<s1>.setassndbg(s0, i0);
			}
			"sndplay:" =>	{	s0 = <sdb>.get(irow,id);
				|i0, id| = ._checkvol(sdb,irow,id);
				<s1>.setassndplayer(s0, i0);
			}
			"fxplay:" => 	{	s0 = <sdb>.get(irow,id);
				|i0, id| = ._checkvol(sdb,irow,id);
				<s1>.setassndplayer("sfx/"+s0, i0);
			}
			"fxbg:" => 	{	s2 = <sdb>.get(irow,id);
				|i0, id| = ._checkvol(sdb,irow,id);
				<s1>.setassndbg("sfx/"+s2, i0);
			}
			"wait:" =>	{	i0 = <sdb>.get(irow,id);	id++;
				<s1>.setaswaiter(i0);
			}
			"read:" =>	{	s0 = <sdb>.get(irow,id);	id++;	// plik
				i0 = <sdb>.get(irow,id);	id++;	// x
				i1 = <sdb>.get(irow,id);	id++;	// y
				s2 = "auto";
				if( <sdb>.getcolsno(irow)>id )	{
					s2 = <sdb>.get(irow,id);
					if( s2=="-dir" )	{
						id++;
						s2 = <sdb>.get(irow,id); id++;
					}
				}
				<s1>.setasreader(s0,i0,i1,s2);
			}
			"met:" =>	{	s0 = <sdb>.get(irow,id);	id++;
				s3 = gameapi.getgamename;
				if( s0.contains(".") )	{
					s2 = s0.strgetto(".");
					s0 = s0.strgetfrom(".");
					if( s2=="" || s2=="this" ) s2 = s3;
				} else
					s2 = s3;
				<s1>.setasmet(s2, s0);
			}
			"bsave:" =>	{	s0 = <sdb>.get(irow,id);	id++;
				<s1>.setassaver(s0,"1");
			}
			"save:" =>	{	s0 = <sdb>.get(irow,id);	id++;
				s2 = <sdb>.get(irow,id);	id++;
				<s1>.setassaver(s0,s2);
			}
			"script:" =>	{	s0 = <sdb>.get(irow,id);	id++;
				s2 = <sdb>.get(irow,id);	id++;
				<s1>.setasscript(s0,s2);
			}
			"func:" =>	{
				s2 = <sdb>.get(irow,id);
				
				for(i1=clcbeh.size-1; i1 >= 0; i1--)	{
					s0 = clcbeh.getid(i1) + "script";
					if( <s0>.containsfun(s2) )	{
						i1 = -1;
					}
				}
				//s0 = sdb + "script";
				
				if( <sdb>.dbchecknext(irow,id)=="(" )	{
					i1 = id+2;
					while( <sdb>.get(irow,id)!=")" ) id++;
				} else {
					i1 = -1;
				}
				id++;
				<s1>.setasscript(s0,s2, sdb, irow, i1);
			}
			"use:" => {	s0 = <sdb>.get(irow,id);	id++;
				<s1>.setasuse(s0);
			}
			"topck:" => {
				s2 = <sdb>.get(irow,id);	// przedmiot
				if( <sdb>.dbchecknext(irow,id)=="-pck" )	{
					id+=2;
					s3 = <sdb>.get(irow,id);
				} else s3 = s2;
				id++;
				<s1>.setastopck(s2, s3);
			}
			"enter:"	=> <s1>.setasenter;
			"close:"	=> <s1>.setasclose;
			"music:"	=> {
				i1 = id+1;
				while( <sdb>.get(irow,id)!=")" ) id++;
				<s1>.setasmusic(sdb, irow, i1, id);
				id++;
			}
			? => {		// talker
				s3 = s0.strgetto("_");
				s2 = this.getheroloader( s3 );
				if( s2==null )	{
					if( igmdebug ) engine.print(s1+": "+s0+" loadbeh error: no hero linked to "+s3);
					return s1, icol;
					//<s1>.setassndplayer(s0);
				} else {
					|bool bstart, bool bstop| = <s2>.getstartstop();
					string sdir="auto", string sbase=modadv.varget("_stalk"), int itypsort=1;
					bread = id<icol;
					while(bread)	{
						s3 = <sdb>.get(irow,id);	id++;
						match(s3)	{
							"-stt" =>	{	bstart = <sdb>.get(irow,id);	id++;}
							"-stp"=>	{	bstop = <sdb>.get(irow,id);	id++;}
							"-base"=>	{	sbase = <sdb>.get(irow,id);	id++;}
							"-r" =>	itypsort=1; 
							"-nr" =>	itypsort = 0;
							"-dir" =>	{	sdir = <sdb>.get(irow,id);	id++;}
							? => {	bread = false;	id--;	}
						}
						if( bread && id>=icol )	{
							bread = false;
						}
					}
					<s1>.setastalker( <s2>.varget("sanhero"), s0, sbase,
						itypsort, bstart, bstop, sdir );
					
				}
			}
		}
		<sstarter>.addtostarter( s1 );
		
		if( brand==false)	{
			<sprevobj>.setflags(s1);
			<s1>.addflags( sstarter, bblock, bpar );
		} else {
			<sprevobj>.setflags(null);
			<s1>.addflags( sstarter, bblock, false );
		}
		/*if( id < icol )	{
			this.loadbeh(sdb,irow,icol,id,sstarter,s1,brand, bpar);
		}*/
		return s1, id;
	}
	int buildbeh(string sname, string sdb, int irow, int icol)	{
		int id = dbmacros.findbyrow( <sdb>.get(irow, icol) );
		if( id<0 )	{
			engine.print("no such macro: "+ <sdb>.get(irow, icol) );
			return -1;	
		}	// nie ma takiego makra
		while( <sdb>.get(irow, icol) != "(" )	{	icol++;	}
		icol++;
		int id2 = <sdb>.addrow() -1;
		string s = <sdb>.get( irow, icol ); icol++;
		_vecarg.free();
		while( s!=")" )	{		// sczytanie argumentow
			_vecarg.add( s );
			s = <sdb>.get( irow, icol ); icol++;
		}
		int ile = dbmacros.getcolsno( id );
		int i1;
		<sdb>.add( id2, sname );
		for( int i=1; i<ile; i++)	{
			s = dbmacros.get( id, i );
			if( s.getb(0,1)=="$" )	{
				i1 = s.getb(1,10);
				<sdb>.add( id2, _vecarg.get( i1-1 ) );
			} else {
				<sdb>.add( id2, s );
			}
		}
		return icol;
	}
	loadbehaviours(string sfile)	{
		string sdb = clcbeh.get();
		new db <sdb>;
		//<sdb>.loadbeh(this.getgraphpath()+sfile);
		<sdb>.loadbeh( .getpath(sfile) );
		string s = sdb + "script";
		new Script <s>(sdb);
		int i[2], string s[4], bool brand, bool bread, string bonce, bool bpar, bool bblock, int ienumer;
		int iifsave, string sifsave, string sifvar;
		for( int i=0; i< <sdb>.getrowsno(); i++)	{
			i1 = 0;
			s0 = <sdb>.get(i,i1);	i1++;
			match(s0)	{
				"macro:" => { dbmacros.dbaddrowfrom( sdb, i, 1 );
				} "include:" => {	this.loadbehaviours(<sdb>.get(i,i1));
					i1++;
				} "build:" => { i1 = this.buildbeh( <sdb>.get(i,i1), sdb, i, i1+1 );
				} "func" => 	{ while( <sdb>.get(i,0)!="end" )	i++;
				} "IF" => { _if_pos++;	i = ._found_if( sdb, i, i1, <sdb>.getcolsno(i) );
				} "ELSE" => { i = ._goto_fi(sdb, i+1);
				} "FI" => {
					_if_pos--;
					if( _if_pos< -1 )	("FI error! "+this+"."+ .methodname)->print;
				}
				? => {
					i0 = <sdb>.getcolsno(i);
					s0 = this.getbeh(s0);
					new classbehhero <s0>;
					brand = false;
					bread = true;
					bonce = null;
					bpar = false;
					bblock = true;
					//bblock = false;
					sifvar = null;
					iifsave = -1;
					ienumer=0;
					while(bread)	{
						s1 = <sdb>.get(i,i1);	i1++;
						match(s1)	{
							"-nr"	=>	brand = false;
							"-once"	=>	{ bonce = <sdb>.get(i,i1);	i1++;}
							"-par"=>	bpar = true;
							"-r"	=>	brand = true;
							"-nb"=>	bblock = false;
							"-b"=>		bblock = true;
							"-en"=>	{	ienumer = <sdb>.get(i,i1);	i1++;}
							"-bif"=>	{	iifsave = 1;
								sifsave = <sdb>.get(i,i1);	i1++;
								sifvar=true;
							}
							"-bnif"=>	{	iifsave = 0;
								sifsave = <sdb>.get(i,i1);	i1++;
								sifvar=true;
							}
							"-if"	=>	{	iifsave = 1;
								sifsave = <sdb>.get(i,i1);	i1++;
								sifvar = <sdb>.get(i,i1);	i1++;
							}
							"-nif" =>	{	iifsave = 0;
								sifsave = <sdb>.get(i,i1);	i1++;
								sifvar = <sdb>.get(i,i1);	i1++;
							}
							?	=>	{	bread = false;
								<s0>.setasstarter(bonce, brand, bpar, bblock, ienumer, iifsave, sifsave, sifvar);
								//this.loadbeh(sdb, i, i0, i1-1, s0, s0, brand, bpar);
								
								// loadbeh(string sdb, int irow, int icol, int id, string sstarter, string sprevobj, bool brand, bool bpar)	{
								/*if( id < icol )	{
									this.loadbeh(sdb,irow,icol,id,sstarter,s1,brand, bpar);
								}*/
								i1--;
								s1 = s0;	// sstarter
								while( i1<i0 )	{
									|s1, i1| = .loadbeh( sdb, i, i0, i1, s0, s1, brand, bpar);
								}
							}
						}
					}
				}
			}
		}
		<sdb>.readonly();
	}
	int analizeaninstr(string sdb,int irow,  int icol, string san)	{
		bool bread = true;
		if( icol >= <sdb>.getcolsno(irow) )	{	bread=false;	}
		bool banalize = false;
		if( san!=null )	{
			banalize=true;
			this.advanstand(san);
		}
		int i[3];
		string s[2];
		while(bread)	{
			s1 = <sdb>.get(irow,icol);	icol++;
			match(s1)	{
				"-z"		=>	{
					if( banalize)	<san>.setz( <sdb>.get(irow,icol) );
					icol++;
				}
				"-pos"	=>	{	s0 = <sdb>.get(irow,icol);	icol++;
					i2 = <sdb>.get(irow,icol);	icol++;
					if( banalize)	{
						if(s0=="-id")	{
							s0 = _spathpref+san;
							i0 = <s0>.getbyname(i2);
							i1 = <s0>.getxver(i0) - <s0>.getposx;
							i2 = <s0>.getyver(i0) - <s0>.getposy;
						} else i1=s0;
						//<san>.setpos( i1+ clcamera.getposx(), i2+ clcamera.getposy() );
						<san>.setpos( i1, i2 );
					}
				}
				"-putgr"	=>	if( banalize )	<san>.anputgr();
				"-vis"	=>	{	i0 = <sdb>.get(irow,icol);	icol++;
					if( banalize )	i0==false ? <san>.hide() : <san>.show();
				}
				"-show"	=>	if( banalize )	<san>.show();
				"-hide"	=>	if( banalize )	<san>.hide();
				"-dir"	=>	{s0 = <sdb>.get(irow,icol);	icol++;
					if( banalize)	{
						s1 = <san>.actionname();
						i0 = <san>.framenr();
						<san>.setframe( s1.strsube(2) + s0, 0 );
					}
				}
				"-play"	=>	{
					if( banalize)	<san>.play( <sdb>.get(irow,icol) );
					icol++;
				}
				"-nplay"	=>	{i0 = <sdb>.get(irow,icol);	icol++;
					if( banalize)	<san>.nplay( i0 );
				}
				"-lplay"	=>	{
					if( banalize)	<san>.anloopsplay( <sdb>.get(irow,icol) );
					icol++;
				}
				"-bgr"	=>	{s1 = <sdb>.get(irow,icol);	icol++;
					if( banalize)	{
						<s1>.add(san);
						if( engine.varexist( _spathpref + san ) )	<s1>.add( _spathpref+san );
					}
				}
				"-sc"		=>
					if( banalize)	{
						s1 = _spathpref+san;
						if( engine.varexist( s1 ) )	<s1>.scalean();
					}
				"-ssc"	=>	if( banalize)	clcamera.setscene();
				"-actor"	=>	if( banalize)	clcamera.setactor(san);
				"-mhero"	=>	if( banalize)	this.setmainhero(san);
				"-puty"	=>	{s0 = <sdb>.get(irow,icol);	icol++;
					if( banalize)	s0=="resy" ? <san>.anputy( iResY-1 ) : <san>.anputy(s0);
				}
				"-stopf"	=>	if( banalize )	<san>.stop(false);
				"-stoph"	=>	if( banalize )	{
					<san>.stop(false);
					<san>.hide;
				}
				"-setaction" =>	{s0 = <sdb>.get(irow,icol);	icol++;
					if( banalize)	{
						if( StringChecker::isdigit(s0) )	<san>.setframe(s0.to_i, 0);
						else <san>.setframe(s0, 0);
						<san>.stop(false);
					}
				}
				"-setframe"	=>	{s0 = <sdb>.get(irow,icol);	icol++;
					i0 = <sdb>.get(irow,icol);	icol++;
					if( banalize)	{
						if( StringChecker::isdigit(s0) )	<san>.setframe(s0.to_i, i0);
						else <san>.setframe(s0, i0);
						<san>.stop(false);
					}
				}
				"-stand"	=>	{
					if( banalize)	<san>.setstandbase(<sdb>.get(irow,icol));
					icol++;
				}
				"-delay"	=>	{
					if( banalize)	<san>.setdelay(<sdb>.get(irow,icol));
					icol++;
				}
				"-step" => {
					if( banalize)	< _spathpref + san >.setanstep(<sdb>.get(irow,icol));
					icol++;
				}
				"-sb1" => {	if( banalize)	< san >.setbutbase1(<sdb>.get(irow,icol));	// dla buttona
					icol++;	}
				"-sb2" => {	if( banalize)	< san >.setbutbase2(<sdb>.get(irow,icol));	// dla buttona
					icol++;	}
				?	=>	{	bread = false;		// natrafil na inny string
					icol--;		// przywroc go do analizy
				}
			}
			if( bread && icol>=<sdb>.getcolsno(irow) )	bread = false;
		}
		return icol;
	}
	/*******************************/
	cadvherofinish()	{}
	/*******************************/
	butmoveoff(string sbut)	{
		<sbut>.moveoff();
		this.< <sbut>.getbutname() + "_MOVEOFF">();
	}
	butmoveon(string sbut)	{
		<sbut>.moveon();
		this.< <sbut>.getbutname() + "_MOVEON">();
	}
	advmsmove()	{
		if ( !this.advgetlock() ){
			|int x, int y| = mouse.getpos();
			int id = grbuts.butisin(x,y,true,true);
			if( id )	{
				string s = grbuts.get(id-1);
				if( s!=_slastms )	{
					if( _slastms!=null )	this.butmoveoff(_slastms);
					_slastms = s;
					this.butmoveon(s);
				}
			} else {
				if( _slastms!=null )	{
					this.butmoveoff(_slastms);
					_slastms = null;
				}
			}
			grmsmove.eval2("onmousemove", x, y);
			moddbg.msmove();
		}
	}
	butclickon(string sbut)	{
		//string s = _spocketpref+this.getmainhero();
		//if( engine.varexist(s) )	<s>.skipitem();
		<sbut>.clickon();
		//this.< <sbut>.getbutname() + "_CLICKON">();
		if( !.behplaying )
			_b_rewind = !.playbehif( "beh_"+ <sbut>.getbutname +"_LCLICK" );
	}
	butrelease(string sbut)	{
		//string s = _spocketpref+this.getmainhero();
		//if( engine.varexist(s) )	<s>.skipitem();
		<sbut>.lrel();
		//this.< <sbut>.getbutname() + "_RELEASE">();
	}
	advmsclick()	{
		if( _tim_dbclk.isplaying )	{
			clwalkq.mulspeed(2);
			return;
		} else _tim_dbclk.play;
		_b_rewind = true;
		if( !bmslock )	{
			|int x, int y| = mouse.getpos();
			int id = grbuts.butisin(x,y,true,true);
			if( id )
				this.butclickon(grbuts.get(id-1));
			else {
				string s = _spocketpref+this.getmainhero();
				if( engine.varexist(s) )	<s>.itemhide;
				clwalkq.goto(x,y);
			}
			grmslclick.eval2("onmouselclick",x,y);
		}
		if(_b_rewind) this.behrewind();
		moddbg.mslclick();
	}
	advmsrclick	{
		if( !bmslock )	{
			grmsrclick.eval2("onmouserclick",mouse.getpos);
		}
	}
	advmslrel() {
		if( !bmslock )	{
			|int x, int y| = mouse.getpos();
			int id = grbuts.butisin(x,y,true,true);
			if( id )	this.butrelease(grbuts.get(id-1));
			grmslrel.eval2("onmouselrel",x,y);
		}
		moddbg.mslrel();
	}
	mousemove()	{
		if( igmstate==0 ) this.advmsmove();
		this.mouse_MOVE();
	}
	mouselclick()	{
		if( igmstate==0 ) this.advmsclick();
		this.mouse_LCLICK();
	}
	mouselrel()	{
		if( igmstate==0 ) this.advmslrel();
		this.mouse_LREL();
	}
	mouserclick()	{
		if( igmstate==0 ) .advmsrclick;
		this.mouse_RCLICK();
	}
	keydown()	{
		moddbg.dbkeydown();
		this.keyboard_KEYDOWN();
	}
	exit()	{
		modadvglob.onexit();
	}
	onmusicfin	{
		_music.play;
	}
	/*******************************/
	sndplayobfin(string s, string sob, string sfun)	{
		__sndplay.load( .getsndpath + s + ".wav" );
		__sndplay.sob = (sob);
		__sndplay.sfun = (sfun);
		__sndplay.play;
	}
	sndplayfin(string s, string sfun)	{	.sndplayobfin(s,null,sfun);	}
	sndplay(string s)	{	.sndplayobfin(s, null, null);	}
	/*******************************/
	advsaveonstart	{
		//clsave.set("GAME_game", this);
		clsave.set("GAME_game", gameapi.getgamename);
		clsave.set("GAME_sgmgame", sgmgame);
		clsave.set("GAME_sgmglobpath", sgmglobpath);
		clsave.set("GAME_sgmlastscene", sgmlastscene);
		clsave.set("GAME_ccs", ccs.isvisible);
		.advautosave;
	}
	advautosave	{
		clsave.save("saves/autosave.txt");
		modadvglob.savepck("autosave");
	}
	advautoload	{	._advload("autosave");	}
	advcacheload	{	._advload("cache");	}
	advcachesave	{	._advsave("cache");	}
	_advload(string s)	{
		modadvglob.delheros;
		modadvglob.loadpck(s);
		
		clsave.load("saves/"+s+".txt");
		sgmgame = clsave.get("GAME_sgmgame");
		sgmglobpath = clsave.get("GAME_sgmglobpath");
		sgmlastscene = clsave.get("GAME_sgmlastscene");
		if( clsave.bis("GAME_ccs") ) ccs.show; else ccs.hide;
		gameapi.play( clsave.get("GAME_game") );
	}
	_advsave(string s)	{
		new classfullsave _saver("saves/" + s + ".txt");
		_saver.load("saves/autosave.txt");
		_saver.stdsave;
		delete _saver;
		new vector _vcsave;	_vcsave.type("string");
		new vector _vcsv2;	_vcsv2.type("string");
		_vcsave.load("saves/grpck_autosave.txt");
		_vcsave.save("saves/grpck_"+s+".txt");
		@s2;
		for( int i=0; i<_vcsave.size; i++)	{
			s2 = _vcsave.get(i);
			_vcsv2.load("saves/" + s2 + "autosave_name.txt" );
			_vcsv2.save("saves/" + s2 + s + "_name.txt" );
			_vcsv2.load("saves/" + s2 + "autosave_file.txt" );
			_vcsv2.save("saves/" + s2 + s + "_file.txt" );
		}
		delete _vcsave;
		delete _vcsv2;
// 		arPocket.save( "saves/" + this+sfilepref + "_name.txt" );
// 		arPocketFile.save( "saves/" + this+sfilepref + "_file.txt" );
	}
}


module moddbg : classlocker	{
	init()	{
		classlocker::init();
		new string sstate = "init";
		new int ilastx;
		new int ilasty;
		new text txtpos;
		txtpos.setz(5000);
		txtpos.setpos( 0, 0 );
		txtpos.setbkg(0,0,64,16, 0,0,0,192);
		
		new text txtswin;
		txtswin.setz(5000);
		txtswin.setbkg(0,0,64,16, 0,0,0,192);

		new text txtpod;
		txtpod.setz(5000);
		txtpod.setbkg(0,0,128,16, 0,0,0,192);

		this.disable();

	}
	public enable()	{
		this.unlock();
		txtpos.show();
		txtswin.show();
		txtpod.show();
	}
	public disable()	{
		this.lock();
		txtpos.hide();
		txtswin.hide();
		txtpod.hide();
	}
	public updatetxtpos(int x, int y)	{
		txtpos.set("" + ( x-clcamera.getposx() ) + "," + ( y-clcamera.getposy() ));
		txtpos.setpos(x-32,y+46);
		txtpod.setpos(x-64,y+30);
		txtpod.set( engine.getimg(x,y,true,true,-1000,1000));
	}
	public updateswin()	{
		txtswin.set(" " + (swinka.getposx()-clcamera.getposx()) + "," + (swinka.getposy()-clcamera.getposy()) );
		txtswin.setpos( swinka.getposx()-32, swinka.getposy() );
	}
	msminit(int x, int y)	{	this.updatetxtpos(x,y);	}
	msmmove(int x, int y)	{
		clcamera.moveplans(x-ilastx, y-ilasty);
		this.updatetxtpos(x,y);
	}
	public msmove()	{
		if( this.getlock() )	{	return;	}
		int x = mouse.getpx();
		int y = mouse.getpy();
		this.<"msm"+sstate>(x,y);
		ilastx=x;
		ilasty=y;
	}
	public mslclick()	{
		if( this.getlock() )	{	return;	}
		if( keyboard.iskeydown("space")==true )	{
			sstate="move";
		}
	}
	public mslrel()	{
		if( this.getlock()==true )	{	return;	}
		sstate = "init";
	}
	msrclick()	{
		int x = mouse.getpx();
		int y = mouse.getpy();
		int id = grbuts.isin(x,y,true,true);
		if( id!=false )	{
			string s = grbuts.get(id-1);
			s.print();
		} 
//		txtpod.set( engine.getimg(x,y,true,true,-1000,1000));
	}
	dbkeydown(){
		if( !igmdebug ) return;
		if( keyboard.iskeydown("lctrl") ) {
			if( keyboard.iskey("l") )	<gameapi.getgamename>.advcacheload;
			else if( keyboard.iskey("s") )	{
				<gameapi.getgamename>.advcachesave;
			}
		}
		if( keyboard.iskey("d") )	{
			if(.getlock)	{
				this.enable();
			} else {
				this.disable();
			}
		}
		if( this.getlock() )	{	return;	}
		if( keyboard.iskey("s")==true )	{
			this.updateswin();
		}
	}
}

game Tclassmenu	{
	init()	{
		new db _dbl;
		new gmobjvec gr1;
		gr1.add("bkg");
	}
	public tload(string spath, string sbuts, string sdbfile)	{
		this.setgraphpath(spath);
		if( sdbfile!=null )	{
			_dbl.loadscript(this.getgraphpath()+sdbfile);
			for(int i=0; i<_dbl.getrowsno();i++)	{
				this.newsnd("snd"+_dbl.get(i,0), _dbl.get(i,1)+".wav");
			}
		}
		new classbutton _clb;
		_clb.build2( this.getgraphpath() + sbuts, 10, "imglobcurs", "gr1" );
		_clb.clickfunc("_gmbutclick");
		_clb.movonfunc("_gmbutmove");
		if(engine.varexist("sndintro"))	this.cbplay("sndintro");
	}
	mouselclick()	{
		this.cactsndstop(true);
	}
	_gmbutmove(string s)	{
		sndakskermovon.play();
		if( engine.varexist("sndintro") && sndintro.isplaying() )	return;
		if( engine.varexist("snd"+s) )	this.crselfplay("snd"+s);
	}
	_gmbutclick(string s)	{
		this.<s+"_BUTCLICK">();
	}
}

class TMenu 	{
	init()	{}
	tinit(string sbuts)	{
		new Buttons but1(sbuts);
	}
	mousel_click()	{
		.cactsndstop(true);
	}
	but1_moveon	{
		string s = but1.sobject;
		sndakskermovon.play;
		if( !(engine.varexist("sndintro") && sndintro.isplaying) )
			if( engine.varexist("snd"+s) )	this.cbselfplay("snd"+s);
		.<s+"_MOVEON">;
	}
	but1_moveoff	{	.<but1.sobject + "_MOVEOFF">;	}
	but1_lclick()	{
		this.<but1.sobject+"_BUTCLICK">();
	}
}

/************ template game Painter **************/
class TPainter {
	init()	{}
	tinit(string sndbase, string spath, string sfilebg, string sfilebrush, string sfile, string sfarby, @dir)	{
		if( sndbase!=null )
			GameController::init(sndbase);
		this.unlock();
		this.setgraphpath(spath);
		
		if( sfilebg!=null )
			this.newanima("anbkg",sfilebg,0);
		this.newanima("anbrush1", sfilebrush, 3000);
		this.copyanima("anbrush1","anbrush2");
		anbrush2.setframe(0,1);
		anbrush2.setz(anbrush1.getz-1);
		anima_pack::resizemethods("anbrush1");		// galka
		anima_pack::resizemethods("anbrush2");		// pedzel
		int x, int y;
		match( dir )	{
			"ru" => { x = anbrush2.getex;
				y = anbrush2.getpy; }
			"rd" => { x = anbrush2.getex;
				y = anbrush2.getey; }
			"ld" => { x = anbrush2.getpx;
				y = anbrush2.getey; }
			? => { x = anbrush2.getpx;
				y = anbrush2.getpy; }
		}
		anbrush1.saverelpos(x, y);	// lewy dolny rog - kursor myszy
		anbrush2.saverelpos(x, y);	// lewy dolny rog - kursor myszy
		mouse.hide();
		
		this.newanima("anfg", sfile, 100);
		anfg.setframe("foreground",0);
		
		new gmimgvec grdraw;
		_ = this.newanframesgr("anfg", "andraw", anfg.actionnr("draw"), "grdraw");
		grdraw.setz(10);
		
		new gmimgvec grpaleta;
		//_ = this.newanframesgr("anfg", "anpaleta", anfg.actionnr("paleta"), "grpaleta");
		"grpaleta" ..< sfarby;
		grpaleta.setz(20);
		
		new int _ibrx = anbrush2.getpx();
		new int _ibry = anbrush2.getpy();
		while( !anbrush2.isin(_ibrx, _ibry, false, true) )	{
			_ibrx++;
			if( _ibrx==anbrush2.getex() ) {
				_ibrx = anbrush2.getpx();
				_ibry++;
			}
		}
		_ibrx-=anbrush2.getpx();
		_ibry-=anbrush2.getpy();
		TPainter::mouse_move;		// ustawienie pedzla w pozycji myszy
	}
	game_exit()	{
		mouse.show();
		GameController::game_exit();
	}
	mouse_move()	{
		anbrush1.mssetrelpos();
		anbrush2.mssetrelpos();
	}
	mouse_lclick()	{
		if( !this.getlock() )	{
			|int x, int y| = mouse.getpos();
			if( grdraw.isin(x,y,true,true) )	{
				<grdraw.getsfound()>.paint(
					anbrush2.getrgba(anbrush2.getpx()+_ibrx,anbrush2.getpy()+_ibry), 0 );
				.onpaint;
			} else if ( grpaleta.isin(x,y,false,true) )	{
				|@c[4]| = <grpaleta.getsfound()>.getrgba(x,y);
				c3 = 255;
				anbrush2.paint( c0, c1, c2, c3, 0 );
				.onsetbrush;
			}
		}
	}
}

class TPainterCon : TPainter, GameController	{
	init	{}
}

new int iMusic = 1;
new int iNutka = 1;
new string sAskerGame;

class Computro : classadv, GameController, Localize	{
	init(string s)	{
		AdventureGame = false;
		igmstate = 0;
		classadv::init;
		GameController::init(s);
		Localize::init;
		.path = (s);
		.setwavpath(SNDPATH);
		bsms.setstd;		// ustawia standardowo 
		clmusic.play;
		clbuts.reset;
		new Music mus;
		if( PrzygodaMode )	{
			classadvcontroller::advsaveonstart;
			classadvinfo2::advsave_game;
		}
	}
	cutscene	{
		new CutScene ccs(0, 0, iResX, iResY);
		ccs.setz(2000);
	}
	cshowbut(string sbut, @dir)	{
		clbuts (sbut, dir) { (string sbut, @dir)
			clp.show( buts.callimgfun( sbut, "getcx"), buts.callimgfun( sbut, "getcy"), dir ); 
		};
	}
	napisshow(int x, int y)	{
		.show;
		.move(x,y);
	}
	napispod(string s)	{	.napisshow(<s>.getcx-.getw/2, <s>.getey+5); }
	crect	{	new Rect rec(600,196,403,497);	}
	crect2	{	new Rect rec2(6,174,1012,530);	}
	gotoadv(string spath, string sgame)	{
		sgmlastscene = gameapi.getgamename;
		sgmglobpath = spath;
		sgmgame = sgame;
		gameapi.play("gameadvdef");
	}
	/***********************************************************/
	exit	{
		bsms.setstd;
		.game_exit;
	}
	public askrestart	{	claskexit.askrestart;	}
	onmusicfin	{	mus.play;	}
	/***********************************************************/
	advclick()	{
		if( igmdebug && (igmstate==0 || igmstate==5) )	{
			this.cactsndstop(true);
		}
	}
	/***********************************************************/
	key_down	{
		if( igmdebug && keyboard.iskeydown("lctrl") && keyboard.iskey("r") )	.crestart;
	}
}




new classgamepause clpause;
new classgamemusic clmusic;
clmusic.sndbgrpath("sounds/bgr/");
clmusic.musicpath("sounds/music/");
clmusic.load("sounds/music.db");

new snd sndakskermovon;
sndakskermovon.load("sounds/sfx/butmovon.wav");
sndakskermovon.setvol(40);

class classasker2 : classasker	{
	init()	{
		classasker::init();
		
		new snd sndaskexit;		sndaskexit.setstartstopflag(false,true);
		new snd sndaskexitgame;	sndaskexitgame.setstartstopflag(false,true);
		new snd sndyes;			sndyes.setstartstopflag(false,true);
		new snd sndno;			sndno.setstartstopflag(false,true);
		new snd sndaskrestart;	sndaskrestart.setstartstopflag(false,true);
		new snd sndaskrestart2;	sndaskrestart2.setstartstopflag(false,true);

		.reload;
		this.load( "scripts/common/asker.pyz", 12000 );
		this.fxonmovon("sndakskermovon");
	}
	reload	{
		this.setwavpath(SNDPATH);
		@s = .getsndpath;
		sndaskexit.load( s + "narexit.wav");
		sndaskexitgame.load( s + "narexitgame.wav");
		sndyes.load( s + "naryes.wav");
		sndno.load( s + "narno.wav");
		sndaskrestart.load( s + "narrestart.wav");
// 		sndaskrestart2.load( s + "nar14.wav");
	}
	askexittomenu()	{
		this.ask( "sndaskexit", "sndyes", "sndno", "myestomenu", "mnotomenu");
	}
	askexitgame	{	.ask( "sndaskexitgame", "sndyes", "sndno", "myestomenu", "mnotomenu");	}
	askrestart()	{
		this.ask( "sndaskrestart", "sndyes", "sndno", "myesrestart", "mnorestart");
	}
	askrestart2()	{
		this.ask( "sndaskrestart2", "sndyes", "sndno", "myesrestart", "mnorestart");
	}
	mnotomenu()	{}
	myestomenu()	{
		modadvglob.delheros;
		clsave.free;
		match( gameapi.getgamename() )	{
			"Menu" => "Outro";
			? => "Menu";
		}
		gameapi.play;
	}
	mnorestart()	{
		match(gameapi.getgamename)	{
			"Memo" => "gamemenu";
			? => "Menu";
		}
		gameapi.play;
	}
	myesrestart()	{	this.crestart();	}
	/*****************************************************************/
	ask( string sask, string syes, string sno, string sf1, string sf2 )	{
		if( !ccs.isplaying )	classasker::ask( sask, syes, sno, sf1, sf2 );
	}
}

new classasker2 claskexit;

public LANG=(@s)	{
	LANG = s;
	SNDPATH = "sounds/";
	if( LANG=="pl" ) LANG="";
	else SNDPATH += LANG + "/";
	
	claskexit.reload;
}

module clbuts	{
	init()	{}
	load()	{
		new classbutton buts;
		buts.build("scripts/common/buttons.pyz", 14000, "imglobcurs");
		buts.transclickfunc( engine.actclassname(), "butclick");
		buts.transmovonfunc( engine.actclassname(), "butmovon");
		buts.transmovofffunc( engine.actclassname(), "butmovoff");
		buts.disableall();
		new db dbb;
		dbb.load("scripts/common/buts.db");
		new snd sndfxglobon;
		sndfxglobon.load("sounds/sfx/globbutmovon.wav");
		sndfxglobon.setvol(50);
		new @bvisible = true;
	}
	reset()	{
		buts.disableall();	
		@sgame = gameapi.getgamename;
		int pos = dbb.findbyrow( sgame );
		if( pos>=0 )	{
			int ile = dbb.getcolsno( pos );
			for( int i=1; i<ile; i++)	{
				buts.enable( dbb.get( pos, i ) );
			}
		}
	}
	enable(string sbu)	{
		buts.enable( sbu );
	}
	/*****************************************/
	butmovon(string sc)	{
		sndfxglobon.play();
		bvisible = mouse.isvisible;
		mouse.show;
		match(sc)	{
			"ok"		=> .cbok_MOVEON;
			"help", "help2"	=> .cbhelp_MOVEON;
			? => ;
		}
	}
	butmovoff(string sc)	{
		if( !bvisible ) mouse.hide;
		match(sc)	{
			"ok"		=> .cbok_MOVEOFF;
			"help", "help2"	=> .cbhelp_MOVEOFF;
			? => ;
		}
	}
	butclick(string sc)	{
		match(sc)	{
			"pause"	=> clpause.pause;
			"exit"		=> claskexit.askexittomenu;
			"restart"	=> claskexit.askrestart;
			"ok"		=> .cbok_CLICK;
			"help", "help2"	=> .cbhelp_CLICK;
			? => ;
		}
	}
}

class classplacepointer2 : classplacepointer    {
	init()  {
		classplacepointer::init();
		this.load("scripts/common/strzalka.pyz");
	}
}

/***************************************************/
// new classnextgame clnextgm;
igmstate = 0;
|igmdebug, igmeasy, igmdemo, igmbegin| = false, false, false, true;

bsms.setstd;

//clnextgm.load("scripts/common/games.db");
clbuts.load;

new classfullsave save("scripts/common/save.txt");
save.stdload;

// ADV
advmouse.load("scripts/common/cursors.pyz");
modadv.load("scripts/common/defaults.adv");
modadv.loadsounds("scripts/common/sounds.db");
modadv.settalktype("snd");
modadv.loadscript("scripts/common/initscript.dsc");
clsave.load("saves/global.txt");
sgmlastscene = null;
_fxtakeitem.load("sounds/sfx/getitem.wav");
_fxtakeitem.setvol(50);

gameapi.play("main");

game main	{
	init	{
// 		engine.setdebugstate(1);
		gameapi.play(modadv.get("startgame:",1) );
	}
}



// 
class cTur	{		// obiekt kodu turtla
	init	{
		.vars2(A, "typ", null, "vi1", 0, "vi2", 0, "vs1", null);
	}
}

class cTurtle	{
	init	{
		new real X;
		new real Y;
		new real dir;
		new real dcos;
		new real dsin;
		new real da;
		new bool bPen = true;
		new bool bpion;
		new bool bwrap = true;
		
		/*new int pR;	new int pG;	new int pB;	// pen color
		new int pW=1;	// pen width
		new int cR=255;	new int cG=255;	new int cB=255;	// canvas color
		new int cX=20;	new int cY=20;		// canvas move
		new int cW=400;	new int cH=400;*/
		.vars2(A, "pR", 0, "pG", 0, "pB", 0, "pW", 1, "cR", 255, "cG", 255, "cB", 255,
			"cX", 20, "cY", 10, "cW", 400, "cH", 400);
		
		new img imgdot;
		.mkdot;
		imgdot.hide;
		
		new img imgcan	{
			.setpos(cX, cY);
			.setz(10);
		};
		.mkcan;
		
		.reset;
	}
	goto(real x, real y)	{
		X=x; Y=y;
	}
	gox(real x)	{ .goto(x,Y);	}
	goy(real y)	{ .goto(X,y);	}
	center	{	.goto(cW/2, cH/2);	}
	reset	{	.dir=(90);	.center;	.show; .wrapon; }
	dir=(int id)	{
		dir = id%360;
		if( dir<0 ) dir+=360;
		dcos = dir->cos;
		dsin = dir->sin;
		if( dcos.abs > /*0.1/(cW->to_r)*/0 )	{
			bpion = false;
			da = dsin/dcos;
		} else bpion=true;
	}
	tl(int id)	{	.dir = (dir+id);	}
	tr(int id)	{	.dir = (dir-id);	}
	putpixel(real x, real y)	{
		if( bPen )	{
			imgdot.setpos(x, y);
			imgcan.blit("imgdot");
		}
	}
	fw(real id)	{
		real r = id.abs;
		bool bhide = 0;		// anzolw bvisible
		if( id<0 ) {
			// anzolw.hide;
			.tl(180);
		}
		if( r>5000 )	{
			.merr("outofrange");
			return;
		}
		real x = X;
		real y = Y;
		real xstep;
		real ystep;
		imgcan.move(-cX,-cY);
		if( bpion )	{
			ystep=( dir>0 && dir<180 ? -1 : 1 );
			xstep = 0;
		} else {
			if ( da.abs <= 1 )	{
				xstep = ( dir>90 && dir<270 ? -1 : 1 );
				ystep = da.abs;
				if( dir>0 && dir<180 ) ystep=-ystep;
			} else {
				xstep=1.0/da.abs;
				if( dir>90&&dir<270 ) xstep=-xstep;
				ystep = ( dir>0 && dir<180 ? -1 : 1 );
			}
		}
		real dr = da.length(xstep, ystep);
		if( bwrap )	{
			if( x<0 ) x=cW-1;
			else if (x>=cW) x=0;
			if( y<0 ) y=cH-1;
			else if (y>=cH) y=0;
			.putpixel(x,y);
		} else {
			if( x>=0 && x<cW && y>=0 && y<cH )
				.putpixel(x,y);
		}
		while(r>0)	{
			if( bpion ) {
				y+=ystep;
			} else {
				x+=xstep;
				y+=ystep;
			}
			if( bwrap )	{
				if( x<0 ) x=cW-1;
				else if (x>=cW) x=0;
				if( y<0 ) y=cH-1;
				else if (y>=cH) y=0;
				.putpixel(x,y);
			} else {
				if( x>=0 && x<cW && y>=0 && y<cH )
					.putpixel(x,y);
			}
			r-=dr;
		}
		imgcan.move(cX,cY);
		.goto(x, y);
		if( id<0 )	{
			.tr(180);
			//anzolw.show if bhide
		}
	}
	bw(real id)	{	.fw(-id); }
	turshow	{}
	turhide	{}
	show	{	imgcan.show;	}
	hide	{	imgcan.hide;	}
	penup	{	bPen=false;	}
	pendown	{	bPen=true;	}
	canvascolor(int ir, int ig, int ib)	{
		cR = .between(0, ir, 255);
		cG = .between(0, ig, 255);
		cB = .between(0, ib, 255);
		.mkcan;
	}
	pencolor(int ir, int ig, int ib)	{
		pR = .between(0, ir, 255);
		pG = .between(0, ig, 255);
		pB = .between(0, ib, 255);
		.mkdot;
	}
	penwidth(int iw)	{
		pW = .between(1,iw,20);
		.mkdot;
	}
	wrapon	{	bwrap=true;	}
	wrapoff	{	bwrap=false;	}
	mkdot	{	imgdot.create( pW, pW, pR, pG, pB, 255 );	}
	mkcan	{
		imgcan.create(cW, cH, cR, cG, cB, 255);
		/*imgdot.setpos(cX, cY);
		imgdot.setpos(1, 1);
		imgcan.blit("imgdot");*/
	}
	prepare	{
		pR=0;	pG=0;	pB=0;	// pen color
		pW=1;	// pen width
		cR=255;	cG=255;	cB=255;	// canvas color
		.mkdot;
		.mkcan;
	}
}

game Turtle : Computro	{
	init	{
		Computro::init("turtle");
		
		new string Code;
		Lexer::setas("Code");
		new db dbcode;
		new vector vcode;
		vcode.type("string");
		
		new int Line = 0;	// linia kodu
		new string sError;
		new int iState = 0;	// status parsera 0 - timer go, 1 - fast go, 2 - finish error, 3 - finish ok
		
		new map cvars("real");
		new real iarg1;
		new real iarg2;
		new real iarg3;
		.lang_db("dbparse", "parser");
		new int ifstack;	// stos petli
		
		new cTurtle ctur;
		
		new @ifontsize = 10;
		.monofont("fnkod", ifontsize);
		new @stdfont = .snewfont(sgmfontfile, ifontsize);
// 		.debug =(1);
		new GUITextBoxTyper ttk("fnkod", ifontsize, 0.6*ifontsize, .black, "at0; ,[](){}-+_/=#<>*.\"\\!?%:&",
			495,30, 282,800, 2);	//int x, int y, int w, int h, int dy)	{
		ttk.setz(100);
		
		Code.consts = (A, "for", "repeat", "to", "(", ")", "[", "]", "/", "%", "*","+","-", "=", ",","#");
		
		new RPN rpn;
		
		new img imgbg;
		imgbg.create(800,600, 192,192,255,255);
		
		new int iParseDelay = 10;	// fast
		.timer = ("timparse", iParseDelay, "mparse");
		
		ctur.prepare;
		@dx = 8;
		new GUI gui("butgame");
		
		gui.newrewinder("rewcode", 493 , 28, 0,500, "ttk");
		ttk.setrewinder("rewcode");
		
		gui.newbutton("butstart", "START", 80, 25);
		gui.newbutton("butstop", "STOP", 80, 25);
		gui.newbutton("butspeed1", "x1", 25, 25);
		gui.newbutton("butspeed2", "x2", 25, 25);
		gui.newbutton("butspeed3", "x3", 25, 25);
		butstart.setpos(rewcodebg.getpx, rewcodebg.getey+4 );
		butstop.setpos(butstart.getex+4, butstart.getpy );
		butspeed1.setpos(butstop.getex+14, butstart.getpy );
		butspeed2.setpos(butspeed1.getex+4, butstart.getpy );
		butspeed3.setpos(butspeed2.getex+4, butstart.getpy );
		new string sbutclick = null;
		butspeed3.butclick;
		
		gui.newwndtext("wincode", rewcodebg.getw, rewcodebg.geth);
		wincode.setpos(rewcodebg.getpx, rewcodebg.getpy);
		rewcodebg.blit("wincode");
		gui.delobj("wincode");
		
		new img imgpars;
		imgpars.create(ttk.W-10, ifontsize, .yellow, 255);
		imgpars.hide;
		
		gui.newwnd("wintxt", 420, 170);
		wintxt.setpos(20, 420 );
		
		.newtext("txtzolw", .mturtleoutput, stdfont, .black);
		txtzolw.setpos( wintxt.getpx+20, wintxt.getey-txtzolw.geth-5 );
		.newtext("txtpars", .mparseoutput, stdfont, .black);
		txtpars.setpos( wintxt.getpx+20, txtzolw.getpy-txtpars.geth-5 );
		
		new int izadanie = 1;
		.lang_db("dbprog","progs");
		.lang_db("dbzad","zad");
		new LangTxt ltxt("txt");
		gui.newbutton("butnext", ltxt.get("next"), 150, 25);
		gui.newbutton("butprev", ltxt.get("prev"), 150, 25);
		butprev.setpos(wintxt.getex+10, wintxt.getey-butnext.geth);
		butnext.setpos(butprev.getex+10, butprev.getpy);
		.mloadzad;
		
		ccs.enter( "mstart" );
	}
	mparseoutput	{	"Parser output: ";	}
	mturtleoutput	{	"Turtle output: ";	}
	mloadzad	{	<GAME>	{
		if( igmdebug )	{
			delete dbzad;
			.lang_db("dbzad","zad");
			delete dbprog;
			.lang_db("dbprog","progs");
		}
		ttk.copyfromdbss("dbprog","--start_"+izadanie+"--","--end_"+izadanie+"--");
		if( gui.hasvar("rewzad") )	{
			gui.dellist(A,"rewzad","winzad");
		}
		@x = wintxt.getpx+10;
		@y = wintxt.getpy + 10;
		new TextDb tdzad(stdfont, ifontsize, "$row:dbzad,"+(izadanie-1), .black, x+2, y+2, 2, wintxt.getz+10, "left");
		@w = tdzad.getw+4;
		@w2 = wintxt.getw-36;
		if( w<w2 ) w = w2;
		gui.newwndtext("winzad", w, tdzad.geth+4);
		winzad.setpos(x,y);
		tdzad.blitto("winzad");
		winzad.setz(30);
		gui.newrewinder("rewzad", x-2 , y-2, w2, txtpars.getpy-y-27, "winzad");
		.deletegmobj("tdzad");
	};	}
	mout(string s)	{	txtpars.txtset(.mparseoutput+s);	}
	merr(string s)	{
		@id = dbparse.findbyrow(s);
		if( id>=0 )	sError += dbparse.get(id,1);
	}
	merr2(string s, string s2)	{	.merr(s); sError+=s2+" ";	}
	bool mload(int id)	{
		if( rpn.end )	{
			match( rpn.error )	{
				0 => {
					<"iarg"+id> = rpn.count;
					if( rpn.error!=0 )	{
						.merr2(null, rpn.perror+"; ");
						return false;
					} else {
						rpn.start;
						return true;
					}
				}
				? => .merr2(null, rpn.perror+"; ");
			}
		} else {	.merr("exexpr");	}
		false;
	}
	bool readarg(int istart, int ile)	{	.readarg2(istart,ile,false,false);	}
	bool readarg2(int istart, int ile, bool bracket, bool bto)	{
		string s;
		int ktory = 1;
		rpn.start;
		for( int i=istart; i<vcode.size; i++)	{
			match( vcode.get(i) )	{
				"$int", "$real" => { i++; rpn.num(vcode.get(i)); }
				"$const" => { i++;
					match(vcode.get(i))	{
						"+", "-", "*", "/", "%",  "(", ")" => rpn.op(vcode.get(i));
						"," => {
							ktory++;
							if( ktory<=ile )	{
								if( !.mload(ktory-1) ) return false;
							} else {
								.merr("unex,");
								return false;
							}
						}
						"[" => {
							if( bracket ) {
								@b = .mload(ktory);
								if ( ktory==ile ) return i;
								else return false;
							} else {
								.merr2("unexfr", "[");
								return false;
							}
						}
						"to" => {
							if( bto ) {
								@b = .mload(ktory);
								if ( ktory==ile ) return i+1;
								else return false;
							} else {
								.merr2("unexfr", "to");
								return false;
							}
						}
						? => {
							.merr2("unexfr", vcode.get(i));
							return false;
						}
					}
				}
				"$alpha" => { i++;
					s = vcode.get(i);
					if( cvars.contains(s) ) {
						rpn.num( cvars.get(s) );
					} else {
						.merr2("novar", s);
						return false;
					}
				}
				? => {
					.merr2("unexfr", vcode.get(i));
					return false;
				}
			}
		}
		@b = .mload(ktory);
		if ( ktory==ile ) b;
		else {
			.merr("lowargs");
			false;
		}
	}
	mparse	{
		string s, int id, int id2, string s2;
		vcode.free;
		for( int i=Line; i < ttk.Rows; i++)	{
			s = ttk.getid(i);
			s.clear;
			if( s.length>0 )	{
				ttk.updaterewpos(i);
				imgpars.show;
				imgpars.setpos( ttk.idpx(i), ttk.idpy(i) );
				Line=i+1;
				Code.start(s);
				Code.gettoken("vcode", true);
				match(vcode.get(0))	{
					"$const" => {
						match(vcode.get(1))	{
							"for" => if( vcode.vecchecknext(1)=="$alpha" )	{
								s = vcode.get(3);
								if( vcode.vecchecknext(3)=="$const" && vcode.vecchecknext(4)=="=" )	{
									id = .readarg2(6,1,false,true);
									if( id )	{
										id2 = iarg1;
										id = .readarg2(id, 1, true, false);
										if( id && id+1>=vcode.size )	{
											cvars.set( s, id2 );
											<GAME>.mpushfor( s, iarg1 );
										} else .merr("badfor4");
									} else .merr("badfor3");
								} else .merr("badfor2");
							} else .merr("badfor");
							"repeat" => if (.readarg2(2,1,true,false) )	{
								if( iarg1 <= 0 )	{
									.merr("badrepeat2");
								} else
									<GAME>.mpushrep( iarg1 );
							} else .merr("badrepeat");
							"]" => {
								if( vcode.size > 2 )	.merr("only]");
								else {
									if( ifstack>0 )	{
										s = "_ctur"+ifstack;
										match(<s>.typ)	{
											"for" => {
												s2 = <s>.vs1;
												id = cvars.get( s2 );
												if( id >= <s>.vi1 )	{
													cvars.remove(s2);
													<GAME>.mpop;
												} else {
													cvars.set(s2, id+1);
													Line = <s>.vi2;
												}
											}
											"repeat" => {
												id = <s>.vi1;
												id--;
												if( id )	{
													<s>.vi1=(id);
													Line = <s>.vi2;
												} else <GAME>.mpop;
											}
											? => ;
										}
									} else .merr("nostart");
								}
							}
							"#" => ;
							? => .merr2("wrongcmd", vcode.get(1));
						}
					}
					"$alpha" =>	{
						match(vcode.get(1))	{
							"forward" => if( .readarg(2,1) )	{
								ctur.fw(iarg1);
							} else .merr("forward");
							"backward" =>  if( .readarg(2,1) )	{
								ctur.bw(iarg1);
							} else .merr("backward");
							"turnleft" =>  if( .readarg(2,1) )	{
								ctur.tl(iarg1);
							} else .merr("turnleft");
							"turnright" =>   if( .readarg(2,1) )	{
								ctur.tr(iarg1);
							} else .merr("turnright");
							"direction" =>   if( .readarg(2,1) )	{
								ctur.dir=(iarg1+90);
							} else .merr("direction");
							"center" => ctur.center;
							"go" =>   if( .readarg(2,2) )	{
								ctur.goto(iarg1, iarg2);
							} else .merr("go");
							"gox" =>   if( .readarg(2,1) )	{
								ctur.gox(iarg1);
							} else .merr("gox");
							"goy" =>   if( .readarg(2,1) )	{
								ctur.goy(iarg1);
							} else .merr("goy");
							"print" =>   if( .readarg(2,1) )	{
								txtzolw.txtset(.mturtleoutput + iarg1);
							} else .merr("print");
							"penup" => ctur.penup;
							"pendown" => ctur.pendown;
							"show" => ctur.turshow;
							"hide" => ctur.turhide;
							"wrapon" => ctur.wrapon;
							"wrapoff" => ctur.wrapoff;
							"pencolor" =>  if( .readarg(2,3) )	{
								ctur.pencolor(iarg1, iarg2, iarg3);
							} else .merr("pencolor");
							"penwidth" => if( .readarg(2,1) )	{
								ctur.penwidth(iarg1);
							} else .merr("penwidth");
							"canvascolor" => if( .readarg(2,3) )	{
								ctur.canvascolor(iarg1, iarg2, iarg3);
							} else .merr("canvascolor");
							? => if( vcode.vecchecknext(1)=="$const" && vcode.vecchecknext(2)=="=" && .readarg(4,1) )	{
								cvars.set( vcode.get(1), iarg1 );
							} else .merr2("wrongcmd", vcode.get(1));
						}
					}
					? => {
						.merr("wrongcmd");
					}
				}
				if( sError=="" )	{
					if( iState==0 )	{
						timparse.play;
					}
				} else {
					.mout(sError);
					<GAME>.mflush;
					iState = 2;		// error
				}
				return;
			}
		}
		if( ifstack>0 )	{
			.merr("noend");
			iState = 2;	// error
		} else {
			.merr("OK");
			iState = 3;	// finish
		}
		.mout(sError);
		.startwrite;
	}
	string mpush	{
		ifstack++;
		@s = "_ctur"+ifstack;
		new cTur <s>;
		s;
	}
	mpushrep(int ile)	{
		if( ifstack<50 )	{
			@s = .mpush;
			<s>.typ=("repeat");
			<s>.vi1 = (ile);
			<s>.vi2 = (Line);
		}
	}
	mpushfor(string svar, int ikrok)	{
		if( ifstack<50 )	{
			@s = .mpush;
			<s>.typ = ("for");
			<s>.vs1 = (svar);
			<s>.vi1 = (ikrok);
			<s>.vi2 = (Line);
		}
	}
	mpop	{
		if( ifstack>0 )	{
			delete <"_ctur"+ifstack>;
			ifstack--;
		}
	}
	mflush	{	while( ifstack > 0 )	.mpop;	}
	mstop	{
		timparse.stop(false);
		.mflush;
		delete cvars;
		new map cvars("real");
	}
	mstart	{
		ttk.enable;
		sError = "";
		ifstack = 0;
		igmstate = 1;
		imgpars.hide;
	}
	meval	{
		//ttk.disable;
		ctur.reset;
		txtzolw.txtset(.mturtleoutput);
		Line = 0;
		igmstate = 2;
		timparse.delay(iParseDelay);
		iState=0;
		//ttk.activate(0);
		ttk.disable;
		if( iState==0 )	{
			.mparse;
		} else {
			while(iState==1)	{
				.mparse;
			}
		}
	}
	/*key_down	{
		if( igmstate!=1 && igmdebug )	{
			if( keyboard.iskey("s") )	{
				ttk.save("scripts/turtle/savedprog.db");
			}
		}
	}*/
	unclicklastspeed(int id, int delay)	{
		if( sbutclick!=null ) <sbutclick>.unclick;
		sbutclick = "butspeed"+id;
		iParseDelay=delay;
		timparse.delay(iParseDelay);
	}
	butspeed1_lclick	{	.unclicklastspeed(1, 1);	}
	butspeed2_lclick	{	.unclicklastspeed(2, 60);	}
	butspeed3_lclick	{	.unclicklastspeed(3, 300);	}
	butstart_lclick	{
		butstart.unclick;
		if( igmstate==1 )	{
			ctur.prepare;
			<GAME>.meval;
		}
	}
	startwrite	{
		<GAME>	{
			.mstop;
			.mstart;
		};
	}
	butstop_lclick	{
		butstop.unclick;
		if( igmstate==2 )	.startwrite;
	}
	butnext_lclick	{
		butnext.unclick;
		if( igmstate==1 )	{
			if( izadanie<10 )	{
				izadanie++;
				.mloadzad;
			} else {
				igmstate = 0;
				ccs.close( func {
					if( PrzygodaMode)
						.gotoadv("adxvsala", "gameadxvsala2");
					else gameapi.play("Menu");
					} );
			}
		}
	}
	butprev_lclick	{
		butprev.unclick;
		if( igmstate==1 )	{
			if( izadanie>1 )	{
				izadanie--;
				.mloadzad;
			}
		}
	}
}

game Obrazy : Computro	{
	init	{
		Computro::init("obrazy");
		
		new int izadanie = 1;
		new int izad2 = 0;
		new int irpn = 3;
		new vector vc1;	vc1.type("string");
		new vector vc2;	vc2.type("string");
		new vector vc3;	vc3.type("string");
		
		new vector vv1;	vv1.type("string");
		new vector vv2;	vv2.type("string");
		new vector vv3;	vv3.type("string");
		new string Code;
		Lexer::setas("Code");
		Code.consts = (A, "(", ")", "/", "%", "*","+","-");
		new RPN rpn;
		new RPN rpn1;
		new RPN rpn2;
		new RPN rpn3;
		rpn.addmethod("_rpn", "_rpn");
		new real Cr1;
		new real Cg1;
		new real Cb1;
		new real Ct1;
		new int Cc1;
		new int Cc2;
		new int Cc3;
		
		new bool bylenter;
		
		.imgs = (A, "bkg.pyz", "z1.pyz 10");
		anz1.setpos(19,19);
		new img imz2;
		.mloadz2;
		
		new img imz3;
		imz3.create( anz1.getw, anz1.geth, .black, 255 );
		imz3.convert("anz1");
		imz3.setpos( imz2.getex+20, imz2.getpy );
		imz3.setz(240);
		imz3.hide;
		
		new gfxSquare ghis(0, 0, 400, 250);
		ghis {
			.set(.grey(224),255);
			.build;
			.border(2, 2, .black, 255);
			.setz(500);
			@x = (.getw-256)/2;
			for( int i=x-1; i<x+257; i++)	{
				imggfx.putrgb(i, 25, .blue);
				imggfx.putrgb(i, 226, .blue);
			}
			x--;
			for( i=25; i<227; i++)	{
				imggfx.putrgb(x, i, .blue);
				imggfx.putrgb(x+257, i, .blue);
			}
			
			new img imgx;
			imgx.create(256, 200, .white, 255);
			imgx.setpos(x+1,26);
			//imggfx.blit("imgx");
			imgx.hide;
			.hide;
			.setpos(200, 100);
		};
		new vector vhis;
		
		new @ifontsize = 10;
		.monofont("fnkod", ifontsize);
		new @stdfont = .snewfont(sgmfontfile, ifontsize);
		new TextBoxTyper ttk("fnkod", ifontsize, 0.6*ifontsize, .black, "", 500,30, 290,500, 2);	//int x, int y, int w, int h, int dy)	{
		new img imgred	{
			.create( 290, ifontsize, .red, 192 );
			.setz(5);
			.hide;
		};
		ttk.setz(100);
		.newtext("txtr", "r2 = ", stdfont, .red);
		.newtext("txtg", "g2 = ", stdfont, .green);
		.newtext("txtb", "b2 = ", stdfont, .blue);
		.newtext("txtk", "t1 = ", stdfont, 128,128,0);
		txtk.hide;
		.newtext("txtrh", "", stdfont, .grey(70) );
		.newtext("txtgh", "", stdfont, .grey(70) );
		.newtext("txtbh", "", stdfont, .grey(70) );
		new gmimgvec grhelpy;
		grhelpy.addlist(A, "txtrh", "txtgh", "txtbh");
		
		.loadzad;
		
		//ttp.load( .getgraphpath + "savedprog.db");
		new classplacepointer2 clp;
		
		.sounds = (A,
			"sndintro", "Witam w lekcji powiconej grafice komputerowej; Poznacie na niej najprostsze operacje przetwarzajce obrazy",
				func { .cbplay("snd1"); clp.showob("anz1", "ll"); },
			"snd1", "Bdziemy przetwarza to zdjcie", func { .cbplay("snd2"); clp.showob("imz2", "rr"); },
			"snd2", "A efekty oglda na tym obrazie", func { clp.show(550, 50, "rr"); .cbplay("snd3"); },
			"snd3", "Programista napisa tutaj program ktry", func { clp.stoph; .cbplay("snd4"); .mline(6); },
			"snd4", "Dla kadej kolumny obrazka pierwszego", func { .cbplay("snd5"); .mline(7); },
			"snd5", "I dla kadego wiersza", func { .cbplay("snd6"); .mline(8); },
			"snd6", "Pobiera kolor kolejnego piksela i zapamituje go w zmiennych r 1 g 1 i b 1",
				func { .cbplay("snd7"); clp.show( txtg.getex, txtg.getpy-5, "rd" ); .mln; },
			"snd7", "Twoim zadaniem jest wyliczenie nowych wartoci kolorw piksela i przypisanie ich do zmiennych r 2 g 2 i b 2",
				func { clp.show( ttk.idpx(16)+20, ttk.idpy(16), "rd" ); .cbplay("snd8"); },
			"snd8", "Nowo wyliczone kolory bd automatycznie ograniczone do zakresu od 0 do 255; Jeli na przykad wyliczysz now warto skadowej czerwonej jako 300 to zostanie ona przycita do maksymalnej dozwolonej wartoci 255", func { clp.stoph; .mline(21); .cbplay("snd9"); },
			"snd9", "Na koniec program wstawia do drugiego obrazka nowo wyliczony piksel", func { .mln; .cbplay("snd10"); <GAME>.nextex; clp.showob("tdz","ld"); },
			"snd10", "Zaczynamy; Przeczytaj pierwsze zadanie i wpisz odpowiednie wartoci kolorw",
				func { .cshowbut("ok","rd"); .cbplay("snd11"); },
			"snd11", "Kiedy uznasz e nowe kolory odpowiadaj treci zadania kliknij przycisk OK",
				func { .cshowbut("help","rd"); .cbplay("snd12"); },
			"snd12", "Jeli nie moesz poradzi sobie z zadaniem najed na przycisk pomoc", func { clp.stoph; .mstart; },
			"sndok", "Zadanie wykonane poprawnie", func { <GAME>.nextex; },
			"sndnon", "Co nie tak; Sprbuj ponownie", "mstart",
			"sndenter", "Podaj przynajmniej jedn warto i wcinij klawisz enter", "mstart",
			"sndcheck", "Generuj poprawny obrazek do porwnania", func { <GAME>.mcheck; },
			"sndprog", "Poznamy teraz kolejny algorytm; Progowanie", func { bylenter=false; <GAME>.nextzad; .mline(6); .cbplay("snd13"); },
			"snd13", "Tutaj podasz warto od 0 do 255 i wciniesz klawisz enter; Liczba bdzie odcieniem szarego koloru ktrego nazywamy progiem", func { .mline(13); .cbplay("snd14"); },
			"snd14", "Pobieramy z obrazka 1 piksel i wyliczamy dla niego odpowiednik w szarym kolorze", func { .mline(15); .cbplay("snd15"); },
			"snd15", "Jeli szary kolor jest ciemniejszy ni podany przez ciebie kolor progowy to zamieniamy go na czarny", func { .mline(16); .cbplay("snd16"); },
			"snd16", "Jeli jest janiejszy od koloru progowego zamieniamy go na biay", func { .mline(18); .cbplay("snd17"); },
			"snd17", "I zapisujemy na obrazku 2", func {.mstart; .mln; },
			"sndzoom", "Poka teraz jak w prosty sposb pomniejszy obrazek", func { bylenter=false; <GAME>.nextzad; .mline(7); .cbplay("snd18");	},
			"snd18", "Tutaj wpiszesz ile razy pomniejszy obrazek i wciniesz klawisz enter", func { .mln; .cbplay("snd19"); },
			"snd19", "Zobaczmy teraz jak dziaa algorytm jeli wpiszesz na przykad 5", func { <GAME> {
				new int tmpw = 0.3*anz1.getw+5;
				new int tmph = 0.45*anz1.geth+7;
				new img im7;
				new img im4 {
					.create(780, 500, 200,200,255, 255);
					new img im5;
					@x1 = anz1.getpx;
					@y1 = anz1.getpy;
					anz1.move(-x1,-y1);
					int c[3];
					for( int i=0; i<20; i++)	{
						for( int j=0; j<37; j++)	{
							|c0, c1, c2| = anz1.getrgb(tmpw+j, tmph+i);
							im5.create(20, 20, c0, c1, c2, 255);
							im5.setpos( 20 + j*im5.getw, 20 + i*im5.geth );
							.blit("im5");
						}
					}
					delete im5;
					anz1.move(x1,y1);
					.setz(600);
					.move(10, 10);
				};
				.cbplay("snd20");
				}; },
			"snd20", "Oto powikszony wycinek obrazka na ktrym widzimy oko", func { <GAME> {
				new img im5;
				im5.create( 100, 100, .white, 32 );
				im5.setpos( im4.getpx+20, im4.getpy + 20);
				im5.setz(im4.getz+10);
				.cbplay("snd21");
				clp.showob("im5", "ll");
				}; },
			"snd21", "Poniewa chcemy pomniejszy obraz piciokrotnie pobieramy piksele z kwadratu 5 na 5", func {
				clp.stoph;
				<GAME> {
					.newtext("tx1", "R = (", stdfont, .red);
					.newtext("tx2", "G = (", stdfont, .green);
					.newtext("tx3", "B = (", stdfont, .blue);
					.newtext("tx4", "", stdfont, .black);
					tx1.setpos( im4.getpx + 10, im4.getey - 80 );
					tx2.setpos( im4.getpx + 10, im4.getey - 65 );
					tx3.setpos( im4.getpx + 10, im4.getey - 50 );
					tx4.setpos( im4.getpx + 10, im4.getey - 35 );
					tx1.setz( im5.getz + 10 );
					tx2.setz( tx1.getz );
					tx3.setz( tx1.getz );
					tx4.setz( tx1.getz );
					.getpix(tmpw, tmph);
					.cbplay("snd22");
				};
				},
			"snd22", "Pikseli jest 25; Dodajemy ich skadowe R G B i wyliczamy redni kolor tych pikseli", func { <GAME> {
				new img im6;
				new int tmpiw = 37/5;
				new int tmpih = 20/5;
				new int tmpliczw = 0;
				new int tmpliczh = 0;
				im6.create(tmpiw*20+10, tmpih*20+10, .black, 255);
				im6.setpos( im4.getex - im6.getw - 15 , im4.getey - im6.geth - 15 );
				im6.setz( im4.getz + 10 );
				clp.showob("im6", "rd");
				.cbplay("snd23");
				}; },
			"snd23", "Na tym obrazku bdziemy umieszczali wyliczone rednie piksele", func {	<GAME> {
					clp.stoph;
					_ = .putpix;
					.timer=("timcyk", 500, func {
						if( .putpix ) .play;
						else .cbplay("snd24");
					} );
					timcyk.play;
				}; },
			"snd24", "W ten sposb otrzymalimy piciokrotnie pomniejszone oko; Cho wydaje si ono cakowicie nieczytelne zobaczmy jaki bdzie efekt w normalnej skali",
				func { <GAME> {
					.withlist(A, "tmpiw", "tmpih", "tmpliczw", "tmpliczh", "tx1", "tx2", "tx3", "tx4", "im4",
						"im5", "im6", "im7", "timcyk", "tmpw", "tmph", "vardel");
					.mstart;
				}; },
			"snd25", "Teraz dowiesz si co to jest histogram; Histogram atwiej bdzie nam zrozumie to na przykadzie szarego obrazka", func { .generategrey; .cbplay("snd26"); },
			"snd26", "Szary kolor ma 256 odcieni; Od czerni ktrej odpowiada warto 0 do bieli ktrej odpowiada 255; Jeli policzymy wszystkie odcienie dla danego obrazka i wstawimy je do wykresu otrzymamy histogram", func { .cbplay("snd27"); <GAME>.vardel("imgrey"); },
			"snd27", "Policzmy zatem odcienie szaroci prawego obrazka", func { <GAME>.showhis; .cbplay("snd28"); clp.show(273, 324, "ld"); },
			"snd28", "Oto histogram naszego obrazka; Po lewej stronie znajduj si ciemne kolory; Pierwszy supek od lewej oznacza liczb pikseli czarnych czyli o kolorze 0; Jak widzisz nasz obrazek nie posiada w ogle czarnych pikseli", func { clp.show(330, 324, "ld"); .cbplay("snd29"); },
			"snd29", "Wiksza grupa ciemnych pikseli nalecych gwnie do ta obrazka znajduje si dopiero w okolicach odcienia szaroci o wartoci 60",
				func { clp.show(435, 324, "uu"); .cbplay("snd30"); },
			"snd30", "Najczciej wystpujcym kolorem jest do jasny szary o wartoci 162", func { clp.show(528, 324,"rd"); .cbplay("snd31"); },
			"snd31", "Podobnie jak czarny rwnie czysto biay kolor nie wystpuje w tym obrazku", func { clp.stoph; <GAME>.nextzad; .cbplay("snd32"); },
			"snd32", "Na przykadzie tej starej fotografii poka wam jakie korzyci pyn z analizy histogramu; Fotografia jest bardzo nieczytelna; Obejrzyjmy jej histogram",
				func { <GAME>.showhis;	.cbplay("snd33");	},
			"snd33", "Widzimy e piksele maj podobne odcienie i brakuje zarwno jasnych jak i ciemnych pikseli; Sprbujmy przyciemni zdjcie dzielc wartoci kolorw przez 2",	func { <GAME>.nextzad; .cbplay("snd34");	},
			"snd34", "Zdjcie nie stao si wyraniejsze; Spjrzmy na histogram", func { <GAME>.showhis; .cbplay("snd35"); },
			"snd35", "Histogram przesun si w kierunku pikseli ciemniejszych i zwy; Rozjanijmy teraz obrazek o 25 procent",
				func { <GAME>.nextzad; .cbplay("snd36"); },
			"snd36", "Wyglda troch lepiej; Spjrzmy na histogram", func { <GAME>.showhis; .cbplay("snd37");	},
			"snd37", "Lekko rozcignity ksztat ale tym razem przesunity w kierunku odcieni jasnych; Rozjanijmy zatem o 50 procent",
				func { <GAME>.nextzad; .cbplay("snd38");	},
			"snd38", "Tym razem obrazek jeszcze mniej wyrany; Sprawdmy histogram", func { <GAME>.showhis; .cbplay("snd39");	},
			"snd39", "No tak cz pikseli osigna maksymaln jasno i biel zdominowaa obrazek", func { ghis.hide; .cbplay("snd40");	},
			"snd40", "Komputer wykona teraz algorytm zwany wyrwnaniem histogramu; Algorytm rozcignie histogram na ca szeroko skali; Zobaczmy jeszcze raz oryginalny obrazek",
				func { <GAME>.nextzad; .cbplay("snd41");	},
			"snd41", "I jego histogram", func { <GAME>.showhis; .cbplay("snd42");	},
			"snd42", "Rozpoczynamy rozcignie histogramu", func { <GAME>.nextzad; .cbplay("snd43");	},
			"snd43", "Nasza stara fotografia jest teraz wyraniejsza; Zobaczmy na histogramie co si stao", func { <GAME>.showhis; .cbplay("snd44");	},
			"snd44", "Jak widzicie algorytm rozoy piksele od czarnych do biaych i dziki temu fotografia uzyskaa kontrast", func {
				ghis.hide;
				.timer = ("timend", 2500, func { ccs.close( func {
					if( PrzygodaMode )
						.gotoadv("adxvsala", "gameadxvsala2");
					else gameapi.play("Menu");
					} );} );
				timend.play;
				}
			);
		ccs.enter( func { .cbplay("sndintro"); } );
		
		//.cbplay("snd19");
	}
	meval2	{	_ = <GAME>.meval;	}
	bool putpix	{
		.getpix( tmpw+tmpliczw*5, tmph+tmpliczh*5 );
		|int x, int y| = im6.getpos;
		im6.move(-x, -y);
		im7.setpos( im6.getpx+5+tmpliczw*im7.getw, im6.getpy+5+tmpliczh*im7.geth );
		im6.blit("im7");
		
		im5.setpos( im4.getpx+20+tmpliczw*im5.getw, im4.getpy + 20+tmpliczh*im5.geth);
		
		tmpliczw++;
		if( tmpliczw>=tmpiw )	{
			tmpliczh++;
			tmpliczw=0;
		}
		im6.move(x,y);
		
		return tmpliczh<tmpih;
	}
	getpix(int w, int h)	{
		int k[3];	k0 = 0;	k1 = 0;	k2 = 0;
		int c[3];
		tx1.txtset("R = (");
		tx2.txtset("G = (");
		tx3.txtset("B = (");
		@x1 = anz1.getpx;
		@y1 = anz1.getpy;
		anz1.move(-x1,-y1);
		for(int i=0; i<5; i++) 	{
			for (int j=0; j<5; j++)	{
				|c0, c1, c2| = anz1.getrgb(w+j, h+i);
				k0 += c0;
				k1 += c1;
				k2 += c2;
				tx1.set( tx1.get + c0 + "+" );
				tx2.set( tx2.get + c1 + "+" );
				tx3.set( tx3.get + c2 + "+" );
			}
		}
		k0/=25;
		k1/=25;
		k2/=25;
		tx1.txtset( tx1.get->strsube(1) + ") / 25 = " + k0);
		tx2.txtset( tx2.get->strsube(1) + ") / 25 = " + k1);
		tx3.txtset( tx3.get->strsube(1) + ") / 25 = " + k2);
		tx4.txtset("new RGB = ("+k0+","+k1+","+k2+")");
		anz1.move(x1,y1);
		im7.create( 20, 20, k0, k1, k2, 255 );
		im7.hide;
	}
	mloadz2	{
		imz2.create( anz1.getw, anz1.geth, .black, 255 );
		imz2.convert("anz1");
		imz2.setpos( anz1.getex+20, anz1.getpy );
	}
	mstart	{	igmstate=1; ttp.enable;	}
	mstop	{	igmstate=2; ttp.disable;	}
	mline(int id)	{
		imgred.setpos( ttk.idpx(id-2), ttk.idpy(id-2)+2 );
		imgred.show;
	}
	mln	{ imgred.hide;	}
	togrey(real r)	{	.togrey2(r,false);	}
	togrey2(real r, bool bhis)	{
		@w = anz1.getw;
		@h = anz1.geth;
		@x1 = anz1.getpx;
		@y1 = anz1.getpy;
		anz1.move(-x1,-y1);
		@x = imz2.getpx;
		@y = imz2.getpy;
		imz2.move(-x,-y);
		int i, int j, int c[3];
		for( i=0; i<h; i++)	{
			for( j=0; j<w; j++)	{
				|c0, c1, c2| = anz1.getrgb(j, i);
				c0 = r*(0.3*c0 + 0.59*c1 + 0.11*c2);
				if( bhis )	{
					c0 = vD.get( c0 );
				}
				imz2.putrgb(j, i, c0, c0, c0);
			}
			anz1.move(x1,y1);
			imz2.move(x,y);
			engine.redraw;
			anz1.move(-x1,-y1);
			imz2.move(-x,-y);
		}
		imz2.move(x,y);
		anz1.move(x1,y1);
	}
	loadzad	{
		ttk.load( .getgraphpath + "p" + izadanie + ".db" );
		.rgbpos;
	}
	ttkpos(string s)	{
		for( int i=0; i<ttk.Rows; i++ )	{
			if( ttk.getid(i)==s )	return ttk (i) {(@id)
				.setid("", id);
				<grtt.get(id)>.getpy;
				};
		}
		0;
	}
	rgbpos	{
		int x  = ttk.X;
		string s;
		match(izadanie)	{
			1 => {
				x += 2*ifontsize;
				txtr.setpos( x, .ttkpos("#r") );
				txtg.setpos( x, .ttkpos("#g") );
				txtb.setpos( x, .ttkpos("#b") );
				txtrh.setpos(txtr.getpx+txtr.getw, txtr.getpy);
				txtgh.setpos(txtg.getpx+txtg.getw, txtg.getpy);
				txtbh.setpos(txtb.getpx+txtb.getw, txtb.getpy);
				s = "txtr";
			}
			2, 3 => {
				if( izadanie==2) txtk.txtset("zoom = ");
				else txtk.txtset("t1 = ");
				txtk.setpos( x, .ttkpos("#t1") );
				txtk.show;
				txtr.hide; txtg.hide; txtb.hide;
				s = "txtk";
			}
			? => ;
		}
		.deletegmobj("ttp");
		new TextBoxTyper ttp("fnkod", ifontsize, 0.6*ifontsize, .black, "at0 ()-+/=*.%",
			<s>.getex, <s>.getpy, 200, irpn*(ifontsize+2), 2);	//int x, int y, int w, int h, int dy)	{
		//ttp.enable;
	}
	merror(string s)	{
	}
	merror2(string s1, string s2)	{
		.merror(s1 + " " + s2);
	}
	bool meval	{
		if( igmstate==1 )	{
			igmstate = 2;
			ttp.disable;
			string s; int j, string s2, string s3, string s1;
			bool berror = false;
			//.debug=(1);
			for( int i=0; i < irpn; i++)	{
				s = ttp.getid(i);
				s.clear;
				rpn.start;
				if( s.length>0 && berror==false)	{
					Code.start(s);
					s = "vc" + (i+1);
					s2 = "rpn" + (i+1);
					s1 = "vv"+(i+1);
					<s1>.free;
					<s2>.start;
					Code.gettoken( s, true);
					for( j=0; j< <s>.size; j++)	{
						match( <s>.get(j) )	{
							"$int", "$real" => { j++; rpn.num(<s>.get(j)); <s2>.num( <s>.get(j) ); }
							"$const" => { j++;	rpn.op(<s>.get(j)); <s2>.op( <s>.get(j) ); }
							"$alpha" => { j++;
								s3 = <s>.get(j);
								if( izadanie==1 && s3.in(A,"r1","g1","b1") )	{
									rpn.num(1);
									<s2>.num(1);
									<s2>.var("C"+<s>.get(j));
									<s1>.add( <s2>.size-1 );
									<s1>.add( "C"+<s>.get(j) );
								} else {
									.merror("novar");
									return false;
								}
							}
							? => { .merror("noperator"); return false; }
						}
					}
				} else {
					.merror("empty");
					return false;
				}
				if( berror==false )	{
					if( rpn.end && rpn.error==0 )	{
						_ = <s2>.end;
						_ = rpn.count;
						if( rpn.error==0 )	{
							<s>.veccopy(s2);
							rpn.start;
						} else {
							.merror2("count", rpn.perror);
							return false;
						}
					} else {
						.merror2("count", rpn.perror);
						return false;
					}
				}
			}
			if( berror==false )	{
				@w = anz1.getw;
				@h = anz1.geth;
				@x1 = anz1.getpx;
				@y1 = anz1.getpy;
				anz1.move(-x1,-y1);
				@x = imz2.getpx;
				@y = imz2.getpy;
				imz2.move(-x,-y);
				int k, string s, int n, int m;
				
				//.tickstart;
				
				match(izadanie)	{
					3 => {
						rpn.copyvars("rpn1");
						k = .between(0, rpn.count, 255);
						Cc1 = k; Cc2 =k; Cc3 = k;
					}
					2 => {
						rpn.copyvars("rpn1");
						k = .between(1, rpn.count, 10);
					}
					? => ;
				}
				int c[3];
				if( izadanie==2 )	{
					int k2 = k*k;
					for( i=0; i<h; i+=k)	{
						for( j=0; j<w; j+=k)	{
							c0 = 0;
							c1 = 0;
							c2 = 0;
							for( m=i; m<i+k; m++) {
								for( n=j; n<j+k; n++ ) {
									|Cr1, Cg1, Cb1| = anz1.getrgb(n, m);
									c0+=Cr1;
									c1+=Cg1;
									c2+=Cb1;
								}
							}
							imz2.putrgb(j/k, i/k, c0/k2, c1/k2, c2/k2);
						}
						anz1.move(x1,y1);
						imz2.move(x,y);
						engine.redraw;
						anz1.move(-x1,-y1);
						imz2.move(-x,-y);
					}
				} else {
					for( i=0; i<h; i++)	{
						for( j=0; j<w; j++)	{
							|Cr1, Cg1, Cb1| = anz1.getrgb(j, i);
							match(izadanie)	{
								1 => {
									c0 = rpn._rpn1;
									c1 = rpn._rpn2;
									c2 = rpn._rpn3;
								}
								3 => {
									c0 = 0.3*Cr1 + 0.59*Cg1 + 0.11*Cb1;
									c0 = ( c0 < k ? 0 : 255);
									c1 = c0;
									c2 = c0;
								}
								? => ;
							}
							imz2.putrgb(j, i, c0, c1, c2);
							//imz2.putrgb;
						}
						anz1.move(x1,y1);
						imz2.move(x,y);
						engine.redraw;
						anz1.move(-x1,-y1);
						imz2.move(-x,-y);
					}
				}
				
				anz1.move(x1,y1);
				imz2.move(x,y);
				//.tickstop;
				
				true;
			} else return false;
		} else return false;
	}
	real _rpn1	{
		vout.copy("vc1");
		for( int i=0; i< vv1.size; i+=2) {	vout.set( vv1.get(i), [vv1.get(i+1)] );		}
		.countok;
	}
	real _rpn2	{
		vout.copy("vc2");
		for( int i=0; i< vv2.size; i+=2) {	vout.set( vv2.get(i), [vv2.get(i+1)] );		}
		.countok;
	}
	real _rpn3	{
		vout.copy("vc3");
		for( int i=0; i< vv3.size; i+=2) {	vout.set( vv3.get(i), [vv3.get(i+1)] );		}
		.countok;
	}
	real _rpn(int id)	{
		//ierror = 0;
		//vout.veccopy("vc"+id);
		vout.copy("vc"+id);
		string s = "vv"+id;
		for( int i=0; i< <s>.size; i+=2) {
			vout.set( <s>.get(i), [<s>.get(i+1)] );
		}
		.countok;
	}
	showhis	{
		ghis {
			.setpos(0,0);
			imggfx.blit("imgx");
			.show;
		};
		vhis.resize(256, 0);
		@w = imz2.getw;
		@h = imz2.geth;
		@x1 = imz2.getpx;
		@y1 = imz2.getpy;
		@x2 = anz1.getpx;
		@y2 = anz1.getpy;
		anz1.move(-x2,-y2);
		int i, int j, int id;
		int r, int g, int b;
		imz2.move(-x1, -y1);
		for( i=0; i<h; i++)	{
			for( j=0; j<w; j++)	{
				//|id,_,_| = imz2.getrgb(j, i);
				|id,_,_| = imz2.getrgb(j, i);
				vhis.set( id, vhis.get(id)+1 );
			}
		}
		j = 1;
		for( i=0; i<256; i++)	{
			if( vhis.get(i)>j ) j=vhis.get(i);
		}
		real r = 200.0/j;
		ghis (r) { (real r)
			@x = (ghis.getw-256)/2;
			int y=225, int i, int j, int id;
			for( i=0; i<256; i++)	{
				id = r*vhis.get(i);
				for( j=0; j<id; j++)
					imggfx.putrgb(x+i, y-j, .black);
			}
			.setpos(200,100);
		};
		imz2.move(x1, y1);
		anz1.move(x2,y2);
	}
	mouse_lclick	{
		.cactsndstop(true);
		/*if( igmstate==2 )	{
			igmstate=1;
			ttp.enable;
		}*/
	}
	nextzad	{
		if( izadanie<3 )	{
			izadanie++;
			match(izadanie)	{
				2, 3 => 1;
				? => 3;
			}
			irpn = _;
			.loadzad;
		} else {
			igmstate=1;
			izadanie++;
			ghis.hide;
			match(izadanie)	{
				4=> {
					.mloadan("z1");
					ttk.disable;
					ttk.hide;
					txtk.hide;
					ttp.disable;
					ttp.hide;
					.togrey(1);
					.cbplay("snd25");
				}
				5 => {
					.mloadan("z2");
					.togrey(1);
				}
				6 => {
					.togrey(0.5);
				}
				7 => {
					.togrey(1.25);
				}
				8 => {
					.togrey(1.5);
				}
				9 => .togrey(1);
				10 => {
					ghis.hide;
					new vector vD;
					vD.type("real");
					real r = imz2.getw*imz2.geth;
					vD.add( vhis.get(0) );
					real rD = 0;
					for( int i=1; i<256; i++)	{
						vD.add(vD.get(i-1)+vhis.get(i));
						if( rD==0 && vD.last!=0 ) rD = vD.last;
					}
					rD/=r;
					if( rD>0 && rD<1 )	{
						for( i=0; i<256; i++) {
							vD.set( i, ((vD.get(i)/r - rD)/(1.0-rD) ) * 255.0 );
							//LUT(i) = ((D(i) - D0) / (1 - D0)) * (k - 1)
						}
						.togrey2(1,true);
						.showhis;
					}
				}
				? => ;
			}
		}
	}
	mloadan(string s)	{
		anz1.load(.getgraphpath+s+".pyz");
		anz1.setz(20);
		imz2.setpos(0,0);
		imz2.clone("anz1");
		anz1.setpos(20, 20);
		imz2.setpos(anz1.getex+10, 20);
	}
	generategrey	{
		<GAME>	{
			new img imgrey	{
				.create(780, 500, 200,200,255, 255);
				new img imc;
				int id = 0;
				bool dielaj = true;
				int x=15, int y=15;
				int w = 30;
				int h = 15;
				int dt = 5;
				new text tnr;
				tnr.setfont("fnkod");
				while( dielaj )	{
					imc.create(w, h, .grey(id), 255);
					tnr.txtsetcol(id, .grey(43));
					imc.setpos(x, y);
					tnr.setpos(imc.getex+dt, y);
					.blit("imc");
					.blit("tnr");
					y+=imc.geth + dt;
					if( y>= 485-dt ) {
						y = 15;
						x+= (w+dt)*2;
					}
					id++;
					if( id==256 ) dielaj=false;
				}
				.setz(400);
				.ansetcpos(400, 300);
			};
		};
	}
	ttp_boxontype	{
		if( .mzadnext && keyboard.iskey("enter") && igmstate==1 )	{
			bylenter = true;
			if( <GAME>.meval )	{
				.mstart;
			} else .cbplay("sndnon");
		}
	}
	cbhelp_MOVEON	{
		if( igmstate==1 && izadanie==1 )	{
			match(izad2)	{
				1 => .mhrgb("r1", "g1", "b1");
				2 => .mhrgb("r1 - 30", "g1 - 30", "b1 - 30");
				3 => .mhrgb("1.2 * r1", "1.2 * g1", "1.2 * b1");
				4 => .mhrgb("r1", "g1", "0");
				5 => .mhrgb("255 - r1", "255 - g1", "255 - b1");
				6 => .mhrgb("(r1+g1+b1)/3", "(r1+g1+b1)/3", "(r1+g1+b1)/3");
				7 => .mhrgb("0.33*r1+0.59*g1+0.11*b1", "0.33*r1+0.59*g1+0.11*b1", "0.33*r1+0.59*g1+0.11*b1");
				? => .mhrgb(0,0,0);
			}
			grhelpy.show;
		}
	}
	cbhelp_MOVEOFF	{
		grhelpy.hide;
	}
	mhrgb(string sr, string sg, string sb)	{
		txtrh.txtset(sr);
		txtgh.txtset(sg);
		txtbh.txtset(sb);
	}
	cbok_CLICK		{
		if( igmstate!=1 || izad2>9) return;
		if( izadanie.in(A,2,3) && !bylenter )	{
			.cbplay("sndenter");
			igmstate=3;
			return;
		}
		if( <GAME>.meval )	{
			if( izad2<8 ) .cbplay("sndcheck");
			else if (izad2>=9 )	{
				tdz.hide;
				.nextzad;
			} else <GAME>.mcheck;
		} else .cbplay("sndnon");
	}
	mzadnext	{	izad2.in(A, 8, 9);	}
	mcheck	{
		if( izad2>=8 )	{
			.nextex;
			return;
		}
		@w = anz1.getw;
		@h = anz1.geth;
		@x1 = anz1.getpx;
		@y1 = anz1.getpy;
		anz1.move(-x1,-y1);
		@x = imz3.getpx;
		@y = imz3.getpy;
		imz3.move(-x,-y);
		imz3.show;
		int i, int j, int c[3], int k[3];
		for( i=0; i<h; i++)	{
			for( j=0; j<w; j++)	{
				|c0, c1, c2| = anz1.getrgb(j, i);
				match( izad2 )	{
					1 => {	k0 = c0;	k1 = c1; k2 = c2; }
					2 => {	k0 = c0 - 30;	k1 = c1 - 30;	k2 = c2 - 30;	}
					3 => {	k0 = 1.2*c0;	k1 = 1.2*c1;	k2 = 1.2*c2;		}
					4 => {	k0 = c0;	k1 = c1;	k2 = 0;	}
					5 => {	k0 = 255-c0;	k1 = 255-c1;	k2 = 255-c2;	}
					6 => {	k0 = (c0+c1+c2)/3;	k1 = k0;	k2 = k0;	}
					7 => {	k0=0.33*c0+0.59*c1+0.11*c2;	k1=k0;	k2=k0;	}
					? => ;
				}
				imz3.putrgb(j, i, k0, k1, k2);
			}
			anz1.move(x1,y1);
			imz3.move(x,y);
			engine.redraw;
			anz1.move(-x1,-y1);
			imz3.move(-x,-y);
		}
		imz3.move(x,y);
		anz1.move(x1,y1);
		if( imz2.equal("imz3") )	{
			.cbplay("sndok");
		} else {
			.cbplay("sndnon");
		}
		imz3.hide;
	}
	nextex	{
		izad2++;
		.deletegmobj("tdz");
		new TextDb tdz(stdfont, 12, "$path:"+.lang_path("zad"+izad2)+".db", 10,10,192, 20,335, 2,50, "left");
		match(izad2)	{
			8 => .cbplay("sndzoom");
			9 => {
				.cbplay("sndprog");
				.mloadan("z3");
			}
			? => .mstart;
		}
	}
	mouse_rclick	{
		if( igmdebug ) .cbplay("sndok");
	}
}


class tesKubel	{
	init(int ktory, int x, int y, int ile)	{
		x = x+ktory*(ankubel.getw+2);
		new anima ankub;
		ankub.copy("ankubel");
		ankub.setz(ikubelz);
		ankub.setpos(x, y);
		ankub.show;
		string s;
		new gmimgvec gral;
		gral.add("ankub");
		for( int i=0; i<ile; i++)	{
			s = "ank"+i;
			new anima <s>;
			<s>.copy("ankubel");
			<s>.setz(ikubelz);
			<s>.setframe(1,i);
			<s>.setpos(x,y);
			<s>.show;
			gral.add(s);
		}
		new text txtk;
		txtk.setfont(stdfont16);
		txtk.txtsetcol(ktory, .black);
		txtk.setpos( ankub.getcx-txtk.getw/2, ankub.getey-5 );
		txtk.setz(ikubelz+1);
	}
	isin	{	gral.isin;	}
	setz(int z) 	{ gral.setz(z); ankub.setz(z);	}
}

game Test : Computro	{
	init	{
		Computro::init("test");
		
		.imgs = (A, "bg.pyz", "kubel.pyzH 10");
		
		new int ilevel = 0;
		new db dbpom;
		
		new int ikubelz = 66;
		new int idkubel;
		.newarray("gmimgvec", "grkb", 4);
		/*new gmimgvec grkbs;
		grkbs.addlist(A, "grkb1", "grkb2", "grkb3");*/
		
		new @stdfont64 = .stdfont(64);
		new @stdfont16 = .stdfont(16);
		.newtext("txnr", "1.", stdfont64, .blue);
		txnr.setz(10);
		txnr.setpos(20, 10);
		
		new int iy1 = iResY/2 - 30;
		new int iy3 = iResY - 120;
		new int iy2 = (iy3+iy1)/2;
		
		new gmimgvec grodp;
		.mstdodp;
		new string _slast = null;
		
		new vector vecok;
		vecok.resize(10,0);
		
		.nextlevel;
		ccs.enter( func {
			igmstate = 1;
			mus.playstr("main.ogg -v 5 -l");
		} );
	}
	nextlevel	{ <GAME> {
		if( igmstate ==16 ) igmstate=1;
		ilevel++;
		if( ilevel>10 )	{
			.newtext("txtend", " Wynik: " + vecok.vecsum + "/10", stdfont64, .red);
			txtend.setz(1000);
			txtend.setpos(txnr.getex + 50, txnr.getpy);
			.timer = ("timend", 4000, func {
				ccs.close( func {
					ccs.show;
					clsave.bset("done_Test");
					clsave.set("Test_points", vecok.vecsum);
					.gotoadv("adsala","gameadsala0");
					});
				} );
			timend.play;
			return;
		}
		txnr.txtset("" + ilevel + ".");
		txnr.txtshadow(1, stdfont64);
		.vardelif("dbzad");
		.lang_db("dbzad", "zad"+ilevel);
		.vardelif("tdpyt");
		.vardelif("tdod1");
		.vardelif("tdod2");
		.vardelif("tdod3");
		dbpom.dbcopyfromtos("dbzad", "<part1>", "</part1>");
		int x = 30;
		new TextDb tdpyt(stdfont16, 16, "$var:dbpom", 10,10,192, x,txnr.getey+5, 2,50, "left");
		dbpom.dbcopyfromtos("dbzad", "<part2>", "</part2>");
		new TextDb tdod1(stdfont16, 16, "$var:dbpom", .mstdcol, x, iy1, 2,50, "left");
		dbpom.dbcopyfromtos("dbzad", "<part3>", "</part3>");
		new TextDb tdod2(stdfont16, 16, "$var:dbpom", .mstdcol, x, iy2, 2,50, "left");
		dbpom.dbcopyfromtos("dbzad", "<part4>", "</part4>");
		new TextDb tdod3(stdfont16, 16, "$var:dbpom", .mstdcol, x, iy3, 2,50, "left");
		match( ilevel )	{
			2 => {
				//K[0]=1+3,  K[1]=2,  K[2]=4,  K[3]=mniejsza_z_liczb(5,2) ,  K[4]=0,  K[5]=4-2+1,  K[6]=2*3,  K[7]=8,  K[8]=11,  K[9]=7
				.mkkosz(x);
				
				x += 30;
				int y = iy1+5;
				idkubel = 1;
				.mkosz(x, y, 0, 4);	.mkosz(x, y, 1, 2);	.mkosz(x, y, 2, 4);
				.mkosz(x, y, 3, 2);	.mkosz(x, y, 4, 0);	.mkosz(x, y, 5, 3);
				.mkosz(x, y, 6, 6);	.mkosz(x, y, 7, 8);	.mkosz(x, y, 8, 11);
				.mkosz(x, y, 9, 7);
				
				y = iy2+5;
				idkubel = 2;
				.mkosz(x, y, 0, 4);	.mkosz(x, y, 1, 2);	.mkosz(x, y, 2, 4);
				.mkosz(x, y, 3, 5);	.mkosz(x, y, 4, 0);	.mkosz(x, y, 5, 3);
				.mkosz(x, y, 6, 6);	.mkosz(x, y, 7, 8);	.mkosz(x, y, 8, 11);
				.mkosz(x, y, 9, 7);
				
				y = iy3+5;
				idkubel = 3;
				.mkosz(x, y, 0, 0);	.mkosz(x, y, 1, 1);	.mkosz(x, y, 2, 2);
				.mkosz(x, y, 3, 3);	.mkosz(x, y, 4, 4);	.mkosz(x, y, 5, 5);
				.mkosz(x, y, 6, 6);	.mkosz(x, y, 7, 7);	.mkosz(x, y, 8, 8);
				.mkosz(x, y, 9, 9);
				grkb0.setz(50);
			}
			3 => {
				//K[0]=2,  K[1]=K[0]+2,  K[2]=K[8],  K[3]=K[0]+K[1],  K[4]=10,  K[5]=K[4]-K[3],
				//K[6]=15-K[5],  K[7]=K[7]+1,  K[8]=K[7]*4,  K[9]=K[]+K[1]-K[3]+K[7]
				.mdelkosz;
				.mkkosz(x);
				
				x += 30;
				int y = iy1+5;
				idkubel = 1;
				.mkosz(x, y, 0, 2);	.mkosz(x, y, 1, 4);	.mkosz(x, y, 2, 8);
				.mkosz(x, y, 3, 6);	.mkosz(x, y, 4, 10);	.mkosz(x, y, 5, 3);
				.mkosz(x, y, 6, 12);	.mkosz(x, y, 7, 7);	.mkosz(x, y, 8, 4);
				.mkosz(x, y, 9, 7);
				
				y = iy2+5;
				idkubel = 2;
				.mkosz(x, y, 0, 2);	.mkosz(x, y, 1, 2);	.mkosz(x, y, 2, 8);
				.mkosz(x, y, 3, 1);	.mkosz(x, y, 4, 10);	.mkosz(x, y, 5, 1);
				.mkosz(x, y, 6, 10);	.mkosz(x, y, 7, 8);	.mkosz(x, y, 8, 4);
				.mkosz(x, y, 9, 5);
				
				y = iy3+5;
				idkubel = 3;
				.mkosz(x, y, 0, 2);	.mkosz(x, y, 1, 4);	.mkosz(x, y, 2, 0);
				.mkosz(x, y, 3, 6);	.mkosz(x, y, 4, 10);	.mkosz(x, y, 5, 4);
				.mkosz(x, y, 6, 11);	.mkosz(x, y, 7, 1);	.mkosz(x, y, 8, 4);
				.mkosz(x, y, 9, 1);
				grkb0.setz(50);
			}
			4 => {
				.mdelkosz;
				.mkkosz(x);
				x += 30;
				int y = iy1+5;
				idkubel = 1;
				for( int i=0; i<10; i++)	{
					.mkosz(x,y,i,1);
				}
				
				y = iy2+5;
				idkubel = 2;
				for( i=0; i<10; i++)	{
					.mkosz(x,y,i,i+1);
				}
				
				y = iy3+5;
				idkubel = 3;
				for( i=0; i<10; i++)	{
					.mkosz(x,y,i,10->rand);
				}
				grkb0.setz(50);
			}
			5 => {
				.mstdodp;
				.mdelkosz;
				grkb0.deleteallgm;
				grkb0.free;
				.img = ("machina.pyz");
			}
			6 => {
				delete anmachina;
			}
			7 => {
				.img = ("robo.pyz");
			}
			8 => {
				delete anrobo;
				.img = ("pascal.pyz");
			}
			9 => {
				delete anpascal;
				.img = ("bramki.pyz");
				.copyanima("anbramki", "anbram2");
				anbram2.setframe(1,0);
			}
			10 => {
				delete anbramki;
				delete anbram2;
			}
			? => ;
		}
	}; }
	mdelkosz	{
		for( int i=0; i<4; i++)	{
			<"grkb"+i>.deleteallgm;
			<"grkb"+i>.free;
		}
	}
	mkkosz(int x)	{
		grodp.free;
		grodp.addlist(A,"grkb1", "grkb2", "grkb3");
		
		int y = tdpyt.mgetey;
		idkubel = 0;
		.mkosz(x, y, 0, 0);	.mkosz(x, y, 1, 0);	.mkosz(x, y, 2, 0);
		.mkosz(x, y, 3, 0);	.mkosz(x, y, 4, 0);	.mkosz(x, y, 5, 0);
		.mkosz(x, y, 6, 0);	.mkosz(x, y, 7, 0);	.mkosz(x, y, 8, 0);
		.mkosz(x, y, 9, 0);
	}
	mstdodp	{
		grodp.free;
		grodp.addlist(A,"tdod1", "tdod2", "tdod3");
	}
	mkosz(int x, int y, int id, int ile)	{
		@s = "kos_"+idkubel+"_"+id;
		new tesKubel <s>(id, x, y, ile);
		<"grkb"+idkubel>.add(s);
	}
	mstdcol	{	return 10, 10, 192;	}
	mactcol	{	return 192, 10, 10;	}
	mgetey	{	grtxt.getey;	}
	mretcol	{
		if( _slast!=null) {
			<_slast>.msetcol( .mstdcol );
			_slast = null;
		}
	}
	msetcol(int r, int g, int b)	{
		if( .hasvar("grtxt") )	{
			grtxt.eval3( func { (int r, int g, int b) .createtxt(r,g,b); }, r, g, b );
		} else {
			 <"tdod"+ _slast.strsubb(4)>.setcol(r,g,b);
		}
		|int r2, int g2, int b2| = .mactcol;
		if( r2==r && g2==g && b2==b )	{
			bsms.setact;
		} else bsms.setstd;
	}
	misin(int x, int y)	{	grtxt.isin(x,y,1,0);	}
	mouse_move	{
		if( igmstate!=1 ) return;
		|int x, int y| = mouse.getpos;
		if( grodp.isin(x,y,1,0) )	{
			@s = grodp.getsfound;
			if( s!=_slast )	{
				.mretcol;
				_slast = s;
				<s>.msetcol( .mactcol );
			}
		} else .mretcol;
	}
	mouse_lclick	{
		if( igmstate == 16 ) return .nextlevel;
		if( igmstate!=1 || ilevel>10) return;
		int i1 = 0;
		int id;
		if( _slast!=null ) {
			id = _slast.strsubb(4);
			i1 = 1;
		}
		if( i1 )	{
			match(ilevel)	{
				1 => 3;
				2 => 1;
				3 => 3;
				4 => 2;
				5 => 3;
				6 => 2;
				7 => 1;
				8 => {
					anpascal.setframe(1,0);
					3;
				}
				9 => {
					anbram2.setframe(2,0);
					2;
				}
				10 => 1;
				? => 0;
			}
			int odp = _;
			vecok.set( ilevel-1, odp==id );
			/*if( !.hasvar("timnext") )	{
				.timer = ("timnext", 3000, "nextlevel");
			}
			timnext.play;*/
			<"tdod"+odp>.setcol(.green);
			igmstate = 16;
			//.nextlevel;
		}
	}
}
game Historia : Computro	{
	init	{
		Computro::init("historia");
		
		.img = ("bg.pyz");
		
		new @stdfont24 = .stdfont(24);
		
		/*new classsimplebutton cbok;
		cbok.build("scripts/common/butok.pyz", "imglobcurs", 720,525, 100, 0);*/
		new classplacepointer2 clp;
		
		new gmimgvec grep;
		"grep" .* "story1.pyz";
		grep.hide;
		.mshow(0);
		.sounds = (A,
			"sndintro", "Komputery wykonuj ogromne iloci oblicze w bardzo krtkim czasie; Kiedy umiejtno liczenia zarezerwowana bya dla nielicznych ludzi",
				func { .mplay(1,1); },
			"snd1", "W dawnych czasach ludzie ktrzy potrafili liczy stanowili skarb dla wodzw i krlw; Dziki nim wadca mg oszacowa swoje siy i zapasy; Pierwsi matematycy zapisywali liczby zwyczajnymi kreskami na glinianych tabliczkach; Niestety liczby takie byy trudne do odczytania; Spjrzmy jak duo czasu zajmuje policzenie wszystkich kresek eby odczyta liczb 13",
				func { grep.hide; .mplay(2,2);	},
			"snd2", "Z czasem pisarze zastpili wiele kresek symbolami; Oto symbole wymylone przez staroytnych Egipcjan oznaczajce liczby dziesitek setek i tysicy",
				func { <GAME> {
					igmstate = 1;
					new gmimgvec greg;
					.imgs = (A, "egipskieH.pyz", "cyfryeg.pyz");
					grep.hide;
					int x = 50;
					new int ilasth = 0;
					new int iposy = ancyfryeg.getey + 50;
					x = .megipt(7, x);
					x = .megipt(13, x);
					x = .megipt(28, x);
					x = .megipt(74, x);
					x = .megipt(339, x);
					x = .megipt(1003, x);
					x = .megipt(3121, x);
					x = .megipt(436, x);
					x = .megipt(2008, x);
					x = .megipt(25, x);
					.cbplay("snd3");
					.cshowbut("ok", "rd");
				}; },
			"snd3", "Aby przej dalej kliknij ten przycisk", func { clp.stoph; },
			"snd4", "Wpisz jakie liczby zakodowano w systemie staroegipskim; Liczby zatwierdzaj klawiszem enter; Kiedy skoczysz kliknij przycisk OK",
				func { igmstate = 2; clp.stoph; tc1.enable; },
			"snd5", "Liczby wpisane niepoprawnie; Prbuj dalej", func { igmstate=2; .menabl; },
			"snd6", "wietnie", func { <GAME> {
				igmstate=3;
				.mshow(3);
				grtc.deleteallgmobj;
				delete grtc;
				greg.deleteallgm;
				greg.free;
				delete anegipskie;
				iposy = ancyfryeg.getey + 50;
				delete ancyfryeg;
				/*int x = 50;
				x = .megipt(7, x);
				x = .megipt(13, x);
				x = .megipt(28, x);
				x = .megipt(74, x);
				x = .megipt(339, x);
				x = .megipt(1003, x);
				x = .megipt(3121, x);
				x = .megipt(436, x);
				x = .megipt(2008, x);
				x = .megipt(25, x);*/
				.cbplay("snd7");
				}; },
			"snd7", "Staroytni Rzymianie zapisywali liczby za pomoc siedmiu cyfr ktre znajdziemy dzi w alfabecie; Cho cyfry rzymskie wygldaj elegancko i uywa si ich  czsto przy datach lub numerach rozdziaw ksiek zostay wyparte przez cyfry arabskie znacznie wygodniejsze przy obliczeniach",	func { <GAME> {
				grep.deleteallgm;
				grep.free;
				"grep" .* "story2.pyz";
				grep.hide;
				.mshow(0);
				greg.deleteallgm;
				delete greg;
				.cbplay("snd8");
				}; },
			"snd8", "Cyfry ktre nazywamy arabskimi w rzeczywistoci wymylili Hindusi; Arabowie poznali je i przekazali Europejczykom", func { .mplay(9,1); },
			"snd9", "Liczby zapisane cyframi arabskim kodowane s w systemie pozycyjnym; Oznacza to e jeli zmienimy kolejno cyfr otrzymamy inn liczb",
				func { .mplay(10,2); },
			"snd10", "W starszym systemie egipskim kolejno cyfr nie ma znaczenia; Liczy si tylko ich skad; Na ekranie widzimy liczb 12 zakodowan na 2 sposoby",
				func { .mplay(11,3); },
			"snd11", "Jednak najwikszym odkryciem Hindusw bya liczba 0; Dla wczeniejszych matematykw ta liczba nie istniaa; Nie potrafili wyobrazi sobie e mona nada symbol czemu czego nie mona policzy; Bez liczby 0 ludzie nie wymyliliby komputerw", func { <GAME> {
				grep.deleteallgm;
				grep.free;
				"grep" .* "story3.pyz";
				grep.hide;
				.mshow(0);
				.cbplay("snd12");
				}; },
			"snd12", "Obliczenia wykonywano na liczydach i abakusach", func { .mplay(13,1); },
			"snd13", "Dopiero upowszechnienie praktycznych cyfr arabskich i wymylenie sposobw dodawania odejmowania mnoenia i dzielenia bardzo uatwio obliczenia",
				func { .mplay(14,2); },
			"snd14", "Im wicej ludzie potrafili obliczy tym wicej mogli poznawa i przewidywa; Szczeglnie wan rol peniy obliczenia w szyfrowaniu wiadomoci; Aby zama szyfr naleao wykona nieporwnywalnie wicej oblicze zatem istniao cige zapotrzebowanie na rozwj technik i szybkoci liczenia",
				func { .mplay(15,3); },
			"snd15", "Matematycy zaczli budowa pierwsze mechaniczne maszyny liczce; Jednak byy one bardzo skomplikowane", func { <GAME> {
				grep.deleteallgm;
				grep.free;
				.imgs = (A, "story4.pyz", "bramki.pyzH");
				.cbplay("snd16");
				}; },
			"snd16", "Dzisiejsze komputery pracuj w oparciu o prawa logiki matematycznej ktra wzia swoj nazw od angielskiego matematyka Georgesa Boolea",
				func { <GAME> {
					new gmimgvec grb;
					new db dbp;
					dbp.dbbuild(A,
						1, 1, 0, 0,
						0, 0,20,1,
						1, 1, 0, 0,
						0, 0, 0, 0,
						0, 0, 0, 0,
						0, 0, 0, 0,
						0, 0, 0, 0,
						1, 1, 0, 0,
						0, 0,21,1,
						1, 1, 0, 0,
						0, 0, 0, 0,
						0, 0, 0, 0,
						0, 0, 0, 0,
						0, 0, 0, 0,
						1, 1, 0, 0,
						0, 0,22,1,
						1, 1, 0, 0,
						0, 0, 0, 0,
						0, 0, 0, 0,
						0, 0, 0, 0,
						0, 0, 0, 0,
						1, 1,23,1,
						4);
					.mcode;
					.timer = ("timtik", 500, func {
						int cols = dbp.getcolsno(0);
						int l, int i2, int i3, int i4;
						int rows = dbp.getrowsno;
						for( int i=0; i<rows; i++) {
							match( dbp.get(i, 0) )	{
								1, 101 => .mset(i, 0, 2->rand);
								? => ;
							}
						}
						for( int j=1; j<cols; j++)	{
							for( int i=0; i< rows; i++) {
								l = dbp.get(i, j);
								i2 = dbp.get(i, j-1);
								if( i>0 ) i3 = .mbol( dbp.get(i-1, j-1) );
								if( i<rows-1) i4 = .mbol( dbp.get(i+1, j-1) );
								match( l )	{
									1, 2, 4, 101, 102, 104 => {
										//if( l==4 || l==104 ) i2 = dbp.get(i-1, j-1);
										match(i2)	{
											1, 2, 4, 20, 21, 22, 23 => .mset(i, j, true);
											101, 102, 104, 120, 121, 122, 123 => .mset(i, j, false);
											? => {
												match(l)	{
													2, 102 => .mset( i, j, .mbol(dbp.get(i-1,j)) );
													4, 104 => {
														for( i2=i+1; dbp.get(i2,j)->to_i!=0; i2++ ) {}
														.mset( i, j, .mbol(dbp.get(i2-1,j-1)) );
													}
													? => if( i>0 && dbp.get(i-1,j)->to_i > 0 ) .mset(i,j, .mbol(dbp.get(i-1,j)) );
														else {
															for( i2=i+1; dbp.get(i2,j)->to_i!=0; i2++ ) {}
															.mset(i,j, .mbol(dbp.get(i2-1,j-1)) );
														}
												}
											}
										}
									}
									20, 120 => .mset(i, j, i3&&i4);
									21, 121 => .mset(i, j, !i3 || !i4);
									22, 122 => .mset(i, j, i3||i4);
									23, 123 => .mset(i, j, !.mbol(i2));
									? => ;
								}
							}
						}
						.play;
						} );
					timtik.play;
					.cbplay("snd17");
				}; },
			"snd17", "Cho nie sposb wyliczy wszystkich rzeczy ktre moe robi komputer jego praca opiera si na dziaaniu milionw maych elementw wykonujcych bardzo proste operacje; Tak jak te 4 bramki ktre wyliczaj podstawowe funkcje logiczne", 	func { <GAME> {
				timtik.stop(false);
				grb.deleteallgm;
				grb.free;
				dbp.dbbuild(A,
					1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
					0,20,1, 1, 2, 0, 0, 1, 1, 1, 1, 1, 0, 0,
					1, 0, 0, 0, 1, 0, 0,14, 0, 0, 0, 0,20, 1,
					0, 0, 0, 0, 0,21, 1, 1, 2, 0, 0, 1, 0, 0,
					1, 1,23, 1, 1, 0, 0, 0, 2, 0, 0, 4, 0, 0,
					0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,14, 0, 0,
					0, 0, 0, 0, 0, 0, 0, 0, 0,20, 1, 1,23, 1,
					1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,
					0,21, 1, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0,
					1, 0, 0,21,1,23, 1, 1, 4, 0, 0, 0, 0, 0,
					0, 0, 1, 0, 0, 0, 0,12, 0, 0, 1, 1,23, 1,
					1, 1, 4, 0, 0, 0, 0, 2, 0, 0, 4, 0, 0, 0,
					0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 14, 0, 0, 0,
					0, 0, 0, 0, 0, 0, 0, 0,20, 1, 1, 2, 0, 0,
					1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0,
					0,22,1, 2, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0,
					1, 0, 0, 1, 1, 0, 0,14, 0, 0, 0, 0,21, 1,
					0, 0, 0, 0, 0,21, 1, 1, 2, 0, 0, 1, 0, 0,
					0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 4, 0, 0,
					0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0, 4, 0, 0,
					0, 0, 0, 0, 4, 0, 0, 0, 0,22, 1, 4, 0, 0,
					1,23, 1, 1, 4, 0, 0, 1, 1, 0, 0, 0, 0, 0,
					0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0,
					1, 1, 1, 1, 1, 1, 1, 4, 0, 0, 0, 0, 0, 0,
					0, 0, 0,12, 0, 0,12, 0, 0, 0, 0, 0, 0, 0,
					0, 0, 0, 2, 0, 0, 1, 1,23, 1, 0, 0, 0, 0,
					0, 0, 0, 1, 1, 0, 0, 0, 0, 0,22, 1, 1, 1,
					0, 0, 0, 0, 0,21, 1, 1, 1, 1, 0, 0, 0, 0,
					1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
					0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
					14);
				.mcode;
				.cbplay("snd18");
				.timer = ("tim2", 5000, func { <GAME> {
					grb.deleteallgm;
					delete grb;
					delete timtik;
					delete dbp;
					delete anbramki;
					delete anstory4;
					"grep" .* "story5.pyz";
					grep.hide;
					.mshow(0);
					//new TextDb tdz(stdfont, 12, "$path:"+.lang_path("zad"+izad2)+".db", 10,10,192, 20,335, 2,50, "left");
					.cbplay("snd19");
					}; } );
				timtik.play;
				}; },
				"snd18", "Jeli te proste elementy poczymy w wiksze ukady bd wykonyway coraz bardziej zoone operacje", func { tim2.play; },
				"snd19", "Te zoone operacje rozwija i bada angielski matematyk Alan Turing", func { .mplay(20,1); },
				"snd20", "Wymyli on hipotetyczny komputer nazywany maszyn Turinga ktry przyczyni si do powstania algorytmw i jzykw programowania", func {
					<GAME > {
					grep.deleteallgm; grep.free;
					"grep" .* "story6.pyz";
					grep.setz(5);
					<grep.get(2)>.setz(4);
					.img = ("obudowa6.pyz 3");
					grep.hide;
					.mplay(21,0);
					new @stdfont14 = .stdfont(14);
					}; },
				"snd21", "Model dzisiejszego komputera pracuje w oparciu o t sam ide; Sercem komputera jest procesor ktry wykonuje instrukcje",
					func { .mplay(22,1); },
				"snd22", "Instrukcje do wykonania czyta z pamici; Ta sama pami przechowuje rwnie dane ktre nie s rozkazami; Na przykad obrazy do wywietlenia na ekranie czy muzyk", func { .mplay(23,2); },
				"snd23", "Wszystkie podzespoy umocowane s na pycie gwnej ktra umoliwia komunikacj midzy nimi", func { .mplay(24,3); },
				"snd24", "I doprowadza zasilanie", func { .mplay(25,4);
					<GAME> {
						new TextDb tdin(stdfont14, 14, "$path:"+.lang_path("stdin")+".db", 128,0,0, 650,350, 5,50, "center");
						tdin.stdshadow(1);
					}; },
				"snd25", "Specjalne kontrolery interpretuj sygnay urzdze wejciowych takich jak klawiatura", func { .mplay(26,5); },
				"snd26", "czy mysz; Stan tych urzdze jest widoczny dla procesora poprzez komrki pamici; W informatyce mwimy na klawiatur Standardowe urzdzenie wejciowe w skrcie standardowe wejcie", func { .mplay(27,6);
					<GAME> {
						new TextDb tdout(stdfont14, 14, "$path:"+.lang_path("stdout")+".db", 128,0,0, 10,250, 5,50, "center");
						tdout.stdshadow(1);
					};},
				"snd27", "Dane z pamici czyta take karta graficzna ktra zamienia je na sygnay i wysya do monitora; Monitor jest Standardowym urzdzeniem wyjciowym w skrcie standardowym wyjciem", func {
						ccs.close( func {
							ccs.show;
							clsave.set("epizod", "Komputer");
							.gotoadv("adxvsala","gameadxvsala0");
						});
					}
			);
		.cbplay("sndintro");
		
		/*grep.deleteallgm;
		grep.free;
		"grep" .* "story5.pyz";
		.cbplay("snd19");*/
	}
	int mbol(int id)	{	id<100 ? 1 : 0;	}
	mset(int i, int j, bool b)	{
		int l = dbp.get(i, j);
		if( l>100 && b ) l-=100;
		else if (l<100 && !b) l+=100;
		dbp.set(i, j, l);
		string s = "anb"+i+"_"+j;
		if( <s>.gettype=="img" )	{
			<s>.create(<s>.getw, <s>.geth, .mcol(l), 255);
		}
	}
	mcode	{
		string s;
		int icol = dbp.getcolsno(0), int j, int l, int i;
		int w = 0.85*anbramki.getw;
		int h = anbramki.geth/3;
		int h2;
		int x = iResX/2-100;
		int y = 100;
		for( j=0; j<icol; j++)	{
			for( i=0; i<dbp.getrowsno; i++)	{
				s = "anb"+i+"_"+j;
				l = dbp.get(i, j);
				match(l)	{
					1, 101 => {
						new img <s>;
						<s>.create(w, 2, .mcol(l), 255);
						<s>.setz( 40 );
						<s>.setpos(x+w*j, y+h*i);
						grb.add(s);
					}
					2, 4, 14, 12, 102, 104 => {
						new img <s>;
						if( l==14 || l==12 ) {
							l-=10;
							dbp.set(i, j, l);
							h2 = 2*h;
						} else h2 = h;
						<s>.create(2, h2, .mcol(l), 255);
						<s>.setz( 40 );
						<s>.setpos(x+w*j, y+h*i);
						if( l==4 || l==104 ) <s>.move(0, -h+2);
						else if( h2>h ) <s>.move(0, -h);
						grb.add(s);
					}
					20, 21, 22, 23 => {
						.copyanima("anbramki", s);
						<s>.setframe(l-20, 0);
						<s>.show;
						<s>.setz( 50 );
						<s>.setpos(x+w*j, y+h*i);
						grb.add(s);
					}
					? => ;
				}
			}
		}
	}
	mcol(int id)	{
		match( id )	{
			101, 102, 104, 120, 121, 122, 123 => .blue;
			? => .red;
		}
	}
	int madd(int id, int x, int y)	{
		if( id<=0 ) return 0;
		@s = "aneg" + greg.size;
		if( igmstate==3 )	{
			match(id)	{
				7 => "VII";
				13 => "XIII";
				28 => "XXVIII";
				74 => "LXXIV";
				339 => "CCCXXXIX";
				1003 => "MIII";
				3121 => "MMMCXXI";
				436 => "CDXXXVI";
				2008 => "MMVIII";
				25 => "XXV";
				? => "MM";
			}
			string s2 = _;
			.newtext(s, s2, stdfont24, 0,0,128);
		} else	{
			.copyanima("anegipskie", s);
			<s>.setframe(0, id-1);
		}
		<s>.show;
		<s>.setpos(x, y);
		greg.add(s);
		if( <s>.geth > ilasth ) ilasth = <s>.geth;
		<s>.getw + 2;
	}
	int megipt(string val, int x)	{
		int y = iposy;
		string s, int ile, int j;
		if( igmstate==3 ) x+=.madd(val,x,y);
		else {
			for( int i=0; i<val.length; i++)	{
				ile = val.getb(i, 1);
				match( val.length-i )	{
					0 => ;
					1 => x+=.madd(val.getb(i,1), x, y);
					2 => for( j=0; j<ile; j++) x+=.madd(10, x, y);
					3 => for( j=0; j<ile; j++) x+=.madd(11, x, y);
					4 => for( j=0; j<ile; j++) x+=.madd(12, x, y);
					? => ;
				}
			}
		}
		s = "txeg"+greg.size;
		greg.add(s);
		.newtext(s, " = "+val, stdfont24, .black );
		if( igmstate==3 ) <s>.setpos(x,y);
		else <s>.setpos(x+5, y+10);
		x += <s>.getw+50;
		if( x>iResX-200 ) {
			x = 50;
			iposy += 50;
		}
		x;
	}
	mhide(int id)	{	<grep.get(id)>.hide;	}
	mshow(int id)	{	<grep.get(id)>.show;	}
	mplay(int id1, int id2)	{	.cbplay("snd"+id1); .mshow(id2);	}
	int mtc(string sn, int x, int nr)	{
		new ConTextTyper <sn>(stdfont24, 24, .grey(32), "0", 5);
		x = .megipt(nr, x);
		@s = greg.last;
		<s>.txtset(" = ");
		<sn>.setpos(<s>.getex, <s>.getpy );
		grtc.add(sn);
		x + 10;
	}
	cbok_CLICK	{
		match( igmstate )	{
			1 => <GAME> {
				igmstate = 0;
				.cbplay("snd4");
				iposy += 15;
				new gmimgvec grtc;
				int x = .mtc("tc1", 20, 26);
				x = .mtc("tc2", x, 319);
				x = .mtc("tc3", x, 2215);
				clp.show(tc2.getpx+50, tc2.getpy, "dd");
				new int ienabl = 0;
			};
			2 => {
				igmstate = 0;
				grtc.eval("disable");
				if( (tc1.get==26 && tc2.get==319 && tc3.get==2215) || igmdebug ) .cbplay("snd6");
				else .cbplay("snd5");
			}
			? => ;
		}
	}
	menabl	{	<grtc.get(ienabl)>.enable;	}
	key_down	{
		match( igmstate )	{
			2 => if( keyboard.iskey("enter") )	{
				grtc.eval("disable");
				ienabl = (ienabl+1)%3;
				.menabl;
			}
			? => ;
		}
	}
	mouse_lclick	{
		if( igmdebug ) .cactsndstop(true);
		|int x, int y| = mouse.getpos;
		match( igmstate )	{
			2 =>	if( grtc.isin(x,y,1,0) )	{
					grtc.eval("disable");
					ienabl = grtc.getfound;
					.menabl;
				}
			? => ;
		}
	}
}
game Komp : Computro	{
	init	{
		Computro::init("komp");
		
		.imgs = (A, "bg.pyz", "maskiH.pyz", "mask2.Hpyz", "kableH.pyz 100");
		.sfxs = (A, "getpuz 50", "putpuz 50");
		new gmimgvec grdev;
		"grdev" .* "devs.pyz";
		new DelayMover cmov;
		new vector vkb;
		vkb.resize( anmask2.nofactions, 1 );
		new vector vpt;
		vpt.resize( anmaski.nofactions, 1 );
		
		cmov.unlock;
		igmstate=1;
	}
	cmov_GET	{
		if( igmstate!=1 ) return;
		|int x, int y| = mouse.getpos;
		int id = anmask2.anisin(x,y,0,1);
		if( id>=0 && vkb.get(id) )	{
			ankable.setframe( "k"+anmask2.nameofaction(id)->strsubes("_m2"), 0 );
			ankable.show;
			.setpobj("ankable");
			.msmove;
			fxgetpuz.play;
		}
	}
	cmov_PUT	{
		_ = .getfree;
		ankable.hide;
		@s = ankable.actionname->strsubb(1);
		anmaski.setframe( s+"_mask", 0 );
		if( anmaski.isin(mouse.getpos,0,0) )	{
			vpt.set(anmaski.actionnr(-1), 0);
			vkb.set( anmask2.actionnr(s+"_m2"), 0);
			<grdev.getsac(s)>.setframe(-1, 1);
			fxputpuz.play;
			if( vkb.vecsum==0 )	{
				ccs.close( func {
					ccs.show;
					sgmlastscene = "Komputer";
					clsave.set("epizod", "Siec");
					.gotoadv("adinania","gameadinania0");
					});
			}
		}
	}
	mouse_move	{
		|int x, int y| = mouse.getpos;
		int id;
		if( cmov.moving )	{
			id = anmaski.anisin(x,y,0,0);
			if( id==3 && vpt.get(3)==0 ) id=4;
			( id>=0 && vpt.get(id) ) ? bsms.setact : bsms.setstd;
		} else {
			id = anmask2.anisin(x,y,0,1);
			(id>=0 && vkb.get(id) ) ? bsms.setact : bsms.setstd;
		}
	}
}
game Sysopold : Computro	{
	init	{
		Computro::init("sysop");
		
		.img=("bg.pyz");
		anbg.anaddfilter;
		new real rsetzoom = 1;
		new real rzoomer = 0.01;
		//anbg.setzoom(rsetzoom);
		//anbg.ancenterscreen;
		
		new @stdmono12 = .snewfont( "configs/fonts/mono.ttf", 12);
		new @stdfont12 = .snewfont( "configs/fonts/normal.ttf", 12);
		new @stdfont14 = .snewfont( "configs/fonts/normal.ttf", 14);
		new @cols = 40;
		.newimgarray("grti", "text", "txti", cols);
		grti.each(func { (@id)
			.setfont(stdmono12);
			.setpos(12,54+id*12);
			.createtxt(.white);
			 } );
		new @column = 0;
		new @ilimit = 60;
		new string Code;
		Lexer::setas("Code");
		Code.consts = (A, "../", "./","/", "..", ".", "|", ">", ">>", "<" , "<<", "-al", "-la", "-a", "-l", "ls", "'");
		new vector vec1;
		vec1.type("string");
		
		new ConTextTyper ttp(stdmono12, 12, .white, "at0 !@#$%^&*()-=_+{}|\\[];':\",./<>?", ilimit);
		ttp.onenter(GAME, "mcheck");
		
		new TextDb tdhp(stdfont12, 12, "helpos.db", 1,4,52, 491,91, 2,50, "left");
		tdhp.hide;
		//tdhp.view(A,0,1,2,3,4,5);
		
		new @Level = 0;
		new @HelpLevel = 0;
		new @sublevel = 0;
		new @benter = false;
		new @spasswd = "";
		new @sread = "";
		new @Dir = "~";
		new @retdir="~";
		
		new gfxSquare gsq(50,20,700,525);
		gsq.set( 0,128,0, 220);
		gsq.build;
		gsq.setz(500);
		gsq.hide;
		
		.sfxs = (A, "pik", "type2 50", "blink 50");
		
		.sounds = (A,
			"sndok", "okej", null,
			"sndend","Doskonale! Wszystkie zadania z tej lekcji wykonane! Przeczytaj wnioski i kliknij aby powrci do menu gwnego", func { <GAME>.buildopis; igmstate=11; }
			);
		fxpik.addmethod("onstart", func { .mnext; } );
		
		//.buildopis;
		.timer = ("timtik", 300, func {
			.tickstart;
			/*if( mouse.getposy<300 ) rzoomer=0.01;
			else rzoomer=-0.01;*/
			if( rsetzoom<1.3 ) rsetzoom+=0.01;
			else if (rsetzoom<1.6) rsetzoom+=0.02;
			else rsetzoom+=0.04;
			/*if( rsetzoom<1 ) rsetzoom=1;
			else if (rsetzoom>2 ) rsetzoom=2;*/
			anbg.setzoom(rsetzoom);
			anbg.ancenterscreen;
			if( rsetzoom<2 )
				.play;
			.tickstop;
			} );
		timtik.play;
	}
	mpos(int id)	{
		ttp.txtset("");
		ttp.setpos(9 + <"txti"+id>.getw,54+id*12);
		ttp.limit = ( ilimit-<"txti"+id>.get->length );
	}
	menable	{	.mpos(column);	ttp.enable;	}
	mout(string s)	{	<"txti"+column>.txtset(s);	}
	moutln(string s)	{	.mout(s); .mnewline;	}
	mrewind	{
		for( int i=0; i<cols-1; i++)	<"txti"+i>.txtset( <"txti"+(i+1)>.get );
		<"txti"+(cols-1)>.txtset("");
	}
	mnewline	{
		column++;
		if( column==cols )	{
			column--;
			.mrewind;
		}
	}
	ttp_ontype	{	fxtype2.playif;	}
	mread	{
		Code = ttp.get;
		Code.id = (0);
	}
	mput	{
		@s = "txti"+column;
		.mread;
		<s>.txtset( <s>.get + Code );
		ttp.txtset("");
		.mnewline;
	}
	mclear	{	grti.txtreset;	}
	buildopis	{
		.deletegmobj("dbopis");
		.newdb("dbopis", "help" + HelpLevel + ".db");
		.deletegmobj("tdopis");
		new TextDb tdopis(stdfont14, 10, "$var:dbopis", 255,255,0, 65,35, 4, 550, "left");
		HelpLevel++;
		igmstate = 2;
		gsq.show;
		tdopis.show;
	}
	viewzad	{
		.deletegmobj("dbzad");
		.newdb( "dbzad", "zad" + Level + ".db");
		.deletegmobj("tdzad");
		new TextDb tdzad(stdfont12, 10, "$var:dbzad", 128,0,0, 485,304, 3,150, "left");
		Level++;
	}
	bool mget0	{
		.mput;
		Code.clear;
		if( Code.length )	return true;
		else .mready;
		false;
	}
	bool mget(string s)	{
		if( .mget0 )	{
			if( Code==s ) return true;
			.mno;
		}
		false;
	}
	bool mget2(string s)	{
		if( .mget0 )	{
			if( Code.expects(s, " ", true) ) return true;
			.mno;
		}
		false;
	}
	bool mget3(string s1, string s2)	{
		if( .mget0 )	{
			if( Code.expects(s1, " ", true) || Code.expects(s2," ",true) ) return true;
			.mno;
		}
		false;
	}
	bool mget4(string s1, string s2, string s3)	{
		if( .mget0 )	{
			if( Code.expects(s1, " ", true) || Code.expects(s2," ",true)
			|| Code.expects(s3," ",true) ) return true;
			.mno;
		}
		false;
	}
	mcheck	{
		string s[2];
		benter = true;
		match(sublevel)	{
			0 => {
				.mput;
				if( Code.contains(" ") || !Code.expects("$alpha", " ", false) )	{
					.moutln("Login incorrect");
					.mstart;
				} else {
					sublevel++;
					spasswd = "";
					.mout("Password: ");
				}
			}
			3 => if( .mget("passwd") )	{
					sublevel++;
					spasswd="";
					.mout("type current password: ");
				}
			6 => if (.mget("pwd") )	{
					.moutln("/home/jacek");
					.mok;
				}
			7 => if (.mget4("ls", "ls .", "ls ./") )	{
					.moutln("lekcje  Mail  public_html");
					.mok;
				}
			8, 12 => if (.mget2("$alpha man ls") )	{
					.manls;
					.mnextsub;
				}
			9 => if( .mget4("ls -a", "ls -a .", "ls -a ./") )	{
					.moutln(".  ..  .adresy  lekcje  Mail  public_html  .zajecia");
					.mok;
				} else { sublevel=8; }
			10 => if( .mget3("ls $alpha Mail", "ls $alpha Mail /") )	{
					if( .misdir("Mail") )	{
						.moutln("mbox");
						.mnextsub;
					} else .mno;
				}
			11 => if( .mget3("ls -a ..", "ls -a ../") )	{
					.moutln(". .. jacek");
					.mok;
				} else sublevel=10;
			13 =>  if( .mget4("ls -l", "ls -l .", "ls -l ./") )	{
					.moutln("total 12");
					.moutln("-rw-r--r-- 1 jacek jacek  415 2007-05-16 17:10 lekcje");
					.moutln("drwx------ 2 jacek jacek 4096 2007-05-16 12:51 Mail");
					.moutln("drwxr-xr-x 2 jacek jacek 4096 2007-05-16 13:05 public_html");
					.mok;
				} else sublevel = 12;
			14 => if (.mget3("ls -l $alpha Mail", "ls -l $alpha Mail /") )	{
					if( .misdir("Mail") )	{
						.moutln("total 0");
						.moutln("-rw-r--r-- 1 jacek jacek 0 2007-05-16 12:51 mbox");
						.mok;
					} else .mno;
				}
			15 => if (.mget3("ls -al", "ls -la") )	{
					.moutln("total 28");
					.moutln("drwxr-xr-x 4 jacek jacek 4096 2007-05-16 13:03 .");
					.moutln("drwxr-xr-x 3 jacek jacek 4096 2007-05-16 11:27 ..");
					.moutln("-rw-r--r-- 1 jacek jacek  121 2007-05-16 13:03 .adresy");
					.moutln("-rw-r--r-- 1 jacek jacek  415 2007-05-16 17:10 lekcje");
					.moutln("drwx------ 2 jacek jacek 4096 2007-05-16 12:51 Mail");
					.moutln("drwxr-xr-x 2 jacek jacek 4096 2007-05-16 13:05 public_html");
					.moutln("-rw-r--r-- 1 jacek jacek  130 2007-05-16 13:00 .zajecia");
					.mok;
				}
			16 => if( .mget0 )	{
					if( .misvec(A, "ls", "/home/jacek") || .misvec(A, "ls", "/home/jacek/") )	{
						.moutln("lekcje  Mail  public_html");
						.mok;
					} else .mno;
				}
			17 => if (.mget2("$alpha cat $alpha lekcje") )	{
					.mcatlekcje;
					.mok;
				}
			18 => if (.mget2("$alpha cat $alpha lekcje > $alpha plik_tmp") )	{
					.mnextsub;
				}
			19 => if (.mget4("ls", "ls .", "ls ./") )	{
					.moutln("lekcje  Mail  plik_tmp  public_html");
					.mok;
				} else sublevel=18;
			20 => if ( .mget2("$alpha cat $alpha lekcje") )	{
					.mcatlekcje;
					.mnextsub;
				}
			21 => if( .mget3("$alpha cat $alpha lekcje | $alpha grep $alpha rogramow",
				 "$alpha cat $alpha lekcje | $alpha grep ' $alpha rogramow '") )	{
					if( Code.gete(0,1)=="'" )	{
						if( Code.gete(0,10)=="'rogramow'" &&
							Code.getb(Code.find("grep")+4, 1)==" ")	{
							.mcatlek2;
							.mok;
						} else { .mno; sublevel=20; }
					} else {
						.mcatlek2;
						.mok;
					}
				} else sublevel=20;
			22 => if ( .mget3("ls -a | $alpha grep $alpha a", "ls -a | $alpha grep ' $alpha a '") )	{
					if( Code.gete(0,1)=="'" )	{
						if( Code.gete(0,3)=="'a'" &&
							Code.getb(Code.find("grep")+4, 1)==" ")	{
							.moutln(".adresy");
							.moutln("Mail");
							.moutln(".zajecia");
							.mok;
						} else .mno;
					} else {
						.moutln(".adresy");
						.moutln("Mail");
						.moutln(".zajecia");
						.mok;
					}
				}
			23 => if( .mget4("ls -a", "ls -a .", "ls -a ./") )	{
					.moutln(".  ..  .adresy  lekcje  Mail  plik_tmp  public_html  .zajecia");
					.mnextsub;
				}
			24 => if( .mget0 )	{
					if( .misvec(A, "cat", ".adresy") )	{
						.moutln("Magda, ul. Biala 1/5");
						.moutln("Janek, ul. Zielona 6");
						.moutln("Poziomka prof., ul. Cauchy 1/1");
						.moutln("Ania, ul. Wegierska 3/52");
						.moutln("Witek, ul. Maliny 6/66");
						.mnextsub;
					} else { .mno; sublevel=23; }
				}
			25 => if( .mget2("$alpha cat . $alpha adresy | $alpha sort") )	{
					if( Code.getb(Code.find("adresy")-1,1)=="." )	{
						.moutln("Ania, ul. Wegierska 3/52");
						.moutln("Janek, ul. Zielona 6");
						.moutln("Magda, ul. Biala 1/5");
						.moutln("Poziomka prof., ul. Cauchy 1/1");
						.moutln("Witek, ul. Maliny 6/66");
						.mnextsub;
					} else { .mno; sublevel=23; }
				} else { sublevel=23; }
			26 => if( .mget2("$alpha cat . $alpha adresy | $alpha sort > $alpha nowe_adresy") )	{
					if( Code.getb(Code.find("adresy")-1,1)=="." )	{
						.mnextsub;
					} else { .mno; sublevel=23; }
				} else { sublevel=23; }
			27 => if( .mget2("$alpha cat $alpha nowe_adresy") )	{
					.moutln("Ania, ul. Wegierska 3/52");
					.moutln("Janek, ul. Zielona 6");
					.moutln("Magda, ul. Biala 1/5");
					.moutln("Poziomka prof., ul. Cauchy 1/1");
					.moutln("Witek, ul. Maliny 6/66");
					.mok;
				} else { sublevel=23; }
			28 => if( .mget0 )	{
					if( .misvec(A, "cd", "public_html") || .misvec(A, "cd", "public_html/")
						|| .misvec(A, "cd", "./public_html/") || .misvec(A, "cd", "./public_html"))	{
						Dir = "~/public_html";
						.mnextsub;
					} else .mno;
				}
			29 => if (.mget("pwd") )	{
					.moutln("/home/jacek/public_html");
					.mnextsub;
				} else {sublevel=28;}
			30 => if( .mget3("$alpha cd ..", "$alpha cd ../") )	{
					Dir = "~";
					.mnextsub;
				} else {sublevel=28;}
			31 => if (.mget("pwd") )	{
					.moutln("/home/jacek");
					.mok;
				} else {sublevel=28;}
			32 => if( .mget0 )	{
					if( .misvec(A,"ls","public_html") || .misvec(A,"ls","./public_html") ||
						.misvec(A,"ls","public_html/") || .misvec(A,"ls","./public_html/") )	{
						.moutln("index.html");
						.mnextsub;
					} else .mno;
				}
			33 => if( .mget0 )	{
					if( .misvec(A,"cd","public_html") || .misvec(A,"cd","./public_html") ||
						.misvec(A,"cd","public_html/") || .misvec(A,"cd","./public_html/") )	{
						Dir = "~/public_html";
						.mnextsub;
					} else { sublevel=32; .mno; }
				}
			34 => if( .mget0 )	{
					if( .misvec(A,"mkdir","bekap") || .misvec(A,"mkdir","./bekap") ||
						.misvec(A,"mkdir","bekap/") || .misvec(A,"mkdir","./bekap/") )	{
						.mnextsub;
					} else { sublevel=32; .mno; }
				}
			35 => if( .mget0 )	{
					if( .misvec(A,"cp","index.html", "bekap") || .misvec(A,"cp","./index.html", "bekap") ||
						.misvec(A,"cp","index.html", "bekap/") || .misvec(A,"cp","./index.html", "bekap/") ||
						.misvec(A,"cp","index.html", "./bekap") || .misvec(A,"cp","./index.html", "./bekap") ||
						.misvec(A,"cp","index.html", "./bekap/") || .misvec(A,"cp","./index.html", "./bekap/")) {
						.mnextsub;
					} else { sublevel=32; .mno; }
				}
			36 => if( .mget0 )	{
					if( .misvec(A,"cd","bekap") || .misvec(A,"cd","./bekap") ||
						.misvec(A,"cd","bekap/") || .misvec(A,"cd","./bekap/") )	{
						Dir = "~/public_html/bekap";
						.mnextsub;
					} else { sublevel=32; .mno; }
				}
			37 => if (.mget4("ls", "ls .", "ls ./") )	{
					.moutln("index.html");
					.mnextsub;
				} else sublevel=32;
			38 => if( .mget0 )	{
					if( .misvec(A,"cd","../../") || .misvec(A,"cd") || .misvec(A,"cd","/home/jacek/") ||
						.misvec(A,"cd","~") || .misvec(A,"cd","/home/jacek") || .misvec(A,"cd","../..") )	{
						Dir = "~";
						.mok;
					} else { sublevel=32; .mno; }
				}
				/*1) usu go poleceniem 'rm <file>'.
2) Wywietl zawarto katalogu 'public_html'.
3) Uruchom manual polecenia 'rm'.
4) Usu katalog 'bekap' z 'public_html'.*/
			39 => if( .mget0 )	{
					if( .misvec(A, "rm", ".adresy") )	{
						.mnextsub;
					} else .mno;
				}
			40 => if( .mget0 )	{
					if( .misvec(A,"ls","public_html") || .misvec(A,"ls","./public_html") ||
						.misvec(A,"ls","public_html/") || .misvec(A,"ls","./public_html/") )	{
						.moutln("bekap index.html");
						.mnextsub;
					} else { .mno; sublevel=39; }
				}
			41 =>  if (.mget2("$alpha man $alpha rm") )	{
					.moutln("NAME");
					.moutln("   rm - remove files or directories");
					.moutln("SYNOPSIS");
					.moutln("   rm [OPTION]... FILE...");
					.moutln("DESCRIPTION");
					.moutln("   Removes FILEs. Use option '-r' to remove");
					.moutln("   directory.");
					.moutln("   OPTION");
					.moutln("   -r : remove directories and their contents recursively");
					.moutln("END RM");
					.mnextsub;
				} else sublevel=39;
			42 => if( .mget0 )	{
					if( .misvec(A,"rm","-r","public_html/bekap") ||
						.misvec(A,"rm","-r","./public_html/bekap") ||
						.misvec(A,"rm","-r","public_html/bekap/") ||
						.misvec(A,"rm","-r","./public_html/bekap/") )	{
						.mnextsub;
					} else { sublevel=39; .mno; }
				}
			43 => if( .mget0 )	{
					if( .misvec(A,"ls","public_html") || .misvec(A,"ls","./public_html") ||
						.misvec(A,"ls","public_html/") || .misvec(A,"ls","./public_html/") )	{
						.moutln("index.html");
						igmstate = 10;
						.cbplay("sndend");
					} else { .mno; sublevel=39; }
				}
			? => ;
		}
	}
	mnextsub	{	sublevel++; .mready;	}
	bool misvec	{
		Code.clear;
		vec1.vecbuildfromstring2(Code," ");
		vec1.veceq2;
	}
	misdir(string sdir)	{
		Code.clear;
		@id = Code.find(sdir)+sdir.length;
		return id>=Code.length || Code.getb(id,1)=="/";
	}
	mcatlek2	{
		.moutln("Lekcja 5: Programowanie mikroprocesorow - jezyki Asembler.");
		.moutln("Lekcja 6: Podstawy programowania w jezyku C : obliczenia.");
		.moutln("Lekcja 7: Podstawy programowania obiektowego.");
	}
	mcatlekcje	{
		.moutln("Lekcja 1: Podstawy logiki.");
		.moutln("Lekcja 2: Bramki \"and\" i \"or\".");
		.moutln("Lekcja 3: Cwiczenia na bramkach.");
		.moutln("Lekcja 4: Jednobitowy procesor.");
		.moutln("Lekcja 5: Programowanie mikroprocesorow - jezyki Asembler.");
		.moutln("Lekcja 6: Podstawy programowania w jezyku C : obliczenia.");
		.moutln("Lekcja 7: Podstawy programowania obiektowego.");
		.moutln("Lekcja 8: Podstawy grafiki komputerowej.");
		.moutln("Lekcja 9: Praca podzespolow komputera.");
		.moutln("Lekcja 10: Podstawy systemu operacyjnego Linuks.");
	}
	manls	{
		.moutln("NAME");
		.moutln("  ls - list directory contents;");
		.moutln("SYNOPSIS");
		.moutln("  ls [OPTION]... [FILE]...");
		.moutln("DESCRIPTION");
		.moutln("  list informations about the FILEs -");
		.moutln("  (the current directory by default).");
		.moutln("  OPTION");
		.moutln("  -a : don't ignore hidden files");
		.moutln("  -l : use a long listing format");
		.moutln("END LS");
	}
	mnos(string s)	{	.moutln(s);	.mready;	}
	mno	{ fxblink.play; Dir=retdir; .mnos("Error: repeat whole activity nr "+Level+" again.");	}
	mgo(@id)	{	sublevel=id; .mready;	}
	mstart	{
		match(Level)	{
			1 => { sublevel=0; .mout("jacek login: "); .menable; }
			2 => { tdhp.view(A,0); .mgo(3);	}
			3 => { tdhp.view(A,1,2); .mgo(6);	}
			4 => { tdhp.view(A,3,4); .mgo(7);	}
			5 => { tdhp.view(A,5); .mgo(8);	}
			6 => { .mgo(10);	}
			7 => { .mgo(12);	}
			8 => { .mgo(14);	}
			9 => { .mgo(15);	}
			10 => { .mgo(16);	}
			11 => { tdhp.view(A,6); .mgo(17);	}
			12 => { .mgo(18); }
			13 => { tdhp.view(A,7); .mgo(20); }
			14 => { .mgo(22); }
			15 => { tdhp.view(A,8); .mgo(23); }
			16 => { tdhp.view(A,9); .mgo(28); }
			17 => { tdhp.view(A,10,11); .mgo(32); }
			18 => { tdhp.view(A,12); .mgo(39); }
			? => .mready;
		}
	}
	mready	{	.mout("jacek@jacek:"+Dir+"$ ");	.menable;	}
	mok	{	igmstate=3; fxpik.play; .cbplay("sndok");	}
	bool mreadpas	{
		fxtype2.playif;
		if( keyboard.iskey("enter") )	{
			.mnewline;
			return true;
		} else if( keyboard.iskey("backspace")) {
			spasswd = spasswd.strsube(1);
		} else spasswd += keyboard.getkey;
		false;
	}
	key_down	{
		if( benter )	{
			benter = false;
			return;
		}
		if( igmstate==2 )	{
			.mouse_lclick;
			return;
		}
		if( igmstate!=1) return;
		match(sublevel)	{
			1 =>	if( .mreadpas )	{
					if( Code=="jacek" && spasswd=="jacek")	.mok;
					else {
						.moutln("Login incorrect");
						.mstart;
					}
				}
			4 => if( .mreadpas )	{
					if( spasswd=="jacek" )	{
						sublevel++;
						spasswd="";
						.mout("type new password: ");
					} else {
						sublevel = 3;
						.mnos("Incorrect password");
					}
				}
			5 => if( .mreadpas )	{
					if( spasswd=="he,35hsu" )	{
						.moutln("Password succesfully changed");
						.mok;
					} else {
						sublevel = 3;
						.mnos("Error: write password given in exercise");
					}
				}
			? => ;
		}
	}
	mnext	{	<GAME> { igmstate=1; .viewzad; .mstart; };	}
	mouse_lclick	{
		match(igmstate)	{
			1 => ;
			2 => { gsq.hide; tdopis.hide; igmstate=1; .viewzad; .mstart; }
			10 => ;
			11 => gameapi.play("MenuGlowne");
			? => .cactsndstop(true);
		}
	}
	mouse_rclick	{
		if( igmdebug )	{
			if( Level==18 ) .cbplay("sndend");
			else .mok;
		}
	}
}

game Intro : Computro	{
	init	{
		Computro::init("intro");
		.img = ("bg.png");
		new real rsetzoom = 0.67;
		new real rzoomer = 0.003;
		//new real rzoomer = 0.03;
		imgbg.anaddfilter;
		imgbg.setzoom(rsetzoom);
		imgbg.ancenterscreen;
		
		.lang_db("dbtxt", "teksty");
		new @stdfont32 = .stdfont(28);
		new string stxtstart = dbtxt.dbgets("txtstart",1);
		.newtext("txtdata", stxtstart, stdfont32, .grey(248));
		txtdata.setz(10);
		txtdata.setpos( iResX-txtdata.getw-20, 20 );
		txtdata.txtset("");
		
		//.cutscene;
		
		.sounds=(A,
			"rektor1", "Witam was bardzo serdecznie w murach naszej Akademii; Rozpoczynamy kolejny rok zaj w ponad szesetletniej historii szkoy", "mcheck0",
			"rektor2", "Nazywam si Antoni Bbenek i mam zaszczyt piastowa stanowisko rektora", func { .mscene2; .mrektor("rektor3"); },
			"rektor3", "Wykadam zajcia od ponad pidziesiciu lat; Budowaem pierwsze komputery lampowe", 
				func { .mscene1; .rektor("rektor4"); },
			"rektor4", "Pamitam jak sumator zbudowalimy w 61 ho ho; Mona byo uamki dodawa i mnoy; To byy czasy", 
				func { .rektor("rektor5"); },
			"rektor5", "Ale wrmy do dzi; O czym to ja; Acha", func { .mscene2; .mrektor("rektor6"); },
			"rektor6", "Akademia w ktrej rozpoczynacie nauk jest niezwyka; Jedyna w swoim rodzaju; Caym yciem Akademii zarzdza Komputer Centralny", func { .mrektor("rektor7"); },
			"rektor7", "Tak tak moi drodzy; Od planw lekcji przydziau pokojw finansw ksigowoci po wzywanie mechanikw i hydraulikw; Wszystko spoczywa na barkach a raczej tranzystorach Komputera Centralnego; Dziki temu moemy skupi wszystkie wysiki na badaniach i nauczaniu", func { .mrektor("rektor8"); },
			"rektor8", "Oto moi przyjaciele ktrzy poprowadz z wami zajcia", func { .mrektor("rektor9"); },
			"rektor9", "Profesor Wincenty; Ekspert podstaw informatyki; To on zainicjowa budow Komputera Centralnego w 1973 roku", func { .mrekfin; anwinc._mplay("winc1"); },
			"winc1", "Wincenty; Mio mi", func { anwinc.play("stand"); .mrektor("rektor11"); },
			"rektor11", "Profesor Sp; Sieci neuronowe", func { .mrekfin; ansep._mplay("sep1"); },
			"sep1", "Witam uprzejmie", func { ansep.play("stand"); .timer = ("timgiar", 30, func {
					if( anbgprof.getex-5 > iResX )	{
						grsc1.move(-5, 0);
						.play;
					} else {
						.mrektor("rektor10");
					}
				} );
				timgiar.play;
				},
			"rektor10", "Doktor Giaro; Specjalista z dziedziny sztucznej inteligencji", func { .mrekfin; angiaro._mplay("giaro1"); },
			"giaro1", "Bardzo mi mio", func { .mscene1; .reks(12); },
			"rektor12", "Historia Akademii zaczyna si w roku 1405 od przybycia braci Benedyktynw ktrzy zaoyli tu swj klasztor", func { .reks(13); },
			"rektor13", "Zakonnicy synli z wytwarzanego wina i wysokiego poziomu nauczania", func { .reks(14); },
			"rektor14", "Do dzi przetrwa po nich gwny budynek i nieczynna ju kaplica", func { .reks(15); },
			"rektor15", "W roku 1895 na miejscu starych ruin zbudowano nowy gmach w ktrym teraz jestemy", func { .reks(16); },
			"rektor16", "A nasza szkoa otrzymaa nazw Akademia Maszyn; Wyksztacio si tutaj wielu wspaniaych inynierw i powstaway maszyny ktre potem trafiay do fabryk", 
				func { .reks(17); },
			"rektor17", "50 lat pniej Akademia przeksztacia si w szko nowoczesnych technologii elektrycznych", func { .rek(18); },
			"rektor18", "Niedugo potem trafiem tu ja i rozpoczlimy z profesorem Wincentym i profesorem Spem prace nad mzgiem elektronowym", func { .reks(19); },
			"rektor19", "Naszym dzieem jest Komputer Centralny", func { .rek(20); },
			"rektor20", "Jednak prawdziwy przeom nastpi kilka lat temu wraz z nadejciem doktora Giaro", func { .reks(21); },
			"rektor21", "Doktor jest bliski zbudowania pierwszego mylcego robota", func { .rek(22); },
			"rektor22", "ycz i wam abycie mili swj udzia w przeomowych wynalazkach", func { .rek(23); },
			"rektor23", "Tymczasem przygotujcie si do pierwszych jutrzejszych zaj", func { grsc1.move( -anbgprof.getpx, 0); .mscene2; .mrektor("rektor24"); },
			"rektor24", "Komputer Centralny przydzieli kademu z was pokj w Internacie a starsi studenci zanieli tam wasze rzeczy; Kiedy wyjdziecie z auli mj asystent da kademu kart magnetyczn do pokoju i plan lekcji; Dzikuj za uwag", func { .mrekfin;
				mus.fadeout(1000);
				ccs.close( func {
					clsave.set("game_day", 1);
					.gotoadv("adaula","gameadaula0");
					ccs.show;
					});
				}
		);
		
		new img im2;
		im2.create(iResX, iResY, .white, 255);
		im2.anaddfilter;
		im2.hide;
		
		/*new img imx;
		imx.create(300, 300, .white, 255);
		@dx = (imgbg.getw-iResX)/2;
		@dy = (imgbg.geth-iResY)/2;
		imx.setpos(200+dx, 200+dy);
		imx.blit("imgbg");
		imx.move(-dx, -dy);*/
				
		new string simbg = "imgbg";
		
		.cnewtimerfin("timstart", 50, stxtstart.length+1, func { timtik.play; } );
		timstart.addmethod("ontick", func {
			txtdata.txtset( stxtstart.getb(0, txtdata.get->length+1) );
			txtdata.txtshadow(1, stdfont32);
			} );
		new real RY = iResY/2;
		.timer = ("timtik", 1300, func {
// 			.tickstart;
			if( .getdelay==1300 )	{
				.delay(30);
				.play;
				return;
			}
			if( rsetzoom<1 ) RY -= rsetzoom;
			if( rsetzoom<1 && rsetzoom+rzoomer>=1 )	{
				simbg = "im2";
				im2.blit("imgbg");
				//imgbg.unlink;
				imgbg.hide;
				im2.show;
				RY = iResY/2;
				gameapi.setmusicvol(30);
				.cbplay("rektor1");
			} else gameapi.setmusicvol(60);
			rsetzoom+=rzoomer;
			<simbg>.setzoom(rsetzoom);
			//<simbg>.ancenterscreen;
			
			<simbg>.ansetcpos( iResX/2, RY);
			
			if( rsetzoom<1.4 )
				.play;
			else {
				<GAME>	{
					delete imgbg;
					/*new img im3;
					im3.create(iResX, iResY, .white, 255);
					im3.blit("im2");
					delete im2;*/
					.mcheck0;
				};
			}
// 			.tickstop;
			} );
		
		ccs.enter( func {
			timstart.play;
			mus.playstr("sala.ogg sala.ogg -l -v 30");
			} );
		
		
		// debug
 		/*delete imgbg;
 		igmstate=1;
 		.mcheck0;*/
		// debug
	}
	mendintro	{
		clsave.set("game_day", 1);
		.gotoadv("adaula","gameadaula0");
		ccs.show;
	}
	mcheck0	{
		<GAME> {
			igmstate++;
			if( igmstate==2 )	{
				ccs.playfin( func {
					delete txtdata;
					delete im2;
					
					new gmimgvec grsala;
					"grsala" .* "sala.pyz";
					.imgs = (A, "slajdy.pyzH 10", "bgprof.pyzH", "giaroH.pyz 10", "rektorH.pyz 10", "sepH.pyz 10", "wincH.pyz 10", "reksmall.pyz", "mrok.pyz 20", "swiatlo.pyzH 20");
					<grsala.get(4)>.setz(1);
					new gmimgvec grsc1;
					.copyanima("anbgprof", "anbiurko");
					anbiurko.setframe(1,0);
					anbiurko.setz(15);
					grsc1.addlist(A, "anbgprof", "angiaro", "anrektor", "ansep", "anwinc", "anbiurko", "answiatlo");
					}, func {
					.rektor("rektor2");
					} );
			}
		};
	}
	_mplay(string s)	{
		.play("talk");
		<GAME>.cbplay(s);
	}
	rek(int n)	{	.rektor("rektor"+n);	}
	reks(int n)	{	.rek(n); .mslajd;	}
	rektor(string s)	{	anreksmall._mplay(s);	}
	rekfin	{	anreksmall.play("stand");	}
	mrektor(string s)	{	anrektor._mplay(s);	}
	mrekfin	{	anrektor.play("stand");	}
	mscene1	{	// sala
		if( anslajdy.actionnr(-1)>0 ) anslajdy.show;
		grsala.eval1("play", -1);
		grsc1.anhide;
		anreksmall.play("stand");
		anmrok.show;
	}
	mscene2	{
		anslajdy.hide;
		grsala.eval("anhide");
		anreksmall.anhide;
		anmrok.hide;
		grsc1.nplay(-1);
	}
	mslajd	{
		if( anslajdy.isvisible )	anslajdy.ansetnextact;
		else anslajdy.show;
	}
	mouse_lclick	{
		//if( igmdebug ) .cactsndstop(true);
		.cactsndstop(true);
	}
	mouse_rclick	{
		if( igmdebug )	{
			.mendintro;
		}
	}
}

new db dbplan;
dbplan.load("lang/PlanLekcji.db");
new font fntplan;
fntplan.load( sgmfontfile, 24 );
new font fntnotes;
new int ifntnotes = 21;
new int inoteslimit = 20;
fntnotes.load( sgmfontitalic, ifntnotes );
new int inotesx = 45;
new int inotesy = 50;
public notescol	{	return 10,20,128;	}

class classadvinfo2 : classadvcontroller	{
	init	{
		clbuts.reset;
		classadvcontroller::init;
		.advsave_game;
	}
	mouse_LCLICK	{
		match( igmstate )	{
			1 => .hide_plan;
			2 =>  if( .hasvar("_annot2") && !_annot2.isplaying(-1))	{	igmstate = 3;	_annot2.play(2);	}
			? => ;
		}
	}
	hide_plan	{
		delete _implan;
		delete _anpusty;
		delete _anplan;
		delete _anblysk;
		igmstate = 0;
	}
	show_plan	{
		igmstate = 1;
		if( engine.varexist("clwalkq") )	clwalkq.stand;
		.newanima("_anplan", "$scripts/common/plan.pyz", 3000);
		new img _implan;
		_implan.copy("_anplan");
		.copyanima("_anplan", "_anpusty");
		_anpusty.setframe(1,0);
		.copyanima("_anplan", "_anblysk");
		_anblysk.setframe(2,0);
		_anplan.hide;
		@id = dbplan.findbyrow( clsave.get("lesson") );
		if( id>=0 )	{
			_anpusty.hide;
			.newtext( "_txtplan", dbplan.get(0,1), "fntplan", .grey(240) );
			@x = _implan.getpx + 50;
			@y = _implan.getpy + 60;
			_txtplan.setpos(_implan.getcx - _txtplan.getw/2, y);
			_implan.blit("_txtplan");
			y+=50;
			for( int i=1; i<=3; i++)	{
				_txtplan.txtset( dbplan.get(0,i+1)+dbplan.get(id, i) );
				_txtplan.setpos(x, y+i*(_txtplan.geth+10));
				_implan.blit("_txtplan");
			}
			delete _txtplan;
		}
	}
	show_notes	{
		igmstate = 2;
		if( engine.varexist("clwalkq") )	clwalkq.stand;
		.newanima("_annotes", "$scripts/common/notes.pyz", 3000);
		string s = clsave.get("anotes_text");
		new img _imgnotes;
		if( s!=null )	{
			new db dbnotes;
			_imgnotes.copy("_annotes");
			dbnotes.load("lang/anotes_"+s+".db");
			.newtext("_txtnot", "", "fntnotes", .notescol );
			int x = _annotes.getpx + inotesx;
			int y = _annotes.getpy + inotesy;
			for( int i=0; i<dbnotes.getrowsno; i++)	{
				_txtnot.setpos( x, y+i*(ifntnotes+4) );
				_txtnot.txtset( dbnotes.get(i,0) );
				_imgnotes.blit("_txtnot");
			}
			delete dbnotes;
			delete _txtnot;
			_annotes.hide;
		}
		.copyanima("_annotes", "_annot2");
		_annot2.setframe(1,0);
		_annot2.show;
	}
	_annot2_FINISH {
		if( .actionnr(-1)==2 )	{
			<gameapi.getgamename> {
				if( !.hasvar("_tim_not") )	{
					.timer = ("_tim_not", 50, "hide_notes");
				}
				_tim_not.play;
			};
		}
	}
	hide_notes	{	<gameapi.getgamename> {
		delete _imgnotes;
		delete _annot2;
		delete _annotes;
		igmstate = 0;
	}; }
	show_kartka	{	<gameapi.getgamename> {
		// kartka_dbdane, kartka_file, kartka_posx, kartka_posy, kartka_angle
		new db dbkartka;
		dbkartka.load("lang/kartka_" + clsave.get("kartka_dbname") + ".db");
		.newtext("_txtkar", "", "fntnotes", .notescol );
		.newanima("_ankartka", "$scripts/common/"+clsave.get("kartka_file")+".pyz", 3000);
		new img _imgkartka;
		_imgkartka.copy("_ankartka");
		_ankartka.hide;
		int x = _ankartka.getpx + clsave.get("kartka_posx");
		int y = _ankartka.getpy + clsave.get("kartka_posy");
		int angle = clsave.get("kartka_angle");
		if( angle )	{
			new filter ftkar;
			ftkar.link("_txtkar");
		}
		for( int i=0; i<dbkartka.getrowsno; i++)	{
			_txtkar.setpos( x, y+i*(ifntnotes+4) );
			_txtkar.txtset( dbkartka.get(i,0) );
			if( angle )	ftkar.rotate(angle);
			_imgkartka.blit("_txtkar");
		}
		if( angle )	delete ftkar;
		delete _txtkar;
		delete dbkartka;
	}; }
	hide_kartka	{	<gameapi.getgamename> {
		delete _imgkartka;
		delete _ankartka;
	}; }
	/*********************************************/
	advload_game	{	._advload("save"+PrzygodaNumer);	}
	advsave_game	{	._advsave("save"+PrzygodaNumer);	}
}

game gameadvdef : classadvinfo2	{
	init	{
		classadvinfo2::init;
	}
}

game gameadtyl2 : classadvinfo2	{
	init	{
		classadvinfo2::init;
	}
	feliks_ENDFRAME	{
		SoundSource::setvol("bgrmachinel", 80, 20, 500, feliks.getcx-(imgbkg.getpx+100));
	}
}

game gameadkor3 : classadvinfo2	{
	init	{
		classadvinfo2::init;
	}
	feliks_ENDFRAME	{
		//setvol(string ssnd, int srcvol, int outvol, real rad, real length)	{
		SoundSource::setvol("bgrwiatrak", 90, 5, 500, feliks.getcx-(imgbkg.getpx+100));
		SoundSource::setvol("alarm", 30, 3, 500, feliks.getcx-(imgbkg.getpx+100));
	}
}

game Mapa : Computro	{
	init	{
		Computro::init("mapa");
		clsave.set("mapscene", sgmlastscene);
		new Buttons butm("mapa.pyz");
		match( clsave.get("game_day") )	{
			1,2,3 => 0;
			4,5 => 2;
			? => 0;
		}
		new string sprzygoda = _;
	}
	butm_lclick	{
		sgmlastscene = "Mapa";
		.gotoadv("ad"+sobject, "gamead"+sobject+sprzygoda);
	}
}


game Sysop : Computro	{
	init	{
		Computro::init("sysop");
		
		new string kcsystem = clsave.get("kcsystem");
		new string subepizod = clsave.get("subepizod");
		new string slastact = clsave.get("kcsystem_slastact");
		
		new int systate = 0;	// stan gry
		
		new int ihelp;
		.lang_db("dbhp", "helps");
		new gmimgvec grhelps;
		
		new int iconstate = clsave.get("iconstate");
		new bool benter = false;
		
		sgmlastscene = "Sysop";
		
		.sounds = (A,
			":ania1", "System si instaluje", null,
			":ania2", "System zainstalowany; Teraz musimy poczy si z sieci", "mgotogame",
			":ania3", "To nasz system; Mamy 2 zainstalowane programy; Zak mgby przypomnie co mwi admin?", func { <GAME>.mhelps(3); .cbplay("zak1"); },
			":zak1", "Mam trzy wypowiedzi wybieraj je do odsuchania", "gmunlockall",
			":ania4", "Brak poczenia z sieci; To pewnie jaka przegldarka", func { .cbplay("zak2"); },
			":zak2", "FTP to protok i program do wymiany plikw; Jak bdziemy mieli sie cigniemy za jego pomoc oprogramowanie z serwera", "munlockhelp",
			":ania5", "A wic to jest konsola; Ju to widziaam nie raz; Teraz powinnam wpisa polecenie", null,
			":ania6", "Najpierw musz zdoby ten adres MAC", null,
			":ania7", "Hmm to chyba nie to polecenie", null,
			":ania8", "Dobra idziemy zanie adres adminowi", "mexit",
			":ania9", "Gdzie w tych danych jest ten adres; Przepisz go do notesu", "mnotes",
			":ania10", "To jak Zak? Zanosimy taki adres adminowi?", null,
			":zak3", "Tak zobaczmy co powie", null,
			":zak4", "Sam nie wiem popatrzmy jeszcze troch", null,
			// ftp
			":ania11", "Admin mwi e mamy poczy si z serwerem przez FTP; To pewnie ten drugi program", "gmunlockall",
			":ania12", "Ok widz 2 programy; Jeden z nich to edytor tekstu", null,
			":ania14", "Program ju zainstalowany", null,
			":ania_word", "Zainstalowaam edytor tekstu Word",null,
			":ania_calc", "Zainstalowaam arkusz kalkulacyjny", null,
			":ania15", "Najpierw musimy zainstalowa sterowniki do drukarki", null,
			":ania16", "Na razie nie mam czasu na uycie tego programu", null,
			// ssh
			":ania17", "Sprbujmy zalogowa si na to konto; Wcz pomoc", func { .cbplay("zak5"); },
			":zak5", "Dobra; Wykonuj czynnoci po kolei", func { <GAME>.mhelps(1); .gmunlockall; },
			":zak6", "Ze haso; Wpisz to ktre pokazuj w pomocy", null,
			":ania18", "Udao si; Co teraz?", func { .cbplay("zak7"); },
			":zak7", "Jestemy w systemie uniksowym; Generuj now pomoc ebymy rozeznali si w sytuacji", func { subepizod = "kcssh2"; <GAME>.mhelps(1); .mconunlock; },
			":zak8", "O rany! Poznaj te pliki; To konto rektora przez ktre wprowadza zakupy do Komputera Centralnego", func { .cbplay("ania19"); },
			":ania19", "Jak moemy je skopiowa?", func { .cbplay("zak9"); },
			":zak9", "Musimy si wylogowa i uy programu escepe; Postpuj wedug moich wskazwek", func { subepizod="kcssh3";<GAME>.mhelps(2); .mconunlock; },
			":zak10", "Syntax Error", func { isyntax++; if( isyntax==4 ) .cbplay("ania20"); },
			":ania20", "Ju przesta z tym syntax error bo mnie denerwujesz", func { .cbplay("zak10"); },
			":zak11", "Inaczej nie mog", null,
			":zak12", "Super; Otwrz teraz arkusz kalkulacyjny", func { subepizod="kcssh4";<GAME>.mhelps(1); .mconunlock; }
			);
		new int isyntax = 0;
		
		match(kcsystem)	{
			"install" => {
				.imgs = (A, "bginstall.pyz", "logoinstall.pyz 10");
				.cbplay("ania1");
				anlogoinstall.anplayfin(0, func {
					clsave.set("kcsystem", "loading");
					gameapi.play("Sysop");
					} );
			}
			"loading" => {
				.imgs = (A, "bgload.pyz", "loading.pyz 10");
				.copyanima("anloading", "annapisload");
				annapisload.setframe(1,0);
				.copyanima("anloading", "annapison");
				annapison.setframe(2,0);
				annapison.hide;
				new int ixclip = anloading.getpx;
				anloading.clip( 0, 0, ixclip, iResY );
				
				.timer = ("timload", 200, func {
					.delay(200 + 200->rand);
					ixclip+=50+50->rand;
					anloading.clip( 0, 0, ixclip, iResY );
					if(ixclip>=iResX)	{
						clsave.set("kcsystem", "ready");
						gameapi.play("Sysop");
					} else
						.play;
					} );
				timload.play;
			}
			"ready" => {
				.imgs = (A, "bgsys.pyz");
				if( subepizod=="kcinstall" )
					.cbplay("ania2");
				new Button butstart;
				butstart.load("grbutstart", "readybut.pyz", func { (@id)
					.Button_isin;
					.addmethod("butclick", func {
						if( .framenr==2 || subepizod=="kcinstall") return;
						.setframe(0, 2);
						.timer = ("timstart", 250, func {
							clsave.set("kcsystem", "go");
							gameapi.play("Sysop");
							} );
						timstart.play;
						} );
					.addmethod("butmoveon", func {
						if( .framenr!=2 )	{
							bsms.setact;
							.setframe(0,1);
						}
						} );
					.addmethod("butmoveoff", func {
						if( .framenr!=2 )	{
							bsms.setstd;
							.setframe(0, 0);
						}
						} );
				} );
			}
			"go" => {
				.imgs = (A, "bgsys.pyz", "syswin.pyz 10");
				new gmimgvec grwinbut;
				new gmimgvec grdesk;
				
				new Button butoff;
				butoff.load("grbutoff", "sysoff.pyz", func { (@id)
					.Button_isin;
					.addmethod("butclick", func {
						if( igmstate!=0 )	return;
						
						match(subepizod)	{
							"kcifconfig" => {
								
								//return;
							}
							? => ;
						}
					
						if( .framenr==2 ) return;
						.setframe(0, 2);
						
						clsave.set("kcsystem_slastact", slastact);
						.mexit;
						} );
					.addmethod("butmoveon", func {
						if( .framenr!=2 )	{
							bsms.setact;
							.setframe(0,1);
						}
						} );
					.addmethod("butmoveoff", func {
						if( .framenr!=2 )	{
							bsms.setstd;
							.setframe(0, 0);
						}
						} );
				} );
				.mshow("con");
				.mshow("ftp");
				.mcheckshow("print");
				.mcheckshow("word");
				.mcheckshow("calc");
				
				match( subepizod )	{
					"kcifconfig" => {
						.newsnd("sndh1", "admin_13");
						.newsnd("sndh2", "admin_14");
						.newsnd("sndh3", "admin_18");
						if( !clsave.bis("poczatek_kcifconfig") )	{
							clsave.bset("poczatek_kcifconfig");
							.mplay("ania3");
						} else {
							.mhelps(3);
							.gmunlockall;
						}
					}
					"kcword" => {
						if( !clsave.bis("poczatek_kcword") )	{
							clsave.bset("poczatek_kcword");
							.mplay("ania11");
						} else .gmunlockall;
					}
					"kcprinter" => {
						if( !clsave.bis("kcsys_print") )	{
							clsave.bset("kcsys_print");
							.newanima("anwinprinter", "win_print.pyz", 2000);
							.lock=(1);
							igmstate = 8;
							.timer = ("timprint", 5000, func {
								anwinprinter.hide;
								<GAME>.mshow("print");
								<GAME>.mexit2(1500);
								} );
							timprint.play;
						}
					}
					"kcssh" => {
						.mplay("ania17");
					}
					? => ;
				}
			}
			? => ;
		}
	}
	mexit	{	.mexit2(250);	}
	mexit2(int ile)	{
		igmstate = 0;
		.lock=(true);
		.timer = ("timstart", ile, "mgotogame" );
		timstart.play;
	}
	munlockhelp	{	grhelps.eval("unlock");	}
	mlockhelp		{	grhelps.eval("lock");	}
	mplay(string s)	{
		.lock = (1);
		.cbplay(s);
	}
	mgotogame	{
		clsave.set("iconstate", iconstate);
		if( clsave.get("game_day")=="5" )
			.gotoadv("adinania","gameadinania2");
		else	.gotoadv("adinania","gameadinania0");
	}
	mcheckshow(string s)	{	if( clsave.bis("kcsys_"+s) )	.mshow(s);	}
	mshow(string s)	{
		.newanima("an" + s, "win" + s + ".pyz", 20);
		string s2 = "but"+s;
		s = "an" + s;
		string sdesk = s + "desk";
		.copyanima(s, sdesk);
		<s+"desk">.setframe(1,0);
		new Button <s2>;
		<s2>.add(s);
		<s2>.add(sdesk);
		
		<s>	{
			.addmethod("isbutin", func { (@x,@y)
				@id = .framenr;
				.setframe(0,1);
				.isin(x,y,1,0);
				.setframe(0,id);
				} );
			.addmethod("butclick", func {
				if( igmstate!=0 )	return;
				if( slastact!=null )	{
					<slastact>.setframe(0,0);
				}
				slastact = this;
				.setframe(0,1);
				<GAME>.<this+"_click">;
				} );
			._msact;
			._msstd;
		};
		<sdesk>	{
			.Button_isin;
			._msact;
			._msstd;
			.addmethod("butclick", func {
				if( igmstate!=0 )	return;
				<GAME>.<this->strsubes("desk")+"_click">;	
				} );
		};
		if( slastact==s )	<s>.setframe(0, 1);
		
		grwinbut.add(s);
		grdesk.add(sdesk);
	}
	_msact	{	.addmethod("butmoveon", func {	bsms.setact;	} );	}
	_msstd	{	.addmethod("butmoveoff", func {	bsms.setstd;	} );	}
	_msact2	{	.addmethod("butmoveon", func {	bsms.setact; .setframe(-1,1);	} );	}
	_msstd2	{	.addmethod("butmoveoff", func {	bsms.setstd; .setframe(-1,0);	} );	}
	mhelps(int ile)	{
		if( .hasvar("ihelpfont") )	.delhelps;
		new int ihelpfont = 14;
		new string shelpfont = .stdfont(ihelpfont);
		string s, string s2;
		new gmobjvec grhpdel;
		for( int i=1; i<=ile; i++ )	{
			s = "anbh" + i;
			.newanima(s, "help"+i+".pyz", 20);
			grhpdel.add(s);
			<s> (i) { (@id)
				new int ibut = id;
				.Button_isin;
				._msact;
				._msstd;
				.addmethod("butclick", func {
					if( <GAME>.hasvar("imgh") )	<GAME>.delhelp;
					if( igmstate!=0 || .cisplaying)	return;
					igmstate = 2;
					//.lock=(true);
					.mlockhelp;
					<GAME>.mhelp(ibut);
					} );
			};
			s2 = "buth" + i;
			new Button <s2>;
			<s2>.add(s);
			grhelps.add(s2);
		}
	}
	delhelps	{
		if( .hasvar("imgh") )	.delhelp;
		grhelps.deleteallgmobj;
		grhelps.free;
		grhpdel.deleteallgm;
		delete grhpdel;
		delete ihelpfont;
		delete <shelpfont>;
		delete shelpfont;
	}
	mhelp(int id)	{
		ihelp = id;
		
		id = dbhp.findbyrow( subepizod + "_" + id);
		new img imgh;
		imgh.create( 400, 20 + (ihelpfont+4)*(dbhp.getcolsno(id)-1) , .grey(240), 240 );
		imgh.setpos( 380, <"anbh"+ihelp>.getpy - 10 );
		imgh.setz(1000);
		new gmimgvec grth;
		string s;
		for( int i=1; i<dbhp.getcolsno(id); i++ )	{
			s = "txth"+i;
			.newtext(s, dbhp.get(id,i), shelpfont, .grey(20) );
			<s>.setpos(0, (ihelpfont+4)*(i-1) );
			<s>.setz(1010);
			grth.add(s);
		}
		grth.move( imgh.getpx+10, imgh.getpy + 10 );
		
		if( engine.varexist("sndh"+ihelp) )
			.cbplay("sndh" + ihelp);
	}
	delhelp	{
		delete imgh;
		grth.deleteallgm;
		delete grth;
	}
	mouse_lclick	{
		match( igmstate )	{
			0 => .cactsndstop(true);
			1 => ;
			2 => igmstate = 3;
			3 => {
				igmstate = 0;
				.delhelp;
				.cactsndstop(false);
				//.lock = (false);
				.munlockhelp;
			}
			4 => igmstate = 0;
			5 => ;	// moving ftp
			//? => .cactsndstop(true);
			? => ;
		}
	}
	/*************************** sygnaly **************************/
	mwinexit	{
		.cactsndstop(false);
		.newanima("anwinexit", "closewin.pyz", 110);
		anwinexit {
			.Button_isin;
			._msact2;
			._msstd2;
			.addmethod("butclick", func {
				if( igmstate!=0 )	return;
				.lock = (1);
				.setframe(0,2);
				<GAME> {
					if( !.hasvar("timwinclose") )	{
						.timer = ("timwinclose", 100, func {	<GAME> {
							.deletegmobj("butclosewin");
							delete anwinexit;
							grwindow.deleteallgm;
							delete grwindow;
							grgmwin.deleteallgmobj;
							delete grgmwin;
							.cactsndstop(true);
							.lock=(0);
							}; } );
					}
					timwinclose.play;
				};
				} );
		};
		new Button butclosewin;
		butclosewin.add("anwinexit");
	}
	_win_click(string swin)	{
		.lock = (1);
		bsms.setstd;
		.mwinexit;
		.newanima("anwindow", "win_"+swin+".pyz", 100);
		new gmobjvec grwindow;
		new gmobjvec grgmwin;
		grwindow.add("anwindow");
		igmstate = 4;
	}
	/*************************** obsluga ftp **********************************/
	anftp_click	{
		._win_click("ftp");
		match(subepizod)	{
			"kcifconfig" => {
				new string sftpfont = .stdfont(20);
				.newtext("txtwinftp", "Connection error", sftpfont, .grey(20) );
				txtwinftp.setpos( anwindow.getpx + 30, anwindow.getpy + 90 );
				txtwinftp.setz( anwindow.getz + 10 );
				grwindow.addlist(A, "txtwinftp", "sftpfont", sftpfont );
				.cbplay("ania4");
			}
			"kcword", "kcssh", "kcssh2", "kcssh3", "kcssh4" => {
				.copyanima("anwindow", "_anword");
				_anword.setframe(1,0);
				.copyanima("anwindow", "_ancalc");
				_ancalc.setframe(1,1);
				//new ConImgMover cftp;
				new DelayMover cftp;
				cftp.setclickrel(false);
				cftp.unlock;
				new gmimgvec grftp;
				grftp.addlist(A, "_anword", "_ancalc");
				.copyanima("anwindow", "_anword2");
				_anword2.setframe(2,0);
				_anword2.hide;
				.copyanima("anwindow", "_ancalc2");
				_ancalc2.setframe(2,1);
				_ancalc2.hide;
				grwindow.addlist(A,"_anword", "_ancalc", "grftp", "_anword2", "_ancalc2");
				grgmwin.add("cftp");
				if( subepizod=="kcword" )	{
					if( !clsave.bis("a_zobaczyla_ftp") )	{
						clsave.bset("a_zobaczyla_ftp");
						.cbplay("ania12");
					}
				}
			}
			? => ;
		}
	}
	cftp_GET	{
		if( grftp.isin(mouse.getpos,1,0) )	{
			@s = grftp.getsfound;
			s+=2;
			<s>.show;
			cftp.mssetobj(s);
			igmstate = 5;
		}
	}
	cftp_PUT	{
		@s = cftp.getfree;
		<s>.hide;
		<s>.setpos(0,0);
		igmstate = 0;
		if( !anwindow.isin(mouse.getpos, 1, 0) )	{
			igmstate = 4;
			s = ( <s>.framenr ? "calc" : "word");
			if( clsave.bis("kcsys_"+s) )	.cbplay("ania14");
			else {
				clsave.bset("kcsys_"+s);
				<GAME>.mshow(s);
				<"but"+s>.lock;
				.cbplay("ania_"+s);
			}
		}
	}
	/*************************** obsluga konsoli **********************************/
	ancon_click	{
		._win_click("konsola");
		.munlockhelp;
		
		new @stdmono12 = .stdmono(12);
		new @cols = 25;
		string s;
		new int xwin = anwindow.getpx + 30;
		new int ywin = anwinexit.getpy + 68;
		for( int i=0; i<cols; i++)	{
			s = "txti" + i;
			new text <s>;
			<s>.setfont(stdmono12);
			<s>.setpos(xwin,ywin+i*12);
			<s>.createtxt(.white);
			<s>.setz( anwindow.getz + 10 );
			grwindow.add(s);
		}
		new @column = 0;
		new @ilimit = 70;
		new @Dir = "~";
		new @spasswd = "";
		new @suser = "student";
		new @shost = "kchost";
		
		new string Code;
		Lexer::setas("Code");
		Code.consts = (A, "../", "./","/", "..", ".", "|", ">", ">>", "<" , "<<","'", "@", ":");
		new vector vec1;
		vec1.type("string");
		
		new ConTextTyper ttp(stdmono12, 12, .white, "at0 !@#$%^&*()-=_+{}|\\[];':\",./<>?", ilimit);
		ttp.onenter(GAME, "mcheckcon");
		ttp.setz( anwindow.getz + 10 );
		
		grwindow.addlist(A, "stdmono12", stdmono12, "cols", "column", "ilimit", "Code", "vec1", "Dir", "suser", "shost", "xwin", "ywin", "spasswd");
		grgmwin.add("ttp");
		
		.mready;
		
		if( subepizod=="kcssh" ) clsave.bset("a_poznala_konsole");
		else if( !clsave.bis("a_poznala_konsole") )	{
			clsave.bset("a_poznala_konsole");
			.cbplay("ania5");
		}
	}
	mpos(int id)	{
		ttp.txtset("");
		ttp.setpos(xwin + <"txti"+id>.getw, ywin+id*12);
		ttp.limit = ( ilimit-<"txti"+id>.get->length );
	}
	menable	{	.mpos(column);	ttp.unlock; ttp.enable;	}
	mout(string s)	{	<"txti"+column>.txtset(s);	}
	moutln(string s)	{	.mout(s); .mnewline;	}
	mrewind	{
		for( int i=0; i<cols-1; i++)	<"txti"+i>.txtset( <"txti"+(i+1)>.get );
		<"txti"+(cols-1)>.txtset("");
	}
	mclear	{
		grti.txtreset;
		column = 0;
	}
	mnewline	{
		column++;
		if( column==cols )	{
			column--;
			.mrewind;
		}
	}
	//ttp_ontype	{	fxtype2.playif;	}
	mread	{
		Code = ttp.get;
		Code.id = (0);
		Code.clear;
	}
	bool mcode(string s)	{
		if( Code.length )	{
			Code.expects(s, " ", true);
		} else	{
			false;
		}
	}
	mput	{
		@s = "txti"+column;
		.mread;
		<s>.txtset( <s>.get + Code );
		ttp.txtset("");
		.mnewline;
	}
	mready	{	.mout(suser + "@" + shost+":"+Dir+"$ ");	.menable;	}
	mgocon	{	.mput;	.mready;	}
	mcplay(string s)	{	ttp.enable;	.cbplay(s);	}
	mcheckcon	{
		benter = true;
		.mread;
		match( subepizod )	{
			"kcifconfig" => {
				if( .mcode("$alpha ifconfig") )	{
					.mput;
					.moutln("eth0      Link encap:Ethernet  HWaddr 00:10:A4:78:85:80  ");
					.moutln("          UP BROADCAST MULTICAST  MTU:1500  Metric:1");
					.moutln("          RX packets:0 errors:0 dropped:0 overruns:0 frame:0");
					.moutln("          TX packets:1 errors:0 dropped:0 overruns:1 carrier:0");
					.moutln("          collisions:0 txqueuelen:100 ");
					.moutln("          RX bytes:0 (0.0 b)  TX bytes:342 (342.0 b)");
					.moutln("          Interrupt:11 Base address:0xb000 ");
					.moutln("");
					.moutln("lo        Link encap:Local Loopback  ");
					.moutln("          inet addr:127.0.0.1  Mask:255.0.0.0");
					.moutln("          UP LOOPBACK RUNNING  MTU:16436  Metric:1");
					.moutln("          RX packets:44 errors:0 dropped:0 overruns:0 frame:0");
					.moutln("          TX packets:44 errors:0 dropped:0 overruns:0 carrier:0");
					.moutln("          collisions:0 txqueuelen:0 ");
					.moutln("          RX bytes:2808 (2.7 KiB)  TX bytes:2808 (2.7 KiB)");
					.moutln("");
					.mconplay("ania9");
				} else {
					.mnocon;
				}
			}
			"kcword", "kcprinter" => .mgocon;
			"kcssh" => {
				if( iconstate==0 )	{
					if( .mcode("$alpha ssh $alpha shop $const @ $alpha kcentral") )	{
						.mput;
						.moutln("shop@kcentral's password: ");
						iconstate = 1;
						spasswd = "";
					} else .mnocon;
				}
			}
// kcssh2_1|Wpisz: ls|ls - list directory contents - wywietla zawarto katalogu
// kcssh3_1|Aby si wylogowa wpisz: exit
// kcssh3_2|Skopiuj plik Purchase_2008_08_02.cal na swj dysk. Uyj programu scp i dokadnej skadni:|scp login@host:path/Purchase_2008_08_02.cal .|login: shop|host: kcentral|path: .|passwd: io2pb6ku
			"kcssh2" => {
				if( .mcode("$alpha ls") )	{
					.mput;
					.moutln("Purchase_2008_01_12.cal  Purchase_2008_06_08.cal");
					.moutln("Purchase_2008_01_15.cal  Purchase_2008_06_26.cal");
					.moutln("Purchase_2008_03_05.cal  Purchase_2008_07_21.cal");
					.moutln("Purchase_2008_04_01.cal  Purchase_2008_08_02.cal");
					iconstate = 2;
					.mconplay("zak8");
				} else {
					.mnocon;
				}
			}
			"kcssh3" => {
				if( iconstate==2 )	{
					if( .mcode("$alpha exit") )	{
						.mput;
						.moutln("Connection to kcentral closed.");
						Dir = "~";
						suser = "student";
						shost = "kchost";
						.mgocon;
						iconstate = 3;
						.mconunlock;
					} else {
						.mnocon;
					}
				} else if (iconstate==3)	{
					//scp login@host:path/Purchase_2008_08_02.cal .
					if( .mcode("$alpha scp $alpha shop $const @ $alpha kcentral $const : $const ./ $alpha Purchase_2008_08_02 $const . $alpha cal $const .") )	{
						.mput;
						.moutln("shop@kcentral's password: ");
						iconstate = 4;
						spasswd = "";
					} else {
						.mnocon;
					}
				}
			}
			? => ;
		}
	}
	key_down	{
		if( benter )	{
			benter = false;
			return;
		}
		if (iconstate==1 || iconstate==4)	{
			if( .mreadpas )	{
				if( spasswd == "io2pb6ku" )	{
					if( iconstate==1)	{
						.moutln("Last login: 2008.08.02");
						Dir = "~] ";
						suser = "[shop";
						shost = "kcentral";
						.mgocon;
						.mconplay("ania18");
					} else {
						.moutln("Purchase_2008_08_02.cal              100% 4355     4.3KB/s   00:00");
						.mgocon;
						.mconplay("zak12");
					}
				} else {
					.moutln("Invalid password");
					.mgocon;
					.mcplay("zak6");
				}
				if( iconstate==1 )		iconstate = 0;
				else iconstate = 3;
			}
		}
	}
	bool mreadpas	{
		if( keyboard.iskey("enter") )	{
			.mnewline;
			return true;
		} else if( keyboard.iskey("backspace")) {
			spasswd = spasswd.strsube(1);
		} else spasswd += keyboard.getkey;
		false;
	}
	mconunlock	{
		.munlockhelp;
		butclosewin.unlock;
		ttp.enable;
		igmstate = 0;
	}
	mconplay(string s)	{
		.mready;
		ttp.disable;
		butclosewin.lock;
		igmstate = 1;
		.mlockhelp;
		.cbplay(s);
	}
	mnocon	{
		if( Code.length ) .mcplay("ania7");
		else .mgocon;
	}
	mnotes	{	<GAME>	{
		.newanima("annotes", "$scripts/common/notes.pyz", 2000 );
		.copyanima("annotes", "annottop");
		annottop.anplayfin(1, func {
			.cycle = ("timtop", func {
				annotes.move(-8,6);
				annottop.move(-8,6);
				if( annotes.getex > 350 )	.play;
				else {	<GAME> {
					new ConTextTyper ttmac("fntnotes",ifntnotes, .notescol, "at0 !@#$%^&*()-=_+{}|\\[];':\",./<>?", inoteslimit);
					ttmac.setpos( annotes.getpx+inotesx, annotes.getpy+inotesy);
					ttmac.enable;
					ttmac.setz(2010);
					ttmac.onenter( GAME, func {
						string s = ttmac.get;
						s.clear;
						if( s.length==0 ) return;
						
						igmstate = 1;
						.mlockhelp;
						claskexit.ask( "ania10", "zak3", "zak4", func {	<GAME> {
							new db dbmac;
							dbmac.dbbuild(A, ttmac.get, 1);
							dbmac.setseparator("|");
							dbmac.save("lang/anotes_MAC.db");
							clsave.set("anotes_text", "MAC");
							string s = ttmac.get->to_u;
							s.clear;
							s.change(" ", "");
							clsave.set("prawidlowy_MAC", s=="00:10:A4:78:85:80");
							
							.mgotogame;
							}; } , func {
								igmstate = 0;
								.munlockhelp;
								ttmac.enable;
							} );
						} );
					igmstate = 0;
					.munlockhelp;
				}; }
				} );
			timtop.play;
			} );
	}; }
	/*********************** wlaczenie worda *****************************/
	anword_click	{
		match( subepizod )	{
			"kcword" => {
				igmstate = 4;
				if( clsave.bis("kcsys_print") )	{
					gameapi.play("Word");
				} else .cbplay("ania15");
			}
			? => ;
		}
	}
	/*********************** calc *****************************/
	ancalc_click	{
		match( subepizod )	{
			"kcssh4" => gameapi.play("Calc");
			? => {	igmstate = 4;
				.cbplay("ania16");
			}
		}
	}
}
game Word : Computro	{
	init	{
		Computro::init("word");
		
		sgmlastscene = "Word";
		
		.img = ("bkg.pyz");
		
		new Buttons buts("buts.pyz");
		buts	{
			.mgetbut("bold");
			.mgetbut("italic");
			.mgetbut("left");
			.mgetbut("center");
			.mgetbut("right");
			<grbuts.getsac("print")>.addtogamevars("anprint");
			.lock;
		};
		
		new classplacepointer2 clp;
		
		.sounds = (A,
			":zak1", "Aniu przeskanowaem ci wzr podania ale nie umiem go wypeni", func { clp.showob("imgtxt", "ll"); .cbplay("zak2");	},
			":zak2", "Przepisz tutaj podanie i poprawnie je wypenij", func { clp.show(<sfirsthelp>.getpx+<sfirsthelp>.getw/2, <sfirsthelp>.getpy, "dd"); .cbplay("zak3");	},
			":zak3", "Klikaj na te znaki zapytania eby przeczyta jak dokadnie napisa kad lini tekstu", func { clp.showob("anprint", "lu"); .cbplay("zak4"); },
			":zak4", "Kiedy podanie bdzie wypenione poprawnie wydrukuj je", func { clp.showob("anbold", "ru"); .cbplay("zak5"); },
			":zak5", "Wszystkie opcje takie jak pogrubienie nachylenie czy zmiana rozmiaru tekstu znajduj si tutaj", func { clp.stoph; .mstart; },
			":zak_err", "Nie moemy drukowa; W tej linii jest bd", func { <GAME>.vardel("imger"); .mstart; },
			":zak_ok", "Super dokument idealnie skopiowany; Pirania nie powinna si czepia; Ustaw jeszcze kilka parametrw i drukujemy", func { /* buts2.unlock; */; },
			":zak_quit", "Najpierw napiszmy podanie", null
			);
		
		new font fnital;
		fnital.load( sgmfontitalic, 36 );
		new font fnbold;
		fnbold.load(sgmfontmonobold, 36);
		.newtext("txtitalic", "I", "fnital", .black);
		.newtext("txtbold", "B", "fnbold", .black);
		txtitalic.setpos( anitalic.getcx-txtitalic.getw/2, anitalic.getcy-txtitalic.geth/2 );
		txtbold.setpos( anbold.getcx - txtbold.getw/2, anbold.getcy-txtbold.geth/2 );
		txtitalic.setz(10);
		txtbold.setz(10);
		
		new font fnsize;
		new int ifontsize = 10;
		new string senumfont = .stdfont(10);
		.mfontsize(0);
		
		new img imgtxt	{
			.create(273, 390, .grey(242), 255);
			.setpos( 60, 140 );
			.setz(5);
			new img im1;
			im1.create(.getw, 1, .grey(192), 240);
			im1.setpos(.getpx, .getpy);
			.blit("im1");
			im1.move(0, .geth-im1.geth);
			.blit("im1");
			im1.create(1, .geth, .grey(192), 240);
			im1.setpos(.getpx, .getpy);
			.blit("im1");
			im1.move(.getw-im1.getw, 0);
			.blit("im1");
			delete im1;
		};
		new img imszablon;
		imszablon.copy("imgtxt");
		imszablon.setpos( iResX - imszablon.getw - imgtxt.getpx, imgtxt.getpy );
		new int ikartax = 90;
		new int ikartay = 170;
		new int ienumpos = 15;
		new string schars = "a0 -.,:";
		new int idty = 3;
		new TextBoxTyper ttt("fnsize", ifontsize, 0.6*ifontsize, .black, schars, ikartax,ikartay, 217,310, idty);
		ttt.cut(17);
		ttt.setz(20);
		ttt.enablemove = (false);
		.menum;
		
		string s;
		for( int i=0; i<ttt.Rows; i++)	{
			s = "fntt_" + i;
			new font <s>;
			new int <"i" + s> = ifontsize;
			<s>.load( sgmfontmono, ifontsize );
			<s> {
				.vars2(A,"bold", 0, "italic", 0);
			};
			ttt.settyper( i, s, ifontsize, 0.6*ifontsize, .black, schars, "left");
		}
		
		.mfontstd;
		.mdir("left");
		
		.lang_db("dbsz", "szablon");
		int i[3], string s[3];
		new font fntp;
		new gmimgvec grel;
		new gmimgvec grhelps;
		new string sfirsthelp = null;
		int x = ikartax - imgtxt.getpx + imszablon.getpx;
		int y = ikartay;
		for( i = 0; dbsz.get(i,0)!="<expect>"; i++ )	{
			s2 = "txen"+i;
			.newtext(s2, ""+(i+1)+":", senumfont, .grey(24));
			<s2>.setpos(x-<s2>.getw-ienumpos, y);
			<s2>.setz(40);
			if( dbsz.getcolsno(i)>1) {
				s0 = dbsz.get(i,1);
				i1 = s0;	// sczytaj rozmiar
				if( s0.contains("b") ) fntp.load( sgmfontmonobold, i1 );
				else if (s0.contains("i") ) fntp.load( sgmfontitalic, i1 );
				else fntp.load( sgmfontmono, i1);
				grel.free;
				i2 = 0;
				for( i0 = 2; i0<dbsz.getcolsno(i); i0++)	{
					s1 = dbsz.get(i,i0);
					i0++;
					s = "tx"+i+"_"+i0;
					match(s1)	{
						"t", "x" => {
							.newtext(s, dbsz.get(i, i0), "fntp", s1=="t" ? .black : .blue);
							<s>.setpos(x+i2, y);
							i2 += <s>.getw;
							<s>.setz(30);
							grel.add(s);
						}
						"op" => {
							s1 = "txh"+i;
							.newtext(s1, dbsz.get(i, i0), "fntp", .white);
							<s1>.setpos( <s2>.getpx+5, y );
							if( <s1>.getex > iResX-20 )
								<s1>.setpos( iResX-<s1>.getw-20, y );
							<s1> {
								.setz(100);
								new img imbg;
								imbg.create( .getw+10, .geth+2, .red, 222 );
								imbg.setpos( .getpx-5, .getpy-1 );
								imbg.setz(90);
								imbg.hide;
								.hide;
							};
							s1 += "h";
							if( sfirsthelp==null ) sfirsthelp=s1;
							.newtext( s1, "?", "fntp", .white );
							<s1>.setpos( <s2>.getex+2, y );
							<s1> {
								.setz(80);
								new img imbg;
								imbg.create( .getw+2, .geth+2, .red, 222 );
								imbg.setz(40);
								imbg.setpos( .getpx-1, .getpy-1 );
							};
							grhelps.add(s1);
						}
						? => ;
					}
				}
				if( s0.contains("c") )	grel.move( (ttt.W - i2)/2, 0 );
				else if (s0.contains("r") ) grel.move( ttt.W - i2, 0 );
				y += i1 + idty;
			} else {
				y+=ifontsize + idty;
			}
		}
		// podpowiedzi: <sdb>.findbyrow(sfrom)+1
		i0 = 0;
		i1 = 0;
		new gmimgvec grpod;
		i2 = 0;
		@ipodpo = 16;
		@spodpofont = .stdfont(ipodpo);
		for( i=dbsz.findbyrow("<podp>")+1; i<dbsz.getrowsno; i++)	{
			s = "txpod"+i;
			.newtext(s, dbsz.get(i, 0), spodpofont, .grey(32) );
			<s>.setz(200);
			<s>.move(0, i2*ipodpo);
			i2++;
			if( <s>.getw > i0 ) i0 = <s>.getw;
			i1+=<s>.geth;
			grpod.add(s);
		}
		new img imgpod;
		imgpod.create( i0+30, i1+10, .grey(244), 222 );
		grpod.move( (iResX-i0)/2, iResY-i1-20 );
		imgpod.setpos( <grpod.first>.getpx - 15, <grpod.first>.getpy - 5 );
		imgpod.setz(190);
		imgpod.imgborders(1, .grey(23), 228);
		
		igmstate = 0;
		.cbplay("zak1");
	}
	mstart	{
		ttt.enable;
		buts.unlock;
		igmstate = 1;
	}
	menum	{
		int dx = ienumpos;
		string s0;
		if( !.hasvar("gren") )	{
			new gmimgvec gren;
			for( int i=0; i<ttt.Rows; i++)	{
				s0 = "txte"+i;
				new text <s0>;
				gren.add(s0);
				<s0>.setz(20);
				<s0>.setfont(senumfont);
				<s0>.txtsetcol(""+(i+1)+":", .grey(24));
			}
		}
		for( int i =0; i<gren.size; i++)	{
			s0 = gren.get(i);
			<s0>.setpos(ikartax-<s0>.getw-dx, ttt.idpy(i));
		}
	}
	//string mgetdir	{	if( ancenter.isvisible ) "center"; else if (anright.isvisible ) "right"; else "left"; }
	string mgetdir	{	ttt { <.actual>.Sdir; }; }
	mupdate	{
		string s = "fntt_"+ttt.Row;
		int size = ["i"+s];
		ttt.settyper( ttt.Row, s, size, 0.6*size, .black, schars, .mgetdir);
	}
	ttt_activate	{
		<GAME>.mfontsize( <.actual>.iFontSize-ifontsize );
		<GAME>.mdir( <.actual>.Sdir );
		if( <"fntt_"+Row>.bold ) anbold.show; else anbold.hide;
		if( <"fntt_"+Row>.italic ) anitalic.show; else anitalic.hide;
		<"tt"+ Row>.enable;
	}
	ttact	{	ttt { <"tt"+ Row>.enable; }; }
	mfontsize(int id)	{
		id=.between(8, ifontsize+id, 32);
		
		string s;
		if( .hasvar("ttt") && 0.6*ttt.getact->length*id > ttt.W ) return;
		
		ifontsize = id;
		
		.vardelif("txtsize");
		fnsize.load(sgmfontmono, ifontsize);
		.newtext("txtsize", ifontsize, "fnsize", .black);
		txtsize.setpos( 453-txtsize.getw/2, 97-txtsize.geth/2 );
		txtsize.setz(10);
		
		if( .hasvar("ttt") )	{
			s = "fntt_"+ttt.Row;
			if( <s>.bold )	<s>.load(sgmfontmonobold, ifontsize);
			else if (<s>.italic )	<s>.load(sgmfontitalic, ifontsize);
			else <s>.load(sgmfontmono, ifontsize);
			<"i"+s> = ifontsize;
			.mupdate;
			.menum;
		}
	}
	mgetbut(string s)	{
		string s2 = "an"+s;
		.copyanima(grbuts.getsac(s), s2);
		<s2>.setframe(-1,1);
		<s2>.addtogamevars(s2);
	}
	mfontstd	{
		anbold.hide;
		anitalic.hide;
		<"fntt_"+ttt.Row>.bold = (false);
		<"fntt_"+ttt.Row>.italic = (false);
		.mfontsize(0);
	}
	mfontbold	{
		anbold.show;
		anitalic.hide;	
		<"fntt_"+ttt.Row>.bold = (true);
		.mfontsize(0);
	}
	mfontitalic	{
		anbold.hide;
		anitalic.show;
		<"fntt_"+ttt.Row>.italic = (true);
		.mfontsize(0);
	}
	mdir(string sdir)	{
		anleft.hide;	ancenter.hide;	anright.hide;
		<"an"+sdir>.show;
		if( ttt(sdir) {(@sdir) <.actual>.Sdir!=sdir; } )	{
			ttt (sdir) { (@sdir) <.actual>.Sdir = (sdir); };
			.mupdate;
			ttt.activateact;
		}
	}
	buts_lclick	{
		match(sobject)	{
			"up" => { <GAME>.mfontsize(1); .ttact;	}
			"down" => { <GAME>.mfontsize(-1); .ttact;	}
			"left", "right", "center" => <GAME>.mdir(sobject);
			"bold" => {
				if( anitalic.isvisible )
					<GAME>.mfontstd;
				if( anbold.isvisible ) <GAME>.mfontstd;
				else <GAME>.mfontbold;
				.ttact;
			}
			"italic" => {	if( anbold.isvisible )
					<GAME>.mfontstd;
				if( anitalic.isvisible ) <GAME>.mfontstd;
				else <GAME>.mfontitalic;
				.ttact;
			}
			"close" => .cbplay("zak_quit");
			"print" => {
				new vector vec1;
				vec1.type("string");
				string s[4];
				int i[4];
				igmstate = 3;
				buts.lock;
				ttt.disable;
				bool bleft;
				bool bright;
				for( int i=0; i<ttt.Rows; i++)	{
					s0 = ttt.getid(i);
					if( dbsz.getcolsno(i)==1 )	{
						s0.clear;
						if( s0!="" )	{
							.merror(i);
							delete vec1;
							return;
						}
					} else {
						s1 = dbsz.get(i,1);
						s2 = "fntt_" + i;
						s3 = .mttval(i, "Sdir");
						bright = s1.contains("r");
						bleft = !bright && !s1.contains("c");
						if( ["i"+s2]!=s1.getb(0,2) ||
							(s1.contains("b") && !<s2>.bold ) ||
							(s1.contains("i") && !<s2>.italic) ||
							(bright && s3!="right") ||
							(s1.contains("c") && s3!="center") ||
							(bleft && s3!="left")
							)	{
							.merror(i);
							delete vec1;
							return;
						}
						s1 = "";
						i2 = 0;
						if( bright )	{
							while(s0.getb(i2,1)==" ") {
								i2++;
								s1 = " " + s1;
							}
						}
						for( i0=2; dbsz.get(i,i0)!="op"; i0++ )	{
							s2 = dbsz.get(i,i0);
							i0++;
							match(s2)	{
								"t" => {
									s3 = dbsz.get(i,i0);
									if( s0.getb(i2, s3.length)==s3 )	{
										i2 += s3.length;
										s1 += s3;
									} else {
										.merror(i);
										delete vec1;
										return;
									}
								}
								"x" => {
									vec1.vecbuildfromstring( dbsz.get( dbsz.findbyrow( "e" + dbsz.get(i,0) ), 1 ), "," );
									i1 = 1;
									for( i3=0; i3< vec1.size; i3++)	{
										s3 = vec1.get(i3);
										if( s0.getb(i2, s3.length)==s3 && (i2+s3.length==s0.length || s0.getb(i2+s3.length,1)==" ") )	{
											i1 = 0;
											i2 += s3.length;
											s1 += s3;
										}
									}
									if(i1) {
										.merror(i);
										delete vec1;
										return;
									}
								}
								? => ;
							}
						}
						if( s0 != s1 )	{
							s3 = s0.strsubb(s1.length);
							s3.clear;
							if( !(bleft && s3=="") )	{		// same spacje z tylu i kierunek lewo
								.merror(i);
								delete vec1;
								return;
							}
						}
					}
				}
				delete vec1;
				igmstate = 5;
				// tmp
				.mfinish;
			}
			? => ;
		}
	}
	merror(int id)	{ <GAME> (id){(@id)
		new img imger;
		imger.create( .mttval(id, "W"), .mttval(id, "iFontSize"), .red, 192);
		imger.setpos( .mttval(id, "X"), .mttval(id, "Y") );
		imger.setz(imgtxt.getz);
		.cbplay("zak_err");
	}; }
	def mttval(int id, string sval)	{
		ttt (id, sval) { (@id, @sval) <"tt"+id>.<sval>; };
	}
	mshow	{
		.show;
		imbg.show;
	}
	mhide	{
		.hide;
		imbg.hide;
	}
	mhelp	{
		buts.lock;
		igmstate = 0;
		.cbplay("zak1");
	}
	mouse_lclick	{
		match( igmstate )	{
			0, 4 => .cactsndstop(true);
			1 => {
				if( grhelps.isin(mouse.getpos, 1, 0) )	{
					<grhelps.getsfound->strsube(1)>.mshow;
					igmstate = 2;
				}
			}
			2 => {
				<grhelps.getsfound->strsube(1)>.mhide;
				igmstate = 1;
			}
			3 => igmstate = 4;
			? => ;
		}
	}
	mfinish	{
		clsave.set("wydruk_podania", 1);
		.gotoadv("adinania","gameadinania0");
	}
}
game CShol : Computro	{
	init	{
		Computro::init("cshol");
		.imgs = (A, "bg.pyz", "giaro.pyz 10", "winc.pyz 10");
		.sounds = (A,
			":giaro1", "no i wanie id zobaczy tamten sprzt; Moe to jaka bdna dostawa bya", func { .winc(1); },
			":winc1", "Suchaj ja chyba wiem co to za czci; Pewnie chodzi o wyposaenie do pracowni; Zostaw to mnie", func { .giaro(2); },
			":giaro2", "Acha; Mylaem e to moe jaka pomyka", func { .winc(2); },
			":winc2", "Nie wszystko w porzdku ja si tym zajm", func { .giaro(3); },
			":giaro3", "Dobra dziki", func {
				mus.fadeout(1000);
				ccs.close( func { .gotoadv("adhol","gameadhol0"); }
				); }
			);
		ccs.enter( func {
			mus.playstr("plama.ogg -v 30");
			//.giaro(1);
			.winc(1);
		} );
	}
	giaro(int id)	{
		.cbplay("giaro"+id);
		angiaro.play("talk");
		anwinc.play("stand");
	}
	winc(int id)	{
		.cbplay("winc"+id);
		angiaro.play("stand");
		anwinc.play("talk");
	}
	mouse_lclick	{
		if( igmdebug ) .cactsndstop(true);
	}
}

game CSgim : Computro	{
	init	{
		Computro::init("csgim");
		.imgs = (A, "bkg.pyz", "asystent.pyz 10");
		anasystent.anplayfin(0, func {
			//sgmlastscene = "CSgim";
			.gotoadv("adgim","gameadgim2");
			} );
	}
}


game Biurkow : Computro	{
	init	{
		Computro::init("biurkow");
		advmouse.setstd;
		
		.sfxs=(A, "szuflada 60", "kluczyk 70", "getpuz 80", "putpuz 80", "wlaczkomp");
		//bkg.pyz  czek.pyz  dogim.pyz  ekran.pyz  els.pyz  pen.pyz  tablet.pyz
		.imgs = (A, "bkg.pyz", "czek.pyzH", "ekran.pyzH 10", "pen.pyzH 100", "tablet.pyzH 60", "kurs.pyzH 56", "dogimH.pyz 55", "powrotH.pyz 20");
		.copyanima("anczek", "anczek2");
		anczek2.setframe(-1,1);
		new gmimgvec gramka;
		"gramka" ..< "ramka.pyz";
		gramka.setz(58);
		new gmimgvec grels;
		"grels" .* "els.pyz";
		grels.setz(50);
		grels.hide;
/*<action>        zamek2	<action>        dogim	<action>        1jpg	<action>        2jpg	<action>        3jpg
<action>        4jpg	<action>        monitor	<action>        komp	<action>        zamek*/
		.withlist(A, "zamek", "zamek2", "komp", "monitor", "mshow");
		.msetz("monitor",5);
		.msetz("komp",5);
		//grels.remove(.mget("monitor"));
		grels.sortimgs;
		
		new bool bmaklucz = clsave.bis("zak_ma_kluczyk");
		new string smoved = null;
		new string smovac;
		new bool bjpg = true;
		new string mvjpg = null;
		new int imisjakarta = 0;
		new int imisjaplik = 0;
		
		// tmp
// 		bmaklucz = true;
		
		if( bmaklucz )	{
			new ConImgMover imov;
			new ConImgMover tmov;
			
			.newanima("anklucz", "$scripts/items/kluczw.pyz", 200);
			.mretklucz;
		} else {
			anpowrot.show;
			grels.add("anpowrot");
		}
		
		.sounds = (A,
			":zak1", "Zakluczone", null,
			":zak2", "Jaka karta wejciowa; Moe si przyda", "mdali",
			":zak3", "To mi wyglda na jakie wane dane; Skopiuj je do pamici", null,
			":zak4", "Doprowadz jeszcze wszystko do porzdku i zmykam", "porzadki"
			);
		
		.menable;
	}
	mdali	{	igmstate = 1;	}
	menable	{
		igmstate = 1;
		if( bmaklucz )	{
			imov.unlock;
			tmov.unlock;
		}
	}
	mretklucz	{
		fxputpuz.play;
		imov.free;
		anklucz.setframe(0, 0);
		anklucz.show;
		anklucz.setpos( (iResX-anklucz.getw)/2, iResY-anklucz.geth-5 );
		grels.add("anklucz");
	}
	mtakeklucz	{
		//_fxtakeitem.play;
		fxgetpuz.play;
		grels.remove("anklucz");
		anklucz.setframe(1, 0);
		imov.mssetobj("anklucz");
	}
	string mget(string s)	{	grels.getsac(s);	}
	mhide(string s)	{	<.mget(s)>.hide;	}
	mshow(string s)	{	<.mget(s)>.show;	}
	msetz(string s, int z)	{	<.mget(s)>.setz(z);	}
	bool mvis(string s)	{	<.mget(s)>.isvisible;	}
	mouse_move	{
		if( igmstate == 5 ) return;
		|int x, int y| = mouse.getpos;
		if( bmaklucz )	{
			if( igmstate == 4 )	{
				.movpen;
			} else if( grels.isin(x,y,0,1) )	{
				if( .mcopy )	{
					match(smovac)	{
						"zamek", "zamek2" => advmouse.setbut;
						"komp", "klucz" => 	if( <smoved>.framenr==0 )	advmouse.setexit;
						"tablet", "dogim" => if (<smoved>.isvisible && <smoved>.framenr==0 ) advmouse.setexit;
						"pen", "czek", "powrot" => advmouse.setexit;
						? => 	.mret;
					}
				}
			} else .mret;
		} else {
			if( grels.isin(x,y,1,1) )	{
				if( .mcopy )	{
					match(smovac)	{
						"zamek", "zamek2" => advmouse.setbut;
						"powrot" => advmouse.setexit;
						? => 	.mret;
					}
				}
			} else .mret;
		}
	}
	mcopy	{
		string s = grels.getsfound;
		if( smoved!=s )	{
			smoved = s;
			smovac = <smoved>.actionname;
			true;
		} else false;
	}
	mret	{
		if( smoved!=null )	{
			smoved = null;
			smovac = null;
			advmouse.setstd;
		}
	}
	putklucz {
		imov.free;
		match( smovac )	{
			"zamek" => {
				<smoved>.setframe(-1, 1);
				fxszuflada.play;
				if( antablet.framenr==0 )	{
					antablet.show;
					grels.add("antablet");
				}
				anklucz.hide;
			}
			"zamek2" => {
				fxszuflada.play;
				<smoved>.setframe(-1, 1);
				if( andogim.framenr==0 )	{
					andogim.show;
					grels.add("andogim");
					grels.sortimgs;
				}
				anklucz.hide;
			}
			? => .mretklucz;
		}
	}
	mpowrot(int id)	{
		if( id==0 && !imisjakarta) imisjakarta=1;
		else if (id==1 && !imisjaplik) imisjaplik=1;
		if( imisjakarta && imisjaplik )	{
			anpowrot.show;
			grels.add("anpowrot");
		}
	}
	puttablet	{
		imov.free;
		fxputpuz.play;
		match(smovac)	{
			"komp" => {
				antablet.setframe(-1,1);
				antablet.setpos(0, 0);
				anpen.show;
				grels.add("anpen");
			}
			? => {
				antablet.setpos(0, 0);
				grels.add("antablet");
			}
		}
	}
	mretpen	{
		fxputpuz.play;
		grels.remove("anczek");
		grels.add("anpen");
		imov.free;
		grels.sortimgs;
		igmstate = 1;
		anpen.setpos(0, 0);
	}
	movpen	{
		int x = anpen.getpx;
		int y = anpen.getey;
		if( anczek.isin(x,y,0,1) )	{
			x = anczek2.getpx + 2*(x-anczek.getpx);
			y = anczek2.getpy + 2*(y-anczek.getpy);
			ankurs.ansetbpos( x, y );
			if( bjpg && grels.isin(x,y,1,1) )	{
				@s = <grels.getsfound>.actionname;
				if( mvjpg!=s )	{
					mvjpg = s;
					match( s )	{
						"1jpg", "2jpg", "3jpg", "4jpg" => ankurs.setframe(-1,1);
						? => {
							mvjpg = null;
							ankurs.setframe(-1,0);
						}
					}
				}
			}
		}
	}
	mouse_lclick	{
		if( .cisplaying || igmstate==5) return;
		if(!bmaklucz)	{
			if( smoved != null )	{
				if( smovac == "powrot" ) .gotoadv("adrektor", "gameadrektor2");
				else .cbplay("zak1");
			}
		} else {
			if( igmstate == 2 ) {
				.putklucz;
				igmstate = 1;
			} else if (igmstate == 3)	{
				.puttablet;
				igmstate = 1;
			} else if (igmstate == 4)	{
				if( anekran.isvisible )	{
					int x = anpen.getpx;
					int y = anpen.getey;
					if( anczek.isin(x,y,0,1) )	{
						if( bjpg )	{
							if( mvjpg!=null )	{
								bjpg = false;
								<.mget(mvjpg)> {
									.setframe(-1,1);
									.setz(52);
								};
								if( mvjpg=="4jpg" )	{
									.cbplay("zak3");
									.mpowrot(1);
								}
							}
						} else {
							<.mget(mvjpg)> {
								.setframe(-1,0);
								.setz(50);
							};
							bjpg = true;
						}
					} else .mretpen;
				} else .mretpen;
			} else {
				match( smovac )	{
					"komp" => {
						if( <smoved>.framenr==0 )	{
							fxwlaczkomp.play;
							<smoved>.setframe(-1,1);
							anekran.show;
							ankurs.show;
							.withlist(A, "1jpg", "2jpg", "3jpg", "4jpg", "mshow");
						}
					}
					"zamek" => {
						if(<smoved>.framenr==1 )	{
							fxszuflada.play;
							if( antablet.framenr==0 ) {
								antablet.hide;
								grels.remove("antablet");
							}
							<smoved>.setframe(-1,0);
							.mretklucz;
						}
					}
					"zamek2" => {
						if(<smoved>.framenr==1 )	{
							fxszuflada.play;
							if( andogim.framenr==0 )	{
								andogim.hide;
								grels.remove("andogim");
							}
							<smoved>.setframe(-1,0);
							.mretklucz;
						}
					}
					"klucz" => {
						igmstate = 2;
						.mtakeklucz;
					}
					"dogim" => {
						.cbplay("zak2");
						andogim.hide;
						andogim.setframe(-1,1);
						grels.remove("andogim");
						.mpowrot(0);
					}
					"tablet" => {
						fxgetpuz.play;
						igmstate = 3;
						grels.remove("antablet");
						imov.mssetobj("antablet");
					}
					"pen" => {
						fxgetpuz.play;
						igmstate = 4;
						grels.add("anczek");
						grels.remove("anpen");
						imov.mssetobj("anpen");
						grels.sortimgs;
					}
					"powrot" => {
						igmstate = 5;
						clsave.bset("zak_end_rektor");
						.cbplay("zak4");
					}
					? => ;
				}
			}
		}
	}
	porzadki	{
		.gotoadv("adrektor", "gameadrektor2");
	}
}
new int oldcomputrocnt = 0;
game Oldkomp : Computro	{
	init	{
		Computro::init("oldkomp");
		advmouse.setstd;
// 		bkg.pyz  buton.pyz  karta.pyz  klawisze.pyz  on.pyz
		.imgs = (A,"bkg.pyz", "buton.pyz 20", "karta.pyzH 20", "on.pyzH 10", "powrot.pyz 30");
		.sfxs = (A, "wlaczkomp", "type2", "bgrwiatrak 20");
		new gmimgvec grkl;
		"grkl" .* "klawisze.pyz";
		grkl.hide;
		
		new bool bon = clsave.get("oldkomp_on");
		new string snumber = clsave.get("oldkomp_number");
		new int ikarta = clsave.get("oldkomp_karta");
		
		.monofont("fntscreen", 22);
		.newtext("txtnr", "", "fntscreen", .grey(222) );
		txtnr.setz(50);
		
		if( bon )	{
			anbuton.setframe(-1,1);
			.mwlacz;
			if( snumber!= null )	.putnumber;
		}
		if( ikarta==1 ) ankarta.show;
		
		new string smove = null;
		
		anpowrot.Button_std;
		anpowrot.addmethod("butclick", func { if( igmstate==1 ) .gotoadv("adgiaro", "gameadgiaro2"); } );
		new Button butret;
		butret.add("anpowrot");
		
		.sounds = (A,
			":zak1", "Znowu jaka karta wejciowa; Pamitam e czasami papa Giaro j wyciga", "mret",
			":zak2", "Szkoda e tylko cyfry mona podawa; Gdyby dostpne byy te literki mgbym na przykad wpisa sowo helikopter", "mret"
			);
		
		igmstate = 1;
	}
	mwlacz	{
		anon.show;
		bon = true;
		fxbgrwiatrak.playloop;
	}
	mwylacz	{
		fxbgrwiatrak.stop(false);
		anon.hide;
		bon = false;
	}
	putnumber	{
		clsave.set("oldkomp_number", snumber);
		if(snumber==null)	txtnr.txtset("");
		else txtnr.txtset(snumber);
		txtnr.setpos(325,143);
	}
	msetmove(string s)	{
		if( smove!=s )	{
			smove = s;
			advmouse.setbut;
		}
	}
	mouse_move	{
		if( igmstate == 1 )	{
			|int x, int y| = mouse.getpos;
			if( anbuton.isin(x,y,1,1) )	.msetmove("anbuton");
			else if( ankarta.isin(x,y,1,1) )	.msetmove("ankarta");
			else if ( grkl.isin(x,y,0,1) )	.msetmove(grkl.getsfound);
			else if (smove!=null)	{
				smove = null;
				advmouse.setstd;
			}
		}
	}
	mplay(string s)	{
		igmstate = 0;
		.cbplay(s);
	}
	mret	{	igmstate = 1;	}
	mouse_lclick	{
		if( igmstate == 1)	{
			match(smove)	{
				null => ;
				"anbuton" => {
					fxwlaczkomp.play;
					if(bon)	{
						clsave.set("oldkomp_on", false);
						snumber = null;
						.putnumber;
						.mwylacz;
						anbuton.setframe(-1,0);
					} else {
						.mwlacz;
						clsave.set("oldkomp_on", true);
						anbuton.setframe(-1,1);
					}
				}
				"ankarta" => {
					clsave.set("oldkomp_karta",2);
					ankarta.hide;
					smove = null;
					advmouse.setstd;
					_fxtakeitem.play;
				}
				? => {
					if( !bon ) return;
					@id = <smove>.actionnr(-1);
					fxtype2.play;
					if( id==10 )	{
						if( snumber=="1892" && ikarta==0)	{
							ikarta = 1;
							clsave.set("oldkomp_karta", 1);
							ankarta.show;
							.mplay("zak1");
						} else {
							oldcomputrocnt++;
							if( oldcomputrocnt==5 ) .mplay("zak2");
						}
						snumber = null;
						.putnumber;
					} else {
						if( snumber==null ) snumber = id;
						else if( snumber.length<10 ) {
							snumber+=id;
							//clsave.set("oldkomp_number", snumber);
						}
						.putnumber;
					}
				}
			}
		}
	}
}
game Biurkolu : Computro	{
	init	{
		Computro::init("biurkolu");
		advmouse.setstd;
// 		bkg.pyz  els.pyz  pacajek.pyz  szufla.pyz
		.imgs = (A, "bkg.pyz", "pacajek.pyzH 40", "szufla.pyzH 10");
		new gmimgvec grels;
		"grels" .* "els.pyz";
		grels.setz(50);
		grels.hide;
		new ConImgMover bmov;	// bateria, klucz
		//<action>        mouse	<action>        battery	<action>        szuflada	<action>        pacajek	<action>        kluczyk	<action>        powrot
		.withlist(A, "mouse", "pacajek", "mshow");
		.msetz("pacajek", 20);
		.sfxs=(A,"pacajek", "szuflada 60", "putpuz 60", "zamykaklapke 60", "odklucza 90", "zabawka 30", "klamka 50");
		fxpacajek.addmethod("onfinish", func {
			igmstate = 1;
			.mshow("kluczyk");
			anpacajek.play(2);
			fxzabawka.play;
			.mgomus;
			});
		
		new string smoved = null;
		new string smovac;
		new bool bmabaterie = false;
		
		.sounds = (A,
			":fel1", "O jaka gra komputerowa", "mwroc"
		);
		.mgomus;
	}
	mgomus	{		mus.playstr("bitewna.ogg -v 30 -p -l -fin 1000");	}
	string mget(string s)	{	grels.getsac(s);	}
	mhide(string s)	{	<.mget(s)>.hide;	}
	mshow(string s)	{	<.mget(s)>.show;	}
	msetz(string s, int z)	{	<.mget(s)>.setz(z);	}
	bool mvis(string s)	{	<.mget(s)>.isvisible;	}
	mwroc	{	igmstate = 1;	}
	mouse_move	{
		if( igmstate == 5 ) return;
		|int x, int y| = mouse.getpos;
		if( grels.isin(x,y,0,1) )	{
			if( .mcopy )	{
				match(smovac)	{
					"mouse", "szuflada", "pacajek" => advmouse.setbut;
					"battery" => if (<smoved>.isvisible) advmouse.setbut;
					"kluczyk", "piast", "powrot" => if (<smoved>.isvisible) advmouse.setexit;
					? => 	.mret;
				}
			}
		} else .mret;
	}
	mcopy	{
		string s = grels.getsfound;
		if( smoved!=s )	{
			smoved = s;
			smovac = <smoved>.actionname;
			true;
		} else false;
	}
	mret	{
		if( smoved!=null )	{
			smoved = null;
			smovac = null;
			advmouse.setstd;
		}
	}
	mplay(string s)	{	igmstate=5;		.cbplay(s);	}
	mouse_lclick	{
		if( igmstate == 5 ) return;
		@s;
		if( igmstate==3 )	{
			s = bmov.getfree;
			if( smovac=="pacajek" )	{
				fxzamykaklapke.play;
				<smoved>.hide;
				anpacajek.show;
				bmabaterie = true;
				<s>.hide;
			} else {
				<s>.setpos(0,0);
				grels.add(s);
				grels.sortimgs;
			}
			igmstate = 1;
		} else if (igmstate==4)	{
			s = bmov.getfree;
			if( smovac=="szuflada" )	{
				<s>.hide;
				grels.remove(smoved);
				igmstate = 5;
				fxodklucza.play;
				anszufla.anplayfin(0, func {
					igmstate = 1;
					.mshow("piast");
					.setframe(1,0);
					} );
			} else {
				<s>.setpos(0,0);
				grels.add(s);
				grels.sortimgs;
				igmstate = 1;
			}
		} else match( smovac )	{
			"mouse" => {
				fxputpuz.play;
				grels.remove(smoved);
				<smoved>.setframe(-1,1);
				.mshow("battery");
				.mret;
			}
			"battery" => if( <smoved>.isvisible ) {
				_fxtakeitem.play;
				igmstate = 3;
				grels.remove(smoved);
				bmov.mssetobj(smoved);
			}
			"pacajek" => if( bmabaterie ) {
				<smoved>.hide;
				grels.remove(smoved);
				anpacajek.play(1);
				fxpacajek.play;
				mus.fadeout(500);
				igmstate = 5;
			}
			"kluczyk" => if( <smoved>.isvisible )	{
				igmstate = 4;
				grels.remove(smoved);
				bmov.mssetobj(smoved);
			}
			"piast" => if( <smoved>.isvisible )	{
				_fxtakeitem.play;
				<smoved>.hide;
				grels.remove(smoved);
				.mshow("powrot");
				.mplay("fel1");
			}
			"powrot" => if (<smoved>.isvisible )	{
				.gotoadv("adinfel", "gameadinfel2");
			}
			"szuflada" => fxklamka.play;
			? => ;
		}
	}
}
game Czujnik : Computro	{
	init	{
		Computro::init("czujnik");
		advmouse.setstd;
		
// 		bkg.pyz  ekran.pyz  els.pyz  mruga.pyz
// 		kontrol3.pyz	kontrol2.pyz	kontrolka.pyz
		.imgs = (A, "bkg.pyz", "ekran.pyz 40", "mruga.pyzH 10", "kontrolka.pyzP 10", "kontrol2.pyzP 10", "kontrol3.pyzP 10");
		.copyanima("anekran", "anczuj");
		.sfxs = (A, "hydrant 70", "wyciagabezpiecznik 40", "wsadzabezpiecznik 40");
		new gmimgvec grkon;
		grkon.addlist(A, "ankontrolka", "ankontrol2", "ankontrol3");
		anczuj.setz(10);
		anczuj.setframe(1,0);
		new gmimgvec grels;
		"grels" .* "els.pyz";
		grels.setz(50);
		new ConImgMover bmov;	// item
		
		new string smoved = null;
		new string smovac;
		new int imoved;
		new int ilaststate = 1;
		
		modadvglob	{
			pcfeliks	{
				arPocket.addtogamevars("vpck");
				arPocketFile.addtogamevars("vpckfile");
			};
		};
		string s;
		new gmimgvec grpc;
		for( int i=0; i<vpck.size; i++)	{
			s = "an"+vpck.get(i);
			.newanima( s, "$scripts/items/"+vpckfile.get(i)+".pyz", 100);
			<s> (i){ (@id)
				new int posx = 50 + id*67;
				new int posy = 540;
				.addmethod("mpos", func { .setpos(posx, posy); } );
				.mpos;
			};
			grpc.add(s);
		}
		
		.sounds = (A,
			":fel1", "To mi wyglda na jakie centrum sterowania", "mwroc",
			":fel2", "Nie mog tego przekrci", "mwroc",
			":fel3", "Rne bezpieczniki; Ciekawe co oznaczaj liczby na prawym panelu", "mwroc",
			":fel4", "Uszkodzony bezpiecznik; Wezm go", func { .mwroc2; <GAME>.takeuszkodzony; },
			":fel5", "Nie mog go wyj; Za mocno siedzi", "mwroc",
			":fel6", "Prawidowy bezpiecznik", "mwroc2",
			":fel7", "Naprawiony bezpiecznik", "mwroc2",
			":fel8", "Powinno teraz dziaa", "mwroc"
		);
		
		.cycle = ("timcpos", func {
			|int x, int y| = mouse.getpos;
			if( y>=540 )	{
				if( x<50 && <grpc.first>.getpx<50 )	grpc.move(10,0);
				else if (x>750 && <grpc.last>.getex>750 ) grpc.move(-10,0);
			}
			.play;
			} );
		timcpos.play;
		
		.mrestore;
		
		igmstate = 1;
		if(!clsave.bis("wszedl_do_bazyC"))	{
			clsave.bset("wszedl_do_bazyC");
			.mplay("fel1");
		}
	}
	takeuszkodzony	{
		grpc.sortimgs;
		.newanima( "anbezpiecznik1", "$scripts/items/bezpiecznik1.pyz", 100);
		anbezpiecznik1 (grpc.size){ (@id)
			new int posx = 50 + id*67;
			new int posy = 540;
			.addmethod("mpos", func { .setpos(posx, posy); } );
			.mpos;
		};
		grpc.add("anbezpiecznik1");
		modadvglob	{
			pcfeliks.additem("bezpiecznik1", "bezpiecznik1");
		};
	}
	mrestore	{
		grels.show;
		.mhide("powrotb");
		anbkg.show;
		anekran.show;
		anczuj.show;
		grkon.nplay(-1);
		.mmrugaj;
	}
	mmrugaj	{
		if( anczuj.framenr==6 && !clsave.bis("bezpiecznik_naprawionyC") ) anmruga.play(-1);
	}
	string mget(string s)	{	grels.getsac(s);	}
	mhide(string s)	{	<.mget(s)>.hide;	}
	mshow(string s)	{	<.mget(s)>.show;	}
	msetz(string s, int z)	{	<.mget(s)>.setz(z);	}
	bool mvis(string s)	{	<.mget(s)>.isvisible;	}
	mwroc	{	igmstate = ilaststate;	}
	mwroc2	{	igmstate = ilaststate;	gmbezp.mwroc;	}
	mouse_move	{
		if( igmstate == 5) return;
		|int x, int y| = mouse.getpos;
		if( igmstate == 15 || (igmstate==3 && ilaststate==15)) {
			if (grpc.isin(x,y,1,1) )	{
				gmbezp.mzeruj;
				if( .mcopy2 )	advmouse.setbut;
			} else if (gmbezp.mbezp) {
				.mret;
			} else {
				gmbezp.mzeruj;
				.mret;
			}
		} else if(ilaststate!=15) {
			if( grels.isin(x,y,0,1) )	{
				if( .mcopy )	{
					match(smovac)	{
						"powrot" => advmouse.setexit;
						"powrotb" => ;
						? => advmouse.setbut;
					}
				}
			} else if (grpc.isin(x,y,1,1) )	{
				if( .mcopy2 )	advmouse.setbut;
			} else .mret;
		}
	}
	mcopy	{	._mcopy("grels"); imoved=1;	}
	mcopy2	{	._mcopy("grpc");	imoved=2;	}
	_mcopy(string sgrp)	{
		string s = <sgrp>.getsfound;
		if( smoved!=s )	{
			smoved = s;
			smovac = <smoved>.actionname;
			true;
		} else false;
	}
	mret	{
		if( smoved!=null )	{
			smoved = null;
			smovac = null;
			advmouse.setstd;
		}
		imoved = 0;
	}
	mplay(string s)	{
		ilaststate = igmstate;
		igmstate=5;		.cbplay(s);
	}
	mouse_lclick	{
		if( igmstate == 15 && imoved!=2 ) {
			if( <.mget("powrotb")>.isin(mouse.getpos,1,1) )	{
				.cactsndstop(false);
				.deletegmobj("gmbezp");
				.mrestore;
				ilaststate = 1;
				igmstate = 1;
			}
			return;
		} else if (igmstate==5 ) return;
		string s; int id;
		if( igmstate==3 )	{
			s = bmov.getfree;
			<s>.setframe(0,0);
			<s>.mpos;
			grpc.add(s);
			grpc.sortimgs;
			<s>.move(grpc.getpx, grpc.getpy);
			if( ilaststate!=15 && imoved==1 && s=="ankluczfr" )	{
				fxhydrant.play;
				id = smovac;
				if( id>=1 && id<=10 )	{
					if( <smoved>.framenr )	<smoved>.setframe(-1,0);
					else <smoved>.setframe(-1,1);
				}
				igmstate = ilaststate;
			} else if (ilaststate==15 && gmbezp.getsbezp!=null)	{
				igmstate = 15;
				gmbezp.mwyjmij(s);
			} else igmstate = ilaststate;
		} else if( imoved==1 ) match( smovac )	{
			"up" =>	.mczuj( anczuj.framenr-1 );
			"down" =>	.mczuj( anczuj.framenr+1 );
			"powrot" => {
				if( clsave.bis("bezpiecznik_naprawionyC") && !clsave.is("naprawil_czujnik",2) )	{
					clsave.set("naprawil_czujnik",1);
					modadvglob	{
						pcfeliks.pckremove("bezpiecznik2");
					};
				}
				.gotoadv("adghol", "gameadghol");
			}
			? => {
				id = smovac;
				if( id>=1 && id<=10 )	{
					if( <smoved>.framenr==0 )	.mplay("fel2");
					else {
						igmstate = 15;
						grels.hide;
						.mshow("powrotb");
						anbkg.hide;
						anekran.hide;
						anczuj.hide;
						anmruga.anhide;
						grkon.stop(false);
						grkon.hide;
						advmouse.setstd;
						new Bezpieczniki gmbezp;
					}
				}
			}
		} else if (imoved==2) {
			grpc.remove(smoved);
			<smoved>.setframe(1,0);
			bmov.mssetobj(smoved);
			ilaststate = igmstate;
			igmstate = 3;
		}
	}
	mczuj(int id)	{
		if( id>=0 && id<anczuj.nofframes(-1) )	{
			anczuj.setframe(-1,id);
			if( id==6 )	.mmrugaj;
			else anmruga.anhide;
		}
	}
}

class Bezpieczniki : LObjController	{
	init	{
		LObjController::init;
// 		bezp.pyz  bgb.pyz  bkg.pyz  ekran.pyz  els.pyz  mruga.pyz  panel.pyz
		.imgs = (A, "bezp.pyz 20", "bgb.pyz", "panel.pyz 10", "czek.pyzH 50");
		anczek.ancenterscreen;
		new int idczuj = smovac;
		int i, int j, int k, int i1;
		@s = "scripts/czujnik/bezpieczniki"+idczuj+".db";
		new db dbb;
		if( !engine.fileexist(s) )	{
			for(i=1; i<=10; i++)	{
				for( j=0; j<8; j++)	{
					i1 = dbb.addrow - 1;
					for(k=0; k<8; k++)	{
						dbb.add(i1,2->rand);
					}
				}
				if( i==7 )	dbb.set(6,6,1);	// uszkodzony
				dbb.save("scripts/czujnik/bezpieczniki"+i+".db");
				dbb.free;
			}
		}
		dbb.load(s);
		new gmimgvec grb;
		new vector vypos;
		vypos.beginadd("begin",119,166,211,256,333,378,426,471);
		.monofont("fnmon",20);
		for(i=0; i<8; i++)	{
			for( j=0; j<8; j++)	{
				s = "anb"+i+"_"+j;
				.copyanima("anbezp",s);
				<s> (j,vypos.get(i)) {	(@x,@y)
					new int xpos = 172+(.getw+1)*x;
					if( x>=4 ) xpos+=6;
					new int ypos = y;
				};
				<s>.setframe(0,dbb.get(i,j));
				<s> { .setpos(xpos, ypos); };
				grb.add(s);
			}
			s = "txtczuj"+i;
			//653
			.newtext(s, clstrdigit::bintohex(dbb.dbgetstringrow(i)), "fnmon", .grey(242) );
			<s>.setz(5);
			<s>.setpos(653,vypos.get(i));
		}
		if( idczuj==7 )	{
			anb6_6.setframe(0,0);
			if( !clsave.bis("bezpiecznik_naprawionyC") )	{
				if( clsave.is("bezpiecznik_wyjetyC",1) )	anb6_6.hide;
			} else {
				.mnapraw;
			}
		}
		anbezp.hide;
		new string sbezp = null;
		new string swyjety = null;
		
		if( !clsave.bis("otworzyl_czujnikC") )	{
			clsave.bset("otworzyl_czujnikC");
			.mplay("fel3");
		}
		
		.unlock;
	}
	mnapraw	{
		dbb.set(6,6,0);
		txtczuj6.txtset(clstrdigit::bintohex(dbb.dbgetstringrow(6)));
	}
	mwyjmij(string s)	{
		if( s=="anobcegi" && <sbezp>.isvisible)	{
			fxwyciagabezpiecznik.play;
			if( idczuj==7 && sbezp=="anb6_6" )	{
				if( clsave.bis("bezpiecznik_naprawionyC") )	{
					anczek.setframe( 3, 0 );
					.mplay("fel7");
				} else {
					clsave.set("bezpiecznik_wyjetyC",1);
					anczek.setframe(2,0);
					.mplay("fel4");
				}
			} else {
				anczek.setframe( <sbezp>.framenr, 0 );
				.mplay("fel6");
			}
			anczek.show;
			<sbezp>.hide;
			swyjety = sbezp;
		} else if (s=="anbezpiecznik2" && idczuj==7 && sbezp=="anb6_6")	{
			fxwsadzabezpiecznik.play;
			clsave.set("bezpiecznik_wyjetyC",0);
			clsave.bset("bezpiecznik_naprawionyC");
			anb6_6.show;
			.mnapraw;
			grpc.remove("anbezpiecznik2");
			anbezpiecznik2.hide;
			.mplay("fel8");
		} else igmstate=ilaststate;
	}
	getsbezp	{	sbezp;	}
	mwroc	{
		anczek.hide;
		if( swyjety=="anb6_6" )	{
			if( !clsave.is("bezpiecznik_wyjetyC",1) ) <swyjety>.show;
		} else <swyjety>.show;
	}
	onmousemove	{}
	onmouselclick	{
		if( igmstate==15 && sbezp!=null && <sbezp>.isvisible ) {
			advmouse.setstd;
			sbezp = null;
			.mplay("fel5");
		}
	}
	mzeruj	{	sbezp=null;	}
	mbezp	{
		|int x, int y|=mouse.getpos;
		if( grb.isin(x,y,0,1) )	{
			@s = grb.getsfound;
			if( sbezp!=s )	{
				sbezp = s;
				advmouse.setbut;
			}
		} else {
			sbezp = null;
			advmouse.setstd;
		}
		true;
	}
}
game Obrazrle : Computro	{
	init	{
		Computro::init("obrazrle");
		
		.imgs = (A, "bkg.pyz", "maski.pyz 5", "herbH.pyz");
		new img imgbkg;
		imgbkg.copy("anbkg");
		anbkg.hide;
		.copyanima("anmaski", "anblik");
		anblik.setframe(1,0);
		
		new vector vecorigin;
		new vector vecnew;
		
		new int ilesq = 8;
		new @sqw = anherb.getw/ilesq;
		new @sqh = anherb.geth/ilesq;
		int c[3];
		int dy, string s, int dx, int j, string s2, int id;
		int x = anherb.getpx;
		int y = anherb.getpy;
		new gmimgvec grels;
		new gmobjvec gcols;
		new int ifont = 12;
		new string stdfont12 = .stdfont(ifont);
		@wk = 80;
		@hk = 40;
		.newtext("txtcol", "", stdfont12, .grey(15));
		txtcol.hide;
		int pos, int oldpos=-1, int ile=0, int lastx;
		for( int i=0; i<ilesq; i++)	{
			dy = y+i*sqh;
			lastx = 140;
			for( j=0; j<ilesq; j++)	{
				dx = x+j*sqw;
				|c0,c1,c2| = anherb.getrgb(dx+5, dy+5);
				s = "img"+i+"_"+j;
				new img <s> {
					.vars2(A,"icol",-1,"iid",vecorigin.size);
				};
				vecorigin.add(c0);
				vecorigin.add(c1);
				vecorigin.add(c2);
				//<s>.create(sqw, sqh, c0,c1,c2,255);
				<s>.create(sqw, sqh, .grey(30),255);
				<s>.setpos(dx, dy);
				vecnew.add(-1);
				vecnew.add(-1);
				vecnew.add(-1);
				
				grels.add(s);
				
				s = ""+c0+"_"+c1+"_"+c2;
				pos = gcols.find(s);
				if( pos<0 )	{
					id = gcols.size;
					pos = id;
					gcols.add(s);
					s2 = "imgcol"+id;
					new img <s2>;
					<s2>.create(wk, hk, c0,c1,c2,255 );
					txtcol.txtset(id);
					txtcol.setpos( (wk-ifont)/2, (hk-ifont)/2 );
					<s2>.blit("txtcol");
					<s2>.setpos(143+id*(wk+8),122);
					<s2> (id,c0,c1,c2)	{ (@id,@c0,@c1,@c2)
						.vars2(A,"id",id,"R",c0,"G",c1,"B",c2);
						.addmethod("mcol", func { return R,G,B; } );
					};
				}
				if( pos==oldpos ) ile++;
				else if( oldpos!=-1 )	{
					lastx = .mblitcopies(ile,oldpos,lastx,dy);
					oldpos=pos;
					ile=1;
				} else {
					oldpos=pos;
					ile=1;
				}
			}
		}
		if( ile!=0 )	_ = .mblitcopies(ile,oldpos,lastx,dy);
		.sounds = (A,
			":fel1", "Jaki abstrakcyjny ten obraz; Wyglda jak ekran dotykowy", "mret",
			":fel2", "Gotowe; To chyba jaki herb", func {	<GAME> {
				new Buttons butend("powrot.pyz");
				}; }
			);
		.cbplay("fel1");
	}
	butend_lclick	{
		clsave.bset("obraz_zlozony");
		.gotoadv("adkaplica", "gameadkaplica");
	}
	mret	{	igmstate=1;	}
	int mblitcopies(int ile, int oldpos, int lastx, int dy)	{
		txtcol.txtset("("+ile+"*"+oldpos+") ");
		txtcol.setpos(lastx, dy);
		imgbkg.blit("txtcol");
		lastx + txtcol.getw+4;
	}
	mnext	{	.mset((icol+1)%gcols.size);	}
	mset(int id)	{
		icol = id;
		int c[3];
		|c0,c1,c2| = <"imgcol"+id>.mcol;
		.create(sqw, sqh, c0,c1,c2, 255);
		txtcol.setpos(.getcx-ifont/2, .getcy-ifont/2);
		txtcol.txtset(id);
		.blit("txtcol");
		vecnew.set(iid,c0);
		vecnew.set(iid+1,c1);
		vecnew.set(iid+2,c2);
		if( vecorigin.veceq("vecnew") )	{
			igmstate = 0;
			.cbplay("fel2");
		}
	}
	mouse_lclick	{
		if( igmstate!=1 ) return;
		if( grels.isin(mouse.getpos,1,1) )	{
			<grels.getsfound>.mnext;
		}
	}
	mouse_rclick	{
		if( igmdebug )	.cbplay("fel2");
	}
}

game Schody : Computro	{
	init	{
		Computro::init("schody");
// 		bkg.pyz  maska.pyz  plyta.pyz
		.imgs = (A, "bkg.pyz", "maska.pyzH 20", "plyta.pyz 10");
		.sfxs = (A, "otwiera_wlaz 50", "start_wlaz 50", "end_wlaz 50", "wciska_glaz 70");
		new img imgbkg;
		imgbkg.copy("anbkg");
		anbkg.hide;
		anplyta.addmethod("onendframe", func {
			grtxt.each( func { (@id)
				if( .getpy< anplyta.getcy-5 ) .move(2,2);
				else .move(2,-2);
				} );
			} );
		anplyta.addmethod("onfinish", func {
			anmaska.show;
			fxotwiera_wlaz.playloop;
			.cycle = ("timcyk", func {
				anplyta.move(2, 0);
				grtxt.move(2, 0);
				if( anplyta.getpx<642 )	{
					.play;
				} else {
					mus.fadeout(1500);
					fxend_wlaz.objplayfin( func {
						clsave.bset("schody_odsloniete");
						.gotoadv("adkaplica", "gameadkaplica");
						} );
				}
				} );
			timcyk.play;
			} );
		// ffc600 - zloty
		new font fn12;
		new int ifn12 = 12;
		fn12.load( sgmfontitalic, ifn12 );
		new font fn20;
		new int ifn20 = 20;
		fn20.load( sgmfontitalic, ifn20 );
		new gmimgvec grels;
		"grels" .* "klocki.pyz";
		grels.setz(30);
		.newtext("txtnr", "", "fn12", .mgold);
		new img imblit;
		/*new vector vecnr;
		if( !engine.fileexist("scripts/schody/numery.vec") )	{
			for( int i=0; i<grels.size; i++)	vecnr.add(30->rand);
			vecnr.save("scripts/schody/numery.vec");
		}
		vecnr.load("scripts/schody/numery.vec");*/
		grels.each( func { (@id)
				imblit.copy(this);
				txtnr.txtsetcol( id+1, .mshadow );
				txtnr.setpos( imblit.getcx - txtnr.getw/2 + 1, imblit.getcy - txtnr.geth/2 + 1 );
				imblit.blit("txtnr");
				txtnr.createtxt( .mgold );
				txtnr.move(-1,-1);
				imblit.blit("txtnr");
				
				.setframe(-1,1);
				imblit.copy(this);
				txtnr.move(2,2);
				txtnr.createtxt( .mshadow );
				imblit.blit("txtnr");
				txtnr.createtxt( .mgold );
				txtnr.move(-1,-1);
				imblit.blit("txtnr");
				.setframe(-1,0);
			} );
		imblit.hide;
		
		.lang_db("dbc", "tekst");
		new gmimgvec grtxt;
		.newtext("txtup", .mgetdb(0), "fn20", .mgold );
		txtup.setpos( anplyta.getcx - txtup.getw/2, anplyta.getpy + 17 );
		txtup.setz(12);
		.mtxtshadow("txtup");
		
		.newtext("txtdown", .mgetdb(1), "fn20", .mgold );
		txtdown.setpos( anplyta.getcx - txtdown.getw/2, anplyta.getey - 32 - txtdown.geth );
		txtdown.setz(12);
		.mtxtshadow("txtdown");
		
		.newtext("txtwzor", "-2", "fn20", .mgold );
		txtwzor.setz(12);
		txtwzor.setpos( anplyta.getpx+50, anplyta.getcy - txtwzor.geth/2 );
		.mtxtshadow("txtwzor");
		.newtext("txtpodp", "C-2 -> A", "fn12", .mgold );
		txtpodp.setz(12);
		txtpodp.setpos( anplyta.getpx+40, txtwzor.getpy+26 );
		._mtxtshadow("txtpodp","fn12");
		
		//133,97
		@s = "A";
		@y = 97;
		@x = anmaska.getpx - 30;
		.newtext("txtalf", "A", "fn12", .mgold );
		while(s.getbyte(0)<=BYTEZ)	{
			txtalf.txtsetcol( s, .mshadow );
			txtalf.setpos(x, y);
			imgbkg.blit("txtalf");
			txtalf.move(-1,-1);
			txtalf.createtxt( .mgold );
			imgbkg.blit("txtalf");
			y+= txtalf.geth + 2;
			s.setbyte( 0, s.getbyte(0)+1 );
		}
		txtalf.hide;
		
		.sounds = (A,
			":fel1", "Co tu mamy; Po lewej stronie alfabet; Na pycie jakie literki; Najpewniej zaszyfrowany napis", func { .cbplay("ania1"); },
			":ania1", "U gry i na dole kamienne przyciski", func { .cbplay("zak1"); },
			":zak1", "A na lewej czci pyty minus 2 i poniej jaki wzr; Kombinujcie ja jestem jeszcze za saby do rozgryzania algorytmw", func { igmstate = 1; }
			);
		.cbplay("fel1");
	}
	mtxtshadow(string stxt)	{	._mtxtshadow(stxt,"fn20");	}
	_mtxtshadow(string stxt, string sfont)	{
		@s = stxt+"s";
		.newtext(s, <stxt>.get, sfont, .mshadow );
		<s>.setpos( <stxt>.getpx+1, <stxt>.getpy+1 );
		<s>.setz(<stxt>.getz-1);
		grtxt.add(s);
		grtxt.add(stxt);
	}
	string mgetdb(int row)	{
		@s = dbc.get(row,0)->to_u;
		int ba = BYTEA - 2;
		int bz = BYTEZ - BYTEA+1;
		for( int i=0; i<s.length; i++)	{
			if( s.getbyte(i)!=BYTESPACE )
				s.setbyte( i, (s.getbyte(i)-ba)%bz+BYTEA );
		}
		s;
	}
	mgold	{	return 255,204,0; }
	mshadow	{	.grey(32);	}
	mouse_lclick	{
		if( igmdebug )	.cactsndstop(true);
		if( igmstate!=1 ) return;
		if( grels.isin(mouse.getpos,1,1) )	{
			@s = grels.getsfound;
			fxwciska_glaz.play;
			<s>.setframe(-1,!<s>.framenr);
			s ="";
			for( int i=0; i<grels.size; i++) s+= <grels.get(i)>.framenr;
			if( s==dbc.get(2,0) )	{
				igmstate = 0;
				fxstart_wlaz.play;
				anplyta.play(-1);
			}
		}
	}
}
game Calc : Computro	{
	init	{
		Computro::init("calc");
		
		.img = ("bkg.pyz");
		new img imgbkg;
		imgbkg.copy("anbkg");
		anbkg.hide;
		
		new Buttons buts("buts.pyz");
		buts.lock;
		
		new classplacepointer2 clp;
		new string scell = null;
		new int izadanie = 1;
		new int subhelp = 0;
		new string Code;
		Lexer::setas("Code");
		Code.consts = (A, "(", ")", "/", "%", "*","+","-","$","=",";");
		.sounds = (A,
			":zak_quit", "Jeszcze za wczenie na wyjcie", "mstart",
			":zak1", "Przed nami arkusz kalkulacyjny poprzez ktry rektor wprowadza zakupy do Komputera Centralnego", func { .cbplay("zak2"); clp.showob("im2_2","dd"); },
			":zak2", "W tej kolumnie s nazwy zakupw", func { .cbplay("zak3"); clp.showob("im2_3", "dd"); },
			":zak3", "Tutaj ceny pojedynczych zakupw", func { .cbplay("zak4"); clp.showob("im2_4", "dd"); },
			":zak4", "Tutaj ilo jednostek", func { .cbplay("zak5"); clp.showob("im2_5", "dd"); },
			":zak5", "A tutaj koszt wszystkich sztuk; Na przykad w pierwszym wierszu mamy koszt 34 dugopisw", func { .cbplay("zak6"); clp.showob("im17_5", "dd"); },
			":zak6", "W tej komrce mamy czny koszt wszystkich artykuw", func { clp.stoph; .cbplay("ania1"); },
			":ania1", "Na pierwszy rzut oka nie wida adnych bdw", func { clp.showob("im2_6", "dd"); .cbplay("ania2"); },
			":ania2", "Wykonamy tutaj obliczenia i porwnamy wyniki; Umiesz obsugiwa arkusz kalkulacyjny?", func { clp.stoph; .cbplay("zak7"); },
			":zak7", "Nie ale wczytam sobie do pamici helpa; Sekunda; Ju; Wykonuj moje polecenia", func { clp.showob("im2_6", "dd"); .cbplay("zak8"); },
			":zak8", "Zaczniemy od prostych wicze; Najpierw przepisz tutaj cen pierwszego zakupu i wcinij enter", func { clp.stoph; .mstart; },
			":zak9", "Dobrze; Teraz przepiszemy cen ponownie ale wykorzystamy wasno komrek arkusza", func { clp.show(309,82,"lu"); .msetact("im2_3"); .cbplay("zak10"); },
			":zak10", "Zaznaczyem komrk Ce 2; Aby pobra jej warto", func { clp.showob("im2_6", "dd"); .cbplay("zak11"); },
			":zak11", "Wpisz tutaj znak rwna si i nazw komrki w ktrej jest cena pojedynczego dugopisa; W razie problemw najed na przycisk pomoc", func { clp.stoph; .mstart; },
			":zak12", "wietnie; Przeanalizujmy nasz komrk", func { clp.showob("im2_6","rd"); .cbplay("zak13"); },
			":zak13", "Cho wpisalimy pewn formu poprzedzon znakiem rwnoci w komrce widzimy wynik", func { clp.show( 510, 91, "lu"); .cbplay("zak14"); },
			":zak14", "A tu widzimy wzr obliczajcy warto tej komrki", func { clp.stoph; .cbplay("zak15"); },
			":zak15", "Teraz oblicz w naszej komrce cen dugopisa pomnoon przez 2", "mstart",
			":zak16", "Umiesz ju odwoa si do komrki; Obliczmy zatem ile kosztoway wszystkie zakupione dugopisy; Pomn cen jednego dugopisa przez ilo kupionych sztuk", "mstart",
			":ania3", "Spjrz! czny koszt si nie zgadza; Kto zawyy cen dugopisw", func { .cbplay("zak17"); },
			":zak17", "Obliczmy pozostae zakupy; eby nie wpisywa za kadym razem formuy od nowa", func { clp.showob("imgsq", "rd"); .cbplay("zak18"); },
			":zak18", "Kliknij na ten kwadracik i przecignij go na wszystkie komrki w tej kolumnie w ktrych chcemy dokona oblicze", func { clp.stoph; .mstart; },
			":zak19", "Za krtko przecigna", "mstart",
			":ania4", "czna cena niemal kadego artykuu jest wpisana wysza ni wyliczylimy; Nie ma mowy o pomyce w obliczeniach rnice s ogromne; Jak moemy sprawdzi ca kwot?", func { .cbplay("zak20"); .msetact("im17_6"); clp.showob("im17_6","rd"); },
			":zak20", "Tutaj obliczymy czn sum wszystkich zakupw; Skorzystamy z wbudowanych w arkusze funkcji; Jedn z funkcji jest suma; Spjrz w tre zadania jak j zapisujemy",
				func { clp.stoph; .mstart; },
			":ania5", "Ponad 8 tysicy rnicy midzy poniesionymi wydatkami a wynikajcymi z rozpiski! Zao si e w innych plikach kocowe ceny te s inne od rzeczywistych; Musimy wydrukowa ten arkusz", "mstart"
			);
		// 25,133	750x400
		new int C = 7;	// 6*75 + 225 = 750
		new int R = 20;	// 20*20 = 400
		new @xstart = 24;
		new @ystart = 134;
		@x;
		@y = ystart;
		new @dx = 83;
		new @dy = 20;
		new @dxname = 252;
		@w = 750;
		@h = 400;
		.lang_db("dbc", "form");
		.lang_db("dbzad", "zad");
		new string smoved = null;
		
		new int ifont = 16;
		new @stdfont16 = .stdfont(ifont);
		.newtext("txt16", "", stdfont16, .black);
		new @stdbold16 = .stdbold(ifont);
		.newtext("txtzd", "", stdfont16, .grey(240));
		.newtext("txtb16", "", stdbold16, .black);
		.newtext("txtb16c", "", stdbold16, .black);
		new img imgc;
		imgc.create(1,h,.black,255);
		new img imgr;
		imgr.create(w,1,.black,255);
		int i, int j;
		new vector vcode;
		vcode.type("string");
		
		new ConTextTyper ttp( stdbold16, ifont, .black, "a0 -.,:()$*+/=;", 30);
		ttp.setpos(371, 80);
		.newtext("txtname", "", stdbold16, .black);
		txtname.setpos(290,80);
		
		// 1 - create belki
		new img im1;
		im1.create( dx, dy, .grey(230), 255 );
		new img im2;
		im2.create( dxname, dy, .grey(230), 255 );
		for( i=0; i<R; i++)	{
			im1.setpos(xstart, y);
			imgbkg.blit("im1");
			if( i>0 )	{
				txt16.txtset(i);
				txt16.txtcenter("im1");
				imgbkg.blit("txt16");
			}
			y+=dy;
		}
		x = xstart;
		@s = "A";
		for( j=0; j<C; j++)	{
			if( j==2 )	{
				im2.setpos(x, ystart);
				imgbkg.blit("im2");
				s.setbyte(0, BYTEA+j-1);
				txt16.txtset(s);
				txt16.txtcenter("im2");
				imgbkg.blit("txt16");
				x+=dxname;
			} else {
				im1.setpos(x, ystart);
				imgbkg.blit("im1");
				if( j>0 )	{
					s.setbyte(0, BYTEA+j-1);
					txt16.txtset(s);
					txt16.txtcenter("im1");
					imgbkg.blit("txt16");
				}
				x+=dx;
			}
		}
		txt16.hide;
		// aktywne pole belki
		im1.create( dx, dy, 220,220,240, 255 );
		im1.imgborders(1,.black,255);
		im2.create( dxname, dy, 220,220,240, 255 );
		im2.imgborders(1,.black,255);
		new img im1c;	im1c.copy("im1");
		new img im2c;	im2c.copy("im2");
		new gmimgvec gractb;
		txtb16.setz(10);
		txtb16c.setz(10);
		gractb.addlist(A, "im1", "im2", "txtb16", "txtb16c", "im1c", "im2c");
		gractb.hide;
		//	aktywne pole arkusza
		new img imgsq	{
			.create(6,6,.black,255);
			.addmethod("actionname", func { "imgsq"; });
			.addmethod("setframe", func { (int i1, int i2) ; } );
		};
		new int isqx;
		new int isqy;
		buts ("imgsq") { (@s)
			grbuts.add(s);
			};
		new bool bmoving = false;
		new img im00;		im00.create(dx, 2, .black, 255);
		new img im10;		im10.create(dx, 2, .black, 255);
		new img im01;		im01.create(2, dy, .black, 255);
		new img im11;		im11.create(2, dy, .black, 255);
		new gmimgvec gract;
		gract.addlist(A, "im00", "im10", "im01", "im11", "imgsq");
		gract.hide;
		gract.setz(20);
		new img im20;		im20.create(dxname, 2, .black, 255);
		new img im30;		im30.create(dxname, 2, .black, 255);
		new gmimgvec gract2;
		gract2.addlist(A, "im20", "im30", "im01", "im11", "imgsq");
		gract2.hide;
		gract2.setz(20);
		
		y = ystart+dy;
		new gmimgvec gral;
		string s2 = "A";
		string s3;
		int ir = dbc.getrowsno;
		int ic = dbc.getcolsno(1);
		for( i=1; i<R; i++)	{
			x = xstart + dx;
			for( j=1; j<C; j++)	{
				s = "im"+i+"_"+j;
				new img <s>;
				s2.setbyte(0, BYTEA-1+j);
				<s>.vars2(A, "row", i, "col", j, "txtcol", s2, "name", s2+i, "stekst", "", "sformula","");
				if( j==2 )	{
					<s>.create(dxname, dy, .white, 255);
					<s>.setpos(x, y);
					x+=dxname;
				} else {
					<s>.create(dx, dy, .white, 255);
					<s>.setpos(x, y);
					x+=dx;
				}
				<s>.imgborders(1, .mcolcol);
				gral.add(s);
				.mprinton(ir, ic, i, j, s);
			}
			y+=dy;
		}
		x = xstart;
		y = ystart;
		for( j=0; j<=C; j++)	{
			imgc.setpos(x, y);
			imgbkg.blit("imgc");
			if( j==2 ) x+=dxname;
			else x+=dx;
		}
		y = ystart;
		for( i=0; i<=R; i++)	{
			imgr.setpos(xstart, y);
			imgbkg.blit("imgr");
			y+=dy;
		}
		delete imgr;
		delete imgc;
		//.mprinton(ir, ic, 0, 1, "im17_4");
		//.mprinton(ir, ic, 0, 2, "im17_5");
		txt17_4.txtset( dbc.get(0,0) );
		txt17_4.txtcenter("im17_4");
		im17_4.stekst = ( txt17_4.get );
		im17_4.sformula = ( txt17_4.get );
		txt17_5.txtset( dbc.get(0,1) );
		txt17_5.txtright("im17_5");
		im17_5.stekst = ( txt17_5.get );
		im17_5.sformula = ( txt17_5.get );
		
		new img imzad;
		imzad.copy("im2_6");
		imzad.hide;
		.newtext("txtzad", "", stdfont16, .grey(64) );
		txtzad.hide;
		txtzad.txtcenter("imzad");
		new img imsum;
		imsum.copy("im17_6");
		imsum.hide;
		.newtext("txtsum", "", stdfont16, .grey(64) );
		txtsum.hide;
		txtsum.txtcenter("imsum");
		
		.timer = ("timend", 3000, func {
			clsave.set("epizod", "Sep");
			.gotoadv("adinania", "gameadinania2");
			} );
		
		.mloadzad;
		
		.cbplay("zak1");
	}
	mprinton(int ir, int ic, int i, int j, string simg)	{
		string s3 = "txt"+i+"_"+j;
		if( j<=ic && i<ir )		.newtext(s3, dbc.get(i, j-1), stdfont16, .black);
		else .newtext(s3, "", stdfont16, .black);
		<s3>.setz(20);
		if( j==3 || j==5 || (i==0&&j==2))	{
			<s3>.txtright(simg);
			<s3>.move(-2,0);
		} else	<s3>.txtcenter(simg);
		<simg>.stekst = ( <s3>.get );
		<simg>.sformula = ( <s3>.get );
	}
	mcolcol	{	return 148,148,192, 255;	}
	msetact(string s)	{
		.msetstd;
		scell = s;
		@r = <s>.row;
		@c = <s>.col;
		// tekst w wierszu
		im1.setpos(xstart, ystart+r*dy);
		im1.show;
		txtb16.txtset(r);
		txtb16.txtcenter("im1");
		txtb16.show;
		// w kolumnie z uwzglednieniem dluzszej
		if( c==2 )	{
			im2c.setpos(<s>.getpx, ystart);
			im2c.show;
			txtb16c.txtset(<s>.txtcol);
			txtb16c.txtcenter("im2c");
			txtb16c.show;
			im20.setpos(<s>.getpx, <s>.getpy);
			im30.setpos(<s>.getpx, <s>.getey-im10.geth);
			imgsq.setpos( im30.getex-imgsq.getw/2, im30.getey-imgsq.geth/2 );
			gract2.show;
		} else {
			im1c.setpos(<s>.getpx, ystart);
			im1c.show;
			txtb16c.txtset(<s>.txtcol);
			txtb16c.txtcenter("im1c");
			txtb16c.show;
			im00.setpos(<s>.getpx, <s>.getpy);
			im10.setpos(<s>.getpx, <s>.getey-im10.geth);
			imgsq.setpos( im10.getex-imgsq.getw/2, im10.getey-imgsq.geth/2 );
			gract.show;
		}
		im01.setpos(<s>.getpx, <s>.getpy);
		im11.setpos(<s>.getex-im11.getw, <s>.getpy);
		// 290,80
		txtname.txtset( <s>.name );
		ttp.txtset( <s>.sformula );
		<"txt"+r+"_"+c>.txtset( <s>.stekst );
		if( (izadanie.in(A,1,2,3,4) && r==2 && c==6) || (izadanie==6 && r==17 && c==6) )	{
			ttp.enable;
		}
	}
	ttp_onwrite	{
		if( scell==null ) return;
		@s = "txt"+<scell>.row+"_"+<scell>.col;
		<s>.txtset( .get );
		<s>.txtcenter( scell );
		<s>.clip( <scell>.getpx+1, <scell>.getpy+1, <scell>.getex-1, <scell>.getey-1 );
	}
	ttp_onenter	{
		if( scell==null ) return;
		@s = "txt"+<scell>.row+"_"+<scell>.col;
		<scell>.stekst = ( .get );
		<scell>.sformula = ( .get );
		string s2;
		match( izadanie )	{
			1 => {
				s2 = <s>.get;
				s2.clear;
				if( s2==dbc.get(2,2) )	.mnext("zak9");
			}
			2,3,4,6 => {
				Code.start( <s>.get->to_u );
				Code.clear;
				Code.gettoken( "vcode", true);
				if( izadanie==2 )	{
					if( vcode.veceq2(A,"$const", "=", "$alpha", "C2") ) {
						<scell>.stekst = (dbc.get(2,2));
						<scell>.sformula = ("= C2");
						.msetact(scell);
						.mnext("zak12");
					}
				} else if (izadanie==3) {
					if( vcode.veceq2(A,"$const", "=", "$int",2, "$const", "*", "$alpha", "C2") ||
						vcode.veceq2(A,"$const", "=", "$alpha", "C2", "$const", "*", "$int",2)  ) {
							s2 = 2.0*dbc.get(2,2);
							s2 = s2.strdotpos(2);
							<scell>.stekst = (s2);
							<scell>.sformula = ("= 2 * C2");
							txt2_6.txtset(s2);
							txt2_6.txtright("im2_6");
							.msetact(scell);
							.mnext("zak16");
						}
				} else if (izadanie==4) {
					if( vcode.veceq2(A,"$const", "=", "$alpha","D2", "$const", "*", "$alpha", "C2") ||
						vcode.veceq2(A,"$const", "=", "$alpha","C2", "$const", "*", "$alpha", "D2") )	{
							s2 = dbc.get(2,2)->to_r * dbc.get(2,3)->to_r;
							s2 = s2.strdotpos(2);
							<scell>.stekst = (s2);
							<scell>.sformula = ("= C2 * D2");
							txt2_6.txtset(s2);
							txt2_6.txtright("im2_6");
							.msetact(scell);
							.mnext("ania3");
						}
				} else if (izadanie==6)	{
					if( vcode.veceq2(A,"$const", "=", "$alpha","SUM", "$const", "(", "$alpha", "F2", "$const", ";", "$alpha", "F16", "$const", ")") )	{
						real r = 0.0;
						for( int i=2; i<=16; i++)	{
							r += <"im"+i+"_6">.stekst;
						}
						s2 = r;
						s2 = s2.strdotpos(2);
						<scell>.stekst = (s2);
						<scell>.sformula = ("= SUM(F2;F16)");
						txt17_6.txtset(s2);
						txt17_6.txtright("im17_6");
						.msetact(scell);
						.mnext("ania5");
					}
				}
			}
			? => ;
		}
	}
	mnext(string s)	{
		igmstate = 0;
		izadanie++;
		.mloadzad;
		ttp.disable;
		.cbplay(s);
	}
	mloadzad	{
		txtzd.txtset( dbzad.get(izadanie-1,0));
		txtzd.setpos(15, iResY - txtzd.geth - 4);
		txtzd.txtshadow(1, stdfont16);
	}
	msetstd	{
		gract.hide;
		gract2.hide;
		gractb.hide;
		txtname.txtset("");
		ttp.txtset("");
		ttp.disable;
		scell = null;
	}
	mstart	{
		buts.unlock;
		igmstate = 1;
	}
	buts_lclick	{
		match(sobject)	{
			"close" => .cbplay("zak_quit");
			"print" => if( izadanie==7 )	{
				igmstate = 0;
				buts.lock;
				timend.play;
			}
			"imgsq" => {
				if( izadanie==5 )	{
					bmoving = true;
					smoved = scell;
				}
			}
			? => ;
		}
	}
	mouse_lrel	{
		if( izadanie==5 && bmoving )	{
			bmoving = false;
			string s;
			for( int i=2; i<=15; i++)	{
				s = "im"+i+"_6";
				if( !im01.isin( <s>.getpx+1, <s>.getpy+5, 1, 1) )	{
					.msetbord(0);
					igmstate = 0;
					.cbplay("zak19");
					return;
				}
			}
			.msetbord(0);
			int j;
			string s2;
			for( j=3; j<=16; j++)	{
				s2 = "im"+j+"_6";
				s = dbc.get(j,2)->to_r * dbc.get(j,3)->to_r;
				<s2>.stekst = ( s.strdotpos(2) );
				<s2>.sformula = ("= C"+j+" * D" +j);
				<"txt"+j+"_6">.txtset( <s2>.stekst );
				<"txt"+j+"_6">.txtright( "im"+j+"_6" );
			}
			.mnext("ania4");
		}
	}
	msetbord(int y)	{
		@y1 = <smoved>.getpy;
		if( y< y1 ) y=y1;
		if( y>im16_6.getey) y = im16_6.getey;
		@ile = (y-y1)/dy+1;
		im01.create(2, ile*dy, .black, 255);
		im11.create(2, ile*dy, .black, 255);
		im01.setpos(<smoved>.getpx, <smoved>.getpy);
		im11.setpos(<smoved>.getex, <smoved>.getpy);
		im10.setpos(<smoved>.getpx, im11.getey);
		imgsq.setpos( im10.getex-imgsq.getw/2, im10.getey-imgsq.geth/2 );
	}
	mmove(int r, int c)	{		if( scell!=null )	.msetpos( <scell>.row + r, <scell>.col + c);	}
	msetpos(int r, int c)	{
		if( r>0 && r<R && c>0 && c<C )	{
			.msetstd;
			.msetact( "im"+r+"_"+c );
		}
	}
	cbhelp_MOVEON	{
		if( igmstate!=1 ) return;
		match(izadanie)	{
			1 => .mhelp( dbc.get(2,2) );
			2 => .mhelp( "= C2" );
			3 => .mhelp("= 2 * C2");
			4 => .mhelp("= C2 * D2" );
			5 => {
				clp.showob("imgsq", "rd");
				.cbplay("zak18");
			}
			6 => .mhelp2("= SUM(F2;F16)");
			7 => ;
			? => ;
		}
	}
	cbhelp_MOVEOFF	{
		imzad.hide;
		imsum.hide;
		txtzad.hide;
		txtsum.hide;
	}
	mhelp(string s)	{
		imzad.show;
		txtzad.show;
		txtzad.txtset(s);
		txtzad.txtcenter("imzad");
	}
	mhelp2(string s)	{
		imsum.show;
		txtsum.show;
		txtsum.txtset(s);
		txtsum.txtcenter("imsum");
	}
	key_down	{
		if( igmstate!=1 ) return;
		if( keyboard.iskey("up") ) .mmove(-1,0);
		else if( keyboard.iskey("down") ) .mmove(1,0);
		else if( keyboard.iskey("left") ) .mmove(0,-1);
		else if( keyboard.iskey("right") ) .mmove(0,1);
	}
	mouse_move	{
		if( igmstate!=1 ) return;
		if( izadanie==5 )	{
			if( bmoving )	.msetbord(mouse.getposy);
		}
	}
	mouse_lclick	{
		if( igmdebug ) .cactsndstop(true);
		if( igmstate!=1 ) return;
		if( izadanie!=5 && gral.isin(mouse.getpos,1,1) )	{
			@s = gral.getsfound;
			.msetact(s);
		}
	}
}
game Gimp : Computro	{
	init	{
		Computro::init("gimp");
		
		// bkg.pyz  kolor.pyz  layer.pyz  layopts.pyz  pens.pyz
		.imgs = (A, "bkg.pyz", "kolor.pyz 10", "layer.pyzH 10", "tools.pyz 5", "kursory.pyzH");
		@xtools = 100;
		antools.move( xtools, 0);
		
		new int iprevx;
		new int iprevy;
		new real rpozyczka;
		new int izadanie = 1;
		new int isubzad = 1;
		new string sactpen = null;
		.lang_db("dbl", "txt");
		.lang_db("dbzad", "zad");
		new @stdfont12 = .stdfont(12);
// 		.mloadzad;
		
		new int ilayers = 0;
		new int iactlayer = 0;
		new gmimgvec grlay;
		new string slastname;
		new string styped = null;
		new gmimgvec grdraws;
		new int imgW = 450;
		new int imgH = 360;
		
		new GUI gui("butgame");
		
		new vector vm1;
		vm1.type("string");
		//vm1.beginadd("begin", "File", "Edit", "Image", "Layer", "Filter");
		.mloadvec("menu1");
		@w = 100;	@x = 17;	@y = 8;	@z = 50;	@h = 20;
		gui.newsubmenu("menu1", w, h, "vm1", "horizontal");
		menu1.setz(z);
		menu1.move(x, y);
		
		.mloadvec("menuplik");		gui.addsubmenu("menu1", 0, "menuplik", "vm1");
		.mloadvec("menuedycja");	gui.addsubmenu("menu1", 1, "menuedycja", "vm1");
		.mloadvec("menuobraz");	gui.addsubmenu("menu1", 2, "menuobraz", "vm1");
		.mloadvec("menuwarstwa");	gui.addsubmenu("menu1", 3, "menuwarstwa", "vm1");
		
// 		rgbtitle		rgbcol		color		rgbpaleta		paleta
		.copyanima("ankolor", "anrgbcol");
		anrgbcol.setframe(1,0);
		new Color pencolor;
		pencolor.set(.black,255);
		new img imgcolor;
		ankolor.setframe("color",0);
		imgcolor.clone("ankolor");
		ankolor.setframe("rgbtitle",0);
		.newtext("txtr", 0, stdfont12, .black);	txtr.setpos(61,432);	txtr.setz(30);
		.newtext("txtg", 0, stdfont12, .black);	txtg.setpos(61,456);	txtg.setz(30);
		.newtext("txtb", 0, stdfont12, .black);	txtb.setpos(61,480);	txtb.setz(30);
		.copyanima("ankolor", "anrgbpaleta");
		anrgbpaleta.setframe("rgbpaleta",0);
		anrgbpaleta.Button_isin;
		anrgbpaleta.stdbutmoveon;
		anrgbpaleta.stdbutmoveoff;
		anrgbpaleta.setz(20);
		anrgbpaleta.addmethod("butclick", func { <GAME> {
			if ( isubzad==8 || isubzad==16 || isubzad==23 || isubzad==35)	{
				gui.newwndtitle("wincolor", null, .mtekst("setcolor"), anpaleta.getw, anpaleta.geth);
				wincolor.winmove( anpaleta.getpx-wincolor.ibar, anpaleta.getpy-wincolor.ititlebar );
				wincolor.winsetz( anpaleta.getz -1 );
				anpaleta.show;
				isubzad++;
			}
			}; } );
		.msetcolor;
		butgame.add("anrgbpaleta");
		.copyanima("ankolor", "anpaleta");
		anpaleta.setframe("paleta",0);
		anpaleta.setz(20);
		anpaleta.hide;
		
		new gmimgvec grsize;
		new int ibutsize = 1;
		"grsize" .* "pedzle.pyz";
		grsize.setz(5);
		grsize.move(xtools,0);
		grsize.hide;
		grsize.Button_isin;
		<grsize.get(ibutsize)>.setframe(-1,1);
		grsize.stdbutmoveon;
		grsize.stdbutmoveoff;
		grsize.addmethod("butclick", func {
			@id = .getfound;
			<.get(ibutsize)>.setframe(-1,0);
			ibutsize = id;
			<.get(id)>.setframe(-1,1);
			.msetkursor;
			if( isubzad==7 && ibutsize==3 )	{
				isubzad = 8;
			} else if (isubzad==19 && ibutsize==0 )	{
				isubzad = 20;
			}
			} );
		butgame.add("grsize");
		
		new gmimgvec grtool;
		"grtool" .* "pens.pyz";
		new ConImgMover cpen;
		new img imgpen;
		grtool.setz(5);
		grtool.each( func { (@id)
			.addmethod("butmoveon", func {
				if( .actionname!=sactpen )	{
					.setframe(-1,1);
				}
				} );
			.addmethod("butmoveoff", func {
				if( .actionname!=sactpen )	{
					.setframe(-1,0);
				}
				} );
			.Button_isin;
			butgame.add(this);
			} );
		<.mgetpen("rotate")>.addmethod("butclick", func {
			.stdpenclick;
			if (isubzad==43)	{
				isubzad++;
				<GAME>.newrotatewin;
			}
			} );
		<.mgetpen("bucket")>.addmethod("butclick", func {
			.stdpenclick;
			} );
		<.mgetpen("scale")>.addmethod("butclick", func {
			.stdpenclick;
			if (isubzad==40)	{
				isubzad++;
				<GAME>.newscalewin;
			}
			} );
		<.mgetpen("move")>.addmethod("butclick", func {
			.stdpenclick;
			} );
		<.mgetpen("erase")>.addmethod("butclick", func {
			.stdpenclick;
			} );
		<.mgetpen("pen")>.addmethod("butclick", func {
			.stdpenclick;
			if( isubzad==6 )	{
				isubzad = 7;
			}
			} );
		<.mgetpen("circle")>.addmethod("butclick", func {
			.stdpenclick;
			} );
		<.mgetpen("square")>.addmethod("butclick", func {
			.stdpenclick;
			} );
		
// 		newlayer	<action>        trashlayer	<action>        checklayer	<action>        downlayer	<action>        uplayer
		new gmimgvec grlayopt;
		"grlayopt" .* "layopts.pyz";
		grlayopt.each( func { (@id)
			.Button_isin;
			.addmethod("butmoveon", func {		.setframe(-1,1);	} );
			.addmethod("butmoveoff", func {		.setframe(-1,0);	} );
			.addmethod("butclick", func {
				match( .actionname )	{
					"newlayer" => {
						if( isubzad==14 || isubzad==33 )	{
							isubzad++;
							<GAME>.newlayerwin;
						}
					}
					? => ;
				}
				} );
			butgame.add(this);
			} );
		
		.msetcolor;
		<.mgetpen("move")>.stdpenclick;
		
		new string slayeropt = null;
		
		// tmp
 		//clsave.set("epizod", "Sep");
		
		.sounds = (A,
			":ania1", "Musimy jako oczyci ten obraz", null,
			":ania2", "Spjrzcie! Pod tymi zanieczyszczeniami wida kontur", func { .cbplay("fel1"); },
			":fel1", "Po prawej jest budynek klasztorny i kaplica; Z kaplicy biegnie poczenie z innym budynkiem", func { .cbplay("ania3"); },
			":ania3", "Zamiast ktrego mamy dzi Gmach Gwny; Zagadka rozwizana! Kiedy asystent zostawi adunek w oranerii Wincenty ukrad strowi klucz do kaplicy i przenis adunek podziemnym przejciem do zamurowanej piwnicy", func { .cbplay("fel2"); },
			":fel2", "No to teraz musimy wej do tej kaplicy", func { ccs.close( func { .gotoadv("adsala", "gameadsala2"); } ); }
			);
		if( PrzygodaMode && clsave.is("epizod","Sep") )	{
			izadanie=11;
			isubzad = 50;
			
			.newanima("anmapa", "mapka.pyz", 10);
			imgW = anmapa.getw;
			imgH = anmapa.geth;
			gui.newwndtitle("windraw", null, "PICT_00235.jpg "+imgW+"x"+imgH, imgW, imgH);
			windraw.winmove( 380-windraw.getw/2, 360-windraw.geth/2 );
			.newlayer(false, .mtekst("bkg"));
			.msetkursor;
			@s = .activelayer;
			anmapa.setpos( <s>.getpx, <s>.getpy );
			<s>.blit("anmapa");
			delete anmapa;
			
			.cbplay("ania1");
		}
		.mloadzad;
		
		ccs.enter( func { igmstate = 1; } );
	}
	_empty_	{}
	stdbutmoveon	{	.addmethod("butmoveon", "_empty_");	}
	stdbutmoveoff	{	.addmethod("butmoveoff", "_empty_");	}
	msetcolor	{
		imgcolor.paint( pencolor.get , 0);
		txtr.txtset(pencolor.r);
		txtg.txtset(pencolor.g);
		txtb.txtset(pencolor.b);
		if( sactpen=="pen" )	{
			imgpen.paint( pencolor.get, 0 );
		}
	}
	msetkursor	{
		if( sactpen.in(A,"pen","erase") )	{
			ankursory.setframe(sactpen, ibutsize);
		} else ankursory.setframe(sactpen, 0);
		//ankursory.ansetbpos(0,0);
		//ankursory.move( -ankursory.getw, -ankursory.geth);
		if( <GAME>.hasvar("windraw") )	{
			imgpen.clone("ankursory");
			imgpen.setz(windraw.getz+1);
			imgpen.show;
			imgpen.anclipob("windraw");
			if( sactpen=="pen" )	{
				imgpen.paint( pencolor.get, 0 );
			}
			cpen.set("imgpen", ankursory.getw, ankursory.geth, 0, 0);
		}
	}
	stdpenclick	{
		@s = .actionname;
		if( sactpen!=s )	{
			if( sactpen!=null )	{
				grsize.hide;
				<.mgetpen(sactpen)>.setframe(-1,0);
			}
			sactpen = s;
			if( s.in(A,"pen","erase") )	{
				grsize.show;
			}
			antools.setframe(s,0);
			.setframe(-1,2);
		}
		.msetkursor;
	}
	string mgetpen(string s)	{	grtool.getsac(s);	}
	string mtekst(string s)	{	dbl.get( dbl.findbyrow(s), 1 ); }
	mloadvec(string s)	{
		@id = dbl.findbyrow(s);
		vm1.free;
		for( int i=1; i< dbl.getcolsno(id); i++)	{
			vm1.add( dbl.get(id, i) );
		}
	}
	mloadzad	{	<GAME> {
		if( .hasvar("tdzad") )
			.deletegmobj("tdzad");
		new TextDb tdzad(stdfont12, 12, "$row:dbzad,"+(izadanie-1), .white, 9, 566, 2, 100, "left");
	}; }
	menuplik_lclick	{
		if( isubzad==1 )	{
			if( menuplik.idclicked==0 )	{
				isubzad = 2;
				.mbuilzad;
			}
		}
	}
	menuwarstwa_lclick	{
		if( isubzad==14 || isubzad==33)	{
			if( menuwarstwa.idclicked==0 )	{
				isubzad++;
				<GAME>.newlayerwin;
			}
		} else if (isubzad==40)	{
			if( menuwarstwa.idclicked==1 )	{
				isubzad++;
				<GAME>.newscalewin;
			}
		} else if (isubzad==43)	{
			if( menuwarstwa.idclicked==2 )	{
				isubzad++;
				<GAME>.newrotatewin;
			}
		} else if (isubzad==50)	{
			if( menuwarstwa.idclicked==3 )	{
				isubzad++;
				<GAME>.newlevelwin;
			}
		}
	}
	mbuilzad	{	<GAME> {
		match( isubzad )	{
			2 => 	.newimagewin;
			3 => {
				gui.newwndtitle("windraw", null, "Bez nazwy "+imgW+"x"+imgH, imgW, imgH);
				windraw.winmove( 380-windraw.getw/2, 300-windraw.geth/2 );
				.newlayer(false, .mtekst("bkg"));
				.msetkursor;
			}
			6 => {
				if( sactpen=="pen" )	{
					isubzad = 7;
					if( ibutsize==3 ) isubzad = 8;
				}
			}
			42 => {
				@s = .activelayer;
				new filter ftsubzad42;
				ftsubzad42.link(s);
				ftsubzad42.setzoomxy(200.0/<s>.getw,200.0/<s>.geth);
			}
			? => ;
		}
	}; }
	newimagewin	{	.newsizewin("newimg", "wymiary", false); }
	newscalewin	{	.newsizewin("zoomlayer", "wymiarylayer", true); }
	newsizewin(string stitle, string soptitle, bool bsetwymiar)	{
		gui.newwndtitle("winnew", null, .mtekst(stitle), 275, 180);
		winnew.winmove(400-winnew.getw/2,300-winnew.geth/2);
		gui.newbutton("butoknew", "OK", 80, 30);
		gui.newbutton("butcancelnew", "Cancel", 80, 30);
		butoknew.setpos(winnew.getcx-85,winnew.getey-40);
		butcancelnew.setpos(butoknew.getex+10, butoknew.getpy);
		gui.newtextbox("ttw", "0", 50, 20);
		ttw.winmove( winnew.getcx, winnew.getcy-35 );
		gui.newtextbox("tth", "0", 50, 20);
		tth.winmove( winnew.getcx, winnew.getcy );
		@x = ttwwnd.getex + 5 - winnew.getpx;
		@yw = ttw.getpy-winnew.getpy;
		@yh = tth.getpy-winnew.getpy;
		gui.print("winnew", x, yw, "px");
		gui.print("winnew", x, yh, "px");
		x = 50;
		gui.print("winnew", x, yw, .mtekst("szerokosc"));
		gui.print("winnew", x, yh, .mtekst("wysokosc"));
		gui.print("winnew", x-30, yw-40, .mtekst(soptitle));
		if( bsetwymiar )	{
			ttw.setid( imgW, 0 );
			tth.setid( imgH, 0 );
		}
		@z = 10;
		winnew.winsetz(z);
		butoknew.setz(z);
		butcancelnew.setz(z);
		ttw.winsetz(z);
		tth.winsetz(z);
	}
	newrotatewin	{
		gui.newwndtitle("winnew", null, .mtekst("rotatelayer"), 275, 180);
		winnew.winmove(400-winnew.getw/2,300-winnew.geth/2);
		gui.newbutton("butoknew", "OK", 80, 30);
		gui.newbutton("butcancelnew", "Cancel", 80, 30);
		butoknew.setpos(winnew.getcx-85,winnew.getey-40);
		butcancelnew.setpos(butoknew.getex+10, butoknew.getpy);
		gui.newtextbox("ttw", "0", 50, 20);
		ttw.winmove( winnew.getcx, winnew.getcy-35 );
		@yw = ttw.getpy-winnew.getpy;
		@x = 50;
		gui.print("winnew", x, yw, .mtekst("rotateangle"));
		gui.print("winnew", x-30, yw-40, .mtekst("obrot"));
		@z = 10;
		winnew.winsetz(z);
		butoknew.setz(z);
		butcancelnew.setz(z);
		ttw.winsetz(z);
	}
	newlevelwin	{
		gui.newwndtitle("winnew", null, .mtekst("levellayer"), 400, 200);
		winnew.winmove(400-winnew.getw/2, 60);
		gui.newbutton("butoknew", "OK", 80, 30);
		gui.newbutton("butcancelnew", "Cancel", 80, 30);
		butoknew.setpos(winnew.getcx-85,winnew.getey-40);
		butcancelnew.setpos(butoknew.getex+10, butoknew.getpy);
		gui.newtextbox("ttw", "0", 50, 20);
		ttw.winmove( winnew.getcx-ttwwnd.getw/2, butoknew.getpy- ttwwnd.geth - 20 );
		@z = 20;
		winnew.winsetz(z);
		butoknew.setz(z);
		butcancelnew.setz(z);
		ttw.winsetz(z);
		
		new img imhis;
		new AlgImg algimg;
		algimg.makehistogram("imhis", 256, 60, .activelayer);
		
		imhis.setpos( winnew.getcx - imhis.getw/2, winnew.getpy + 40 );
		imhis.setz(z+1);
		
		@w = 256;
		@h = 15;
		gui.newwndconcave("winsuwak", w+4, h+4);
		
		new img imgreypal;
		algimg.makegreypallete("imgreypal", 1, 15);
		imgreypal.setpos(imhis.getpx, imhis.getey+6);
		winsuwak.setz(imhis.getz);
		winsuwak.setpos(imgreypal.getpx-2, imgreypal.getpy-2);
		winsuwak.blit("imgreypal");
		delete imgreypal;
		
		delete algimg;
		new img imsuw;
		imsuw.create(8, (winsuwak.getey+1) - (imhis.getpy-2), .transparent);
		new img im1;
		im1.create(8, h+6, .msuwcol);
		im1.imgroundborder(1, .msuwbor);
		im1.setpos(imsuw.getpx, imsuw.getey-im1.geth);
		imsuw.blit("im1");
		im1.create(4, imsuw.geth-winsuwak.geth, .msuwcol);
		im1.imgroundborder(1, .msuwbor);
		im1.setpos(imsuw.getcx-im1.getw/2, imsuw.getpy);
		imsuw.blit("im1");
		imsuw.setz(imhis.getz+2);
		delete im1;
		
		imsuw.addmethod("isbutin", func { (int x, int y) .isin(x,y,1,1); });
		imsuw.stdbutmoveon;
		imsuw.stdbutmoveoff;
		imsuw.addmethod("butclick", func {
			isubzad=52;
			slayeropt = "level";
			} );
		butgame.add("imsuw");
		new filter ftlevel;
		ftlevel.link(.activelayer);
		.msetlevel(127);
	}
	msuwcol	{	return 64,64,255,255;	}
	msuwbor	{	return 0,0,128,255;	}
	msetlevel(int id)	{
		if( id<0 ) id=0;
		if( id>255) id=255;
		imsuw.setpos( imhis.getpx+2+id-imsuw.getw/2, imhis.getpy-2 );
		ttw.setid(id,0);
		ftlevel.setlevel(id);
	}
	mchecklevel	{
		int id = ttw.get;
		if( id>=7 && id<=14 )	{
			isubzad=53;
			igmstate = 0;
			butgame.lock;
			ttw.disable;
			.cbplay("ania2");
		} else
			isubzad = 51;
	}
	ttw_boxontype	{
		if( keyboard.iskey("enter") )	{
			.disable;
			if( isubzad==51 )	{
				.msetlevel(ttw.get);
				.mchecklevel;
			}
		}
	}
	newlayerwin	{
		gui.newwndtitle("winnewlayer", null, .mtekst("newlayer"), 280, 180);
		winnewlayer.winmove(400-winnewlayer.getw/2,200-winnewlayer.geth/2);
		gui.newbutton("butoknewlay", "OK", 80, 30);
		gui.newbutton("butcancelnewlay", "Cancel", 80, 30);
		butoknewlay.setpos(winnewlayer.getcx-85,winnewlayer.getey-40);
		butcancelnewlay.setpos(butoknewlay.getex+10, butoknewlay.getpy);
		@z = windraw.getz+10;
		winnewlayer.winsetz(z);
		butoknewlay.setz(z);
		butcancelnewlay.setz(z);
		
		gui.newtextbox("ttnamelay", "a_0", 100, 20);
		ttnamelay.setid( .mtekst("stdnazwa"), 0 );
		ttnamelay.winmove( winnewlayer.getcx, winnewlayer.getcy-55 );
		ttnamelay.winsetz(z);
		gui.newtextbox("ttwlay", "0", 50, 20);
		ttwlay.setid( imgW, 0 );
		ttwlay.winmove( winnewlayer.getcx, winnewlayer.getcy );
		ttwlay.winsetz(z);
		gui.newtextbox("tthlay", "0", 50, 20);
		tthlay.winmove( winnewlayer.getcx, winnewlayer.getcy+22 );
		tthlay.setid( imgH, 0 );
		tthlay.winsetz(z);
		
		@x = ttwlaywnd.getex + 5 - winnewlayer.getpx;
		@yn = ttnamelay.getpy-winnewlayer.getpy;
		@yw = ttwlay.getpy-winnewlayer.getpy;
		@yh = tthlay.getpy-winnewlayer.getpy;
		gui.print("winnewlayer", x, yw, "px");
		gui.print("winnewlayer", x, yh, "px");
		x = 50;
		gui.print("winnewlayer", x, yn, .mtekst("nowanazwa"));
		gui.print("winnewlayer", x, yw, .mtekst("szerokosc"));
		gui.print("winnewlayer", x, yh, .mtekst("wysokosc"));
		gui.print("winnewlayer", x-10, yw-25, .mtekst("wymiarylayer"));
	}
	mendnewimg	{	gui.dellist(A, "butoknew", "butcancelnew", "winnew", "tth", "ttw");	}
	mendnewlayer	{	gui.dellist(A, "butoknewlay", "butcancelnewlay", "winnewlayer", "tthlay", "ttwlay", "ttnamelay");	}
	mendrotatewin	{	gui.dellist(A, "butoknew", "butcancelnew", "winnew", "ttw");	}
	mendlevelwin	{
		gui.dellist(A, "butoknew", "butcancelnew", "winnew", "winsuwak", "ttw");
		butgame.removebut("imsuw");
		<GAME> {
			ftlevel.unlink;
			delete ftlevel;
			delete imhis;
			delete imsuw;
		};
	}
	mnextzad	{
		izadanie++;
		isubzad++;
		.mbuilzad;
		.mloadzad;
	}
	butoknew_lclick	{
		if( igmstate!=1 ) return;
		if( isubzad==51 )	{
			butoknew.unclick;
		} else if( isubzad==44 )	{
			int kat = ttw.get;
			.mendrotatewin;
			<GAME> (kat%360) { (int kat)
				@s = .activelayer;
				new filter ftsubzad44;
				ftsubzad44.link(s);
				ftsubzad44.rotate(kat);
				<s>.anclipob(grdraws.get(0));
			};
			.mnextzad;
		} else if( isubzad==41 )	{
			if( ttw.get->to_i == 200 && tth.get->to_i == 200 )	{
				.mendnewimg;
				.mnextzad;
			} else butoknew.unclick;
		} else if( isubzad==2) {
			if( ttw.get->to_i == imgW && tth.get->to_i == imgH )	{
				.mendnewimg;
				.mnextzad;
			} else butoknew.unclick;
		}
	}
	butoknewlay_lclick	{
		if( ttwlay.get->to_i == imgW && tthlay.get->to_i == imgH &&
			((isubzad==15 && ttnamelay.get=="Layer1") || (isubzad==34 && ttnamelay.get=="layer_zoom")) )	{
			.newlayer(true, ttnamelay.get);
			.mendnewlayer;
			isubzad++;
		} else butoknewlay.unclick;
	}
	butcancelnew_lclick	{
		if( igmstate!=1 ) return;
		isubzad--;
		if( isubzad==43 ) .mendrotatewin;
		else if (isubzad==50) .mendlevelwin;
		else .mendnewimg;	
	}
	butcancelnewlay_lclick	{	isubzad--;	.mendnewlayer;	}
	winnew_lclick	{	.butcancelnew_lclick;	}
	winnewlayer_lclick	{	.butcancelnewlay_lclick;	}
	/******************************************/
	wincolor_lclick	{
		if( isubzad==9 || isubzad==17 || isubzad==24 || isubzad==36)	{
			isubzad--;
		} else if (isubzad==10 || isubzad==18 || isubzad==25 || isubzad==37)	{
			isubzad++;
			if( isubzad==19 )	{
				if( sactpen=="pen" && ibutsize==0)	{
					isubzad = 20;
				}
			}
		}
		anpaleta.hide;
		gui.delobj("wincolor");
	}
	/******************************************/
	newlayer(bool btransparent, string sname)	{	<GAME> (btransparent, sname) { (bool btransparent, string sname)
		if( ilayers>0 ) .deactivatelayer(iactlayer);
		iactlayer = ilayers;
		@s = "imdraw"+iactlayer;
		new img <s>;
		if( btransparent )	<s>.create(imgW, imgH, .transparent);
		else <s>.create(imgW, imgH, .white, 255 );
		<s>.setpos(windraw.getpx+gui.ibar, windraw.getpy+gui.ititlebar);
		grdraws.add(s);
		ilayers++;
		s = "anlay"+iactlayer;
		.copyanima("anlayer", s);
		<s>.show;
		@y = -(ilayers-1)*<s>.geth;
		<s>.setpos( 0, y );
		grlay.add(s);
		<.msetlayer("eye", y)>.show;
		@s2 = .msetlayer("name", y);
		@s3 = "tt"+s;
		//new TextBoxTyper <s3>( stdfont12, 12, 0.6*12, .black, "a0_", <s2>.getpx+2, <s2>.getcy-6, <s2>.getw-4, 14, 1 );
		new ConTextTyper <s3>(stdfont12, 12, .black, "a0_", 15);
		<s3>.setpos(<s2>.getpx+2, <s2>.getcy-6);
		.mlayname( iactlayer, sname );
		<s3>.setz(115);
		//<s3>.unlock;
		<s3>.addmethod(s3+"_onenter", func {
			if( .get=="" ) .txtset(slastname);
			styped = null;
			if( isubzad==3 && .get=="Background" )	{
				.mnextzad;
			}
			});
		<s3>.addmethod(s3+"_ontype", func {
			if( keyboard.iskey("escape") )	{
				.disable;
				.txtset(slastname);
				styped = null;
			}
			});
		//<s3>.addmethod(s3 + 
		//<action>        img		<action>        eye	<action>        name	<action>        active
		_ = .msetlayer("active", y);
		.activatelayer(iactlayer);
	}; }
	mlayname(int id, string s)	{	<"ttanlay"+id>.txtset(s);	}
	string getactlayname	{	"ttanlay"+iactlayer;	}
	deactivatelayer(int id)	{	<.sgetlayer(id)>.hide;	}
	string sgetlayer(int id)	{	grlay.get(id*4+3); }
	string sactlayer	{	grlay.get(iactlayer*4+3); }
	string activelayer	{	grdraws.get(iactlayer);	}
	activatelayer(int id)	{
		if( id<0 ) id = 0;
		if( id>=ilayers ) id = ilayers-1;
		.deactivatelayer(iactlayer);
		iactlayer = id;
		<grlay.get(id*4+3)>.show;
	}
	string msetlayer(string s, int y)	{
		@s2 = "anlay"+iactlayer+s;
		.copyanima("anlayer", s2);
		<s2>.setframe(s,0);
		<s2>.setpos(0,y);
		<s2>.hide;
		grlay.add(s2);
		s2;
	}
	bool isonactlayer	{
		<.sactlayer>.isin(mouse.getpos,0,0);
	}
	mhide(int id)	{
		if( id<ilayers )	{
			<grlay.get(id*4+1)>.setframe(-1,1);
			<"imdraw"+id>.hide;
		}
	}
	mshow(int id)	{
		if( id<ilayers )	{
			<grlay.get(id*4+1)>.setframe(-1,0);
			<"imdraw"+id>.show;
		}
	}
	mouse_lclick	{
		if( igmstate!=1 ) return;
		|int x, int y| = mouse.getpos;
		match( isubzad )	{
			3 => 	if( styped!=null && .getactlayname!=styped )	{
					<styped>.txtset(slastname);
					<styped>.disable;
				}
			4 => 	if( anlay0eye.isin(x,y,0,0) )	{
					.mhide(0);
					isubzad++;
				}
			5 => 	if( anlay0eye.isin(x,y,0,0) )	{
					.mshow(0);
					.mnextzad;
				}
			9, 10, 17,18, 24, 25, 36, 37 => {
				if( anpaleta.isin(x,y,1,0) )	{
					pencolor.set( anpaleta.getrgba(x,y) );
					if( isubzad<=10 )
						isubzad=10;
					else if( isubzad<=18 ) isubzad=18;
					else if( isubzad<=25 ) isubzad=25;
					else isubzad=37;
					.msetcolor;
				}
			}
			11, 12, 20, 26, 38 => {
				@s = .activelayer;
				if( <s>.isin(x,y,1,0) && sactpen=="pen" )	{
					isubzad++;
					iprevx = imgpen.getpx; iprevy = imgpen.getpy;
					rpozyczka = 0.0;
					slayeropt = "draw";
					<s>.blit("imgpen");
				}
			}
			22 => .mactivatelayer(0);
			28 => if( anlay1eye.isin(x,y,0,0) )	{
					.mhide(1);
					isubzad++;
				}
			29 => if( anlay1eye.isin(x,y,0,0) )	{
					.mshow(1);
					.mnextzad;
				}
			30, 42 => .mactivatelayer(1);
			31 => {
				@s = .activelayer;
				if( <s>.isin(x,y,1,0) && sactpen=="erase" )	{
					isubzad++;
					iprevx = imgpen.getpx; iprevy = imgpen.getpy;
					rpozyczka = 0.0;
					slayeropt = "erase";
					<s>.erase("imgpen");
				}
			}
			45 => {
				igmstate = 0;
				ccs.close( func {
					if( PrzygodaMode )
						.gotoadv("adsala", "gameadsala2");
					else gameapi.play("Menu");
					} );
			}
			? => ;
		}
	}
	mactivatelayer(int id)	{
		if( <.sgetlayer(id)>.isin(mouse.getpos,0,0) )	{
			.activatelayer(id);
			isubzad++;
		}
	}
	mouse_move	{
		//|int x, int y| = mouse.getpos;
		match( slayeropt )	{
			"draw" => rpozyczka = <.activelayer>.imgdrawline("imgpen", iprevx, iprevy, imgpen.getpx, imgpen.getpy, 3, rpozyczka);
			"erase" => rpozyczka = <.activelayer>.imgeraseline("imgpen", iprevx, iprevy, imgpen.getpx, imgpen.getpy, 3, rpozyczka);
			"level" => .msetlevel( mouse.getposx-(winsuwak.getpx+2) );
			? => ;
		}
		|iprevx, iprevy| = imgpen.getpx, imgpen.getpy;
	}
	mouse_lrel	{
		slayeropt = null;
		match( isubzad )	{
			13, 21, 32 => .mnextzad;
			27, 39 => isubzad++;
			52 => .mchecklevel;
			? => ;
		}
	}
	mouse_dblclick	{
		if( igmstate!=1 ) return;
		|int x, int y| = mouse.getpos;
		match( isubzad )	{
			3 => {
				if( .isonactlayer ) {
					styped = .getactlayname;
					slastname = <styped>.get;
					<styped>.enable;
				}
			}
			? => ;
		}
	}
	mouse_rclick	{
		if( igmdebug )	{
			match(izadanie)	{
				1 => 2;
				2 => 3;
				3 => 5;
				4 => 13;
				5 => 20;
				? => 0;
			}
			isubzad = _;
			.mnextzad;
		}
	}
}
game Sql : Computro	{
	init	{
		Computro::init("sql");
		new GUI gui("butgame");
		.lang_db("dbl","txt");
		new vector vm1;
		vm1.type("string");
		new img imgbkg;
		imgbkg.create(iResX, iResY, .grey(32), 255);
		
		gui.newwndtitle("winmain", null, .mtekst("maintit"), 784, 520);
		winmain.winmove(400-winmain.getw/2, 4);
		gui.newbutton("butshow", .mtekst("pokapoka"), 180, 25);
		butshow.setpos( 800 - 195, 35 );
		butshow.hide;
		gui.newbutton("butprev", .mtekst("prev"), 180, 25);
		butprev.setpos(800-butshow.getex, butshow.getpy);
		
		new @stdfont12 = .stdfont(12);
		.lang_db("dbzad","zad");
		.newdb("dbsql","zapytania.db");
		.newdb("dbcmp", "zapytania.sql");
		new db dbodp2;
		
		new SQL dbazy;
		dbazy.load(.getgraphpath);
		new db dbodp;
		new int ilesql = 0;
		
		new AlgImg algim;
		new int izadanie = 1;
		new int izapytanie = 0;
		.mloadzad;
		ccs.enter( func { igmstate = 1; } );
	}
	int mquery(string s)	{
		@id = dbazy.query(s);
		if(id==0)	{
			ilesql++;
			dbodp.free;
			dbazy.copyresult("dbodp");
			if( dbodp.getrowsno>30 )	{
				dbodp.dbcuttosize(30);
				for( int i=0; i<dbodp.getcolsno(29); i++) dbodp.set(29,i,"...");
			}
			s = "winsql"+ilesql;
			gui.newsqltable(s, "dbodp", "center");
			<s>.setz(510);
			<s>.setpos( 400 - <s>.getw/2, winbgtxt.getey + 20 );
			//if(<s>.getw>620)	{
			@y = 500-winbgtxt.getey;
			@w = <s>.getw;
			gui.newrewinder("rewsql"+ilesql, (w>620 ? 100 : 400-w/2) , <s>.getpy, (w>620 ? 600 : 0), (<s>.geth>y+10 ? y : 0), s);
			<"rewsql"+ilesql>.winsetz(500);
		}
		id;
	}
	butshow_lclick	{
		if( <GAME>.hasvar("tdzad") )	.mshowtext;
	}
	merror(int id)	{
		igmstate = 2;
		gui.newwndtitle("winerror", null, .mtekst("error"), 480, 120);
		winerror.winmove(400-winerror.getw/2,100-winerror.geth/2);
		if( id )	{
			gui.print("winerror", 10, 40, .mtekst("error1"));
			gui.print("winerror", 10, 60, .mtekst("er"+id) + ": " + dbazy.serror);
		} else {
			gui.print("winerror", 10, 50, .mtekst("error2"));
		}
		gui.newbutton("butokerror", "OK", 80, 30);
		butokerror.setpos( winerror.getcx - butokerror.getw/2, winerror.getey-10-butokerror.geth );
		winerror.winsetz(600);
		butokerror.winsetz(610);
		ttsql.disable;
	}
	butokerror_lclick	{
		butokerror.unclick;
		igmstate = 1;
		gui.dellist(A, "butokerror", "winerror");
		ttsql.enable;
		.mdeltabs;
	}
	butok_lclick	{
		butok.unclick;
		if( igmstate!=1 ) return;
		if( izadanie.in(A,7,9,11,13,15,17,19,21,23,25,27,29,31,33) )	{
			.mdeltabs;
			@sq = ttsql.getlines;
			@id = .mquery(sq);
			if( id )	{
				<GAME>.merror(id);
			} else {
				_ = .mquery(sq);
				_ = dbazy.query( .mgetrow );
				dbodp2.free;
				dbazy.copyresult("dbodp2");
				if( dbodp.dbeq("dbodp2") )	.mnextzad;
				else <GAME>.merror(0);
			}
		} else
			.mnextzad;
	}
	string mgetrow	{
		@row = izapytanie-1;
		@rows = dbcmp.getcolsno(row);
		@s = "";
		for( int i=1; i<rows; i++) s+=dbcmp.get(row,i)+" ";
		s;
	}
	butprev_lclick	{
		butprev.unclick;
		if( igmstate!=1 ) return;
		.mprevzad;
	}
	mtabpos(int id, int x, int y)	{
		if( gui.hasvar("rewsql"+id) )	<"rewsql"+id>.winsetallpos(x, y);
		else <"winsql"+id>.setpos(x, y);
	}
	mtabmove(int id, int x, int y)	{
		if( gui.hasvar("rewsql"+id) )	<"rewsql"+id>.winmove(x, y);
		<"winsql"+id>.move(x,y);
	}
	mhidetxt	{
		tdzad.hide;
		wintxt.hide;
		winbgtxt.hide;
		butok.unclick;
		butok.hide;
		butshow.show;
	}
	mshowtext	{
		tdzad.show;
		winbgtxt.show;
		wintxt.show;
		butok.show;
		butshow.unclick;
		butshow.hide;
	}
	mtekst(string s)	{	dbl.get( dbl.findbyrow(s), 1); }
	mloadvec(string s)	{
		@id = dbl.findbyrow(s);
		vm1.free;
		for( int i=1; i< dbl.getcolsno(id); i++)	{
			vm1.add( dbl.get(id, i) );
		}
	}
	mnextzad	{
		if( izadanie < dbzad.getrowsno)	{
			.mendzad;
			izadanie++;
			.mloadzad;
		} else {
			igmstate = 0;
			ccs.close( func {
				if( PrzygodaMode )
					.gotoadv("adbib", "gameadbib2");
				else gameapi.play("Menu");
				} );
		}
	}
	mprevzad	{
		if( izadanie>1 ) {
			.mendzad;
			izadanie--;
			.mloadzad;
		}
	}
	mendzad	{
		.mdeltabs;
		.mdelquery;
	}
	mdeltabs	{
		for( int i=1; i<=ilesql; i++)	{
			gui.delobj("winsql"+i);
			if( gui.hasvar("rewsql"+i) )	gui.delobj("rewsql"+i);
		}
		ilesql=0;
	}
	mgetpos(int id, string spos)	{
		if( gui.hasvar("rewsql"+id) )	<"rewsql"+id>.<"get"+spos>;
		else <"winsql"+id>.<"get"+spos>;
	}
	mypos(int id)	{
		int y = 0;
		for( int i=1; i<=id; i++)	{
			y+=<"winsql"+i>.geth + 20;
			if( gui.hasvar("rewsql"+i) ) y+=20;
		}
		y;
	}
	mdelquery	{	<GAME> {
		if( .hasvar("tdsql") )	{
			.deletegmobj("tdsql");
			gui.dellist(A,"ttsql","buthelp");
		}
	}; }
	mloadquerry	{
		.mdelquery;
		new TextDb tdsql(stdfont12, 12, "$row:dbsql,"+(izapytanie-1), .white, 9, 566, 2, 100, "left");
		gui.newtextbox("ttsql", .allchars, 600, 140);
		ttsql.winmove(100, 360 );
		gui.newbutton("buthelp", .mtekst("help"), 80, 30);
		buthelp.setpos( ttsqlwnd.getcx - buthelp.getw/2, ttsqlwnd.getey+4 );
	}
	ttsql_activate	{
		ttsql.winsetz( tdzad.getz+100 );
		buthelp.winsetz(ttsql.getz);
		butok.lock;
	}
	ttsql_OUTSIDE	{
		if( !buthelp.isin(mouse.getpos,0,0) )	{
			ttsql.winsetz( 5 );
			buthelp.winsetz(ttsql.getz);
			ttsql.deactivate;
			butok.unlock;
		}
	}
	buthelp_lclick	{
		buthelp.unclick;
		if( igmstate!=1 ) return;
		@row = izapytanie-1;
		ttsql.clear;
		for( int i=1; i<dbcmp.getcolsno(row); i++)	ttsql.setid( dbcmp.get(row,i), i-1 );
	}
	mloadzad	{	<GAME> {
		if( .hasvar("tdzad") )	{
			.deletegmobj("tdzad");
			gui.dellist(A,"wintxt","winbgtxt","butok");
		}
		if( igmdebug )	dbzad.load(.lang_path("zad") + ".db" );
		new TextDb tdzad(stdfont12, 12, "$row:dbzad,"+(izadanie-1), .black, 0,0, 2, 200, "left");
		gui.newwndtext("wintxt", tdzad.getw+8, tdzad.geth+8);
		gui.newwnd("winbgtxt", wintxt.getw+8, wintxt.geth+50);
		winbgtxt.setz(100);
		wintxt.setz(winbgtxt.getz+10);
		gui.newbutton("butok", "OK", 80, 30);
		butok.winsetz(wintxt.getz+10);
		winbgtxt.setpos( 400-winbgtxt.getw/2, 70 );
		butok.setpos( winbgtxt.getcx - butok.getw/2, winbgtxt.getey-10-butok.geth );
		wintxt.setpos( winbgtxt.getpx+4, winbgtxt.getpy+4 );
		tdzad.move( wintxt.getpx+4, wintxt.getpy+4 );
		.mshowtext;
		
		match( izadanie )	{
			7,9,11,13,15,17,19,21,23,25,27,29,31,33 => izapytanie = (izadanie-5)/2;
			8,10,12,14,16,18,20,22,24,26,28,30,32,34 => izapytanie = (izadanie-6)/2;
			? => ;
		}
		
		match( izadanie )	{
			2 => _ = .mquery("select * from wol1;");
			3, 4 => _ = .mquery("select * from wol2;");
			5, 6 => {
				_ = .mquery("select * from autor where nazwisko = 'christa';");
				_ = .mquery("select * from wydawca where nazwa = 'egmont';");
				.mtabmove(2, 0, .mypos(1) );
				_ = .mquery("select * from wolumin where id = 1 or id = 2;");
				.mtabmove(3, 0, .mypos(2));
			}
			7,9,11,13,15,17,19,21,23,25,27,29,31,33 => 	.mloadquerry;
			8,10,12,14,16,18,20,22,24,26,28,30,32,34 => .mviewquery;
			? => ;
		}
	}; }
	mviewquery	{
		_ = .mquery( .mgetrow );
	}
	mouse_rclick	{
		if( igmdebug ) .butok_lclick;
	}
}
game Info : Computro	{
	init	{
		Computro::init("info");
		
		//new img imbg;
		//imbg.create(800,600,.grey(240),255);
		.img = ("bkg.pyz");
		
		new GUI gui("butgame");
		
		.sounds = (A,
			"sndgo1", "Dzisiejszy wiat zalewaj informacje; Codziennie niezliczone wiadomoci pyn do nas z telewizora radia i internetu; Czy jestemy przygotowani na taki natok informacji? Zobaczmy jak y pierwotny czowiek", "mnext",
			"snd1", "Cae ycie otaczaa go przyroda; Jedynym nonikiem informacji by drugi czowiek z ktrym czsto porozumiewa si bez sw", "mnext",
			"snd2", "Ludzie yli w maych spoecznociach a starsi przekazywali modym wiedz; Wiedzy tej nie spisywano wic czsto gina wraz ze mierci dowiadczonych osobnikw", "mnext",
			"snd3", "Duo waniejsza od posiadanej wiedzy bya dla przecitnego czowieka zrczno; Od tego czy rozpali ogie upoluje zwierz lub umknie drapienikowi zaleao jego przeycie", "mnext",
			"snd4", "Przez tysice lat ycie ludzi biego podobnie", "mnext",
			"sndgo2", "Z czasem w ciepych suchych rejonach Ziemi na yznych terenach wzdu rzek powstay due skupiska ludzi", "mnext",
			"snd5", "Ludzie zaczli gromadzi wiedz i stworzyli pierwsze cywilizacje zdolne do budowania skomplikowanych konstrukcji", "mnext",
			"snd6", "Ludzka pami nie wystarczaa do zachowania odkry technicznych i matematycznych", "mnext",
			"snd7", "Dlatego ludzie wymylili pismo; Pierwsi skrybowie uwaani byli za wielkich czarownikw; Zwykli ludzie nie mogli poj jak mona przechowywa wiedz na papirusie lub glinianej tabliczce", "mnext",
			"snd8", "Przez dugi czas litery traktowano jak magiczne znaki; Tymczasem byy to proste rysunki odwzorowujce realne pojcia; Czsto jeden rysunek mia wiele pokrewnych znacze", "mnext",
			"snd9", "Z czasem znaki upraszczano; Pismo rozpowszechniao si i coraz wiksza ilo informacji przechodzia na nastpne pokolenia", func { .mnext; .mshow; },
			"sndgo3", "Lecz jeszcze niespena 300 lat temu przecitny czowiek przeczyta przez cae swoje ycie mniej informacji ni zawiera jedno wydanie dzisiejszego oglnokrajowego dziennika", "mnext",
			"snd10", "Zdecydowana wikszo ludzi ya na wsi i mao kto opuszcza kiedykolwiek rodzinne strony", "mnext",
			"snd11", "Wielkie zmiany nadeszy wraz z rewolucj przemysow pod koniec 18 wieku", "mnext",
			"snd12", "Wynalezienie maszyny parowej umoliwio masowe przemieszczanie ludzi najpierw po Europie pniej po caej kuli ziemskiej", "mnext",
			"snd13", "Pojawia si buruazja; Klasa przedsibiorcw zamieszkujcych due miasta", "mnext",
			"sndgo4", "Zjawiska te day pocztek nowemu porzdkowi spoecznemu Kapitalizmowi a wraz z nim nowej gazi nauki Ekonomii", "mnext",
			"snd14", "Dawniej uczeni formowali rne niesprawdzalne teorie czsto na pograniczu mistyki i religii", "mnext",
			"snd15", "Wraz z rewolucj przemysow rozwija si jednak nowy typ naukowca; Wolnego od ideologii i szukajcego potwierdzenia swoich teorii w cisych obserwacjach przyrody", "mnext",
			"snd16", "Jego praca wizaa si z wykonywaniem niezliczonych pomiarw i wymagaa coraz bardziej rozbudowanego aparatu matematycznego", "mnext",
			"snd17", "Ilo odkry i wiedza o wiecie rosa tak szybko e aby normalnie funkcjonowa w spoeczestwie wszystkie dzieci musiay zacz chodzi do szkoy", "mnext",
			"sndgo5", "Dzisiaj dzienna dawka informacji ktr przetwarza pojedynczy czowiek jest wiksza ni kiedykolwiek; Czy nasze organizmy przystosowane przez prawie ca histori gatunku ludzkiego do ycia pord przyrody wytrzymaj takie natenie?", "mnext"
			);
		new int iscena = 1;
		new int ishow = 0;
		new int iwav = 1;
		new gmimgvec grels;
		.mloadscene;
	}
	mloadscene	{
		grels.deleteallgm;
		grels.free;
		"grels" .* ("scena"+iscena+".pyz");
		grels.hide;
		ishow=0;
		.mshow;
		.cbplay("sndgo"+iscena);
	}
	mshow	{
		<grels.get(ishow)>.show;
		ishow++;
	}
	mnext	{	<GAME>	{
		if( ishow>=grels.size )	{
			iscena++;
			if(iscena>5 )	<GAME>.mplay;
			else {
				.mloadscene;
			}
		} else {
			.mshow;
			.cbplay("snd"+iwav);
			iwav++;
		}
	}; }
	mplay	{
// 		grels.deleteallgm;
// 		grels.free;
		ccs.close( func { .gotoadv("adaula", "gameadaula0"); } );
		//gui.newcheckbox("cb1");
		//cb1.winsetpos(400,300);
	}
	mouse_lclick	{
		if( igmdebug ) .cactsndstop(true);
	}
	mouse_rclick	{
		if( igmdebug ) clpause.pause;
	}
}
game Logika : Computro {
	init	{
		Computro::init("logika");
		.img = ("bg.pyz");
		new int izadanie =1;
		.sounds = (A,
			"sndgo", "Klikaj na czarnych przewodach w taki sposb by przyjy poprawny kolor", func { .cbplay("snd1"); },
			"snd1", "Po lewej stronie widzisz jaki kolor powstaje w wyniku mieszania w odpowiednich bramkach", "mstart"
			);
		new gmimgvec grels;
		.mloadzad;
		//.cbplay("sndgo");
		ccs.enter( func { .cbplay("sndgo"); } );
	}
	mstart	{
		igmstate = 1;
	}
	mloadzad	{
		grels.deleteallgm;
		grels.free;
		"grels" ..< "zad"+izadanie+".pyz";
	}
	mouse_lclick	{
		if( igmdebug ) .cactsndstop(true);
		if( igmstate != 1 ) return;
		if( grels.isin(mouse.getpos, 1,1) && grels.getfound>0)	{
			@s = grels.getsfound;
			if( .miscol(s, "mblue") )	<s>.paint( .red, 255, 0 );
			else <s>.paint( .mblue, 255, 0 );
			for( int i=1; i<grels.size; i++)	{
				s = grels.get(i);
				if( !.miscol( s, .mgetcol( <s>.framename ) ) ) return;
			}
			if( izadanie<8 )	{
				izadanie++;
				.mloadzad;
			} else {
				igmstate = 15;
				ccs.close( func { .gotoadv("adsala", "gameadsala0"); } );
			}
		}
	}
	mouse_move	{
		if( grels.isin(mouse.getpos, 1,1) && grels.getfound>0 )	{
			if( bsms.isstd ) bsms.setact;
		} else if (bsms.isact ) bsms.setstd;
	}
	mgetcol(int id)	{	id ? "mblue" : "red";	}
	mblue	{	return 69, 170, 255;	}
	miscol(string s, string scol)	{
		int r[3], int c[3];
		//|r0,r1,r2| = <s>.getrgb( <s>.anfirstnontr );
		|r0,r1,r2| = <s>.getrgb( classansearcher::firstnotrx1y(s) );
		|c0,c1,c2| = .<scol>;
		r0==c0 && r1==c1 && r2==c2;
	}
	mouse_rclick	{
		if( igmdebug ) {	izadanie++; .mloadzad; }
	}
}

new db dbTurniej;
new int TurniejLevel;
game Turniej : Computro	{
	init	{
		Computro::init("turniej");
		advmouse.setstd;
		
		TurniejLevel = 1 + clsave.get("TurniejLevel");
		
		.sounds = (A,
			":ania1", "Co teraz? Te roboty nie przejawiaj przyjacielskich zamiarw", func { .cbplay("fel1"); },
			":fel1", "Wszdzie walaj si jakie czci; Zbudujemy nasze roboty; Pomoesz nam Zak?", func { .cbplay("zak1"); },
			":zak1", "Jasne; Znam co nieco te podzespoy; Najpierw poszukajmy bateri", func { .cbplay("ania2"); },
			":ania2", "Mam bateri; Chyba wiem o co chodzi", func { .cbplay("ania3"); },
			":ania3", "Kady element robota zabiera kawaek mocy baterii; Musimy zoy robota ktry stanie do walki", func { .cbplay("zak2"); },
			":zak2", "Czytajcie opisy urzdze i zcie zwyciskiego robota", "mstart",
			":ania4", "Robot gotowy do pojedynku", null,
			":ania8", "Robotowi brakuje mocy obliczeniowej", null,
			":ania9", "Robot zuywa za duo energii", null
			);
// 		bkg.pyz        robo.pyz     szeyes.pyz  szhead.pyz  szufw.pyz
// robocorps.pyz  szarmor.pyz  szhand.pyz  szuf.pyz    szwheels.pyz
		
		.imgs = (A, "bkg.pyz", "robocorps.pyz 30", "ikoi.pyz 50", "ikoe.pyz 50");
		anikoi.move(0,5);
		anikoe.move(0,5);
		new gmimgvec grszuf;
		"grszuf" .* "szuf.pyz";
		new gmimgvec grszufw;
		"grszufw" .* "szufw.pyz";
		grszufw.hide;
		new gmimgvec grobo;
		"grobo" ..< "robo.pyz";
		grobo.setz(60);
		grobo.hide;
		new img anitem;
		anitem.setz(100);
		anitem.vars2(A, "szuflada", null, "sobject", null);
		
		new font fncyf;
		fncyf.load("configs/fonts/ala.ttf", 14);
		.newtext("txti", "", "fncyf", .micol);
		.newtext("txte", "", "fncyf", .mecol);
		txti.setpos( anikoi.getcx+5, anikoi.getcy - txti.geth/2);
		txte.setpos( anikoe.getcx+5, anikoe.getcy - txte.geth/2);
		
		new int Energy;
		new int Armor;
		new int Speed;
		new int Power;
		new int Supply;
		new int Inteligence;
		new string stdfont12 = .stdfont(12);
		new int istdfont = 12;
		new string slasthelp = null;
		
		.newdb("dbwsp", "wspolczynniki.db");
		.newdb("dblev", "levele.db");
		.lang_db("dblevel", "level");
		new db dbl;
		dbl.dbcopy("dblevel");
		dbl.dbremovecol(0);
		
		new ConImgMover cmov;
		new GUI gui("butgame");
		
		anrobocorps.Button_isin;
		anrobocorps.Button_moveoffms;
		anrobocorps.addmethod("butmoveon", func { advmouse.setexit; });
		butgame.add("anrobocorps");
		anrobocorps.vars2(A, "shead", null, "sarmor",null, "shand", null, "seyes", null, "srhand", null, "swheels", null);
		
		new int ilevel = TurniejLevel;
		.msetlevel;
		
		new string sactszuf = null;
		grobo.eval( func {
			.Button_isinalpha;
			.Button_moveoffms;
			.Button_moveonms;
			.addmethod("butclick", func {
				if( igmstate!=1 ) return;
				
				anitem.clone(this);
				anitem.setz(100);
				anitem.sobject = (sobject);
				anitem.szuflada = (szuflada);
				cmov.mssetobj("anitem");
				
				.hide;
				if( sobject == "anszarmor3" )	{
					.mgetrobo( anrobocorps.srhand );
					anrobocorps.srhand=(null);
				} else {
					.mgetrobo( anrobocorps.<"s"+szuflada> );
					anrobocorps.<"s" + szuflada + "=">(null);
				}
				} );
			.addmethod("butlrel", "mcheckput");
			.vars2(A, "sitem", null, "szuflada", null, "sobject", null);
			if( .actionnr(-1)==1 ) .setz(20);
			} );
		butgame.addgroup("grobo");
		grszuf.eval( func {
			.setz(15);
			<GAME> (this) { (string s)
				s = <s>.actionname;
				@sgr = "gr" + s;
				new gmimgvec <sgr>;
				sgr .* ("sz"+s+".pyz");
				<sgr>.setz(20);
				<sgr>.eval1( func { (@sszuf)
					.Button_isin;
					.addmethod("butmoveon", func {
						if( igmstate!=1 ) return;
						if( .framenr<2 ) advmouse.setbut;
						.mprinthelp(sactszuf+"_"+.actionnr(-1));
						} );
					.addmethod("butmoveoff", func {
						advmouse.setstd;
						.mprinthelp("intro");
						} );
					.addmethod("butclick", func {
						if( igmstate!=1 ) return;
						if( .framenr==0 )	{
							anitem.clone(this);
							anitem.setz(100);
							anitem.sobject = (this);
							anitem.szuflada = (sactszuf);
							cmov.mssetobj("anitem");
							.setframe(-1,2);
						}
						} );
					.addmethod("butlrel", "mcheckput");
					@id = dbwsp.findbyrow(sszuf) + .actionnr(-1);
					.vars2(A, "szuflada", sszuf, "energy", dbwsp.get(id, 2)->to_i, "inteligence", dbwsp.get(id, 3)->to_i,
						"armor", dbwsp.get(id, 4)->to_i, "speed", dbwsp.get(id, 5)->to_i, "power", dbwsp.get(id, 6)->to_i );
					}, s );
				butgame.addgroup(sgr);
				<sgr>.hide;
			};
			.Button_std;
			.addmethod("butclick", func {
				<GAME>.mwysun(.actionname);
				} );
			} );
		@s[3];
		for( int i=0; i<grobo.size; i++)	{
			s0 = grobo.get(i);
			s1 = <"gr"+<s0>.actionname>.get( <s0>.framenr );
			<s0>.sobject = (s1);
			<s0>.szuflada = (<s0>.actionname);
			<s1>.var2("srobo", s0);
		}
		butgame.addgroup("grszuf");
		
		gui.newbutton("butgo", dblevel.get( dblevel.findbyrow("start"), 1 ), 110, 25);
		butgo.setz(100);
		butgo.setpos( iResX-butgo.getw-5, 4 );
		
		.mprinthelp("intro");
		
		ccs.enter( func {
			if( !clsave.bis("pogadali_wstep_do_turnieju") )	{
				clsave.bset("pogadali_wstep_do_turnieju");
				.cbplay("ania1");
			} else
				.mstart;
			} );
		//.cbplay("ania1");
	}
	mstart	{	igmstate=1;	}
	mcheckput	{
		if( cmov.moving )	{
			cmov.free;
			anitem.hide;
			butgame.sclicked = (null);
			if( anrobocorps.isin(mouse.getpos, 1,0) )	{
				@s = anitem.sobject;
				@sszuf = anitem.szuflada;
				if( s=="anszarmor3" )	{	// tarcza
					anrobocorps.srhand=(s);
				} else {
					.mremrobo( anrobocorps.<"s"+sszuf> );
					anrobocorps.<"s"+sszuf+"="> (s);
				}
				.maddrobo(s);
			} else .mretitem(anitem.sobject);
		}
	}
	micol		{	return 255,255,25;	}
	mecol	{	return 25,255,25;		}
	merrcol	{	return 255,25,25;		}
	mupdate	{
		txti.txtsetcol(Inteligence, ( Inteligence>=0 ? .micol : .merrcol ) );
		txte.txtsetcol(Energy, ( Energy>=0 ? .mecol : .merrcol ) );
	}
	maddrobo(string s)	{
		< <s>.srobo>.show;
		.mupdateei(s, 1);
	}
	mgetrobo(string s)	{
		if(s!=null) {
			< <s>.srobo>.hide;
			.mupdateei(s,-1);
		}
	}
	mremrobo(string s)	{
		.mgetrobo(s);
		if( s!=null )	.mretitem(s);
	}
	mupdateei(string sitem, int mnoz)	{
		if( sitem!=null )	{
			Energy += mnoz * <sitem>.energy;
			Inteligence += mnoz * <sitem>.inteligence;
			Armor += mnoz * <sitem>.armor;
			Speed += mnoz * <sitem>.speed;
			Power += mnoz * <sitem>.power;
			.mupdate;
			.mcheckpower;
		}
	}
	msetlevel	{
		Energy = dblev.get(ilevel,0);
		Supply = Energy;
		Armor = 4;
		Speed = 0;
		Power = 1;
		Inteligence = 0;
		.mupdate;
	}
	mcheckpower	{
		if( sactszuf!=null )	{
			<"gr"+sactszuf>.eval( func {	if( .framenr<2 )	.msetpower; } );
		}
	}
	msetpower	{	.setframe(-1, (Energy+energy<0 || Inteligence+inteligence<0) );	}
	mretitem(string s)	{
		//<s>.setframe(-1, 0);
		<s>.msetpower;
	}
	mwysun(string s)	{
		if( s==sactszuf )	return .mwsun;
		.mwsun;
		sactszuf = s;
		<grszufw.getsac(s)>.show;
		<"gr"+s>.show;
		.mcheckpower;
	}
	mwsun	{
		if( sactszuf!=null )	{
			<"gr"+sactszuf>.hide;
			<grszufw.getsac(sactszuf)>.hide;
			sactszuf = null;
		}
	}
	mprinthelp(string s)	{	<GAME> (s) { (@s)
		if( slasthelp==s ) return;
		slasthelp = s;
		if( .hasvar("tdzad") )	.deletegmobj("tdzad");
		new TextDb tdzad(stdfont12, 12, "$row:dbl,"+dblevel.findbyrow(s), .grey(32), 13,514, 2, 200, "left");
	}; }
	mouse_lclick	{
		if( igmdebug ) .cactsndstop(true);
		if( igmstate!=1 ) return;
		@s = butgame.sclicked;
		if( s==null )	.mwsun;
	}
	/************************************/
	mcopywsp	{
		dbTurniej.free;
		_ = dbTurniej.addrow;
		dbTurniej.add(0,null);
		@s;
		for( int i=0; i<grobo.size; i++)	{
			s = grobo.get(i);
			if( <s>.isvisible )	{
				dbTurniej.add(0, <s>.actionname);
				dbTurniej.add(0, <s>.framenr);
			}
		}
		dbTurniej.save("saves/dbTurniej"+PrzygodaNumer+".db");
		//dbTurniej.dbaddrow(A, "wspolczynniki", "Energy", Energy, "Inteligence", Inteligence, "Armor", Armor, "Speed", Speed, "Power", Power);
	}
	butgo_lclick	{
		butgo.unclick;
		if( Inteligence<0 )	return .cbplay("ania8");
		else if (Energy<0)	return .cbplay("ania9");
		igmstate = 3;
		claskexit.ask( "ania4", "sndakskermovon", "sndakskermovon", func {
				<GAME>.mcopywsp;
				gameapi.play("Turniejvs");
			}, func {
				igmstate=1;
			} );
	}
}

game Turniejvs : Computro	{
	init	{
		TurniejLevel = 1 + clsave.get("TurniejLevel");
		dbTurniej.load("saves/dbTurniej"+PrzygodaNumer+".db");
		
		Computro::init("turniejvs");
		.path = ("turniej");
		advmouse.setstd;
		.newdb("dbl", "vs.db");
		.imgs=(A,"bgvs.pyz", "robocorps.pyzH", "robo.pyzH", "vsnr.pyz 5");
		anvsnr.setframe(0, TurniejLevel-1);
		new img imr1;
		imr1.create(500, 600, .transparent );
		imr1.setpos(iResX-imr1.getw, 0);
		new img imr2;
		imr2.create(500, 600, .transparent );
		imr2.setpos(iResX-imr2.getw, 0);
		.mkrob("imr1", "dbl", TurniejLevel);
		new filter ftrob;
		ftrob.link("imr1");
		ftrob.reversexy(1,0);
		imr1.setpos(0, imr1.getpy );
		.mkrob("imr2", "dbTurniej", 0);
		.timer = ("timfight", 4000, func {
			ccs.close( func { gameapi.play("Arena"); } );
			} );
		timfight.play;
	}
	mkrob(string simg, string sdb, int row)	{
		<simg>.blit("anrobocorps");
		@s;
		for( int i=1; i< <sdb>.getcolsno(row); i+=2)	{
			anrobo.setframe( <sdb>.get(row, i), <sdb>.get(row,i+1) );
			<simg>.blit("anrobo");
		}
	}
	mouse_lclick	{
		if( igmdebug )	timfight.stop(true);
	}
}

game Arena : Computro	{
	init	{
		// tmp
// 		dbTurniej.free;
// 		dbTurniej.dbaddstringrow("null hand 2 armor 2", " ");
		//
		TurniejLevel = 1 + clsave.get("TurniejLevel");
		dbTurniej.load("saves/dbTurniej"+PrzygodaNumer+".db");
		
		Computro::init("arena");
		advmouse.setstd;
		
		.sounds = (A,
			":ania5", "Ten robot by za silny na nas; Zbudujemy nowego", "mturniej",
			":ania6", "Hurra! Zwycistwo", func {
				TurniejLevel++;
				clsave.set("TurniejLevel", TurniejLevel-1);
				if(TurniejLevel<=5 ) .cbplay("ania7");
				else 	.gotoadv("adparkiet", "gameadparkiet");
				} ,
			":ania7", "O nie; Jeszcze jeden robot", "mturniej"
			);
		
		.imgs = (A, "bkg.pyz", "robo.pyzH 10", "bumH.pyz 50", "rozbity.pyzH 10");
		new img imbg;
		imbg.clone("anbkg");
		delete anbkg;
// 		imbg.imgborders(50, .black, 64);
		
		for( int i=0; i<10; i++)	.copyanima("anbum", "anbu"+i);
		new classobjcounter clbu("anbu");
		
		new int W = 50;
		new int H = 50;
		new int Rows = 10;
		new int Cols = 14;
		new int X = 50;
		new int Y = 50;
		new int X1 = 50;
		new int X2 = iResX - X1;
		new int Y1 = 50;
		new int Y2 = iResY - Y1;
		new int odstep = 28;
		
		new classsndbank sndbum;
		sndbum.load("sfx/bum", 1, 4, 0, 1);
		.sfxs = (A, "fire1");
		
		.newdb("dbl", "$scripts/turniej/vs.db");
		.newdb("dbwsp", "$scripts/turniej/wspolczynniki.db");
		new gmimgvec rob1;
		new gmimgvec rob2;
		
		new vector vrob;	vrob.type("string");
		.mkrob("rob1", "dbTurniej", 0, "green", "rob2");
		.mkrob("rob2", "dbl", TurniejLevel, "red", "rob1");
		
		rob2.mputrob(Rows/2, 0, 1);
		rob1.mputrob(Rows/2, Cols-1,3);
		
		new GUI gui("butgame");
		.lang_db("dbt","txt");
		gui.newbutton("butreset", dbt.get( dbt.findbyrow("reset"), 1 ), 150, 25);
		butreset.setz(100);
		butreset.setpos( iResX-butreset.getw-5, 4 );
		gui.newbutton("butnowy", dbt.get( dbt.findbyrow("nowy"), 1 ), 150, 25);
		butnowy.setz(100);
		butnowy.setpos( butreset.getpx-butnowy.getw-5, butreset.getpy );
		
		.cycle = ("timcyk", func {
			rob1.mthinkrob;
			rob2.mthinkrob;
			if( rob1.attack && rob2.attack )	{
				rob1.mattack;
				rob2.mattack;
				.modbij;
			} else if (rob1.attack) {
				rob1.mattack;
				rob1.mbum(1);
				rob2.mface;
				.modbij;
			} else if (rob2.attack) {
				rob2.mattack;
				rob2.mbum(1);
				rob1.mface;
				.modbij;
			}
			if( rob1.malive && rob2.malive )
				.play;
			else {
				if( rob1.malive )	.cbplay("ania6");
				else .cbplay("ania5");
			}
			});
		ccs.enter( func { igmstate=1; .mgo; } );
	}
	butreset_lclick	{
		if( !.cisplaying )
			gameapi.play("Arena");
	}
	butnowy_lclick	{
		if( !.cisplaying )
			.mturniej;
	}
	mturniej	{	gameapi.play("Turniej");	}
	mgo	{
		timcyk.play;
	}
	modbij	{
		if( rob1.malive )	{
			rob1.mturn(-2);
			rob1.movrob;
		}
		if( rob2.malive )	{
			rob2.mturn(-2);
			rob2.movrob;
		}
	}
	mkrob(string sgr, string sdb, int row, string sfun, string senemy)	{
		@s[4];
		s0 = "im"+sgr;
		new img <s0>;
		<s0>.create(W, H, .<sfun>, 128);
		vrob.free;
		for( int i=1; i< <sdb>.getcolsno(row); i+=2)	vrob.add( <sdb>.get(row, i) +"_"+ <sdb>.get(row,i+1) );
		<sgr>.vars2(A, "Energy", 0, "Inteligence", 0, "Armor", 4, "Speed", 0, "Power", 1, "charge", 0);
		
		s2 = sgr + "r";
		new gmimgvec <s2>;
		
		for( i=0; i < anrobo.nofactions; i++)	{
			s0 = anrobo.nameofaction(i);
			if( s0=="corps" || vrob.contains(s0) )	{
				if( s0=="corps" ) {
					s1 = "an" + sgr + "corp";
				} else {
					s1 = "an" + sgr + <sgr>.size;
					<sgr> (s0) { (string s0)
						@id = dbwsp.findbyrow( s0.strgetto("_") ) + s0.strgetfrom("_");
						Inteligence += dbwsp.get(id, 3);
						Armor += dbwsp.get(id, 4);
						Speed += dbwsp.get(id, 5);
						Power += dbwsp.get(id, 6);
					};
				}
				.copyanima("anrobo", s1);
				<s1>.setframe(s0, 0);
				<sgr>.add(s1);
				s3 = s1 + "r";
				.copyanima("anrozbity", s3);
				<s3>.setframe(s0,0);
				<s2>.add(s3);
			}
		}
		<sgr>.show;
		<sgr>.vars2(A, "Row", 0, "Col", 0, "Dir", 0, "idbrow", row, "sdbase", sdb, "enemy", senemy, "enemycorp", "an"+senemy+"corp",
			"attack", 0, "licznik", 0);
		<sgr> {
			if( Speed<0 ) Speed=0;
			if( Power<0 ) Power=0;
			if( Armor<0 ) Armor=0;
			.var2("Step", 3.0*Speed);
			new img imred;
			new img imgreen;
			imred.create( 52, 7, .red, 240 );
			imred.imgborders(1, .black, 255);
			new real live = Armor;
			imgreen.create(50, 5, .green, 240);
			if( .mitem("hand") == 2 )	{
				new img imgun;
				imgun.create(2, 2, .grey(16), 255);
				imgun.setz(40);
				imgun.hide;
				new int gundir;
				.cycle = ("timgun", func {
					match(gundir)	{
						0 => imgun.move(0, -12);
						1 => imgun.move(12, 0);
						2 => imgun.move(0, 12);
						3 => imgun.move(-12, 0);
						? => ;
					}
					@x = imgun.getcx;
					@y = imgun.getcy;
					if(  !clsurf.inscreen(x, y, 0, 0) ) imgun.hide;
					else {
						@s = "an" + enemy + "corp";
						if( 0->length(x-<s>.getcx, y-<s>.getcy) < odstep )	{
							<enemy>.mbum(1);
							imgun.hide;
						} else .play;
					}
					} );
			}
		};
	}
	mputrob(int r, int c, int dir)	{
		Row = r;
		Col = c;
		Dir = dir;
		.setframe(-1,dir);
		@x = X+c*H;
		@y = Y+r*W;
		.setpos(x, y);
		<"im"+this>.setpos(x, y);
		imred.setpos(x-1, y-imred.geth-1);
		imgreen.setpos(x,imred.getpy+1);
	}
	mthinkrob	{
		licznik++;
		int intel = .mitem("eyes");
		if( .checkwall(0, Step) )	{
			match( intel )	{
				0 => .mturn( 2->rand ? -1 : 1 );
				1, 2, 3 => .checkwall(-1, Step) ? .mturn(1) : .mturn(-1);
				? => {
					.mbum(1);
					.mturn(2);
				}
			}
		} else if ( .mclose )	{
			if( charge>3 && .menemypos==Dir )	{
				charge = 0;
				attack = 1;
			} else {
				match(intel)	{
					2 => {
						if( Power < <enemy>.Power && 3->rand )	{
							.muciekaj;
						} else if( 3->rand==0) .matakuj;
						else .muciekaj;
					}
					3 => {
						if( Power < <enemy>.Power && 2->rand )	{
							.muciekaj;
						} else if( 3->rand==0) .matakuj;
						else .muciekaj;
					}
					? => 2->rand ? .muciekaj : .matakuj;
				}
			}
		} else {
			match(intel)	{
				-1 => {
					.movrob;
				}
				0 => .movrob;
				1 => if( licznik>50 ) {
					if( 5->rand==0 ) .mface;
					else .mturn(4->rand);
				} else .movrob;
				2 => if( licznik>35)	{
					if( 3->rand==0 && .hasvar("timgun") ) {
						.mface;
						.mfire;
					} else if( !.oposite && 3->rand )	{
						.mface;
						.movrob;
					} else .mturn(4->rand);
				} else .movrob;
				3 => if( licznik>25)	{
					if( 2->rand==0 && .hasvar("timgun") ) {
						.mface;
						.mfire;
					} else if( !.oposite && 2->rand )	{
						.mface;
						.movrob;
					} else .mturn(4->rand);
				} else .movrob;
				? => ;
			}
		}
	}
	mfire	{
		if( .hasvar("timgun") )	{
			int x[2];
			match(Dir)	{
				0 => { x0 = .mgetex-5; x1 = .mgetpy+10; }
				1 => { x0 = .mgetex-5; x1 = .mgetey-10; }
				2 => { x0 = .mgetpx+5; x1 = .mgetey-10; }
				3 => { x0 = .mgetpx+5; x1 = .mgetpy+10; }
				? => ;
			}
			imgun.setpos( x0, x1);
			imgun.show;
			gundir = Dir;
			fxfire1.play;
			timgun.play;
		}
	}
	matakuj	{
		.mface;
		charge=0;
		attack=1;
	}
	muciekaj	{
		.mface;
		.mturn(-2);
		.movrob;
	}
	mmove(int x, int y)	{
		.move(x,y);
		<"im"+this>.move(x,y);
		imred.move(x,y);
		imgreen.move(x,y);
		.mupdatebum;
	}
	mupdatebum	{	imgreen.clip(imgreen.getpx, imgreen.getpy, imgreen.getpx+(50.0 * Armor)/live, imgreen.getey);	}
	mattack	{
		.mciach(Power);
		attack = 0;
	}
	mbum(int ile)	{
		Armor-=ile;
		@s = clbu.get;
		<s>.setpos( .mgetcx, .mgetcy );
		<s>.play(0);
		sndbum.bgplay;
		.mupdatebum;
		if( Armor<=0 )	{
			if( rob1.Armor>0 && TurniejLevel>=5 ) return;	// nie psuj ostatniego
			.hide;
			s = this + "r";
			<s>.move(.mgetcx-<s>.getw/2, .mgetcy-<s>.geth/2);
			<s>.show;
		}
	}
	mciach(int ile)	{	<enemy>.mbum(ile);	}
	bool malive	{	Armor>0;	}
	mclose	{	.modleg < 2*odstep;	}
	modleg	{	0->length( .mgetcx-<enemy>.mgetcx, .mgetcy - <enemy>.mgetcy );	}
	movrob	{
		charge++;
		match(Dir)	{
			0 => .mmove(0, -Step);
			1 => .mmove(Step, 0);
			2 => .mmove(0, Step);
			3 => .mmove(-Step, 0);
			? => ;
		}
	}
	mface	{	.mturn(.menemypos-Dir);	}
	mturn(int kat)	{
		charge = 0;
		licznik=0;
		Dir = .getkat(kat);
		.setframe(-1,Dir);
	}
	mitem(string s)	{
		@id = <sdbase>.dbfindinrow(idbrow, s);
		id>=0 ? <sdbase>.get(idbrow, id+1) : -1;
	}
	int getkat(int kat)	{
		int dir = Dir + kat;
		if( dir<0 ) dir += 4;
		else if (dir>3) dir%=4;
		dir;
	}
	bool oposite	{	rob1.Dir == rob2.getkat(-2);	}
	bool checknext(int kat, int ds, int x1, int x2, int y1, int y2)	{
		.checkbum(.getkat(kat), ds, x1, x2, y1, y2);
	}
	bool checkwall(int kat, int ds)	{
		.checkbum(.getkat(kat), ds, X1, X2, Y1, Y2);
	}
	bool checkrob(int kat, int ds)	{
		.checkbum( .getkat(kat), ds, <enemy>.mgetpx, <enemy>.mgetex, <enemy>.mgetpy, <enemy>.mgetey );
	}
	mgetcx	{	<"an" + this + "corp">.getcx;	}
	mgetpx	{	.mgetcx - odstep;	}
	mgetex	{	.mgetcx + odstep;	}
	mgetcy	{	<"an" + this + "corp">.getcy;	}
	mgetpy	{	.mgetcy - odstep;	}
	mgetey	{	.mgetcy + odstep;	}
	bool checkbum(int dir, int ds, int x1, int x2, int y1, int y2)	{
		match(dir)	{
			0 => .mgetpy+ds < y1;
			1 => .mgetex+ds > x2;
			2 => .mgetey+ds > y2;
			3 => .mgetpx+ds < x1;
			? => ;
		}
	}
	int menemypos	{
		real dx = .mgetcx - <enemy>.mgetcx;
		real dy = .mgetcy - <enemy>.mgetcy;
		if( dy==0 )	{
			dx > 0 ? 3 : 1;
		} else {
			real r = (dx/dy)->abs;
			if( dx>0 )	{	// lewo
				if( dy<0 )	{	// dol
					r>1 ? 3 : 2;
				} else {		// gora
					r>1 ? 3 : 0;
				}
			} else {		// prawo
				if( dy<0 )	{	// dol
					r>1 ? 1 : 2;
				} else {
					r>1 ? 1 : 0;
				}
			}
		}
	}
	mouse_rclick	{
		if( igmdebug )	{
			rob2.mbum(20);
		}
	}
}
game Preintro : Computro	{
	init	{
		Computro::init("preintro");
		
		.imgs = (A,"bkg.pyz", "swiatlo.pyz 20", "okoH.pyz 130", "napisyH.pyz 140", "robo.pyz 110", "ekrany.pyz 25", "wiatrakP.pyz 15",
			"iskryH.pyz 105", "wyjscieH.pyz 30");
		.copyanima("anekrany", "anekrany2");
		anekrany2.setframe(1,0);
		.copyanima("annapisy", "annapisy2");
		annapisy2.setframe(0,1);
		anrobo.addmethod("onfinish", func {
			if( ilicz==10 )	{
				ilicz++;
				timgo.delay(4500);
				.play("dark2");
				answiatlo.setframe("dark", 0);
				timgo.play;
				fxrobocik3.stop(false);
			}
			} );
		anwyjscie.addmethod("onfinish", func {
			timgo.delay(500);
			timgo.play;
			} );
		mus.playstr("podziemia.ogg -l -v 50");
		
		.lang_db("dbtur", "napis");
		new string sfont32 = .stdfont(32);
		.newtext("txttur", dbtur.get(0,0), sfont32, .grey(248));
		txttur.setpos( (iResX-txttur.getw)/2, iResY-txttur.geth-5 );
		txttur.setz(180);
		txttur.hide;
		
		.sfxs = (A, "wlacznik3 60", "bgrwiatrakN 70", "robocik2 70", "robocik3 70", "podnapis 60", "perun 70", "alarm 60", "iskry 60");
		
		new int ilicz = 0;
		.timer = ("timgo", 4000, func {
			<GAME> {
				match( ilicz )	{
					0, 2, 4 => .mlamp(200);
					1 => .mdark(4000);
					3 => .mdark(250);
					5 => .mdark(2500);
					6 => {
						//.mlamp(500);
						answiatlo.setframe("iskry",0);
						fxiskry.play;
						aniskry.anplayfin( 0, func {
							.hide;
							answiatlo.setframe("dark",0);
							anwyjscie.play(0);
							fxalarm.play;
							} );
					}
					8 => {
						answiatlo.setframe("light",0);
						fxwlacznik3.play;
						anrobo.setframe("light", 0);
						timgo.delay(1000);
						mus.fadeout(800);
					}
					9 => {
						mus.playstr("plama.ogg -v 60");
						anrobo.play("light");
						fxrobocik3.play;
					}
					11 => {
						anoko.show;
						fxrobocik2.play;
						timgo.delay(1000);
					}
					12 => {
						anoko.anplayfin( 0, func {
						ilicz++;
						timgo.delay(2000);
						fxrobocik2.play;
						annapisy.show;
						timgo.play;
						} );
					}
					14 => {
						annapisy2.show;
						fxperun.play;
						txttur.show;
						txttur.txtshadow(1,sfont32);
						timgo.delay(3000);
					}
					15 => .mkoniec;
					? => ;
				}
				ilicz++;
			};
			if( !ilicz.in(A,7,10,13,16) )
				.play;
			} );
		timgo.play;
		ccs.enter( null );
	}
	mlamp(int delay)	{
		timgo.delay(delay);
		answiatlo.setframe("lamp",0);
		anrobo.setframe("lamp",0);
		fxwlacznik3.play;
	}
	mdark(int delay)	{
		timgo.delay(delay);
		answiatlo.setframe("dark",0);
		anrobo.setframe("dark",0);
	}
	mkoniec	{
		if( igmstate==0 )	{
			ccs.close( "mkoniec2" );
			mus.fadeout(1000);
			igmstate = 1;
		}
	}
	mkoniec2	{
		gameapi.play("Menu");
	}
	mouse_lclick	{
		.mkoniec;
	}
	mouse_rclick	{
		if( igmdebug ) timgo.stop(true);
	}
}

new bool PrzygodaMode = false;
new int PrzygodaNumer = 1;

game Menu : Computro	{
	init	{
		clsave.free;
		clsave.set("game_day", 1);
		clsave.set("otwarte_31", 0);
		
		PrzygodaMode = false;
		Computro::init("menu");
		new classfullsave sav("saves/Menu.txt");
		sav.stdload;
		//bkg.pyz    kaplica.pyz  napisy_rozpocznij.pyz  ptaki.pyz       tab_przygoda.pyz
		//gmach.pyz  lekcje.pyz   przygoda.pyz           tab_lekcja.pyz
		.imgs = (A, "bkg.pyz", "kaplicaH.pyz 5", "gmachH.pyz 5", "napisy_rozpocznijH.pyz 5", "ptaki.pyz 3",
			/*"tab_przygodaH.pyz 20", "tab_lekcjaH.pyz 20",*/ "tabliceH.pyz 20");
		
		.newsnd("sndnowa", "narnew");
		.newsnd("sndload", "narload");
		.newsnd("sndraz", "narrestart");
		.newsnd("sndyes", "naryes");
		.newsnd("sndno", "narno");
		
		new Button butg;
		
		new gmimgvec grlek;
		"grlek" .* "lekcje.pyz";
		grlek.setz(30);
		grlek.eval( func {
			.Button_isin;
			.addmethod("butmoveon", func {
				//if( igmstate!=2 ) return;
				sndakskermovon.play;
				advmouse.setact;
				.setframe(-1,1);
				<"td"+.actionname>.show;
				} );
			.addmethod("butmoveoff", func {
				//if( igmstate!=2 ) return;
				advmouse.setstd;
				.setframe(-1,0);
				<"td"+.actionname>.hide;
				} );
			.addmethod("butclick", func {
				if( igmstate!=2 ) return;
				PrzygodaMode = false;
				match( .actionname )	{
					"sql" => "Sql";
					"gimp" => "Gimp";
					"grafa" => "Obrazy";
					"logo" => "Turtle";
					? => ;
				}
				sGame = _;
				.mstart;
				} );
			} );
			
		.lang_db("dblek", "lekcja");
		@ifont = 16;
		@sfont = .stdbold(ifont);
		new gmimgvec grtyt;
		.mktyt("sql", 0, sfont, ifont);
		.mktyt("logo", 1, sfont, ifont);
		.mktyt("grafa", 2, sfont, ifont);
		.mktyt("gimp", 3, sfont, ifont);
		
		new gmimgvec gradv;
		"gradv" .* "przygoda.pyz";
		gradv.setz(30);
		@s[2];
		for( int i=0; i<gradv.size; i++)	{
			s0 = gradv.get(i);
			s1 = <s0>.actionname;
			if( s1.getb(0,4)=="load" )	{
				if( !sav.bis("load"+s1.strsubb(4)) ) {
					gradv.remove(s0);
					<s0>.hide;
					i--;
				}
			}
		}
		gradv.eval( func {
			.Button_isin;
			.addmethod("butmoveon", func {
				sndakskermovon.play;
				advmouse.setact;
				.setframe(-1,1);
				if( .actionname->getb(0,4)=="load" )	.cbselfplay("sndload");
				else .cbselfplay("sndnowa");
				} );
			.addmethod("butmoveoff", func {
				advmouse.setstd;
				.setframe(-1,0);
				} );
			.addmethod("butclick", func {
				if( igmstate!=2 ) return;
				PrzygodaMode = true;
				@s = .actionname;
				if( s.getb(0,4)=="load")	{
					PrzygodaNumer = s.strsubb(4);
					igmstate = 3;
					classadvinfo2::advload_game;
				} else {
					PrzygodaNumer = s.strsubbs("start");
					if( sav.bis("load"+PrzygodaNumer) )	{
						claskexit.ask( "sndraz", "sndyes", "sndno", "mplaynew", null );
					} else .mplaynew;
				}
				} );
			} );
		
		grlek.hide;
		gradv.hide;
		
		ankaplica.mkbut;
		angmach.mkbut;
		
		butg.addgroup("grlek");
		butg.addgroup("gradv");
		
		new string sGame;
		mus.playstr("main.ogg -v 30 -l");
		ccs.enter( func { igmstate=1; } );
	}
	mplaynew	{
		sav.bset("load"+PrzygodaNumer);
		sav.stdsave;
		sGame = "Intro";
		.mstart;
	}
	mktyt(string styt, int id, string sfont, int ifont)	{
		@s = "td"+styt;
		@s2 = grlek.get(id);
		new TextDb <s>(sfont, ifont, "$row:dblek,"+id, .white, <s2>.getex-5, <s2>.getpy, 2, <s2>.getz+3, "left");
		<s>.stdshadow(2);
		<s>.hide;
		grtyt.add(s);
	}
	mkbut	{
		butg.add(this);
		.addmethod("isbutin", func { (@x, @y)
			igmstate==1 && .isin(x,y,0,1);
			} );
		.addmethod("butmoveon", func {
			if( igmstate!=1 ) return;
			if (.isplaying(1) )	{
				int id = .framenr;
				.play(0);
				.setframe(0,id);
			} else .play(0);
			advmouse.setact;
			annapisy_rozpocznij.show;
			annapisy_rozpocznij.setframe( (this=="angmach" ? 0 : 1), 0 );
			} );
		.addmethod("butmoveoff", func {
			if( igmstate!=1 ) return;
			if( .isplaying(0) )	{
				int id = .framenr;
				.play(1);
				.setframe(1,id);
			} else .play(1);
			advmouse.setstd;
			annapisy_rozpocznij.hide;
			} );
		.addmethod("butclick", func {
			if( igmstate!=1 ) return;
			igmstate = 2;
			antablice.show;
			if( this=="angmach" )	{
				antablice.setframe(0,0);
				gradv.show;
			} else {
				antablice.setframe(1,0);
				grlek.show;
			}
			} );
	}
	mstart	{
		igmstate = 3;
		mus.fadeout(1000);
		ccs.close( func { gameapi.play(sGame); } );
	}
	game_exit	{	sav.stdsave;	}
	mouse_lclick	{
		if( igmstate==2 && !antablice.isin(mouse.getpos,1,1))	{
			if( antablice.actionnr(-1) == 0 )	{
				gradv.hide;
			} else {
				grlek.hide;
				grtyt.hide;
			}
			antablice.hide;
			igmstate = 1;
		}
	}
}


game Outro : Computro	{
	init	{
		Computro::init("outro");
// 		bkg.pyz  logo.pyz  maskdol.pyz  maskgora.pyz  robo.pyz
		.imgs = (A, "bkg.pyz", "logoP.pyz 50", "maskdol.pyz 20", "maskgora.pyz 20", "roboP.pyz 40");
		mus.playstr("bitewna.ogg -v 50 -l");
		
		.lang_db("dbend", "napisy");
		new TextDb tdend( .stdfont(16), 16, "$var:dbend", .white, 100, 600, 2, 5, "left");
		.cycle = ("timcyk", func {
			tdend.move(0, -1);
			if( tdend.getey<0 && igmstate==0 )	.mouse_lclick;
			else .play;
			} );
		timcyk.setcycle(2);
		timcyk.play;
	}
	mouse_lclick	{
		if( igmstate==0 )	{
			igmstate = 1;
			mus.fadeout(1000);
			ccs.close( func { gameapi.exit; } );
		}
	}
}
